; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24245.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0ImVec2@@QEAA@XZ				; ImVec2::ImVec2
PUBLIC	??0ImVec2@@QEAA@MM@Z				; ImVec2::ImVec2
PUBLIC	??0ImVec4@@QEAA@MMMM@Z				; ImVec4::ImVec4
PUBLIC	?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z	; ImGui::BeginTable
PUBLIC	?EndTable@ImGui@@YAXXZ				; ImGui::EndTable
PUBLIC	?TableNextRow@ImGui@@YAXHM@Z			; ImGui::TableNextRow
PUBLIC	?TableNextColumn@ImGui@@YA_NXZ			; ImGui::TableNextColumn
PUBLIC	?TableSetColumnIndex@ImGui@@YA_NH@Z		; ImGui::TableSetColumnIndex
PUBLIC	?TableSetupColumn@ImGui@@YAXPEBDHMI@Z		; ImGui::TableSetupColumn
PUBLIC	?TableSetupScrollFreeze@ImGui@@YAXHH@Z		; ImGui::TableSetupScrollFreeze
PUBLIC	?TableHeadersRow@ImGui@@YAXXZ			; ImGui::TableHeadersRow
PUBLIC	?TableHeader@ImGui@@YAXPEBD@Z			; ImGui::TableHeader
PUBLIC	?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ ; ImGui::TableGetSortSpecs
PUBLIC	?TableGetColumnCount@ImGui@@YAHXZ		; ImGui::TableGetColumnCount
PUBLIC	?TableGetColumnIndex@ImGui@@YAHXZ		; ImGui::TableGetColumnIndex
PUBLIC	?TableGetRowIndex@ImGui@@YAHXZ			; ImGui::TableGetRowIndex
PUBLIC	?TableGetColumnName@ImGui@@YAPEBDH@Z		; ImGui::TableGetColumnName
PUBLIC	?TableGetColumnFlags@ImGui@@YAHH@Z		; ImGui::TableGetColumnFlags
PUBLIC	?TableSetColumnEnabled@ImGui@@YAXH_N@Z		; ImGui::TableSetColumnEnabled
PUBLIC	?TableSetBgColor@ImGui@@YAXHIH@Z		; ImGui::TableSetBgColor
PUBLIC	?Columns@ImGui@@YAXHPEBD_N@Z			; ImGui::Columns
PUBLIC	?NextColumn@ImGui@@YAXXZ			; ImGui::NextColumn
PUBLIC	?GetColumnIndex@ImGui@@YAHXZ			; ImGui::GetColumnIndex
PUBLIC	?GetColumnWidth@ImGui@@YAMH@Z			; ImGui::GetColumnWidth
PUBLIC	?SetColumnWidth@ImGui@@YAXHM@Z			; ImGui::SetColumnWidth
PUBLIC	?GetColumnOffset@ImGui@@YAMH@Z			; ImGui::GetColumnOffset
PUBLIC	?SetColumnOffset@ImGui@@YAXHM@Z			; ImGui::SetColumnOffset
PUBLIC	?GetColumnsCount@ImGui@@YAHXZ			; ImGui::GetColumnsCount
PUBLIC	??2@YAPEAX_KUImNewWrapper@@PEAX@Z		; operator new
PUBLIC	??3@YAXPEAXUImNewWrapper@@0@Z			; operator delete
PUBLIC	??0ImGuiTableColumnSortSpecs@@QEAA@XZ		; ImGuiTableColumnSortSpecs::ImGuiTableColumnSortSpecs
PUBLIC	??0ImGuiTableSortSpecs@@QEAA@XZ			; ImGuiTableSortSpecs::ImGuiTableSortSpecs
PUBLIC	??0?$ImVector@D@@QEAA@XZ			; ImVector<char>::ImVector<char>
PUBLIC	??1?$ImVector@D@@QEAA@XZ			; ImVector<char>::~ImVector<char>
PUBLIC	?clear@?$ImVector@D@@QEAAXXZ			; ImVector<char>::clear
PUBLIC	??A?$ImVector@D@@QEBAAEBDH@Z			; ImVector<char>::operator[]
PUBLIC	?swap@?$ImVector@D@@QEAAXAEAU1@@Z		; ImVector<char>::swap
PUBLIC	?_grow_capacity@?$ImVector@D@@QEBAHH@Z		; ImVector<char>::_grow_capacity
PUBLIC	?resize@?$ImVector@D@@QEAAXH@Z			; ImVector<char>::resize
PUBLIC	?reserve@?$ImVector@D@@QEAAXH@Z			; ImVector<char>::reserve
PUBLIC	??0ImGuiTextBuffer@@QEAA@XZ			; ImGuiTextBuffer::ImGuiTextBuffer
PUBLIC	?size@ImGuiTextBuffer@@QEBAHXZ			; ImGuiTextBuffer::size
PUBLIC	?clear@ImGuiTextBuffer@@QEAAXXZ			; ImGuiTextBuffer::clear
PUBLIC	?reserve@ImGuiTextBuffer@@QEAAXH@Z		; ImGuiTextBuffer::reserve
PUBLIC	??1ImGuiTextBuffer@@QEAA@XZ			; ImGuiTextBuffer::~ImGuiTextBuffer
PUBLIC	??A?$ImVector@UImGuiStoragePair@ImGuiStorage@@@@QEAAAEAUImGuiStoragePair@ImGuiStorage@@H@Z ; ImVector<ImGuiStorage::ImGuiStoragePair>::operator[]
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
PUBLIC	?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ	; ImVector<ImDrawCmd>::pop_back
PUBLIC	??0?$ImVector@UImDrawChannel@@@@QEAA@XZ		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
PUBLIC	??1?$ImVector@UImDrawChannel@@@@QEAA@XZ		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
PUBLIC	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z ; ImVector<ImDrawChannel>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z	; ImVector<ImDrawChannel>::resize
PUBLIC	?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z	; ImVector<ImDrawChannel>::reserve
PUBLIC	??0ImDrawListSplitter@@QEAA@XZ			; ImDrawListSplitter::ImDrawListSplitter
PUBLIC	??1ImDrawListSplitter@@QEAA@XZ			; ImDrawListSplitter::~ImDrawListSplitter
PUBLIC	?Clear@ImDrawListSplitter@@QEAAXXZ		; ImDrawListSplitter::Clear
PUBLIC	?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ	; ImVector<ImVec4>::back
PUBLIC	?back@?$ImVector@I@@QEAAAEAIXZ			; ImVector<unsigned int>::back
PUBLIC	??A?$ImVector@M@@QEAAAEAMH@Z			; ImVector<float>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@M@@QEBAHH@Z		; ImVector<float>::_grow_capacity
PUBLIC	?resize@?$ImVector@M@@QEAAXHAEBM@Z		; ImVector<float>::resize
PUBLIC	?reserve@?$ImVector@M@@QEAAXH@Z			; ImVector<float>::reserve
PUBLIC	__local_stdio_scanf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	??0ImVec1@@QEAA@XZ				; ImVec1::ImVec1
PUBLIC	??0ImRect@@QEAA@XZ				; ImRect::ImRect
PUBLIC	??0ImRect@@QEAA@AEBUImVec2@@0@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QEAA@AEBUImVec4@@@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QEAA@MMMM@Z				; ImRect::ImRect
PUBLIC	?GetSize@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetSize
PUBLIC	?GetWidth@ImRect@@QEBAMXZ			; ImRect::GetWidth
PUBLIC	?GetHeight@ImRect@@QEBAMXZ			; ImRect::GetHeight
PUBLIC	?Contains@ImRect@@QEBA_NAEBU1@@Z		; ImRect::Contains
PUBLIC	?Overlaps@ImRect@@QEBA_NAEBU1@@Z		; ImRect::Overlaps
PUBLIC	?Add@ImRect@@QEAAXAEBU1@@Z			; ImRect::Add
PUBLIC	?ClipWith@ImRect@@QEAAXAEBU1@@Z			; ImRect::ClipWith
PUBLIC	?ClipWithFull@ImRect@@QEAAXAEBU1@@Z		; ImRect::ClipWithFull
PUBLIC	?ToVec4@ImRect@@QEBA?AUImVec4@@XZ		; ImRect::ToVec4
PUBLIC	?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z	; ImBitArrayGetStorageSizeInBytes
PUBLIC	?ImBitArrayClearAllBits@@YAXPEAIH@Z		; ImBitArrayClearAllBits
PUBLIC	?ImBitArrayClearBit@@YAXPEAIH@Z			; ImBitArrayClearBit
PUBLIC	?ImBitArraySetBit@@YAXPEAIH@Z			; ImBitArraySetBit
PUBLIC	?ImBitArraySetBitRange@@YAXPEAIHH@Z		; ImBitArraySetBitRange
PUBLIC	??0ImGuiOldColumnData@@QEAA@XZ			; ImGuiOldColumnData::ImGuiOldColumnData
PUBLIC	??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ	; ImVector<ImGuiOldColumnData>::ImVector<ImGuiOldColumnData>
PUBLIC	??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ	; ImVector<ImGuiOldColumnData>::~ImVector<ImGuiOldColumnData>
PUBLIC	??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z ; ImVector<ImGuiOldColumnData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::resize
PUBLIC	?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z ; ImVector<ImGuiOldColumnData>::push_back
PUBLIC	??0ImGuiOldColumns@@QEAA@XZ			; ImGuiOldColumns::ImGuiOldColumns
PUBLIC	??1ImGuiOldColumns@@QEAA@XZ			; ImGuiOldColumns::~ImGuiOldColumns
PUBLIC	??0ImGuiSettingsHandler@@QEAA@XZ		; ImGuiSettingsHandler::ImGuiSettingsHandler
PUBLIC	??A?$ImVector@UImGuiTableTempData@@@@QEAAAEAUImGuiTableTempData@@H@Z ; ImVector<ImGuiTableTempData>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImGuiTableTempData@@@@QEBAHH@Z ; ImVector<ImGuiTableTempData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiTableTempData@@@@QEAAXHAEBUImGuiTableTempData@@@Z ; ImVector<ImGuiTableTempData>::resize
PUBLIC	?reserve@?$ImVector@UImGuiTableTempData@@@@QEAAXH@Z ; ImVector<ImGuiTableTempData>::reserve
PUBLIC	??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z ; ImVector<ImGuiTable>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImGuiTable@@@@QEBAHH@Z ; ImVector<ImGuiTable>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiTable@@@@QEAAXH@Z	; ImVector<ImGuiTable>::resize
PUBLIC	?reserve@?$ImVector@UImGuiTable@@@@QEAAXH@Z	; ImVector<ImGuiTable>::reserve
PUBLIC	?GetByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z ; ImPool<ImGuiTable>::GetByKey
PUBLIC	?GetByIndex@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z ; ImPool<ImGuiTable>::GetByIndex
PUBLIC	?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z ; ImPool<ImGuiTable>::GetIndex
PUBLIC	?GetOrAddByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z ; ImPool<ImGuiTable>::GetOrAddByKey
PUBLIC	?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ ; ImPool<ImGuiTable>::Add
PUBLIC	?Remove@?$ImPool@UImGuiTable@@@@QEAAXIPEBUImGuiTable@@@Z ; ImPool<ImGuiTable>::Remove
PUBLIC	?Remove@?$ImPool@UImGuiTable@@@@QEAAXIH@Z	; ImPool<ImGuiTable>::Remove
PUBLIC	?GetMapSize@?$ImPool@UImGuiTable@@@@QEBAHXZ	; ImPool<ImGuiTable>::GetMapSize
PUBLIC	?TryGetMapData@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z ; ImPool<ImGuiTable>::TryGetMapData
PUBLIC	?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ ; ImChunkStream<ImGuiTableSettings>::clear
PUBLIC	?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z ; ImChunkStream<ImGuiTableSettings>::alloc_chunk
PUBLIC	?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::begin
PUBLIC	?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z ; ImChunkStream<ImGuiTableSettings>::next_chunk
PUBLIC	?chunk_size@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z ; ImChunkStream<ImGuiTableSettings>::chunk_size
PUBLIC	?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::end
PUBLIC	?offset_from_ptr@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z ; ImChunkStream<ImGuiTableSettings>::offset_from_ptr
PUBLIC	?ptr_from_offset@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@H@Z ; ImChunkStream<ImGuiTableSettings>::ptr_from_offset
PUBLIC	?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z ; ImChunkStream<ImGuiTableSettings>::swap
PUBLIC	??0?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ ; ImChunkStream<ImGuiTableSettings>::ImChunkStream<ImGuiTableSettings>
PUBLIC	??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ ; ImChunkStream<ImGuiTableSettings>::~ImChunkStream<ImGuiTableSettings>
PUBLIC	??A?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@H@Z ; ImVector<ImGuiOldColumns>::operator[]
PUBLIC	?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ ; ImVector<ImGuiOldColumns>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z ; ImVector<ImGuiOldColumns>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z ; ImVector<ImGuiOldColumns>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z ; ImVector<ImGuiOldColumns>::push_back
PUBLIC	?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ		; ImGuiWindow::Rect
PUBLIC	??0ImGuiTableColumn@@QEAA@XZ			; ImGuiTableColumn::ImGuiTableColumn
PUBLIC	??0ImGuiTableInstanceData@@QEAA@XZ		; ImGuiTableInstanceData::ImGuiTableInstanceData
PUBLIC	??0?$ImSpan@UImGuiTableColumn@@@@QEAA@XZ	; ImSpan<ImGuiTableColumn>::ImSpan<ImGuiTableColumn>
PUBLIC	?set@?$ImSpan@UImGuiTableColumn@@@@QEAAXPEAUImGuiTableColumn@@0@Z ; ImSpan<ImGuiTableColumn>::set
PUBLIC	?size@?$ImSpan@UImGuiTableColumn@@@@QEBAHXZ	; ImSpan<ImGuiTableColumn>::size
PUBLIC	??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
PUBLIC	??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
PUBLIC	?index_from_ptr@?$ImSpan@UImGuiTableColumn@@@@QEBAHPEBUImGuiTableColumn@@@Z ; ImSpan<ImGuiTableColumn>::index_from_ptr
PUBLIC	??0?$ImSpan@F@@QEAA@XZ				; ImSpan<short>::ImSpan<short>
PUBLIC	?set@?$ImSpan@F@@QEAAXPEAF0@Z			; ImSpan<short>::set
PUBLIC	??A?$ImSpan@F@@QEAAAEAFH@Z			; ImSpan<short>::operator[]
PUBLIC	??0?$ImSpan@UImGuiTableCellData@@@@QEAA@XZ	; ImSpan<ImGuiTableCellData>::ImSpan<ImGuiTableCellData>
PUBLIC	?set@?$ImSpan@UImGuiTableCellData@@@@QEAAXPEAUImGuiTableCellData@@0@Z ; ImSpan<ImGuiTableCellData>::set
PUBLIC	??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z ; ImSpan<ImGuiTableCellData>::operator[]
PUBLIC	??0?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ ; ImVector<ImGuiTableInstanceData>::ImVector<ImGuiTableInstanceData>
PUBLIC	??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ ; ImVector<ImGuiTableInstanceData>::~ImVector<ImGuiTableInstanceData>
PUBLIC	??A?$ImVector@UImGuiTableInstanceData@@@@QEAAAEAUImGuiTableInstanceData@@H@Z ; ImVector<ImGuiTableInstanceData>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImGuiTableInstanceData@@@@QEBAHH@Z ; ImVector<ImGuiTableInstanceData>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiTableInstanceData@@@@QEAAXH@Z ; ImVector<ImGuiTableInstanceData>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiTableInstanceData@@@@QEAAXAEBUImGuiTableInstanceData@@@Z ; ImVector<ImGuiTableInstanceData>::push_back
PUBLIC	??0?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ ; ImVector<ImGuiTableColumnSortSpecs>::ImVector<ImGuiTableColumnSortSpecs>
PUBLIC	??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ ; ImVector<ImGuiTableColumnSortSpecs>::~ImVector<ImGuiTableColumnSortSpecs>
PUBLIC	?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ ; ImVector<ImGuiTableColumnSortSpecs>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEBAHH@Z ; ImVector<ImGuiTableColumnSortSpecs>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z ; ImVector<ImGuiTableColumnSortSpecs>::resize
PUBLIC	?reserve@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z ; ImVector<ImGuiTableColumnSortSpecs>::reserve
PUBLIC	??0ImGuiTable@@QEAA@XZ				; ImGuiTable::ImGuiTable
PUBLIC	??1ImGuiTable@@QEAA@XZ				; ImGuiTable::~ImGuiTable
PUBLIC	??_GImGuiTable@@QEAAPEAXI@Z			; ImGuiTable::`scalar deleting destructor'
PUBLIC	??0ImGuiTableTempData@@QEAA@XZ			; ImGuiTableTempData::ImGuiTableTempData
PUBLIC	??1ImGuiTableTempData@@QEAA@XZ			; ImGuiTableTempData::~ImGuiTableTempData
PUBLIC	??0ImGuiTableColumnSettings@@QEAA@XZ		; ImGuiTableColumnSettings::ImGuiTableColumnSettings
PUBLIC	??0ImGuiTableSettings@@QEAA@XZ			; ImGuiTableSettings::ImGuiTableSettings
PUBLIC	?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ ; ImGuiTableSettings::GetColumnSettings
PUBLIC	?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
PUBLIC	?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ	; ImGui::GetCurrentWindow
PUBLIC	?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z	; ImGui::LocalizeGetMsg
PUBLIC	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z		; ImGui::ItemSize
PUBLIC	?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; ImGui::SetWindowClipRectBeforeSetChannel
PUBLIC	?BeginColumns@ImGui@@YAXPEBDHH@Z		; ImGui::BeginColumns
PUBLIC	?EndColumns@ImGui@@YAXXZ			; ImGui::EndColumns
PUBLIC	?PushColumnClipRect@ImGui@@YAXH@Z		; ImGui::PushColumnClipRect
PUBLIC	?PushColumnsBackground@ImGui@@YAXXZ		; ImGui::PushColumnsBackground
PUBLIC	?PopColumnsBackground@ImGui@@YAXXZ		; ImGui::PopColumnsBackground
PUBLIC	?GetColumnsID@ImGui@@YAIPEBDH@Z			; ImGui::GetColumnsID
PUBLIC	?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z ; ImGui::FindOrCreateColumns
PUBLIC	?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ; ImGui::GetColumnOffsetFromNorm
PUBLIC	?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ; ImGui::GetColumnNormFromOffset
PUBLIC	?TableOpenContextMenu@ImGui@@YAXH@Z		; ImGui::TableOpenContextMenu
PUBLIC	?TableSetColumnWidth@ImGui@@YAXHM@Z		; ImGui::TableSetColumnWidth
PUBLIC	?TableSetColumnSortDirection@ImGui@@YAXHH_N@Z	; ImGui::TableSetColumnSortDirection
PUBLIC	?TableGetHoveredColumn@ImGui@@YAHXZ		; ImGui::TableGetHoveredColumn
PUBLIC	?TableGetHeaderRowHeight@ImGui@@YAMXZ		; ImGui::TableGetHeaderRowHeight
PUBLIC	?TablePushBackgroundChannel@ImGui@@YAXXZ	; ImGui::TablePushBackgroundChannel
PUBLIC	?TablePopBackgroundChannel@ImGui@@YAXXZ		; ImGui::TablePopBackgroundChannel
PUBLIC	?TableFindByID@ImGui@@YAPEAUImGuiTable@@I@Z	; ImGui::TableFindByID
PUBLIC	?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z	; ImGui::BeginTableEx
PUBLIC	?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z ; ImGui::TableBeginInitMemory
PUBLIC	?TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableBeginApplyRequests
PUBLIC	?TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableSetupDrawChannels
PUBLIC	?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::TableUpdateLayout
PUBLIC	?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableUpdateBorders
PUBLIC	?TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableUpdateColumnsWeightFromWidth
PUBLIC	?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::TableDrawBorders
PUBLIC	?TableDrawContextMenu@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableDrawContextMenu
PUBLIC	?TableBeginContextMenuPopup@ImGui@@YA_NPEAUImGuiTable@@@Z ; ImGui::TableBeginContextMenuPopup
PUBLIC	?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableMergeDrawChannels
PUBLIC	?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z ; ImGui::TableGetInstanceData
PUBLIC	?TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableSortSpecsSanitize
PUBLIC	?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableSortSpecsBuild
PUBLIC	?TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z ; ImGui::TableGetColumnNextSortDirection
PUBLIC	?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z ; ImGui::TableFixColumnSortDirection
PUBLIC	?TableGetColumnWidthAuto@ImGui@@YAMPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z ; ImGui::TableGetColumnWidthAuto
PUBLIC	?TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::TableBeginRow
PUBLIC	?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::TableEndRow
PUBLIC	?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z	; ImGui::TableBeginCell
PUBLIC	?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::TableEndCell
PUBLIC	?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z ; ImGui::TableGetCellBgRect
PUBLIC	?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z ; ImGui::TableGetColumnName
PUBLIC	?TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z ; ImGui::TableGetColumnResizeID
PUBLIC	?TableGetMaxColumnWidth@ImGui@@YAMPEBUImGuiTable@@H@Z ; ImGui::TableGetMaxColumnWidth
PUBLIC	?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z ; ImGui::TableSetColumnWidthAutoSingle
PUBLIC	?TableSetColumnWidthAutoAll@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableSetColumnWidthAutoAll
PUBLIC	?TableRemove@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::TableRemove
PUBLIC	?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableGcCompactTransientBuffers
PUBLIC	?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z ; ImGui::TableGcCompactTransientBuffers
PUBLIC	?TableGcCompactSettings@ImGui@@YAXXZ		; ImGui::TableGcCompactSettings
PUBLIC	?TableLoadSettings@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::TableLoadSettings
PUBLIC	?TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::TableSaveSettings
PUBLIC	?TableResetSettings@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableResetSettings
PUBLIC	?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z ; ImGui::TableGetBoundSettings
PUBLIC	?TableSettingsAddSettingsHandler@ImGui@@YAXXZ	; ImGui::TableSettingsAddSettingsHandler
PUBLIC	?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z ; ImGui::TableSettingsCreate
PUBLIC	?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z ; ImGui::TableSettingsFindByID
PUBLIC	?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::DebugNodeTable
PUBLIC	?DebugNodeTableSettings@ImGui@@YAXPEAUImGuiTableSettings@@@Z ; ImGui::DebugNodeTableSettings
PUBLIC	?TableFixFlags@@YAHHPEAUImGuiWindow@@@Z		; TableFixFlags
PUBLIC	??0?$ImSpanAllocator@$05@@QEAA@XZ		; ImSpanAllocator<6>::ImSpanAllocator<6>
PUBLIC	?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z	; ImSpanAllocator<6>::Reserve
PUBLIC	?GetArenaSizeInBytes@?$ImSpanAllocator@$05@@QEAAHXZ ; ImSpanAllocator<6>::GetArenaSizeInBytes
PUBLIC	?SetArenaBasePtr@?$ImSpanAllocator@$05@@QEAAXPEAX@Z ; ImSpanAllocator<6>::SetArenaBasePtr
PUBLIC	?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrBegin
PUBLIC	?GetSpanPtrEnd@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrEnd
PUBLIC	??$GetSpan@UImGuiTableColumn@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableColumn@@@@@Z ; ImSpanAllocator<6>::GetSpan<ImGuiTableColumn>
PUBLIC	??$GetSpan@F@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@F@@@Z ; ImSpanAllocator<6>::GetSpan<short>
PUBLIC	??$GetSpan@UImGuiTableCellData@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableCellData@@@@@Z ; ImSpanAllocator<6>::GetSpan<ImGuiTableCellData>
PUBLIC	??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@ ; `string'
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@ ; `string'
PUBLIC	??_C@_0P@HEMCFMMD@?$CKMissing?5Text?$CK?$AA@	; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	?__LINE__Var@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4JA ; `ImGui::BeginTableEx'::`1'::__LINE__Var
PUBLIC	??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@ ; `string'
PUBLIC	??_C@_1FC@LLGOGPDA@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu@ ; `string'
PUBLIC	??_C@_1CI@NLGBMAGB@?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@ ; `string'
PUBLIC	??_C@_0EN@HCDJLOKE@BeginTable?$CI?$CJ?3?5Cannot?5change?5colu@ ; `string'
PUBLIC	??_C@_1OO@LHJMPKOL@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc@ ; `string'
PUBLIC	??_C@_1BBG@HLLCHCOP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAn?$AAn?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAP?$AAa?$AAd?$AAd?$AAi?$AAn@ ; `string'
PUBLIC	?__LINE__Var@?0??TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableBeginApplyRequests'::`1'::__LINE__Var
PUBLIC	??_C@_1EO@CLPKFPLH@?$AAr?$AAe?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAd?$AAi?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAr?$AAe?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAd?$AAi?$AAr@ ; `string'
PUBLIC	??_C@_1FG@FFJIEHAF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAR@ ; `string'
PUBLIC	??_C@_1GI@FDBBNGED@?$AAd?$AAs?$AAt?$AA_?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAs?$AAt?$AA_@ ; `string'
PUBLIC	?__LINE__Var@?0??TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z@4JA ; `TableSetupColumnFlags'::`1'::__LINE__Var
PUBLIC	??_C@_1HC@EONHDNHI@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	?__LINE__Var@?0??TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableUpdateLayout'::`1'::__LINE__Var
PUBLIC	??_C@_1DO@DEAGPPGG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GM@PGNFGMB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAI?$AAn?$AAd?$AAe?$AAx?$AAW?$AAi?$AAt?$AAh?$AAi?$AAn?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAS?$AAe?$AAt?$AA?5?$AA?$DM?$AA?$DN@ ; `string'
PUBLIC	??_C@_1JA@JKJMNFJF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAL?$AAe?$AAf?$AAt?$AAM?$AAo?$AAs?$AAt?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5@ ; `string'
PUBLIC	??_C@_1BI@PMBHHKFI@?$AA?$CB?$AAi?$AAs?$AA_?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableUpdateBorders'::`1'::__LINE__Var
PUBLIC	??_C@_1FC@BMHMHKON@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAR@ ; `string'
PUBLIC	?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA	; `ImGui::EndTable'::`1'::__LINE__Var
PUBLIC	??_C@_0DD@JFFDACDB@Only?5call?5EndTable?$CI?$CJ?5if?5BeginTab@ ; `string'
PUBLIC	??_C@_1IG@CGOKCKPM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAO?$AAn?$AAl?$AAy?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAE?$AAn?$AAd?$AAT?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_1EA@FGAGBNK@?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAg?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$AA@ ; `string'
PUBLIC	??_C@_1JG@DEMMNCCK@?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$HM?$AA?$HM?$AA?5@ ; `string'
PUBLIC	??_C@_1GA@MJADNMBJ@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAR?$AAo?$AAw?$AAP?$AAo?$AAs?$AAY?$AA2?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9@ ; `string'
PUBLIC	??_C@_0BK@MHDEDKFO@Mismatching?5PushID?1PopID?$CB?$AA@ ; `string'
PUBLIC	??_C@_1MI@BOIHHKDM@?$AA?$CI?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAI?$AAD?$AAS?$AAt?$AAa?$AAc?$AAk?$AA?4?$AAb?$AAa?$AAc?$AAk?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_0BH@GAFFHFPC@Too?5many?5PopItemWidth?$CB?$AA@ ; `string'
PUBLIC	??_C@_1NM@BLFPKGHB@?$AA?$CI?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAI?$AAt?$AAe?$AAm?$AAW?$AAi?$AAd?$AAt?$AAh?$AAS?$AAt?$AAa?$AAc?$AAk@ ; `string'
PUBLIC	??_C@_1FM@ICPCKIED@?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_@ ; `string'
PUBLIC	??_C@_1HG@JFMKDCJB@?$AAg?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5@ ; `string'
PUBLIC	??_C@_1DI@IPEFINGP@?$AAg?$AA?4?$AAT?$AAa?$AAb?$AAl?$AAe?$AAs?$AAT?$AAe?$AAm?$AAp?$AAD?$AAa?$AAt?$AAa?$AAS?$AAt?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??TableSetupColumn@ImGui@@YAXPEBDHMI@Z@4JA ; `ImGui::TableSetupColumn'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@JMKEADIJ@Need?5to?5call?5TableSetupColumn?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_1II@MMHPDEP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_0DH@KOGIGLHC@Need?5to?5call?5call?5TableSetupColu@ ; `string'
PUBLIC	??_C@_1LG@IFCOIHC@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_0DI@CBJAIEBI@Illegal?5to?5pass?5StatusMask?5value@ ; `string'
PUBLIC	??_C@_1NM@DDJLAMJK@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAS@ ; `string'
PUBLIC	??_C@_0CK@FPBLGODL@Called?5TableSetupColumn?$CI?$CJ?5too?5ma@ ; `string'
PUBLIC	??_C@_1LO@INHFIFIG@?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAD?$AAe?$AAc?$AAl?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_0FM@GOCDHGH@Can?5only?5specify?5width?1weight?5if@ ; `string'
PUBLIC	??_C@_1PM@LKIEMPHI@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAo?$AAr?$AA_?$AAw?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??TableSetupScrollFreeze@ImGui@@YAXHH@Z@4JA ; `ImGui::TableSetupScrollFreeze'::`1'::__LINE__Var
PUBLIC	??_C@_0DC@CMJJAIP@Need?5to?5call?5TableSetupColumn?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_1KM@MPIBPMGF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_1DM@GIPBLHPN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DM?$AA?5?$AA5?$AA1?$AA2?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@CGNBCADH@?$AAr?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?5?$AA?$DM?$AA?5?$AA1?$AA2?$AA8?$AA?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?__LINE__Var@?0??TableSetColumnEnabled@ImGui@@YAXH_N@Z@4JA ; `ImGui::TableSetColumnEnabled'::`1'::__LINE__Var
PUBLIC	??_C@_1BG@IPNBPJPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FA@FCMNFGAM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAH@ ; `string'
PUBLIC	??_C@_1GA@OFNPMLNE@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	?__LINE__Var@?0??TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z@4JA ; `ImGui::TableGetColumnResizeID'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??TableSetBgColor@ImGui@@YAXHIH@Z@4JA ; `ImGui::TableSetBgColor'::`1'::__LINE__Var
PUBLIC	??_C@_1EE@NMABAIJJ@?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAB?$AAg?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AA_?$AAN?$AAo?$AAn@ ; `string'
PUBLIC	??_C@_1BO@EGJMPMHM@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableBeginRow'::`1'::__LINE__Var
PUBLIC	??_C@_1CI@JLDNLAAM@?$AA?$CB?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAI?$AAn?$AAs?$AAi?$AAd?$AAe?$AAR?$AAo?$AAw?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableEndRow'::`1'::__LINE__Var
PUBLIC	??_C@_1DK@GFLHACMC@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAn?$AAn?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@HHNDIFPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAI?$AAn?$AAs?$AAi?$AAd?$AAe?$AAR?$AAo?$AAw?$AA?$AA@ ; `string'
PUBLIC	??_C@_01DNKMNLPK@?$HM?$AA@			; `string'
PUBLIC	??_C@_1DO@BPCFJEPF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAU?$AAn?$AAf?$AAr?$AAo?$AAz?$AAe?$AAn?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1JC@PCOAPGIF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAB?$AAg?$AA2?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AAF?$AAo?$AAr?$AAD?$AAr?$AAa?$AAw?$AAC?$AAm?$AAd?$AA?4?$AAM?$AAi?$AAn@ ; `string'
PUBLIC	?__LINE__Var@?0??TableSetColumnIndex@ImGui@@YA_NH@Z@4JA ; `ImGui::TableSetColumnIndex'::`1'::__LINE__Var
PUBLIC	??_C@_1EK@MBNMJGKK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC@ ; `string'
PUBLIC	?__LINE__Var@?0??TableSetColumnWidth@ImGui@@YAXHM@Z@4JA ; `ImGui::TableSetColumnWidth'::`1'::__LINE__Var
PUBLIC	??_C@_1FK@MHBOMDGH@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc@ ; `string'
PUBLIC	??_C@_1DK@PGHMBBCD@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAM?$AAi?$AAn?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FO@DCOODALF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AA0?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_@ ; `string'
PUBLIC	?__LINE__Var@?0??TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableUpdateColumnsWeightFromWidth'::`1'::__LINE__Var
PUBLIC	??_C@_1JM@ELMLJHLO@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAL?$AAe?$AAf?$AAt?$AAM?$AAo?$AAs?$AAt?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$CB@ ; `string'
PUBLIC	??_C@_1DK@MOAONJGL@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAW?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FM@OBNODAI@?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe?$AA_?$AAw?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe@ ; `string'
PUBLIC	?__LINE__Var@?0??TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableSetupDrawChannels'::`1'::__LINE__Var
PUBLIC	??_C@_1GG@NCDBECJP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAB?$AAg?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AA?4?$AAM?$AAi?$AAn?$AA?4?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe@ ; `string'
PUBLIC	?__LINE__Var@?0??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableMergeDrawChannels'::`1'::__LINE__Var
PUBLIC	??_C@_1DA@GEHLCBHG@?$AAs?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DO@EEGFHBNA@?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA_?$AAn?$AAo?$AA?5?$AA?$DM?$AA?5?$AAm?$AAa?$AAx?$AA_?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1LA@JABKDEHA@?$AAh?$AAa?$AAs?$AA_?$AAf?$AAr?$AAe?$AAe?$AAz?$AAe?$AA_?$AAv?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO@ ; `string'
PUBLIC	??_C@_1MG@IJOOMOFE@?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?9?$AA?$DO?$AA_?$AAC?$AAm?$AAd?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@ ; `string'
PUBLIC	??_C@_1KG@FHCGPPO@?$AAd?$AAs?$AAt?$AA_?$AAt?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAg?$AA?4?$AAD?$AAr?$AAa?$AAw?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAs?$AAT?$AAe?$AAm?$AAp?$AAM?$AAe?$AAr@ ; `string'
PUBLIC	?__LINE__Var@?0??TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ@4JA ; `ImGui::TableGetSortSpecs'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z@4JA ; `TableGetColumnAvailSortDirection'::`1'::__LINE__Var
PUBLIC	??_C@_1EK@EKGOAIAF@?$AAn?$AA?5?$AA?$DM?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AAA?$AAv?$AAa?$AAi?$AAl?$AAC@ ; `string'
PUBLIC	?__LINE__Var@?0??TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z@4JA ; `ImGui::TableGetColumnNextSortDirection'::`1'::__LINE__Var
PUBLIC	??_C@_1EK@NEPNAPMF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AAA?$AAv?$AAa?$AAi?$AAl?$AAC?$AAo?$AAu?$AAn?$AAt@ ; `string'
PUBLIC	?__LINE__Var@?0??TableSetColumnSortDirection@ImGui@@YAXHH_N@Z@4JA ; `ImGui::TableSetColumnSortDirection'::`1'::__LINE__Var
PUBLIC	??_C@_1FE@KIEHIAAN@?$AAs?$AAo?$AAr?$AAt?$AA_?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc@ ; `string'
PUBLIC	?__LINE__Var@?0??TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableSortSpecsSanitize'::`1'::__LINE__Var
PUBLIC	??_C@_1FA@NLOFMGNH@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAS@ ; `string'
PUBLIC	??_C@_1GI@FLDFCCLG@?$AAs?$AAo?$AAr?$AAt?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs@ ; `string'
PUBLIC	??_C@_1EM@BCBBNGI@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAw?$AAi?$AAt?$AAh?$AA_?$AAs?$AAm?$AAa?$AAl?$AAl?$AAe?$AAs?$AAt?$AA_?$AAs?$AAo?$AAr?$AAt?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableSortSpecsBuild'::`1'::__LINE__Var
PUBLIC	??_C@_1FE@KLCJNJLO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAS@ ; `string'
PUBLIC	?__LINE__Var@?0??TableHeadersRow@ImGui@@YAXXZ@4JA ; `ImGui::TableHeadersRow'::`1'::__LINE__Var
PUBLIC	??_C@_0DD@NCKBBGOL@Need?5to?5call?5TableHeadersRow?$CI?$CJ?5a@ ; `string'
PUBLIC	??_C@_1IG@FPFBNANE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	?__LINE__Var@?0??TableHeader@ImGui@@YAXPEBD@Z@4JA ; `ImGui::TableHeader'::`1'::__LINE__Var
PUBLIC	??_C@_0CP@HLEIDDEE@Need?5to?5call?5TableHeader?$CI?$CJ?5after@ ; `string'
PUBLIC	??_C@_1HO@PDHKEBPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_1DG@CDIJLMHK@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_04EBNJJJJI@?$CF?4?$CKs?$AA@		; `string'
PUBLIC	?__LINE__Var@?0??TableOpenContextMenu@ImGui@@YAXH@Z@4JA ; `ImGui::TableOpenContextMenu'::`1'::__LINE__Var
PUBLIC	??_C@_1GC@CPFLEHCP@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb@ ; `string'
PUBLIC	??_C@_0O@BMOANCPA@?$CD?$CDContextMenu?$AA@	; `string'
PUBLIC	??_C@_09MGFHLAFE@?$DMUnknown?$DO?$AA@		; `string'
PUBLIC	?__LINE__Var@?0??TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z@4JA ; `ImGui::TableGetBoundSettings'::`1'::__LINE__Var
PUBLIC	??_C@_1DE@KGKHJKNP@?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableSaveSettings'::`1'::__LINE__Var
PUBLIC	??_C@_1MK@NEOBPBEE@?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9@ ; `string'
PUBLIC	??_C@_09BDLBIGPI@0x?$CF08X?0?$CFd?$AA@		; `string'
PUBLIC	??_C@_0M@LAOOHBLO@RefScale?$DN?$CFf?$AA@	; `string'
PUBLIC	??_C@_0M@JOECNJOM@Column?5?$CFd?$CFn?$AA@	; `string'
PUBLIC	??_C@_0BA@KAIOJKEL@UserID?$DN0x?$CF08X?$CFn?$AA@ ; `string'
PUBLIC	??_C@_0L@LJLKPCDP@Width?$DN?$CFd?$CFn?$AA@	; `string'
PUBLIC	??_C@_0M@IJODOCHC@Weight?$DN?$CFf?$CFn?$AA@	; `string'
PUBLIC	??_C@_0N@EKALHFOF@Visible?$DN?$CFd?$CFn?$AA@	; `string'
PUBLIC	??_C@_0L@BHOFPJL@Order?$DN?$CFd?$CFn?$AA@	; `string'
PUBLIC	??_C@_0M@KGHCDDIO@Sort?$DN?$CFd?$CFc?$CFn?$AA@	; `string'
PUBLIC	??_C@_0BB@PGHPBJD@?$FL?$CFs?$FN?$FL0x?$CF08X?0?$CFd?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_0N@NHEEPCEH@RefScale?$DN?$CFg?6?$AA@	; `string'
PUBLIC	??_C@_0M@JLNIJDCE@Column?5?$CF?92d?$AA@		; `string'
PUBLIC	??_C@_0N@PGBEGIHP@?5UserID?$DN?$CF08X?$AA@	; `string'
PUBLIC	??_C@_0N@MFKBBKPH@?5Weight?$DN?$CF?44f?$AA@	; `string'
PUBLIC	??_C@_09PBOBBCAP@?5Width?$DN?$CFd?$AA@		; `string'
PUBLIC	??_C@_0M@CIPDPODB@?5Visible?$DN?$CFd?$AA@	; `string'
PUBLIC	??_C@_09CFPCIBAG@?5Order?$DN?$CFd?$AA@		; `string'
PUBLIC	??_C@_0L@EAJILIBD@?5Sort?$DN?$CFd?$CFc?$AA@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_05LFBINIGO@Table?$AA@			; `string'
PUBLIC	?__LINE__Var@?0??TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z@4JA ; `ImGui::TableGcCompactTransientBuffers'::`1'::__LINE__Var
PUBLIC	??_C@_1EA@HDPGNILG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAC?$AAo?$AAm?$AAp?$AAa?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_08CCPMLANI@FixedFit?$AA@			; `string'
PUBLIC	??_C@_09OOODJBFG@FixedSame?$AA@			; `string'
PUBLIC	??_C@_0M@IGAOBHEB@StretchProp?$AA@		; `string'
PUBLIC	??_C@_0M@LHDDKHJK@StretchSame?$AA@		; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A?$AA@			; `string'
PUBLIC	??_C@_0M@MDILNFHC@?5?$CKInactive?$CK?$AA@	; `string'
PUBLIC	??_C@_0CF@DAHKPIHJ@Table?50x?$CF08X?5?$CI?$CFd?5columns?0?5in?5?8?$CFs@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0EM@JLKLPOOK@?$CK?$CK?5?$CFd?5instances?5of?5same?5table?$CB?5S@ ; `string'
PUBLIC	??_C@_0P@MDFKNKGM@Clear?5settings?$AA@		; `string'
PUBLIC	??_C@_0DL@BMMMGOOI@OuterRect?3?5Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?5Size@ ; `string'
PUBLIC	??_C@_07IOPDKCEG@?5?$CIauto?$CJ?$AA@		; `string'
PUBLIC	??_C@_0EH@GODPECNO@ColumnsGivenWidth?3?5?$CF?41f?0?5Columns@ ; `string'
PUBLIC	??_C@_0EB@FOKPBOFF@CellPaddingX?3?5?$CF?41f?0?5CellSpacingX@ ; `string'
PUBLIC	??_C@_0CP@NOMNLPPG@HoveredColumnBody?3?5?$CFd?0?5HoveredCo@ ; `string'
PUBLIC	??_C@_0DL@PBPICJCB@ResizedColumn?3?5?$CFd?0?5ReorderColumn@ ; `string'
PUBLIC	??_C@_09BHNPHONE@NoResize?5?$AA@		; `string'
PUBLIC	??_C@_0M@IGDNFKMD@WidthFixed?5?$AA@		; `string'
PUBLIC	??_C@_0O@PEPBBILL@WidthStretch?5?$AA@		; `string'
PUBLIC	??_C@_06FEBPAKFP@?5?$CIAsc?$CJ?$AA@		; `string'
PUBLIC	??_C@_06PFKLCOBM@?5?$CIDes?$CJ?$AA@		; `string'
PUBLIC	??_C@_09LODDIFJL@?5?$CIFrozen?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BHH@CNHMONCM@Column?5?$CFd?5order?5?$CFd?5?8?$CFs?8?3?5offset?5@ ; `string'
PUBLIC	??_C@_0BN@LNKMILO@Settings?50x?$CF08X?5?$CI?$CFd?5columns?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BC@LJHOAHJA@SaveFlags?3?50x?$CF08X?$AA@	; `string'
PUBLIC	??_C@_0BK@OLKPLDMA@ColumnsCount?3?5?$CFd?5?$CImax?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_06ODJMJFLN@Weight?$AA@			; `string'
PUBLIC	??_C@_06PALFPBFG@Width?5?$AA@			; `string'
PUBLIC	??_C@_03OFHEPBNG@Asc?$AA@			; `string'
PUBLIC	??_C@_03IAMDMMHH@Des?$AA@			; `string'
PUBLIC	??_C@_03JMFMNIFM@?9?9?9?$AA@			; `string'
PUBLIC	??_C@_0EB@CNABLLAJ@Column?5?$CFd?5Order?5?$CFd?5SortOrder?5?$CFd?5@ ; `string'
PUBLIC	?__LINE__Var@?0??GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z@4JA ; `GetDraggedColumnOffset'::`1'::__LINE__Var
PUBLIC	??_C@_1CC@HNMGCLDB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GE@CFLLPKGA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$CL?$AA?5?$AAI?$AAm?$AAG?$AAu@ ; `string'
PUBLIC	?__LINE__Var@?0??GetColumnOffset@ImGui@@YAMH@Z@4JA ; `ImGui::GetColumnOffset'::`1'::__LINE__Var
PUBLIC	??_C@_1EK@FCGFMMCK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?4@ ; `string'
PUBLIC	?__LINE__Var@?0??SetColumnOffset@ImGui@@YAXHM@Z@4JA ; `ImGui::SetColumnOffset'::`1'::__LINE__Var
PUBLIC	??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??SetColumnWidth@ImGui@@YAXHM@Z@4JA ; `ImGui::SetColumnWidth'::`1'::__LINE__Var
PUBLIC	??_C@_07HIFEPIJN@columns?$AA@			; `string'
PUBLIC	?__LINE__Var@?0??BeginColumns@ImGui@@YAXPEBDHH@Z@4JA ; `ImGui::BeginColumns'::`1'::__LINE__Var
PUBLIC	??_C@_1CG@GDAJJGIO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DO@BPFJENMI@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@IJEAECLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAd?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??NextColumn@ImGui@@YAXXZ@4JA	; `ImGui::NextColumn'::`1'::__LINE__Var
PUBLIC	??_C@_1CM@HCFAHNAF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??EndColumns@ImGui@@YAXXZ@4JA	; `ImGui::EndColumns'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Columns@ImGui@@YAXHPEBD_N@Z@4JA ; `ImGui::Columns'::`1'::__LINE__Var
PUBLIC	??_C@_1FE@GEHGFLGL@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AAC?$AAH?$AAU?$AAN?$AAK?$AAS?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAC?$AAu?$AAr?$AAr?$AAI?$AAd?$AAx?$AA?5@ ; `string'
PUBLIC	??_C@_1DG@BODLFGJA@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAC?$AAu?$AAr?$AAr?$AAI?$AAd?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AAC?$AAH?$AAU?$AAN?$AAK?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@DHFOGPCD@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@OANBFKML@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAt?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@EPOMENA@?$AAo?$AAf?$AAf?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA4?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAf?$AAf?$AA?5?$AA?$DM?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@BDDBABLK@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAe?$AAg?$AAi?$AAn?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAe?$AAn?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@OEELIPPM@?$AAp?$AA?5?$AA?$DM?$AA?5?$AAe?$AAn?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FC@BIEMKEOL@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CL?$AA?5@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@00800000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3d75c28f
PUBLIC	__real@3f000000
PUBLIC	__real@3f266666
PUBLIC	__real@3f333333
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@42c80000
PUBLIC	__real@7f7fffff
PUBLIC	__real@bf800000
PUBLIC	__real@ff7fffff
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	__imp__wassert:PROC
EXTRN	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ:PROC	; ImGui::GetStyle
EXTRN	?EndChild@ImGui@@YAXXZ:PROC			; ImGui::EndChild
EXTRN	?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z:PROC ; ImGui::SetNextWindowContentSize
EXTRN	?SetNextWindowScroll@ImGui@@YAXAEBUImVec2@@@Z:PROC ; ImGui::SetNextWindowScroll
EXTRN	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetContentRegionAvail
EXTRN	?PushStyleColor@ImGui@@YAXHI@Z:PROC		; ImGui::PushStyleColor
EXTRN	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z:PROC	; ImGui::PushStyleColor
EXTRN	?PopStyleColor@ImGui@@YAXH@Z:PROC		; ImGui::PopStyleColor
EXTRN	?PushItemWidth@ImGui@@YAXM@Z:PROC		; ImGui::PushItemWidth
EXTRN	?PopItemWidth@ImGui@@YAXXZ:PROC			; ImGui::PopItemWidth
EXTRN	?GetColorU32@ImGui@@YAIHM@Z:PROC		; ImGui::GetColorU32
EXTRN	?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z:PROC ; ImGui::GetStyleColorVec4
EXTRN	?Separator@ImGui@@YAXXZ:PROC			; ImGui::Separator
EXTRN	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetCursorScreenPos
EXTRN	?GetTextLineHeight@ImGui@@YAMXZ:PROC		; ImGui::GetTextLineHeight
EXTRN	?PushID@ImGui@@YAXH@Z:PROC			; ImGui::PushID
EXTRN	?PopID@ImGui@@YAXXZ:PROC			; ImGui::PopID
EXTRN	?GetID@ImGui@@YAIPEBD@Z:PROC			; ImGui::GetID
EXTRN	?Text@ImGui@@YAXPEBDZZ:PROC			; ImGui::Text
EXTRN	?BulletText@ImGui@@YAXPEBDZZ:PROC		; ImGui::BulletText
EXTRN	?SmallButton@ImGui@@YA_NPEBD@Z:PROC		; ImGui::SmallButton
EXTRN	?Bullet@ImGui@@YAXXZ:PROC			; ImGui::Bullet
EXTRN	?TreeNode@ImGui@@YA_NPEBXPEBDZZ:PROC		; ImGui::TreeNode
EXTRN	?TreePop@ImGui@@YAXXZ:PROC			; ImGui::TreePop
EXTRN	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z:PROC ; ImGui::Selectable
EXTRN	?MenuItem@ImGui@@YA_NPEBD0_N1@Z:PROC		; ImGui::MenuItem
EXTRN	?SetTooltip@ImGui@@YAXPEBDZZ:PROC		; ImGui::SetTooltip
EXTRN	?EndPopup@ImGui@@YAXXZ:PROC			; ImGui::EndPopup
EXTRN	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z:PROC	; ImGui::PushClipRect
EXTRN	?PopClipRect@ImGui@@YAXXZ:PROC			; ImGui::PopClipRect
EXTRN	?IsItemHovered@ImGui@@YA_NH@Z:PROC		; ImGui::IsItemHovered
EXTRN	?IsItemVisible@ImGui@@YA_NXZ:PROC		; ImGui::IsItemVisible
EXTRN	?IsAnyItemHovered@ImGui@@YA_NXZ:PROC		; ImGui::IsAnyItemHovered
EXTRN	?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetItemRectMin
EXTRN	?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetItemRectMax
EXTRN	?SetItemAllowOverlap@ImGui@@YAXXZ:PROC		; ImGui::SetItemAllowOverlap
EXTRN	?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@XZ:PROC ; ImGui::GetForegroundDrawList
EXTRN	?GetFrameCount@ImGui@@YAHXZ:PROC		; ImGui::GetFrameCount
EXTRN	?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z:PROC ; ImGui::CalcTextSize
EXTRN	?IsMouseReleased@ImGui@@YA_NH@Z:PROC		; ImGui::IsMouseReleased
EXTRN	?IsMouseDoubleClicked@ImGui@@YA_NH@Z:PROC	; ImGui::IsMouseDoubleClicked
EXTRN	?GetMousePos@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetMousePos
EXTRN	?IsMouseDragging@ImGui@@YA_NHM@Z:PROC		; ImGui::IsMouseDragging
EXTRN	?SetMouseCursor@ImGui@@YAXH@Z:PROC		; ImGui::SetMouseCursor
EXTRN	?MemAlloc@ImGui@@YAPEAX_K@Z:PROC		; ImGui::MemAlloc
EXTRN	?MemFree@ImGui@@YAXPEAX@Z:PROC			; ImGui::MemFree
EXTRN	?append@ImGuiTextBuffer@@QEAAXPEBD0@Z:PROC	; ImGuiTextBuffer::append
EXTRN	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ:PROC	; ImGuiTextBuffer::appendf
EXTRN	?GetInt@ImGuiStorage@@QEBAHIH@Z:PROC		; ImGuiStorage::GetInt
EXTRN	?SetInt@ImGuiStorage@@QEAAXIH@Z:PROC		; ImGuiStorage::SetInt
EXTRN	?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z:PROC	; ImGuiStorage::GetIntRef
EXTRN	?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ:PROC ; ImDrawListSplitter::ClearFreeMemory
EXTRN	?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z:PROC ; ImDrawListSplitter::Split
EXTRN	?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z:PROC ; ImDrawListSplitter::Merge
EXTRN	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z:PROC ; ImDrawListSplitter::SetCurrentChannel
EXTRN	?PushClipRect@ImDrawList@@QEAAXAEBUImVec2@@0_N@Z:PROC ; ImDrawList::PushClipRect
EXTRN	?PopClipRect@ImDrawList@@QEAAXXZ:PROC		; ImDrawList::PopClipRect
EXTRN	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z:PROC ; ImDrawList::AddLine
EXTRN	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z:PROC ; ImDrawList::AddRect
EXTRN	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z:PROC ; ImDrawList::AddRectFilled
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	?ImHashStr@@YAIPEBD_KI@Z:PROC			; ImHashStr
EXTRN	?ImStrSkipBlank@@YAPEBDPEBD@Z:PROC		; ImStrSkipBlank
EXTRN	?ImFormatString@@YAHPEAD_KPEBDZZ:PROC		; ImFormatString
EXTRN	?GetID@ImGuiWindow@@QEAAIPEBD0@Z:PROC		; ImGuiWindow::GetID
EXTRN	?MarkIniSettingsDirty@ImGui@@YAXXZ:PROC		; ImGui::MarkIniSettingsDirty
EXTRN	?AddSettingsHandler@ImGui@@YAXPEBUImGuiSettingsHandler@@@Z:PROC ; ImGui::AddSettingsHandler
EXTRN	?SetScrollFromPosX@ImGui@@YAXPEAUImGuiWindow@@MM@Z:PROC ; ImGui::SetScrollFromPosX
EXTRN	?ClearActiveID@ImGui@@YAXXZ:PROC		; ImGui::ClearActiveID
EXTRN	?PushOverrideID@ImGui@@YAXI@Z:PROC		; ImGui::PushOverrideID
EXTRN	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z:PROC	; ImGui::ItemSize
EXTRN	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z:PROC	; ImGui::ItemAdd
EXTRN	?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z:PROC	; ImGui::ItemHoverable
EXTRN	?IsClippedEx@ImGui@@YA_NAEBUImRect@@I@Z:PROC	; ImGui::IsClippedEx
EXTRN	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z:PROC	; ImGui::CalcItemSize
EXTRN	?PushItemFlag@ImGui@@YAXH_N@Z:PROC		; ImGui::PushItemFlag
EXTRN	?PopItemFlag@ImGui@@YAXXZ:PROC			; ImGui::PopItemFlag
EXTRN	?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z:PROC ; ImGui::LogRenderedText
EXTRN	?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z:PROC ; ImGui::BeginChildEx
EXTRN	?OpenPopupEx@ImGui@@YAXIH@Z:PROC		; ImGui::OpenPopupEx
EXTRN	?BeginPopupEx@ImGui@@YA_NIH@Z:PROC		; ImGui::BeginPopupEx
EXTRN	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z:PROC	; ImGui::RenderText
EXTRN	?RenderTextEllipsis@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1MMPEBD2PEBU3@@Z:PROC ; ImGui::RenderTextEllipsis
EXTRN	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z:PROC ; ImGui::RenderNavHighlight
EXTRN	?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z:PROC	; ImGui::FindRenderedTextEnd
EXTRN	?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z:PROC ; ImGui::RenderArrow
EXTRN	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z:PROC ; ImGui::ButtonBehavior
EXTRN	?ErrorCheckUsingSetCursorPosToExtendParentBoundaries@ImGui@@YAXXZ:PROC ; ImGui::ErrorCheckUsingSetCursorPosToExtendParentBoundaries
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?GImGui@@3PEAUImGuiContext@@EA:QWORD		; GImGui
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN7
	DD	imagerel $LN7+181
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImVec2@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??0ImVec2@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImVec2@@QEAA@MM@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??0ImVec2@@QEAA@MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImVec4@@QEAA@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??0ImVec4@@QEAA@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z DD imagerel $LN3
	DD	imagerel $LN3+136
	DD	imagerel $unwind$?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EndTable@ImGui@@YAXXZ DD imagerel $LN68
	DD	imagerel $LN68+4111
	DD	imagerel $unwind$?EndTable@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableNextRow@ImGui@@YAXHM@Z DD imagerel $LN5
	DD	imagerel $LN5+372
	DD	imagerel $unwind$?TableNextRow@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableNextColumn@ImGui@@YA_NXZ DD imagerel $LN7
	DD	imagerel $LN7+199
	DD	imagerel $unwind$?TableNextColumn@ImGui@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetColumnIndex@ImGui@@YA_NH@Z DD imagerel $LN8
	DD	imagerel $LN8+218
	DD	imagerel $unwind$?TableSetColumnIndex@ImGui@@YA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetupColumn@ImGui@@YAXPEBDHMI@Z DD imagerel $LN30
	DD	imagerel $LN30+1138
	DD	imagerel $unwind$?TableSetupColumn@ImGui@@YAXPEBDHMI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetupScrollFreeze@ImGui@@YAXHH@Z DD imagerel $LN27
	DD	imagerel $LN27+902
	DD	imagerel $unwind$?TableSetupScrollFreeze@ImGui@@YAXHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableHeadersRow@ImGui@@YAXXZ DD imagerel $LN15
	DD	imagerel $LN15+537
	DD	imagerel $unwind$?TableHeadersRow@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableHeader@ImGui@@YAXPEBD@Z DD imagerel $LN54
	DD	imagerel $LN54+3055
	DD	imagerel $unwind$?TableHeader@ImGui@@YAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ DD imagerel $LN6
	DD	imagerel $LN6+168
	DD	imagerel $unwind$?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetColumnCount@ImGui@@YAHXZ DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$?TableGetColumnCount@ImGui@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetColumnIndex@ImGui@@YAHXZ DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?TableGetColumnIndex@ImGui@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetRowIndex@ImGui@@YAHXZ DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?TableGetRowIndex@ImGui@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetColumnName@ImGui@@YAPEBDH@Z DD imagerel $LN5
	DD	imagerel $LN5+124
	DD	imagerel $unwind$?TableGetColumnName@ImGui@@YAPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetColumnFlags@ImGui@@YAHH@Z DD imagerel $LN8
	DD	imagerel $LN8+197
	DD	imagerel $unwind$?TableGetColumnFlags@ImGui@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetColumnEnabled@ImGui@@YAXH_N@Z DD imagerel $LN9
	DD	imagerel $LN9+301
	DD	imagerel $unwind$?TableSetColumnEnabled@ImGui@@YAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetBgColor@ImGui@@YAXHIH@Z DD imagerel $LN20
	DD	imagerel $LN20+636
	DD	imagerel $unwind$?TableSetBgColor@ImGui@@YAXHIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Columns@ImGui@@YAXHPEBD_N@Z DD imagerel $LN9
	DD	imagerel $LN9+248
	DD	imagerel $unwind$?Columns@ImGui@@YAXHPEBD_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?NextColumn@ImGui@@YAXXZ DD imagerel $LN10
	DD	imagerel $LN10+787
	DD	imagerel $unwind$?NextColumn@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetColumnIndex@ImGui@@YAHXZ DD imagerel $LN5
	DD	imagerel $LN5+101
	DD	imagerel $unwind$?GetColumnIndex@ImGui@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetColumnWidth@ImGui@@YAMH@Z DD imagerel $LN5
	DD	imagerel $LN5+214
	DD	imagerel $unwind$?GetColumnWidth@ImGui@@YAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetColumnWidth@ImGui@@YAXHM@Z DD imagerel $LN5
	DD	imagerel $LN5+180
	DD	imagerel $unwind$?SetColumnWidth@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetColumnOffset@ImGui@@YAMH@Z DD imagerel $LN6
	DD	imagerel $LN6+229
	DD	imagerel $unwind$?GetColumnOffset@ImGui@@YAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetColumnOffset@ImGui@@YAXHM@Z DD imagerel $LN12
	DD	imagerel $LN12+564
	DD	imagerel $unwind$?SetColumnOffset@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetColumnsCount@ImGui@@YAHXZ DD imagerel $LN5
	DD	imagerel $LN5+101
	DD	imagerel $unwind$?GetColumnsCount@ImGui@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??2@YAPEAX_KUImNewWrapper@@PEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??2@YAPEAX_KUImNewWrapper@@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??3@YAXPEAXUImNewWrapper@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$??3@YAXPEAXUImNewWrapper@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiTableColumnSortSpecs@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??0ImGuiTableColumnSortSpecs@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiTableSortSpecs@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??0ImGuiTableSortSpecs@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImVector@D@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$??0?$ImVector@D@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@D@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$??1?$ImVector@D@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@D@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+124
	DD	imagerel $unwind$?clear@?$ImVector@D@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@D@@QEBAAEBDH@Z DD imagerel $LN5
	DD	imagerel $LN5+134
	DD	imagerel $unwind$??A?$ImVector@D@@QEBAAEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?swap@?$ImVector@D@@QEAAXAEAU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+195
	DD	imagerel $unwind$?swap@?$ImVector@D@@QEAAXAEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@D@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@D@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@D@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+121
	DD	imagerel $unwind$?resize@?$ImVector@D@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@D@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+189
	DD	imagerel $unwind$?reserve@?$ImVector@D@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiTextBuffer@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$??0ImGuiTextBuffer@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@ImGuiTextBuffer@@QEBAHXZ DD imagerel $LN5
	DD	imagerel $LN5+97
	DD	imagerel $unwind$?size@ImGuiTextBuffer@@QEBAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@ImGuiTextBuffer@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?clear@ImGuiTextBuffer@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@ImGuiTextBuffer@@QEAAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?reserve@ImGuiTextBuffer@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiTextBuffer@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??1ImGuiTextBuffer@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImGuiStoragePair@ImGuiStorage@@@@QEAAAEAUImGuiStoragePair@ImGuiStorage@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+132
	DD	imagerel $unwind$??A?$ImVector@UImGuiStoragePair@ImGuiStorage@@@@QEAAAEAUImGuiStoragePair@ImGuiStorage@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+132
	DD	imagerel $unwind$??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ DD imagerel $LN4
	DD	imagerel $LN4+120
	DD	imagerel $unwind$?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+112
	DD	imagerel $unwind$?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImVector@UImDrawChannel@@@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$??0?$ImVector@UImDrawChannel@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+132
	DD	imagerel $unwind$??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+121
	DD	imagerel $unwind$?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+197
	DD	imagerel $unwind$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImDrawListSplitter@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$??0ImDrawListSplitter@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImDrawListSplitter@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??1ImDrawListSplitter@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?Clear@ImDrawListSplitter@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ DD imagerel $LN4
	DD	imagerel $LN4+120
	DD	imagerel $unwind$?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$ImVector@I@@QEAAAEAIXZ DD imagerel $LN4
	DD	imagerel $LN4+120
	DD	imagerel $unwind$?back@?$ImVector@I@@QEAAAEAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@M@@QEAAAEAMH@Z DD imagerel $LN5
	DD	imagerel $LN5+132
	DD	imagerel $unwind$??A?$ImVector@M@@QEAAAEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@M@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@M@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@M@@QEAAXHAEBM@Z DD imagerel $LN8
	DD	imagerel $LN8+218
	DD	imagerel $unwind$?resize@?$ImVector@M@@QEAAXHAEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@M@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+197
	DD	imagerel $unwind$?reserve@?$ImVector@M@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_scanf_options DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$__local_stdio_scanf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+126
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+175
	DD	imagerel $unwind$sscanf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImIsPowerOfTwo@@YA_NH@Z DD imagerel ?ImIsPowerOfTwo@@YA_NH@Z
	DD	imagerel ?ImIsPowerOfTwo@@YA_NH@Z+108
	DD	imagerel $unwind$?ImIsPowerOfTwo@@YA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??H@YA?AUImVec2@@AEBU0@0@Z DD imagerel ??H@YA?AUImVec2@@AEBU0@0@Z
	DD	imagerel ??H@YA?AUImVec2@@AEBU0@0@Z+81
	DD	imagerel $unwind$??H@YA?AUImVec2@@AEBU0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImMin@@YA?AUImVec2@@AEBU1@0@Z DD imagerel ?ImMin@@YA?AUImVec2@@AEBU1@0@Z
	DD	imagerel ?ImMin@@YA?AUImVec2@@AEBU1@0@Z+148
	DD	imagerel $unwind$?ImMin@@YA?AUImVec2@@AEBU1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImMax@@YA?AUImVec2@@AEBU1@0@Z DD imagerel ?ImMax@@YA?AUImVec2@@AEBU1@0@Z
	DD	imagerel ?ImMax@@YA?AUImVec2@@AEBU1@0@Z+148
	DD	imagerel $unwind$?ImMax@@YA?AUImVec2@@AEBU1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z DD imagerel ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z
	DD	imagerel ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z+226
	DD	imagerel $unwind$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImFloor@@YAMM@Z DD imagerel ?ImFloor@@YAMM@Z
	DD	imagerel ?ImFloor@@YAMM@Z+29
	DD	imagerel $unwind$?ImFloor@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ImMin@M@@YAMMM@Z DD imagerel ??$ImMin@M@@YAMMM@Z
	DD	imagerel ??$ImMin@M@@YAMMM@Z+110
	DD	imagerel $unwind$??$ImMin@M@@YAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ImMax@M@@YAMMM@Z DD imagerel ??$ImMax@M@@YAMMM@Z
	DD	imagerel ??$ImMax@M@@YAMMM@Z+110
	DD	imagerel $unwind$??$ImMax@M@@YAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImVec1@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??0ImVec1@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImRect@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0ImRect@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImRect@@QEAA@AEBUImVec2@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??0ImRect@@QEAA@AEBUImVec2@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImRect@@QEAA@AEBUImVec4@@@Z DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$??0ImRect@@QEAA@AEBUImVec4@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImRect@@QEAA@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??0ImRect@@QEAA@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSize@ImRect@@QEBA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?GetSize@ImRect@@QEBA?AUImVec2@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetWidth@ImRect@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?GetWidth@ImRect@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetHeight@ImRect@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?GetHeight@ImRect@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Contains@ImRect@@QEBA_NAEBU1@@Z DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$?Contains@ImRect@@QEBA_NAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Overlaps@ImRect@@QEBA_NAEBU1@@Z DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$?Overlaps@ImRect@@QEBA_NAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Add@ImRect@@QEAAXAEBU1@@Z DD imagerel $LN7
	DD	imagerel $LN7+168
	DD	imagerel $unwind$?Add@ImRect@@QEAAXAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClipWith@ImRect@@QEAAXAEBU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$?ClipWith@ImRect@@QEAAXAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClipWithFull@ImRect@@QEAAXAEBU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+113
	DD	imagerel $unwind$?ClipWithFull@ImRect@@QEAAXAEBU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ToVec4@ImRect@@QEBA?AUImVec4@@XZ DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$?ToVec4@ImRect@@QEBA?AUImVec4@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImBitArrayClearAllBits@@YAXPEAIH@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?ImBitArrayClearAllBits@@YAXPEAIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImBitArrayClearBit@@YAXPEAIH@Z DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?ImBitArrayClearBit@@YAXPEAIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImBitArraySetBit@@YAXPEAIH@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?ImBitArraySetBit@@YAXPEAIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImBitArraySetBitRange@@YAXPEAIHH@Z DD imagerel $LN7
	DD	imagerel $LN7+211
	DD	imagerel $unwind$?ImBitArraySetBitRange@@YAXPEAIHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ImMin@H@@YAHHH@Z DD imagerel ??$ImMin@H@@YAHHH@Z
	DD	imagerel ??$ImMin@H@@YAHHH@Z+98
	DD	imagerel $unwind$??$ImMin@H@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiOldColumnData@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+98
	DD	imagerel $unwind$??0ImGuiOldColumnData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+132
	DD	imagerel $unwind$??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+121
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+197
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z DD imagerel $LN4
	DD	imagerel $LN4+183
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiOldColumns@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+187
	DD	imagerel $unwind$??0ImGuiOldColumns@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiOldColumns@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImGuiOldColumns@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiOldColumns@@QEAA@XZ@4HA+43
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiOldColumns@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiOldColumns@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$??1ImGuiOldColumns@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiSettingsHandler@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??0ImGuiSettingsHandler@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImGuiTableTempData@@@@QEAAAEAUImGuiTableTempData@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+132
	DD	imagerel $unwind$??A?$ImVector@UImGuiTableTempData@@@@QEAAAEAUImGuiTableTempData@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiTableTempData@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiTableTempData@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiTableTempData@@@@QEAAXHAEBUImGuiTableTempData@@@Z DD imagerel $LN8
	DD	imagerel $LN8+218
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiTableTempData@@@@QEAAXHAEBUImGuiTableTempData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiTableTempData@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+197
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiTableTempData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiTable@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiTable@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiTable@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+121
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiTable@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiTable@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+203
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiTable@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$?GetByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetByIndex@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?GetByIndex@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z DD imagerel $LN5
	DD	imagerel $LN5+176
	DD	imagerel $unwind$?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetOrAddByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z DD imagerel $LN4
	DD	imagerel $LN4+151
	DD	imagerel $unwind$?GetOrAddByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ DD imagerel $LN8
	DD	imagerel $LN8+338
	DD	imagerel $unwind$?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ@4HA DD imagerel ?dtor$0@?0??Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ@4HA
	DD	imagerel ?dtor$0@?0??Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ@4HA+56
	DD	imagerel $unwind$?dtor$0@?0??Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Remove@?$ImPool@UImGuiTable@@@@QEAAXIPEBUImGuiTable@@@Z DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$?Remove@?$ImPool@UImGuiTable@@@@QEAAXIPEBUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Remove@?$ImPool@UImGuiTable@@@@QEAAXIH@Z DD imagerel $LN3
	DD	imagerel $LN3+194
	DD	imagerel $unwind$?Remove@?$ImPool@UImGuiTable@@@@QEAAXIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetMapSize@?$ImPool@UImGuiTable@@@@QEBAHXZ DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?GetMapSize@?$ImPool@UImGuiTable@@@@QEBAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TryGetMapData@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+112
	DD	imagerel $unwind$?TryGetMapData@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+196
	DD	imagerel $unwind$?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ DD imagerel $LN4
	DD	imagerel $LN4+91
	DD	imagerel $unwind$?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z DD imagerel $LN7
	DD	imagerel $LN7+261
	DD	imagerel $unwind$?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?chunk_size@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$?chunk_size@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?offset_from_ptr@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z DD imagerel $LN5
	DD	imagerel $LN5+158
	DD	imagerel $unwind$?offset_from_ptr@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ptr_from_offset@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+128
	DD	imagerel $unwind$?ptr_from_offset@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$??0?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$??A?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ DD imagerel $LN4
	DD	imagerel $LN4+123
	DD	imagerel $unwind$?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+203
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z DD imagerel $LN4
	DD	imagerel $LN4+186
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ DD imagerel $LN3
	DD	imagerel $LN3+157
	DD	imagerel $unwind$?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiTableColumn@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+305
	DD	imagerel $unwind$??0ImGuiTableColumn@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiTableInstanceData@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$??0ImGuiTableInstanceData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImSpan@UImGuiTableColumn@@@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??0?$ImSpan@UImGuiTableColumn@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?set@?$ImSpan@UImGuiTableColumn@@@@QEAAXPEAUImGuiTableColumn@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?set@?$ImSpan@UImGuiTableColumn@@@@QEAAXPEAUImGuiTableColumn@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$ImSpan@UImGuiTableColumn@@@@QEBAHXZ DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?size@?$ImSpan@UImGuiTableColumn@@@@QEBAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?index_from_ptr@?$ImSpan@UImGuiTableColumn@@@@QEBAHPEBUImGuiTableColumn@@@Z DD imagerel $LN5
	DD	imagerel $LN5+164
	DD	imagerel $unwind$?index_from_ptr@?$ImSpan@UImGuiTableColumn@@@@QEBAHPEBUImGuiTableColumn@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImSpan@F@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??0?$ImSpan@F@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?set@?$ImSpan@F@@QEAAXPEAF0@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?set@?$ImSpan@F@@QEAAXPEAF0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImSpan@F@@QEAAAEAFH@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$??A?$ImSpan@F@@QEAAAEAFH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImSpan@UImGuiTableCellData@@@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$??0?$ImSpan@UImGuiTableCellData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?set@?$ImSpan@UImGuiTableCellData@@@@QEAAXPEAUImGuiTableCellData@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?set@?$ImSpan@UImGuiTableCellData@@@@QEAAXPEAUImGuiTableCellData@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$??0?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImGuiTableInstanceData@@@@QEAAAEAUImGuiTableInstanceData@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+132
	DD	imagerel $unwind$??A?$ImVector@UImGuiTableInstanceData@@@@QEAAAEAUImGuiTableInstanceData@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiTableInstanceData@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiTableInstanceData@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiTableInstanceData@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+197
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiTableInstanceData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiTableInstanceData@@@@QEAAXAEBUImGuiTableInstanceData@@@Z DD imagerel $LN4
	DD	imagerel $LN4+183
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiTableInstanceData@@@@QEAAXAEBUImGuiTableInstanceData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$??0?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+124
	DD	imagerel $unwind$?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+121
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+197
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiTable@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+479
	DD	imagerel $unwind$??0ImGuiTable@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiTable@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImGuiTable@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiTable@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiTable@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ImGuiTable@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0ImGuiTable@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0ImGuiTable@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$1@?0???0ImGuiTable@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0ImGuiTable@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???0ImGuiTable@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???0ImGuiTable@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$2@?0???0ImGuiTable@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiTable@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+146
	DD	imagerel $unwind$??1ImGuiTable@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImGuiTable@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+105
	DD	imagerel $unwind$??_GImGuiTable@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiTableTempData@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+263
	DD	imagerel $unwind$??0ImGuiTableTempData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ImGuiTableTempData@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0ImGuiTableTempData@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0ImGuiTableTempData@@QEAA@XZ@4HA+43
	DD	imagerel $unwind$?dtor$0@?0???0ImGuiTableTempData@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiTableTempData@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??1ImGuiTableTempData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiTableColumnSettings@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+202
	DD	imagerel $unwind$??0ImGuiTableColumnSettings@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiTableSettings@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??0ImGuiTableSettings@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z DD imagerel $LN5
	DD	imagerel $LN5+123
	DD	imagerel $unwind$?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ItemSize@ImGui@@YAXAEBUImRect@@M@Z DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$?ItemSize@ImGui@@YAXAEBUImRect@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z DD imagerel $LN3
	DD	imagerel $LN3+248
	DD	imagerel $unwind$?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginColumns@ImGui@@YAXPEBDHH@Z DD imagerel $LN17
	DD	imagerel $LN17+1707
	DD	imagerel $unwind$?BeginColumns@ImGui@@YAXPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EndColumns@ImGui@@YAXXZ DD imagerel $LN24
	DD	imagerel $LN24+1454
	DD	imagerel $unwind$?EndColumns@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PushColumnClipRect@ImGui@@YAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+149
	DD	imagerel $unwind$?PushColumnClipRect@ImGui@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PushColumnsBackground@ImGui@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+154
	DD	imagerel $unwind$?PushColumnsBackground@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PopColumnsBackground@ImGui@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+132
	DD	imagerel $unwind$?PopColumnsBackground@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetColumnsID@ImGui@@YAIPEBDH@Z DD imagerel $LN7
	DD	imagerel $LN7+187
	DD	imagerel $unwind$?GetColumnsID@ImGui@@YAIPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z DD imagerel $LN8
	DD	imagerel $LN8+279
	DD	imagerel $unwind$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA DD imagerel ?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA
	DD	imagerel ?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableOpenContextMenu@ImGui@@YAXH@Z DD imagerel $LN8
	DD	imagerel $LN8+284
	DD	imagerel $unwind$?TableOpenContextMenu@ImGui@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetColumnWidth@ImGui@@YAXHM@Z DD imagerel $LN23
	DD	imagerel $LN23+926
	DD	imagerel $unwind$?TableSetColumnWidth@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetColumnSortDirection@ImGui@@YAXHH_N@Z DD imagerel $LN20
	DD	imagerel $LN20+589
	DD	imagerel $unwind$?TableSetColumnSortDirection@ImGui@@YAXHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetHoveredColumn@ImGui@@YAHXZ DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$?TableGetHoveredColumn@ImGui@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetHeaderRowHeight@ImGui@@YAMXZ DD imagerel $LN7
	DD	imagerel $LN7+223
	DD	imagerel $unwind$?TableGetHeaderRowHeight@ImGui@@YAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TablePushBackgroundChannel@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+175
	DD	imagerel $unwind$?TablePushBackgroundChannel@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TablePopBackgroundChannel@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+168
	DD	imagerel $unwind$?TablePopBackgroundChannel@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableFindByID@ImGui@@YAPEAUImGuiTable@@I@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$?TableFindByID@ImGui@@YAPEAUImGuiTable@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z DD imagerel $LN88
	DD	imagerel $LN88+5345
	DD	imagerel $unwind$?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4HA DD imagerel ?dtor$0@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4HA
	DD	imagerel ?dtor$0@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z DD imagerel $LN6
	DD	imagerel $LN6+528
	DD	imagerel $unwind$?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN25
	DD	imagerel $LN25+1217
	DD	imagerel $unwind$?TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN22
	DD	imagerel $LN22+978
	DD	imagerel $unwind$?TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN118
	DD	imagerel $LN118+7666
	DD	imagerel $unwind$?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN21
	DD	imagerel $LN21+1180
	DD	imagerel $unwind$?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN19
	DD	imagerel $LN19+592
	DD	imagerel $unwind$?TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN46
	DD	imagerel $LN46+2305
	DD	imagerel $unwind$?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableDrawContextMenu@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN34
	DD	imagerel $LN34+1044
	DD	imagerel $unwind$?TableDrawContextMenu@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableBeginContextMenuPopup@ImGui@@YA_NPEAUImGuiTable@@@Z DD imagerel $LN6
	DD	imagerel $LN6+167
	DD	imagerel $unwind$?TableBeginContextMenuPopup@ImGui@@YA_NPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN65
	DD	imagerel $LN65+3177
	DD	imagerel $unwind$?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+109
	DD	imagerel $unwind$?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN36
	DD	imagerel $LN36+1270
	DD	imagerel $unwind$?TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN16
	DD	imagerel $LN16+651
	DD	imagerel $unwind$?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z DD imagerel $LN10
	DD	imagerel $LN10+303
	DD	imagerel $unwind$?TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z DD imagerel $LN5
	DD	imagerel $LN5+198
	DD	imagerel $unwind$?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetColumnWidthAuto@ImGui@@YAMPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z DD imagerel $LN7
	DD	imagerel $LN7+292
	DD	imagerel $unwind$?TableGetColumnWidthAuto@ImGui@@YAMPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN7
	DD	imagerel $LN7+612
	DD	imagerel $unwind$?TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN52
	DD	imagerel $LN52+3189
	DD	imagerel $unwind$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z DD imagerel $LN9
	DD	imagerel $LN9+761
	DD	imagerel $unwind$?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN8
	DD	imagerel $LN8+390
	DD	imagerel $unwind$?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+241
	DD	imagerel $unwind$?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+185
	DD	imagerel $unwind$?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z DD imagerel $LN5
	DD	imagerel $LN5+169
	DD	imagerel $unwind$?TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetMaxColumnWidth@ImGui@@YAMPEBUImGuiTable@@H@Z DD imagerel $LN7
	DD	imagerel $LN7+545
	DD	imagerel $unwind$?TableGetMaxColumnWidth@ImGui@@YAMPEBUImGuiTable@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+128
	DD	imagerel $unwind$?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetColumnWidthAutoAll@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN7
	DD	imagerel $LN7+155
	DD	imagerel $unwind$?TableSetColumnWidthAutoAll@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableRemove@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN3
	DD	imagerel $LN3+158
	DD	imagerel $unwind$?TableRemove@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN7
	DD	imagerel $LN7+323
	DD	imagerel $unwind$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGcCompactSettings@ImGui@@YAXXZ DD imagerel $LN13
	DD	imagerel $LN13+448
	DD	imagerel $unwind$?TableGcCompactSettings@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA DD imagerel ?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA+36
	DD	imagerel $unwind$?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableLoadSettings@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN27
	DD	imagerel $LN27+1010
	DD	imagerel $unwind$?TableLoadSettings@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN25
	DD	imagerel $LN25+1001
	DD	imagerel $unwind$?TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableResetSettings@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$?TableResetSettings@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z DD imagerel $LN6
	DD	imagerel $LN6+201
	DD	imagerel $unwind$?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsAddSettingsHandler@ImGui@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+192
	DD	imagerel $unwind$?TableSettingsAddSettingsHandler@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z DD imagerel $LN3
	DD	imagerel $LN3+132
	DD	imagerel $unwind$?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z DD imagerel $LN7
	DD	imagerel $LN7+142
	DD	imagerel $unwind$?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN39
	DD	imagerel $LN39+3157
	DD	imagerel $unwind$?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DebugNodeTableSettings@ImGui@@YAXPEAUImGuiTableSettings@@@Z DD imagerel $LN15
	DD	imagerel $LN15+527
	DD	imagerel $unwind$?DebugNodeTableSettings@ImGui@@YAXPEAUImGuiTableSettings@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableFixFlags@@YAHHPEAUImGuiWindow@@@Z DD imagerel $LN12
	DD	imagerel $LN12+345
	DD	imagerel $unwind$?TableFixFlags@@YAHHPEAUImGuiWindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImSpanAllocator@$05@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??0?$ImSpanAllocator@$05@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z DD imagerel $LN5
	DD	imagerel $LN5+263
	DD	imagerel $unwind$?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetArenaSizeInBytes@?$ImSpanAllocator@$05@@QEAAHXZ DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?GetArenaSizeInBytes@?$ImSpanAllocator@$05@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetArenaBasePtr@?$ImSpanAllocator@$05@@QEAAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?SetArenaBasePtr@?$ImSpanAllocator@$05@@QEAAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSpanPtrEnd@?$ImSpanAllocator@$05@@QEAAPEAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+172
	DD	imagerel $unwind$?GetSpanPtrEnd@?$ImSpanAllocator@$05@@QEAAPEAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetSpan@UImGuiTableColumn@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableColumn@@@@@Z DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$??$GetSpan@UImGuiTableColumn@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableColumn@@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetSpan@F@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@F@@@Z DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$??$GetSpan@F@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@F@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetSpan@UImGuiTableCellData@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableCellData@@@@@Z DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$??$GetSpan@UImGuiTableCellData@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableCellData@@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z DD imagerel ?TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z
	DD	imagerel ?TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z+955
	DD	imagerel $unwind$?TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ImClamp@M@@YAMMMM@Z DD imagerel ??$ImClamp@M@@YAMMMM@Z
	DD	imagerel ??$ImClamp@M@@YAMMMM@Z+167
	DD	imagerel $unwind$??$ImClamp@M@@YAMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ImSwap@F@@YAXAEAF0@Z DD imagerel ??$ImSwap@F@@YAXAEAF0@Z
	DD	imagerel ??$ImSwap@F@@YAXAEAF0@Z+103
	DD	imagerel $unwind$??$ImSwap@F@@YAXAEAF0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ DD imagerel ??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ
	DD	imagerel ??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ+74
	DD	imagerel $unwind$??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z DD imagerel ?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z
	DD	imagerel ?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z+140
	DD	imagerel $unwind$?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ImMax@F@@YAFFF@Z DD imagerel ??$ImMax@F@@YAFFF@Z
	DD	imagerel ??$ImMax@F@@YAFFF@Z+110
	DD	imagerel $unwind$??$ImMax@F@@YAFFF@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z DD imagerel ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z
	DD	imagerel ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z+405
	DD	imagerel $unwind$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA DD imagerel ?dtor$0@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA
	DD	imagerel ?dtor$0@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA+56
	DD	imagerel $unwind$?dtor$0@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA DD imagerel ?dtor$1@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA
	DD	imagerel ?dtor$1@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA+53
	DD	imagerel $unwind$?dtor$1@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsCalcChunkSize@@YA_KH@Z DD imagerel ?TableSettingsCalcChunkSize@@YA_KH@Z
	DD	imagerel ?TableSettingsCalcChunkSize@@YA_KH@Z+63
	DD	imagerel $unwind$?TableSettingsCalcChunkSize@@YA_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z DD imagerel ?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z
	DD	imagerel ?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z+171
	DD	imagerel $unwind$?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z DD imagerel ?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z
	DD	imagerel ?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z+164
	DD	imagerel $unwind$?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z DD imagerel ?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z
	DD	imagerel ?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z+252
	DD	imagerel $unwind$?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z DD imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
	DD	imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z+1092
	DD	imagerel $unwind$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+1153
	DD	imagerel $unwind$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DebugNodeTableGetSizingPolicyDesc@@YAPEBDH@Z DD imagerel ?DebugNodeTableGetSizingPolicyDesc@@YAPEBDH@Z
	DD	imagerel ?DebugNodeTableGetSizingPolicyDesc@@YAPEBDH@Z+156
	DD	imagerel $unwind$?DebugNodeTableGetSizingPolicyDesc@@YAPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z DD imagerel ?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z
	DD	imagerel ?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z+344
	DD	imagerel $unwind$?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ImLerp@M@@YAMMMM@Z DD imagerel ??$ImLerp@M@@YAMMMM@Z
	DD	imagerel ??$ImLerp@M@@YAMMMM@Z+96
	DD	imagerel $unwind$??$ImLerp@M@@YAMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z DD imagerel ?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z
	DD	imagerel ?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z+268
	DD	imagerel $unwind$?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z
pdata	ENDS
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+38
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+38
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3d75c28f
CONST	SEGMENT
__real@3d75c28f DD 03d75c28fr			; 0.06
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@00800000
CONST	SEGMENT
__real@00800000 DD 000800000r			; 1.17549e-38
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1FC@BIEMKEOL@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CL?$AA?5@
CONST	SEGMENT
??_C@_1FC@BIEMKEOL@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CL?$AA?5@ DB 'p'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'B', 00H, 'u', 00H
	DB	'f', 00H, '.', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'p', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'B', 00H, 'u', 00H, 'f', 00H, '.', 00H, 'D', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'B', 00H
	DB	'u', 00H, 'f', 00H, '.', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@OEELIPPM@?$AAp?$AA?5?$AA?$DM?$AA?5?$AAe?$AAn?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@OEELIPPM@?$AAp?$AA?5?$AA?$DM?$AA?5?$AAe?$AAn?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'p'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'd', 00H
	DB	'(', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@BDDBABLK@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAe?$AAg?$AAi?$AAn?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAe?$AAn?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@BDDBABLK@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAe?$AAg?$AAi?$AAn?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAe?$AAn?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'p'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'b', 00H, 'e', 00H
	DB	'g', 00H, 'i', 00H, 'n', 00H, '(', 00H, ')', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'p', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'e', 00H, 'n', 00H, 'd', 00H, '(', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@EPOMENA@?$AAo?$AAf?$AAf?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA4?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAf?$AAf?$AA?5?$AA?$DM?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@EPOMENA@?$AAo?$AAf?$AAf?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA4?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAf?$AAf?$AA?5?$AA?$DM?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ DB 'o'
	DB	00H, 'f', 00H, 'f', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'4', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, 'f', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'B', 00H, 'u', 00H
	DB	'f', 00H, '.', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'S'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@OANBFKML@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAt?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@OANBFKML@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAt?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@ DB 'i'
	DB	00H, 't', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'D', 00H
	DB	'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'D', 00H
	DB	'a', 00H, 't', 00H, 'a', 00H, 'E', 00H, 'n', 00H, 'd', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@DHFOGPCD@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@DHFOGPCD@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@ DB 'p'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'D', 00H, 'a', 00H
	DB	't', 00H, 'a', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'p'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'D', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, 'E', 00H, 'n', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ DB 'i'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@BODLFGJA@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAC?$AAu?$AAr?$AAr?$AAI?$AAd?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AAC?$AAH?$AAU?$AAN?$AAK?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@BODLFGJA@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAC?$AAu?$AAr?$AAr?$AAI?$AAd?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AAC?$AAH?$AAU?$AAN?$AAK?$AAS?$AA?$AA@ DB 'n'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'u', 00H
	DB	'r', 00H, 'r', 00H, 'I', 00H, 'd', 00H, 'x', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'n', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'C', 00H, 'H', 00H, 'U', 00H, 'N', 00H, 'K', 00H, 'S', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1FE@GEHGFLGL@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AAC?$AAH?$AAU?$AAN?$AAK?$AAS?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAC?$AAu?$AAr?$AAr?$AAI?$AAd?$AAx?$AA?5@
CONST	SEGMENT
??_C@_1FE@GEHGFLGL@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AAC?$AAH?$AAU?$AAN?$AAK?$AAS?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAC?$AAu?$AAr?$AAr?$AAI?$AAd?$AAx?$AA?5@ DB 'n'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'n', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 'C', 00H, 'H', 00H, 'U', 00H, 'N', 00H, 'K', 00H, 'S', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'C', 00H, 'u', 00H, 'r'
	DB	00H, 'r', 00H, 'I', 00H, 'd', 00H, 'x', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'C', 00H, 'H', 00H, 'U', 00H, 'N', 00H, 'K'
	DB	00H, 'S', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Columns@ImGui@@YAXHPEBD_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??Columns@ImGui@@YAXHPEBD_N@Z@4JA DD 0ff7H ; `ImGui::Columns'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??EndColumns@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??EndColumns@ImGui@@YAXXZ@4JA DD 0facH	; `ImGui::EndColumns'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CM@HCFAHNAF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@HCFAHNAF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	'-', 00H, '>', 00H, 'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??NextColumn@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??NextColumn@ImGui@@YAXXZ@4JA DD 0f74H	; `ImGui::NextColumn'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CE@IJEAECLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@IJEAECLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAd?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	'-', 00H, '>', 00H, 'I', 00H, 'D', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'i', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@BPFJENMI@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@BPFJENMI@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-', 00H
	DB	'>', 00H, 'D', 00H, 'C', 00H, '.', 00H, 'C', 00H, 'u', 00H, 'r'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H, 'o', 00H
	DB	'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@GDAJJGIO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@GDAJJGIO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??BeginColumns@ImGui@@YAXPEBDHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??BeginColumns@ImGui@@YAXPEBDHH@Z@4JA DD 0f27H ; `ImGui::BeginColumns'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_07HIFEPIJN@columns?$AA@
CONST	SEGMENT
??_C@_07HIFEPIJN@columns?$AA@ DB 'columns', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetColumnWidth@ImGui@@YAXHM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetColumnWidth@ImGui@@YAXHM@Z@4JA DD 0eddH ; `ImGui::SetColumnWidth'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetColumnOffset@ImGui@@YAXHM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetColumnOffset@ImGui@@YAXHM@Z@4JA DD 0ec7H ; `ImGui::SetColumnOffset'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EK@FCGFMMCK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?4@
CONST	SEGMENT
??_C@_1EK@FCGFMMCK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?4@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H
	DB	'i', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H
	DB	'n', 00H, 's', 00H, '-', 00H, '>', 00H, 'C', 00H, 'o', 00H, 'l'
	DB	00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H, '.', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetColumnOffset@ImGui@@YAMH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetColumnOffset@ImGui@@YAMH@Z@4JA DD 0e9dH ; `ImGui::GetColumnOffset'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1GE@CFLLPKGA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$CL?$AA?5?$AAI?$AAm?$AAG?$AAu@
CONST	SEGMENT
??_C@_1GE@CFLLPKGA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$CL?$AA?5?$AAI?$AAm?$AAG?$AAu@ DB 'g'
	DB	00H, '.', 00H, 'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'v', 00H
	DB	'e', 00H, 'I', 00H, 'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H
	DB	's', 00H, '-', 00H, '>', 00H, 'I', 00H, 'D', 00H, ' ', 00H, '+'
	DB	00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H
	DB	'I', 00H, 'D', 00H, '(', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u'
	DB	00H, 'm', 00H, 'n', 00H, '_', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'e', 00H, 'x', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@HNMGCLDB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@HNMGCLDB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H
	DB	'i', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z@4JA DD 0e8cH ; `GetDraggedColumnOffset'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EB@CNABLLAJ@Column?5?$CFd?5Order?5?$CFd?5SortOrder?5?$CFd?5@
CONST	SEGMENT
??_C@_0EB@CNABLLAJ@Column?5?$CFd?5Order?5?$CFd?5SortOrder?5?$CFd?5@ DB 'C'
	DB	'olumn %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%0'
	DB	'8X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03JMFMNIFM@?9?9?9?$AA@
CONST	SEGMENT
??_C@_03JMFMNIFM@?9?9?9?$AA@ DB '---', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IAMDMMHH@Des?$AA@
CONST	SEGMENT
??_C@_03IAMDMMHH@Des?$AA@ DB 'Des', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFHEPBNG@Asc?$AA@
CONST	SEGMENT
??_C@_03OFHEPBNG@Asc?$AA@ DB 'Asc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06PALFPBFG@Width?5?$AA@
CONST	SEGMENT
??_C@_06PALFPBFG@Width?5?$AA@ DB 'Width ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ODJMJFLN@Weight?$AA@
CONST	SEGMENT
??_C@_06ODJMJFLN@Weight?$AA@ DB 'Weight', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OLKPLDMA@ColumnsCount?3?5?$CFd?5?$CImax?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@OLKPLDMA@ColumnsCount?3?5?$CFd?5?$CImax?5?$CFd?$CJ?$AA@ DB 'Col'
	DB	'umnsCount: %d (max %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJHOAHJA@SaveFlags?3?50x?$CF08X?$AA@
CONST	SEGMENT
??_C@_0BC@LJHOAHJA@SaveFlags?3?50x?$CF08X?$AA@ DB 'SaveFlags: 0x%08X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LNKMILO@Settings?50x?$CF08X?5?$CI?$CFd?5columns?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@LNKMILO@Settings?50x?$CF08X?5?$CI?$CFd?5columns?$CJ?$AA@ DB 'Se'
	DB	'ttings 0x%08X (%d columns)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BHH@CNHMONCM@Column?5?$CFd?5order?5?$CFd?5?8?$CFs?8?3?5offset?5@
CONST	SEGMENT
??_C@_0BHH@CNHMONCM@Column?5?$CFd?5order?5?$CFd?5?8?$CFs?8?3?5offset?5@ DB 'C'
	DB	'olumn %d order %d ''%s'': offset %+.2f to %+.2f%s', 0aH, 'Ena'
	DB	'bled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d'
	DB	', DrawChannels: %d,%d', 0aH, 'WidthGiven: %.1f, Request/Auto:'
	DB	' %.1f/%.1f, StretchWeight: %.3f (%.1f%%)', 0aH, 'MinX: %.1f, '
	DB	'MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)', 0aH, 'Co'
	DB	'ntentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f', 0aH, 'So'
	DB	'rt: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LODDIFJL@?5?$CIFrozen?$CJ?$AA@
CONST	SEGMENT
??_C@_09LODDIFJL@?5?$CIFrozen?$CJ?$AA@ DB ' (Frozen)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PFKLCOBM@?5?$CIDes?$CJ?$AA@
CONST	SEGMENT
??_C@_06PFKLCOBM@?5?$CIDes?$CJ?$AA@ DB ' (Des)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FEBPAKFP@?5?$CIAsc?$CJ?$AA@
CONST	SEGMENT
??_C@_06FEBPAKFP@?5?$CIAsc?$CJ?$AA@ DB ' (Asc)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PEPBBILL@WidthStretch?5?$AA@
CONST	SEGMENT
??_C@_0O@PEPBBILL@WidthStretch?5?$AA@ DB 'WidthStretch ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IGDNFKMD@WidthFixed?5?$AA@
CONST	SEGMENT
??_C@_0M@IGDNFKMD@WidthFixed?5?$AA@ DB 'WidthFixed ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BHNPHONE@NoResize?5?$AA@
CONST	SEGMENT
??_C@_09BHNPHONE@NoResize?5?$AA@ DB 'NoResize ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@PBPICJCB@ResizedColumn?3?5?$CFd?0?5ReorderColumn@
CONST	SEGMENT
??_C@_0DL@PBPICJCB@ResizedColumn?3?5?$CFd?0?5ReorderColumn@ DB 'ResizedCo'
	DB	'lumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NOMNLPPG@HoveredColumnBody?3?5?$CFd?0?5HoveredCo@
CONST	SEGMENT
??_C@_0CP@NOMNLPPG@HoveredColumnBody?3?5?$CFd?0?5HoveredCo@ DB 'HoveredCo'
	DB	'lumnBody: %d, HoveredColumnBorder: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@FOKPBOFF@CellPaddingX?3?5?$CF?41f?0?5CellSpacingX@
CONST	SEGMENT
??_C@_0EB@FOKPBOFF@CellPaddingX?3?5?$CF?41f?0?5CellSpacingX@ DB 'CellPadd'
	DB	'ingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@GODPECNO@ColumnsGivenWidth?3?5?$CF?41f?0?5Columns@
CONST	SEGMENT
??_C@_0EH@GODPECNO@ColumnsGivenWidth?3?5?$CF?41f?0?5Columns@ DB 'ColumnsG'
	DB	'ivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07IOPDKCEG@?5?$CIauto?$CJ?$AA@
CONST	SEGMENT
??_C@_07IOPDKCEG@?5?$CIauto?$CJ?$AA@ DB ' (auto)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@BMMMGOOI@OuterRect?3?5Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?5Size@
CONST	SEGMENT
??_C@_0DL@BMMMGOOI@OuterRect?3?5Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?5Size@ DB 'O'
	DB	'uterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MDFKNKGM@Clear?5settings?$AA@
CONST	SEGMENT
??_C@_0P@MDFKNKGM@Clear?5settings?$AA@ DB 'Clear settings', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@JLKLPOOK@?$CK?$CK?5?$CFd?5instances?5of?5same?5table?$CB?5S@
CONST	SEGMENT
??_C@_0EM@JLKLPOOK@?$CK?$CK?5?$CFd?5instances?5of?5same?5table?$CB?5S@ DB '*'
	DB	'* %d instances of same table! Some data below will refer to l'
	DB	'ast instance.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DAHKPIHJ@Table?50x?$CF08X?5?$CI?$CFd?5columns?0?5in?5?8?$CFs@
CONST	SEGMENT
??_C@_0CF@DAHKPIHJ@Table?50x?$CF08X?5?$CI?$CFd?5columns?0?5in?5?8?$CFs@ DB 'T'
	DB	'able 0x%08X (%d columns, in ''%s'')%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MDILNFHC@?5?$CKInactive?$CK?$AA@
CONST	SEGMENT
??_C@_0M@MDILNFHC@?5?$CKInactive?$CK?$AA@ DB ' *Inactive*', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A?$AA@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A?$AA@ DB 'N/A', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LHDDKHJK@StretchSame?$AA@
CONST	SEGMENT
??_C@_0M@LHDDKHJK@StretchSame?$AA@ DB 'StretchSame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IGAOBHEB@StretchProp?$AA@
CONST	SEGMENT
??_C@_0M@IGAOBHEB@StretchProp?$AA@ DB 'StretchProp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OOODJBFG@FixedSame?$AA@
CONST	SEGMENT
??_C@_09OOODJBFG@FixedSame?$AA@ DB 'FixedSame', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CCPMLANI@FixedFit?$AA@
CONST	SEGMENT
??_C@_08CCPMLANI@FixedFit?$AA@ DB 'FixedFit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@HDPGNILG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAC?$AAo?$AAm?$AAp?$AAa?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@HDPGNILG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAC?$AAo?$AAm?$AAp?$AAa?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 'c', 00H, 't', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'f'
	DB	00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 0dbcH ; `ImGui::TableGcCompactTransientBuffers'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05LFBINIGO@Table?$AA@
CONST	SEGMENT
??_C@_05LFBINIGO@Table?$AA@ DB 'Table', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EAJILIBD@?5Sort?$DN?$CFd?$CFc?$AA@
CONST	SEGMENT
??_C@_0L@EAJILIBD@?5Sort?$DN?$CFd?$CFc?$AA@ DB ' Sort=%d%c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CFPCIBAG@?5Order?$DN?$CFd?$AA@
CONST	SEGMENT
??_C@_09CFPCIBAG@?5Order?$DN?$CFd?$AA@ DB ' Order=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CIPDPODB@?5Visible?$DN?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@CIPDPODB@?5Visible?$DN?$CFd?$AA@ DB ' Visible=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PBOBBCAP@?5Width?$DN?$CFd?$AA@
CONST	SEGMENT
??_C@_09PBOBBCAP@?5Width?$DN?$CFd?$AA@ DB ' Width=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MFKBBKPH@?5Weight?$DN?$CF?44f?$AA@
CONST	SEGMENT
??_C@_0N@MFKBBKPH@?5Weight?$DN?$CF?44f?$AA@ DB ' Weight=%.4f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PGBEGIHP@?5UserID?$DN?$CF08X?$AA@
CONST	SEGMENT
??_C@_0N@PGBEGIHP@?5UserID?$DN?$CF08X?$AA@ DB ' UserID=%08X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JLNIJDCE@Column?5?$CF?92d?$AA@
CONST	SEGMENT
??_C@_0M@JLNIJDCE@Column?5?$CF?92d?$AA@ DB 'Column %-2d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NHEEPCEH@RefScale?$DN?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0N@NHEEPCEH@RefScale?$DN?$CFg?6?$AA@ DB 'RefScale=%g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PGHPBJD@?$FL?$CFs?$FN?$FL0x?$CF08X?0?$CFd?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BB@PGHPBJD@?$FL?$CFs?$FN?$FL0x?$CF08X?0?$CFd?$FN?6?$AA@ DB '[%s][0'
	DB	'x%08X,%d]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KGHCDDIO@Sort?$DN?$CFd?$CFc?$CFn?$AA@
CONST	SEGMENT
??_C@_0M@KGHCDDIO@Sort?$DN?$CFd?$CFc?$CFn?$AA@ DB 'Sort=%d%c%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BHOFPJL@Order?$DN?$CFd?$CFn?$AA@
CONST	SEGMENT
??_C@_0L@BHOFPJL@Order?$DN?$CFd?$CFn?$AA@ DB 'Order=%d%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKALHFOF@Visible?$DN?$CFd?$CFn?$AA@
CONST	SEGMENT
??_C@_0N@EKALHFOF@Visible?$DN?$CFd?$CFn?$AA@ DB 'Visible=%d%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IJODOCHC@Weight?$DN?$CFf?$CFn?$AA@
CONST	SEGMENT
??_C@_0M@IJODOCHC@Weight?$DN?$CFf?$CFn?$AA@ DB 'Weight=%f%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LJLKPCDP@Width?$DN?$CFd?$CFn?$AA@
CONST	SEGMENT
??_C@_0L@LJLKPCDP@Width?$DN?$CFd?$CFn?$AA@ DB 'Width=%d%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KAIOJKEL@UserID?$DN0x?$CF08X?$CFn?$AA@
CONST	SEGMENT
??_C@_0BA@KAIOJKEL@UserID?$DN0x?$CF08X?$CFn?$AA@ DB 'UserID=0x%08X%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JOECNJOM@Column?5?$CFd?$CFn?$AA@
CONST	SEGMENT
??_C@_0M@JOECNJOM@Column?5?$CFd?$CFn?$AA@ DB 'Column %d%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LAOOHBLO@RefScale?$DN?$CFf?$AA@
CONST	SEGMENT
??_C@_0M@LAOOHBLO@RefScale?$DN?$CFf?$AA@ DB 'RefScale=%f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BDLBIGPI@0x?$CF08X?0?$CFd?$AA@
CONST	SEGMENT
??_C@_09BDLBIGPI@0x?$CF08X?0?$CFd?$AA@ DB '0x%08X,%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1MK@NEOBPBEE@?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9@
CONST	SEGMENT
??_C@_1MK@NEOBPBEE@?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9@ DB 's'
	DB	00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	's', 00H, '-', 00H, '>', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'u'
	DB	00H, 'm', 00H, 'n', 00H, 's', 00H, 'C', 00H, 'o', 00H, 'u', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'C', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's'
	DB	00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, 't'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 's', 00H, '-', 00H, '>', 00H
	DB	'C', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's'
	DB	00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'M', 00H
	DB	'a', 00H, 'x', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 's'
	DB	00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	's', 00H, '-', 00H, '>', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'u'
	DB	00H, 'm', 00H, 'n', 00H, 's', 00H, 'C', 00H, 'o', 00H, 'u', 00H
	DB	'n', 00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 0cb7H ; `ImGui::TableSaveSettings'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DE@KGKHJKNP@?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@KGKHJKNP@?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAD?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	's', 00H, '-', 00H, '>', 00H, 'I', 00H, 'D', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, '-', 00H, '>', 00H, 'I', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z@4JA DD 0ca0H ; `ImGui::TableGetBoundSettings'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09MGFHLAFE@?$DMUnknown?$DO?$AA@
CONST	SEGMENT
??_C@_09MGFHLAFE@?$DMUnknown?$DO?$AA@ DB '<Unknown>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BMOANCPA@?$CD?$CDContextMenu?$AA@
CONST	SEGMENT
??_C@_0O@BMOANCPA@?$CD?$CDContextMenu?$AA@ DB '##ContextMenu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@CPFLEHCP@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb@
CONST	SEGMENT
??_C@_1GC@CPFLEHCP@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H
	DB	'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '-', 00H, '1'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'c', 00H, 'o', 00H
	DB	'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H, 'n', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, '-', 00H, '>', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'u'
	DB	00H, 'm', 00H, 'n', 00H, 's', 00H, 'C', 00H, 'o', 00H, 'u', 00H
	DB	'n', 00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableOpenContextMenu@ImGui@@YAXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableOpenContextMenu@ImGui@@YAXH@Z@4JA DD 0be7H ; `ImGui::TableOpenContextMenu'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_04EBNJJJJI@?$CF?4?$CKs?$AA@
CONST	SEGMENT
??_C@_04EBNJJJJI@?$CF?4?$CKs?$AA@ DB '%.*s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@CDIJLMHK@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@CDIJLMHK@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, 'C', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '-', 00H, '1', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1HO@PDHKEBPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1HO@PDHKEBPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '"', 00H, 'N', 00H, 'e', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, ' ', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'H', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '('
	DB	00H, ')', 00H, ' ', 00H, 'a', 00H, 'f', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 'B', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 'n'
	DB	00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '(', 00H
	DB	')', 00H, '!', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HLEIDDEE@Need?5to?5call?5TableHeader?$CI?$CJ?5after@
CONST	SEGMENT
??_C@_0CP@HLEIDDEE@Need?5to?5call?5TableHeader?$CI?$CJ?5after@ DB 'Need t'
	DB	'o call TableHeader() after BeginTable()!', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableHeader@ImGui@@YAXPEBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableHeader@ImGui@@YAXPEBD@Z@4JA DD 0b54H ; `ImGui::TableHeader'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1IG@FPFBNANE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1IG@FPFBNANE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '"', 00H, 'N', 00H, 'e', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, ' ', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'H', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 'R', 00H, 'o', 00H, 'w', 00H, '(', 00H, ')', 00H, ' ', 00H
	DB	'a', 00H, 'f', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'B'
	DB	00H, 'e', 00H, 'g', 00H, 'i', 00H, 'n', 00H, 'T', 00H, 'a', 00H
	DB	'b', 00H, 'l', 00H, 'e', 00H, '(', 00H, ')', 00H, '!', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@NCKBBGOL@Need?5to?5call?5TableHeadersRow?$CI?$CJ?5a@
CONST	SEGMENT
??_C@_0DD@NCKBBGOL@Need?5to?5call?5TableHeadersRow?$CI?$CJ?5a@ DB 'Need t'
	DB	'o call TableHeadersRow() after BeginTable()!', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableHeadersRow@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableHeadersRow@ImGui@@YAXXZ@4JA DD 0b2aH ; `ImGui::TableHeadersRow'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FE@KLCJNJLO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAS@
CONST	SEGMENT
??_C@_1FE@KLCJNJLO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAS@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '-', 00H
	DB	'>', 00H, 'S', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'O', 00H, 'r'
	DB	00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>'
	DB	00H, 'S', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'S', 00H, 'p', 00H
	DB	'e', 00H, 'c', 00H, 's', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 0aebH ; `ImGui::TableSortSpecsBuild'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EM@BCBBNGI@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAw?$AAi?$AAt?$AAh?$AA_?$AAs?$AAm?$AAa?$AAl?$AAl?$AAe?$AAs?$AAt?$AA_?$AAs?$AAo?$AAr?$AAt?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5@
CONST	SEGMENT
??_C@_1EM@BCBBNGI@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAw?$AAi?$AAt?$AAh?$AA_?$AAs?$AAm?$AAa?$AAl?$AAl?$AAe?$AAs?$AAt?$AA_?$AAs?$AAo?$AAr?$AAt?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H
	DB	'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'm'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 's', 00H, 't', 00H
	DB	'_', 00H, 's', 00H, 'o', 00H, 'r', 00H, 't', 00H, '_', 00H, 'o'
	DB	00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '-', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@FLDFCCLG@?$AAs?$AAo?$AAr?$AAt?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs@
CONST	SEGMENT
??_C@_1GI@FLDFCCLG@?$AAs?$AAo?$AAr?$AAt?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs@ DB 's'
	DB	00H, 'o', 00H, 'r', 00H, 't', 00H, '_', 00H, 'o', 00H, 'r', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'u'
	DB	00H, 'n', 00H, 't', 00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, ')', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H, 's', 00H, 'o', 00H
	DB	'r', 00H, 't', 00H, '_', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, '_', 00H, 'm', 00H, 'a', 00H, 's', 00H, 'k', 00H
	DB	')', 00H, ' ', 00H, '*', 00H, ' ', 00H, '8', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@NLOFMGNH@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAS@
CONST	SEGMENT
??_C@_1FA@NLOFMGNH@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAS@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, '&'
	DB	00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H
	DB	'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'S', 00H, 'o', 00H
	DB	'r', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 0aa9H ; `ImGui::TableSortSpecsSanitize'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FE@KIEHIAAN@?$AAs?$AAo?$AAr?$AAt?$AA_?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc@
CONST	SEGMENT
??_C@_1FE@KIEHIAAN@?$AAs?$AAo?$AAr?$AAt?$AA_?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc@ DB 's'
	DB	00H, 'o', 00H, 'r', 00H, 't', 00H, '_', 00H, 'd', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'm', 00H
	DB	'G', 00H, 'u', 00H, 'i', 00H, 'S', 00H, 'o', 00H, 'r', 00H, 't'
	DB	00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, '_', 00H, 'N', 00H, 'o', 00H, 'n'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSetColumnSortDirection@ImGui@@YAXHH_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSetColumnSortDirection@ImGui@@YAXHH_N@Z@4JA DD 0a88H ; `ImGui::TableSetColumnSortDirection'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EK@NEPNAPMF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AAA?$AAv?$AAa?$AAi?$AAl?$AAC?$AAo?$AAu?$AAn?$AAt@
CONST	SEGMENT
??_C@_1EK@NEPNAPMF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AAA?$AAv?$AAa?$AAi?$AAl?$AAC?$AAo?$AAu?$AAn?$AAt@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '-', 00H
	DB	'>', 00H, 'S', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'D', 00H, 'i'
	DB	00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, 's', 00H, 'A', 00H, 'v', 00H, 'a', 00H, 'i', 00H, 'l'
	DB	00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z@4JA DD 0a7aH ; `ImGui::TableGetColumnNextSortDirection'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EK@EKGOAIAF@?$AAn?$AA?5?$AA?$DM?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AAA?$AAv?$AAa?$AAi?$AAl?$AAC@
CONST	SEGMENT
??_C@_1EK@EKGOAIAF@?$AAn?$AA?5?$AA?$DM?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AAA?$AAv?$AAa?$AAi?$AAl?$AAC@ DB 'n'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'n', 00H, '-', 00H, '>', 00H, 'S', 00H, 'o'
	DB	00H, 'r', 00H, 't', 00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 's', 00H, 'A'
	DB	00H, 'v', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'C', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z@4JA DD 0a67H ; `TableGetColumnAvailSortDirection'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ@4JA DD 0a55H ; `ImGui::TableGetSortSpecs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1KG@FHCGPPO@?$AAd?$AAs?$AAt?$AA_?$AAt?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAg?$AA?4?$AAD?$AAr?$AAa?$AAw?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAs?$AAT?$AAe?$AAm?$AAp?$AAM?$AAe?$AAr@
CONST	SEGMENT
??_C@_1KG@FHCGPPO@?$AAd?$AAs?$AAt?$AA_?$AAt?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAg?$AA?4?$AAD?$AAr?$AAa?$AAw?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAs?$AAT?$AAe?$AAm?$AAp?$AAM?$AAe?$AAr@ DB 'd'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 't', 00H, 'm', 00H, 'p', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'g', 00H, '.', 00H, 'D'
	DB	00H, 'r', 00H, 'a', 00H, 'w', 00H, 'C', 00H, 'h', 00H, 'a', 00H
	DB	'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H, 's', 00H, 'T', 00H, 'e'
	DB	00H, 'm', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'r', 00H, 'g', 00H
	DB	'e', 00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, '.', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, 'g', 00H, '.', 00H, 'D', 00H, 'r', 00H, 'a'
	DB	00H, 'w', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H
	DB	'e', 00H, 'l', 00H, 's', 00H, 'T', 00H, 'e', 00H, 'm', 00H, 'p'
	DB	00H, 'M', 00H, 'e', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 'B', 00H
	DB	'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'S'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1MG@IJOOMOFE@?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?9?$AA?$DO?$AA_?$AAC?$AAm?$AAd?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@
CONST	SEGMENT
??_C@_1MG@IJOOMOFE@?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?9?$AA?$DO?$AA_?$AAC?$AAm?$AAd?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@ DB 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H
	DB	'-', 00H, '>', 00H, '_', 00H, 'C', 00H, 'm', 00H, 'd', 00H, 'B'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, '.', 00H
	DB	'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '1', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'm', 00H, 'e', 00H, 'r', 00H, 'g', 00H, 'e', 00H, '_', 00H, 'c'
	DB	00H, 'l', 00H, 'i', 00H, 'p', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, '.', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't'
	DB	00H, 'a', 00H, 'i', 00H, 'n', 00H, 's', 00H, '(', 00H, 'I', 00H
	DB	'm', 00H, 'R', 00H, 'e', 00H, 'c', 00H, 't', 00H, '(', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H
	DB	'-', 00H, '>', 00H, '_', 00H, 'C', 00H, 'm', 00H, 'd', 00H, 'B'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, '[', 00H
	DB	'0', 00H, ']', 00H, '.', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'p'
	DB	00H, 'R', 00H, 'e', 00H, 'c', 00H, 't', 00H, ')', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1LA@JABKDEHA@?$AAh?$AAa?$AAs?$AA_?$AAf?$AAr?$AAe?$AAe?$AAz?$AAe?$AA_?$AAv?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO@
CONST	SEGMENT
??_C@_1LA@JABKDEHA@?$AAh?$AAa?$AAs?$AA_?$AAf?$AAr?$AAe?$AAe?$AAz?$AAe?$AA_?$AAv?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO@ DB 'h'
	DB	00H, 'a', 00H, 's', 00H, '_', 00H, 'f', 00H, 'r', 00H, 'e', 00H
	DB	'e', 00H, 'z', 00H, 'e', 00H, '_', 00H, 'v', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'l', 00H, 's', 00H
	DB	'e', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 't', 00H, 'a'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H, 'B', 00H
	DB	'g', 00H, '2', 00H, 'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'C'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H
	DB	'U', 00H, 'n', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'z', 00H, 'e'
	DB	00H, 'n', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'T', 00H
	DB	'A', 00H, 'B', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'D', 00H, 'R'
	DB	00H, 'A', 00H, 'W', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'A', 00H
	DB	'N', 00H, 'N', 00H, 'E', 00H, 'L', 00H, '_', 00H, 'B', 00H, 'G'
	DB	00H, '2', 00H, '_', 00H, 'F', 00H, 'R', 00H, 'O', 00H, 'Z', 00H
	DB	'E', 00H, 'N', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@EEGFHBNA@?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA_?$AAn?$AAo?$AA?5?$AA?$DM?$AA?5?$AAm?$AAa?$AAx?$AA_?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@EEGFHBNA@?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA_?$AAn?$AAo?$AA?5?$AA?$DM?$AA?5?$AAm?$AAa?$AAx?$AA_?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAs?$AA?$AA@ DB 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H
	DB	'_', 00H, 'n', 00H, 'o', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm'
	DB	00H, 'a', 00H, 'x', 00H, '_', 00H, 'd', 00H, 'r', 00H, 'a', 00H
	DB	'w', 00H, '_', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n'
	DB	00H, 'e', 00H, 'l', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@GEHLCBHG@?$AAs?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@GEHLCBHG@?$AAs?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'p', 00H, 'l', 00H, 'i', 00H, 't', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, '-', 00H, '>', 00H, '_', 00H, 'C', 00H, 'u', 00H, 'r'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 0939H ; `ImGui::TableMergeDrawChannels'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1GG@NCDBECJP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAB?$AAg?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AA?4?$AAM?$AAi?$AAn?$AA?4?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe@
CONST	SEGMENT
??_C@_1GG@NCDBECJP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAB?$AAg?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AA?4?$AAM?$AAi?$AAn?$AA?4?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'B', 00H, 'g', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'p', 00H, 'R'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '.', 00H, 'M', 00H, 'i', 00H
	DB	'n', 00H, '.', 00H, 'y', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'B', 00H, 'g', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'p'
	DB	00H, 'R', 00H, 'e', 00H, 'c', 00H, 't', 00H, '.', 00H, 'M', 00H
	DB	'a', 00H, 'x', 00H, '.', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 08f5H ; `ImGui::TableSetupDrawChannels'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FM@OBNODAI@?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe?$AA_?$AAw?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe@
CONST	SEGMENT
??_C@_1FM@OBNODAI@?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe?$AA_?$AAw?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe@ DB 'v'
	DB	00H, 'i', 00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'_', 00H, 'w', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H
	DB	'f', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'v', 00H, 'i'
	DB	00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'w', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H, 'f', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@MOAONJGL@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAW?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@MOAONJGL@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAW?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '-', 00H
	DB	'>', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'c'
	DB	00H, 'h', 00H, 'W', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H
	DB	't', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, '.', 00H, '0'
	DB	00H, 'f', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1JM@ELMLJHLO@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAL?$AAe?$AAf?$AAt?$AAM?$AAo?$AAs?$AAt?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$CB@
CONST	SEGMENT
??_C@_1JM@ELMLJHLO@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAL?$AAe?$AAf?$AAt?$AAM?$AAo?$AAs?$AAt?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$CB@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'L', 00H, 'e', 00H, 'f', 00H, 't', 00H, 'M', 00H, 'o', 00H, 's'
	DB	00H, 't', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'e', 00H, 't', 00H
	DB	'c', 00H, 'h', 00H, 'e', 00H, 'd', 00H, 'C', 00H, 'o', 00H, 'l'
	DB	00H, 'u', 00H, 'm', 00H, 'n', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, '-', 00H, '1', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'R', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, 'M'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'S', 00H, 't', 00H, 'r', 00H
	DB	'e', 00H, 't', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'd', 00H, 'C'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, '-', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 08a4H ; `ImGui::TableUpdateColumnsWeightFromWidth'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FO@DCOODALF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AA0?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_@
CONST	SEGMENT
??_C@_1FO@DCOODALF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AA0?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H
	DB	'0', 00H, '_', 00H, 'w', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H
	DB	'f', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'c', 00H, 'o'
	DB	00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H, '1', 00H
	DB	'_', 00H, 'w', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H, 'f', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@PGHMBBCD@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAM?$AAi?$AAn?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@PGHMBBCD@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAM?$AAi?$AAn?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'M', 00H, 'i', 00H, 'n', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'u'
	DB	00H, 'm', 00H, 'n', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, '.', 00H, '0'
	DB	00H, 'f', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@MHBOMDGH@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc@
CONST	SEGMENT
??_C@_1FK@MHBOMDGH@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'I', 00H, 's', 00H, 'L', 00H, 'a', 00H, 'y', 00H, 'o'
	DB	00H, 'u', 00H, 't', 00H, 'L', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'f'
	DB	00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSetColumnWidth@ImGui@@YAXHM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSetColumnWidth@ImGui@@YAXHM@Z@4JA DD 083bH ; `ImGui::TableSetColumnWidth'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EK@MBNMJGKK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC@
CONST	SEGMENT
??_C@_1EK@MBNMJGKK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H
	DB	'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 't', 00H, 'a', 00H, 'b', 00H
	DB	'l', 00H, 'e', 00H, '-', 00H, '>', 00H, 'C', 00H, 'o', 00H, 'l'
	DB	00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H, 'C', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSetColumnIndex@ImGui@@YA_NH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSetColumnIndex@ImGui@@YA_NH@Z@4JA DD 077cH ; `ImGui::TableSetColumnIndex'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1JC@PCOAPGIF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAB?$AAg?$AA2?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AAF?$AAo?$AAr?$AAD?$AAr?$AAa?$AAw?$AAC?$AAm?$AAd?$AA?4?$AAM?$AAi?$AAn@
CONST	SEGMENT
??_C@_1JC@PCOAPGIF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAB?$AAg?$AA2?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AAF?$AAo?$AAr?$AAD?$AAr?$AAa?$AAw?$AAC?$AAm?$AAd?$AA?4?$AAM?$AAi?$AAn@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'B', 00H, 'g', 00H, '2', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'p'
	DB	00H, 'R', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'F', 00H, 'o', 00H
	DB	'r', 00H, 'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'C', 00H, 'm'
	DB	00H, 'd', 00H, '.', 00H, 'M', 00H, 'i', 00H, 'n', 00H, '.', 00H
	DB	'y', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 't', 00H, 'a'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H, 'B', 00H
	DB	'g', 00H, '2', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'p', 00H, 'R'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'F', 00H, 'o', 00H, 'r', 00H
	DB	'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'C', 00H, 'm', 00H, 'd'
	DB	00H, '.', 00H, 'M', 00H, 'a', 00H, 'x', 00H, '.', 00H, 'y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@BPCFJEPF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAU?$AAn?$AAf?$AAr?$AAo?$AAz?$AAe?$AAn?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@BPCFJEPF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAU?$AAn?$AAf?$AAr?$AAo?$AAz?$AAe?$AAn?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'I', 00H, 's', 00H, 'U', 00H, 'n', 00H, 'f', 00H, 'r', 00H, 'o'
	DB	00H, 'z', 00H, 'e', 00H, 'n', 00H, 'R', 00H, 'o', 00H, 'w', 00H
	DB	's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'f', 00H, 'a'
	DB	00H, 'l', 00H, 's', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01DNKMNLPK@?$HM?$AA@
CONST	SEGMENT
??_C@_01DNKMNLPK@?$HM?$AA@ DB '|', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@HHNDIFPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAI?$AAn?$AAs?$AAi?$AAd?$AAe?$AAR?$AAo?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@HHNDIFPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAI?$AAn?$AAs?$AAi?$AAd?$AAe?$AAR?$AAo?$AAw?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'I', 00H, 's', 00H, 'I', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'd'
	DB	00H, 'e', 00H, 'R', 00H, 'o', 00H, 'w', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@GFLHACMC@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAn?$AAn?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@GFLHACMC@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAn?$AAn?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$AA@ DB 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, '-', 00H, '>', 00H, 'I', 00H, 'n', 00H, 'n', 00H
	DB	'e', 00H, 'r', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 06e2H ; `ImGui::TableEndRow'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CI@JLDNLAAM@?$AA?$CB?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAI?$AAn?$AAs?$AAi?$AAd?$AAe?$AAR?$AAo?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@JLDNLAAM@?$AA?$CB?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAI?$AAn?$AAs?$AAi?$AAd?$AAe?$AAR?$AAo?$AAw?$AA?$AA@ DB '!'
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'I', 00H, 's', 00H, 'I', 00H, 'n', 00H, 's', 00H, 'i'
	DB	00H, 'd', 00H, 'e', 00H, 'R', 00H, 'o', 00H, 'w', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 06bfH ; `ImGui::TableBeginRow'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BO@EGJMPMHM@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@EGJMPMHM@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H
	DB	'n', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '-', 00H, '1'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@NMABAIJJ@?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAB?$AAg?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AA_?$AAN?$AAo?$AAn@
CONST	SEGMENT
??_C@_1EE@NMABAIJJ@?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAB?$AAg?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AA_?$AAN?$AAo?$AAn@ DB 't'
	DB	00H, 'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u'
	DB	00H, 'i', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'B', 00H, 'g', 00H, 'T', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'e'
	DB	00H, 't', 00H, '_', 00H, 'N', 00H, 'o', 00H, 'n', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSetBgColor@ImGui@@YAXHIH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSetBgColor@ImGui@@YAXHIH@Z@4JA DD 0668H ; `ImGui::TableSetBgColor'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z@4JA DD 0657H ; `ImGui::TableGetColumnResizeID'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1GA@OFNPMLNE@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1GA@OFNPMLNE@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H
	DB	'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'n', 00H, '_', 00H, 'n', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm'
	DB	00H, 'n', 00H, 's', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H
	DB	't', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@FCMNFGAM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAH@
CONST	SEGMENT
??_C@_1FA@FCMNFGAM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAH@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, '&'
	DB	00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H
	DB	'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'H', 00H, 'i', 00H
	DB	'd', 00H, 'e', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@IPNBPJPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@IPNBPJPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSetColumnEnabled@ImGui@@YAXH_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSetColumnEnabled@ImGui@@YAXH_N@Z@4JA DD 0625H ; `ImGui::TableSetColumnEnabled'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@CGNBCADH@?$AAr?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?5?$AA?$DM?$AA?5?$AA1?$AA2?$AA8?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@CGNBCADH@?$AAr?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?5?$AA?$DM?$AA?5?$AA1?$AA2?$AA8?$AA?$AA@ DB 'r'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'r'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'1', 00H, '2', 00H, '8', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@GIPBLHPN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DM?$AA?5?$AA5?$AA1?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@GIPBLHPN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DM?$AA?5?$AA5?$AA1?$AA2?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H
	DB	'm', 00H, 'n', 00H, 's', 00H, ' ', 00H, '<', 00H, ' ', 00H, '5'
	DB	00H, '1', 00H, '2', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1KM@MPIBPMGF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1KM@MPIBPMGF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'I', 00H, 's', 00H, 'L', 00H, 'a', 00H, 'y', 00H, 'o', 00H, 'u'
	DB	00H, 't', 00H, 'L', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'f', 00H, 'a'
	DB	00H, 'l', 00H, 's', 00H, 'e', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, '"', 00H, 'N', 00H, 'e', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H
	DB	'l', 00H, ' ', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, 'S', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'p', 00H, 'C', 00H
	DB	'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '(', 00H, ')'
	DB	00H, ' ', 00H, 'b', 00H, 'e', 00H, 'f', 00H, 'o', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't'
	DB	00H, ' ', 00H, 'r', 00H, 'o', 00H, 'w', 00H, '!', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CMJJAIP@Need?5to?5call?5TableSetupColumn?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0DC@CMJJAIP@Need?5to?5call?5TableSetupColumn?$CI?$CJ?5@ DB 'Need to'
	DB	' call TableSetupColumn() before first row!', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSetupScrollFreeze@ImGui@@YAXHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSetupScrollFreeze@ImGui@@YAXHH@Z@4JA DD 05d9H ; `ImGui::TableSetupScrollFreeze'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1PM@LKIEMPHI@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAo?$AAr?$AA_?$AAw?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1PM@LKIEMPHI@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAo?$AAr?$AA_?$AAw?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ DB 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	'd', 00H, 't', 00H, 'h', 00H, '_', 00H, 'o', 00H, 'r', 00H, '_'
	DB	00H, 'w', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '0', 00H, '.', 00H, '0'
	DB	00H, 'f', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H
	DB	'C', 00H, 'a', 00H, 'n', 00H, ' ', 00H, 'o', 00H, 'n', 00H, 'l'
	DB	00H, 'y', 00H, ' ', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'f', 00H, 'y', 00H, ' ', 00H, 'w', 00H, 'i', 00H, 'd'
	DB	00H, 't', 00H, 'h', 00H, '/', 00H, 'w', 00H, 'e', 00H, 'i', 00H
	DB	'g', 00H, 'h', 00H, 't', 00H, ' ', 00H, 'i', 00H, 'f', 00H, ' '
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'l', 00H, 'i', 00H, 'c', 00H, 'y'
	DB	00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 's', 00H, 'e', 00H
	DB	't', 00H, ' ', 00H, 'e', 00H, 'x', 00H, 'p', 00H, 'l', 00H, 'i'
	DB	00H, 'c', 00H, 'i', 00H, 't', 00H, 'l', 00H, 'y', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 'e', 00H, 'i', 00H, 't', 00H, 'h'
	DB	00H, 'e', 00H, 'r', 00H, ' ', 00H, 'T', 00H, 'a', 00H, 'b', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'C'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '.', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@GOCDHGH@Can?5only?5specify?5width?1weight?5if@
CONST	SEGMENT
??_C@_0FM@GOCDHGH@Can?5only?5specify?5width?1weight?5if@ DB 'Can only spe'
	DB	'cify width/weight if sizing policy is set explicitly in eithe'
	DB	'r Table or Column.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1LO@INHFIFIG@?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAD?$AAe?$AAc?$AAl?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe@
CONST	SEGMENT
??_C@_1LO@INHFIFIG@?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAD?$AAe?$AAc?$AAl?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe@ DB '('
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'D', 00H, 'e', 00H, 'c', 00H, 'l', 00H, 'C', 00H, 'o'
	DB	00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H, 'C', 00H
	DB	'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n'
	DB	00H, 's', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H
	DB	')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'S', 00H, 'e'
	DB	00H, 't', 00H, 'u', 00H, 'p', 00H, 'C', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'n', 00H, '(', 00H, ')', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'n', 00H
	DB	'y', 00H, ' ', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 's'
	DB	00H, '!', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FPBLGODL@Called?5TableSetupColumn?$CI?$CJ?5too?5ma@
CONST	SEGMENT
??_C@_0CK@FPBLGODL@Called?5TableSetupColumn?$CI?$CJ?5too?5ma@ DB 'Called '
	DB	'TableSetupColumn() too many times!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NM@DDJLAMJK@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAS@
CONST	SEGMENT
??_C@_1NM@DDJLAMJK@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAS@ DB '('
	DB	00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H
	DB	'&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i'
	DB	00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'C', 00H
	DB	'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'S', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'u', 00H, 's', 00H, 'M', 00H, 'a', 00H, 's'
	DB	00H, 'k', 00H, '_', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"'
	DB	00H, 'I', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'g', 00H, 'a', 00H
	DB	'l', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'p', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 'S', 00H, 't', 00H, 'a', 00H
	DB	't', 00H, 'u', 00H, 's', 00H, 'M', 00H, 'a', 00H, 's', 00H, 'k'
	DB	00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H
	DB	's', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'T', 00H, 'a'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, 'S', 00H, 'e', 00H, 't', 00H
	DB	'u', 00H, 'p', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm'
	DB	00H, 'n', 00H, '(', 00H, ')', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CBJAIEBI@Illegal?5to?5pass?5StatusMask?5value@
CONST	SEGMENT
??_C@_0DI@CBJAIEBI@Illegal?5to?5pass?5StatusMask?5value@ DB 'Illegal to p'
	DB	'ass StatusMask values to TableSetupColumn()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1LG@IFCOIHC@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1LG@IFCOIHC@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'I', 00H, 's', 00H, 'L', 00H, 'a', 00H, 'y', 00H, 'o', 00H, 'u'
	DB	00H, 't', 00H, 'L', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'f', 00H, 'a'
	DB	00H, 'l', 00H, 's', 00H, 'e', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, '"', 00H, 'N', 00H, 'e', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H
	DB	'l', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l', 00H, ' '
	DB	00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'S', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'p', 00H, 'C', 00H, 'o', 00H, 'l'
	DB	00H, 'u', 00H, 'm', 00H, 'n', 00H, '(', 00H, ')', 00H, ' ', 00H
	DB	'b', 00H, 'e', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'e', 00H, ' '
	DB	00H, 'f', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	'r', 00H, 'o', 00H, 'w', 00H, '!', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KOGIGLHC@Need?5to?5call?5call?5TableSetupColu@
CONST	SEGMENT
??_C@_0DH@KOGIGLHC@Need?5to?5call?5call?5TableSetupColu@ DB 'Need to call'
	DB	' call TableSetupColumn() before first row!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1II@MMHPDEP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1II@MMHPDEP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '"', 00H, 'N', 00H, 'e', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, ' ', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'S', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'p', 00H, 'C', 00H, 'o'
	DB	00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '(', 00H, ')', 00H
	DB	' ', 00H, 'a', 00H, 'f', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'B', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 'n', 00H, 'T', 00H
	DB	'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '(', 00H, ')', 00H, '!'
	DB	00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JMKEADIJ@Need?5to?5call?5TableSetupColumn?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0DE@JMKEADIJ@Need?5to?5call?5TableSetupColumn?$CI?$CJ?5@ DB 'Need t'
	DB	'o call TableSetupColumn() after BeginTable()!', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSetupColumn@ImGui@@YAXPEBDHMI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSetupColumn@ImGui@@YAXPEBDHMI@Z@4JA DD 0595H ; `ImGui::TableSetupColumn'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DI@IPEFINGP@?$AAg?$AA?4?$AAT?$AAa?$AAb?$AAl?$AAe?$AAs?$AAT?$AAe?$AAm?$AAp?$AAD?$AAa?$AAt?$AAa?$AAS?$AAt?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@IPEFINGP@?$AAg?$AA?4?$AAT?$AAa?$AAb?$AAl?$AAe?$AAs?$AAT?$AAe?$AAm?$AAp?$AAD?$AAa?$AAt?$AAa?$AAS?$AAt?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'g'
	DB	00H, '.', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	's', 00H, 'T', 00H, 'e', 00H, 'm', 00H, 'p', 00H, 'D', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HG@JFMKDCJB@?$AAg?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5@
CONST	SEGMENT
??_C@_1HG@JFMKDCJB@?$AAg?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5@ DB 'g'
	DB	00H, '.', 00H, 'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'w', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 'g', 00H, '.', 00H, 'C', 00H, 'u', 00H, 'r'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'T', 00H, 'a', 00H
	DB	'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FM@ICPCKIED@?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_@
CONST	SEGMENT
??_C@_1FM@ICPCKIED@?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_@ DB '('
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' '
	DB	00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H
	DB	'i', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'F'
	DB	00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'S', 00H
	DB	'c', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'l', 00H, 'X', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NM@BLFPKGHB@?$AA?$CI?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAI?$AAt?$AAe?$AAm?$AAW?$AAi?$AAd?$AAt?$AAh?$AAS?$AAt?$AAa?$AAc?$AAk@
CONST	SEGMENT
??_C@_1NM@BLFPKGHB@?$AA?$CI?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAI?$AAt?$AAe?$AAm?$AAW?$AAi?$AAd?$AAt?$AAh?$AAS?$AAt?$AAa?$AAc?$AAk@ DB '('
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, 'e', 00H, 'r', 00H, '_', 00H
	DB	'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-'
	DB	00H, '>', 00H, 'D', 00H, 'C', 00H, '.', 00H, 'I', 00H, 't', 00H
	DB	'e', 00H, 'm', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '.', 00H
	DB	'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'p', 00H, '_', 00H
	DB	'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, '-', 00H, '>', 00H, 'H'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'B', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, 'u', 00H, 'p', 00H, 'I', 00H, 't', 00H, 'e', 00H, 'm'
	DB	00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, 'S', 00H
	DB	't', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'S', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'"', 00H, 'T', 00H, 'o', 00H, 'o', 00H, ' ', 00H, 'm', 00H, 'a'
	DB	00H, 'n', 00H, 'y', 00H, ' ', 00H, 'P', 00H, 'o', 00H, 'p', 00H
	DB	'I', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'W', 00H, 'i', 00H, 'd'
	DB	00H, 't', 00H, 'h', 00H, '!', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GAFFHFPC@Too?5many?5PopItemWidth?$CB?$AA@
CONST	SEGMENT
??_C@_0BH@GAFFHFPC@Too?5many?5PopItemWidth?$CB?$AA@ DB 'Too many PopItemW'
	DB	'idth!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1MI@BOIHHKDM@?$AA?$CI?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAI?$AAD?$AAS?$AAt?$AAa?$AAc?$AAk?$AA?4?$AAb?$AAa?$AAc?$AAk?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1MI@BOIHHKDM@?$AA?$CI?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAI?$AAD?$AAS?$AAt?$AAa?$AAc?$AAk?$AA?4?$AAb?$AAa?$AAc?$AAk?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@ DB '('
	DB	00H, 'i', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'r', 00H, '_', 00H
	DB	'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-'
	DB	00H, '>', 00H, 'I', 00H, 'D', 00H, 'S', 00H, 't', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, '.', 00H, 'b', 00H, 'a', 00H, 'c', 00H, 'k'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>'
	DB	00H, 'I', 00H, 'D', 00H, ' ', 00H, '+', 00H, ' ', 00H, 't', 00H
	DB	'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H, 'I'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'"', 00H, 'M', 00H, 'i', 00H, 's', 00H, 'm', 00H, 'a', 00H, 't'
	DB	00H, 'c', 00H, 'h', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'P', 00H, 'u', 00H, 's', 00H, 'h', 00H, 'I', 00H, 'D', 00H, '/'
	DB	00H, 'P', 00H, 'o', 00H, 'p', 00H, 'I', 00H, 'D', 00H, '!', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MHDEDKFO@Mismatching?5PushID?1PopID?$CB?$AA@
CONST	SEGMENT
??_C@_0BK@MHDEDKFO@Mismatching?5PushID?1PopID?$CB?$AA@ DB 'Mismatching Pu'
	DB	'shID/PopID!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GA@MJADNMBJ@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAR?$AAo?$AAw?$AAP?$AAo?$AAs?$AAY?$AA2?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9@
CONST	SEGMENT
??_C@_1GA@MJADNMBJ@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAR?$AAo?$AAw?$AAP?$AAo?$AAs?$AAY?$AA2?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'R', 00H, 'o', 00H, 'w', 00H, 'P', 00H, 'o', 00H, 's', 00H, 'Y'
	DB	00H, '2', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'i', 00H
	DB	'n', 00H, 'n', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'w', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-', 00H, '>', 00H
	DB	'D', 00H, 'C', 00H, '.', 00H, 'C', 00H, 'u', 00H, 'r', 00H, 's'
	DB	00H, 'o', 00H, 'r', 00H, 'P', 00H, 'o', 00H, 's', 00H, '.', 00H
	DB	'y', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JG@DEMMNCCK@?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$HM?$AA?$HM?$AA?5@
CONST	SEGMENT
??_C@_1JG@DEMMNCCK@?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$HM?$AA?$HM?$AA?5@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'w', 00H
	DB	'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'n', 00H, 'e', 00H
	DB	'r', 00H, '_', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'w', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, '_', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, '-', 00H, '>', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@FGAGBNK@?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAg?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@FGAGBNK@?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAg?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'n', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'w', 00H
	DB	'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 'g', 00H, '.', 00H, 'C', 00H, 'u', 00H
	DB	'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'W', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IG@CGOKCKPM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAO?$AAn?$AAl?$AAy?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAE?$AAn?$AAd?$AAT?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1IG@CGOKCKPM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAO?$AAn?$AAl?$AAy?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAE?$AAn?$AAd?$AAT?$AAa?$AAb?$AAl@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '"', 00H, 'O', 00H, 'n', 00H, 'l', 00H, 'y', 00H, ' ', 00H
	DB	'c', 00H, 'a', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'E', 00H, 'n'
	DB	00H, 'd', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'(', 00H, ')', 00H, ' ', 00H, 'i', 00H, 'f', 00H, ' ', 00H, 'B'
	DB	00H, 'e', 00H, 'g', 00H, 'i', 00H, 'n', 00H, 'T', 00H, 'a', 00H
	DB	'b', 00H, 'l', 00H, 'e', 00H, '(', 00H, ')', 00H, ' ', 00H, 'r'
	DB	00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 's', 00H
	DB	' ', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'e', 00H, '!', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JFFDACDB@Only?5call?5EndTable?$CI?$CJ?5if?5BeginTab@
CONST	SEGMENT
??_C@_0DD@JFFDACDB@Only?5call?5EndTable?$CI?$CJ?5if?5BeginTab@ DB 'Only c'
	DB	'all EndTable() if BeginTable() returns true!', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA DD 04c4H	; `ImGui::EndTable'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FC@BMHMHKON@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAR@
CONST	SEGMENT
??_C@_1FC@BMHMHKON@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAR@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, '&'
	DB	00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H
	DB	'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'R', 00H, 'e', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 0487H ; `ImGui::TableUpdateBorders'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BI@PMBHHKFI@?$AA?$CB?$AAi?$AAs?$AA_?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@PMBHHKFI@?$AA?$CB?$AAi?$AAs?$AA_?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ DB '!'
	DB	00H, 'i', 00H, 's', 00H, '_', 00H, 'v', 00H, 'i', 00H, 's', 00H
	DB	'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@JKJMNFJF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAL?$AAe?$AAf?$AAt?$AAM?$AAo?$AAs?$AAt?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1JA@JKJMNFJF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAL?$AAe?$AAf?$AAt?$AAM?$AAo?$AAs?$AAt?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'L', 00H, 'e', 00H, 'f', 00H, 't', 00H, 'M', 00H, 'o', 00H, 's'
	DB	00H, 't', 00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 'd', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm'
	DB	00H, 'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 't', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H, 'R', 00H, 'i', 00H
	DB	'g', 00H, 'h', 00H, 't', 00H, 'M', 00H, 'o', 00H, 's', 00H, 't'
	DB	00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'd', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@PGNFGMB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAI?$AAn?$AAd?$AAe?$AAx?$AAW?$AAi?$AAt?$AAh?$AAi?$AAn?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAS?$AAe?$AAt?$AA?5?$AA?$DM?$AA?$DN@
CONST	SEGMENT
??_C@_1GM@PGNFGMB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAI?$AAn?$AAd?$AAe?$AAx?$AAW?$AAi?$AAt?$AAh?$AAi?$AAn?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAS?$AAe?$AAt?$AA?5?$AA?$DM?$AA?$DN@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '-', 00H
	DB	'>', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, 'W'
	DB	00H, 'i', 00H, 't', 00H, 'h', 00H, 'i', 00H, 'n', 00H, 'E', 00H
	DB	'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'd', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '-'
	DB	00H, '>', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'p', 00H, 'l', 00H
	DB	'a', 00H, 'y', 00H, 'O', 00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@DEAGPPGG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@DEAGPPGG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'I', 00H, 's', 00H, 'L', 00H, 'a', 00H, 'y', 00H, 'o', 00H, 'u'
	DB	00H, 't', 00H, 'L', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'f', 00H, 'a'
	DB	00H, 'l', 00H, 's', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 02dbH ; `ImGui::TableUpdateLayout'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1HC@EONHDNHI@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1HC@EONHDNHI@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl@ DB 'I'
	DB	00H, 'm', 00H, 'I', 00H, 's', 00H, 'P', 00H, 'o', 00H, 'w', 00H
	DB	'e', 00H, 'r', 00H, 'O', 00H, 'f', 00H, 'T', 00H, 'w', 00H, 'o'
	DB	00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u'
	DB	00H, 'i', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'C', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 'F'
	DB	00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'W', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, 'M', 00H, 'a', 00H, 's'
	DB	00H, 'k', 00H, '_', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z@4JA DD 02a0H ; `TableSetupColumnFlags'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1GI@FDBBNGED@?$AAd?$AAs?$AAt?$AA_?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAs?$AAt?$AA_@
CONST	SEGMENT
??_C@_1GI@FDBBNGED@?$AAd?$AAs?$AAt?$AA_?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAs?$AAt?$AA_@ DB 'd'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'n', 00H, '-', 00H, '>', 00H, 'D', 00H, 'i'
	DB	00H, 's', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'O', 00H
	DB	'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'd', 00H, 's', 00H, 't', 00H, '_', 00H, 'o', 00H
	DB	'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '-', 00H, ' '
	DB	00H, 'r', 00H, 'e', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, '_', 00H, 'd', 00H, 'i', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@FFJIEHAF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAR@
CONST	SEGMENT
??_C@_1FG@FFJIEHAF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAR@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, '&'
	DB	00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H
	DB	'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'R', 00H, 'e', 00H
	DB	'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@CLPKFPLH@?$AAr?$AAe?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAd?$AAi?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAr?$AAe?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAd?$AAi?$AAr@
CONST	SEGMENT
??_C@_1EO@CLPKFPLH@?$AAr?$AAe?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAd?$AAi?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAr?$AAe?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAd?$AAi?$AAr@ DB 'r'
	DB	00H, 'e', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'_', 00H, 'd', 00H, 'i', 00H, 'r', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '-', 00H, '1', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, 'r', 00H, 'e', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, '_', 00H, 'd', 00H, 'i', 00H, 'r', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '+', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z@4JA DD 025cH ; `ImGui::TableBeginApplyRequests'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BBG@HLLCHCOP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAn?$AAn?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAP?$AAa?$AAd?$AAd?$AAi?$AAn@
CONST	SEGMENT
??_C@_1BBG@HLLCHCOP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAn?$AAn?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAP?$AAa?$AAd?$AAd?$AAi?$AAn@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'I', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'W', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-', 00H, '>', 00H
	DB	'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'P'
	DB	00H, 'a', 00H, 'd', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'.', 00H, 'x', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, '.', 00H, '0', 00H, 'f', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'I', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'r', 00H
	DB	'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-'
	DB	00H, '>', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 'P', 00H, 'a', 00H, 'd', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, '.', 00H, 'y', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, '.', 00H, '0', 00H, 'f', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, '-', 00H, '>', 00H, 'I', 00H, 'n', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, '-', 00H, '>', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 'B', 00H, 'o', 00H, 'r', 00H, 'd', 00H
	DB	'e', 00H, 'r', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H
	DB	'f', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1OO@LHJMPKOL@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc@
CONST	SEGMENT
??_C@_1OO@LHJMPKOL@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '-', 00H, '>', 00H
	DB	'C', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's'
	DB	00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u'
	DB	00H, 'm', 00H, 'n', 00H, 's', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '"', 00H, 'B', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 'n', 00H
	DB	'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '(', 00H, ')'
	DB	00H, ':', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 'n', 00H, 'n', 00H
	DB	'o', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'n'
	DB	00H, 'g', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'n', 00H, 's', 00H, ' ', 00H, 'c', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'm', 00H, 'i', 00H
	DB	'd', 00H, '-', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, ' ', 00H, 'w', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, 'v', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 's', 00H
	DB	'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'I', 00H, 'D', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@HCDJLOKE@BeginTable?$CI?$CJ?3?5Cannot?5change?5colu@
CONST	SEGMENT
??_C@_0EN@HCDJLOKE@BeginTable?$CI?$CJ?3?5Cannot?5change?5colu@ DB 'BeginT'
	DB	'able(): Cannot change columns count mid-frame while preservin'
	DB	'g same ID', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@NLGBMAGB@?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@NLGBMAGB@?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'n', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H, 'f', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@LLGOGPDA@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu@
CONST	SEGMENT
??_C@_1FC@LLGOGPDA@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n'
	DB	00H, 's', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H
	DB	't', 00H, ' ', 00H, '<', 00H, ' ', 00H, '5', 00H, '1', 00H, '2'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
CONST	SEGMENT
??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'g', 00H, 'i', 00H, 't', 00H, 'h', 00H
	DB	'u', 00H, 'b', 00H, '\', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, 'e', 00H, 'w', 00H, 'o', 00H, 'r', 00H, 'k', 00H, '\', 00H
	DB	't', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '\', 00H, 'i', 00H, 'm'
	DB	00H, 'g', 00H, 'u', 00H, 'i', 00H, '\', 00H, 'i', 00H, 'm', 00H
	DB	'g', 00H, 'u', 00H, 'i', 00H, '_', 00H, 't', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, '.', 00H, 'c', 00H, 'p', 00H
	DB	'p', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4JA DD 0137H ; `ImGui::BeginTableEx'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HEMCFMMD@?$CKMissing?5Text?$CK?$AA@
CONST	SEGMENT
??_C@_0P@HEMCFMMD@?$CKMissing?5Text?$CK?$AA@ DB '*Missing Text*', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
CONST	SEGMENT
??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'g', 00H, 'i', 00H, 't', 00H, 'h', 00H
	DB	'u', 00H, 'b', 00H, '\', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, 'e', 00H, 'w', 00H, 'o', 00H, 'r', 00H, 'k', 00H, '\', 00H
	DB	't', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '\', 00H, 'i', 00H, 'm'
	DB	00H, 'g', 00H, 'u', 00H, 'i', 00H, '\', 00H, 'i', 00H, 'm', 00H
	DB	'g', 00H, 'u', 00H, 'i', 00H, '_', 00H, 'i', 00H, 'n', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'n', 00H, 'a', 00H, 'l', 00H, '.', 00H
	DB	'h', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
CONST	SEGMENT
??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'g', 00H, 'i', 00H, 't', 00H, 'h', 00H
	DB	'u', 00H, 'b', 00H, '\', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, 'e', 00H, 'w', 00H, 'o', 00H, 'r', 00H, 'k', 00H, '\', 00H
	DB	't', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '\', 00H, 'i', 00H, 'm'
	DB	00H, 'g', 00H, 'u', 00H, 'i', 00H, '\', 00H, 'i', 00H, 'm', 00H
	DB	'g', 00H, 'u', 00H, 'i', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z DD 035053301H
	DD	0117331cH
	DD	070100023H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ImLerp@M@@YAMMMM@Z DD 015052f01H
	DD	011b1320H
	DD	07014001bH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z DD 035052e01H
	DD	01123317H
	DD	0700b002bH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DebugNodeTableGetSizingPolicyDesc@@YAPEBDH@Z DD 05052601H
	DD	010d0310H
	DD	070060019H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD 035053401H
	DD	0118331dH
	DD	070110043H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z DD 035054a19H
	DD	011d3322H
	DD	07016003bH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	01c8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcName$0 DB 066H ; TableSettingsHandler_ReadLine
	DB	00H
	ORG $+6
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcName$1 DB 063H ; TableSettingsHandler_ReadLine
	DB	06fH
	DB	06cH
	DB	075H
	DB	06dH
	DB	06eH
	DB	05fH
	DB	06eH
	DB	00H
	ORG $+3
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcName$2 DB 072H ; TableSettingsHandler_ReadLine
	DB	00H
	ORG $+2
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcName$3 DB 06eH ; TableSettingsHandler_ReadLine
	DB	00H
	ORG $+2
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcName$4 DB 063H ; TableSettingsHandler_ReadLine
	DB	00H
	ORG $+2
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcVarDesc DD 0d4H ; TableSettingsHandler_ReadLine
	DD	01H
	DQ	FLAT:?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcName$4
	DD	0b4H
	DD	04H
	DQ	FLAT:?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcName$3
	DD	094H
	DD	04H
	DQ	FLAT:?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcName$2
	DD	074H
	DD	04H
	DQ	FLAT:?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcName$1
	DD	054H
	DD	04H
	DQ	FLAT:?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcName$0
	ORG $+240
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcFrameData DD 05H ; TableSettingsHandler_ReadLine
	DD	00H
	DQ	FLAT:?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z DD 025054519H
	DD	0118231dH
	DD	070110029H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0138H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z$rtcName$0 DB 069H ; TableSettingsHandler_ReadOpen
	DB	064H
	DB	00H
	ORG $+5
?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z$rtcName$1 DB 063H ; TableSettingsHandler_ReadOpen
	DB	06fH
	DB	06cH
	DB	075H
	DB	06dH
	DB	06eH
	DB	073H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+10
?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z$rtcVarDesc DD 044H ; TableSettingsHandler_ReadOpen
	DD	04H
	DQ	FLAT:?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z$rtcName$1
	DD	024H
	DD	04H
	DQ	FLAT:?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z$rtcName$0
	ORG $+96
?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z$rtcFrameData DD 02H ; TableSettingsHandler_ReadOpen
	DD	00H
	DQ	FLAT:?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z DD 025052f01H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z DD 025052f01H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsCalcChunkSize@@YA_KH@Z DD 05052601H
	DD	010d0310H
	DD	070060019H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z DD imagerel ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z
	DD	0ffffffffH
	DD	imagerel ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z+115
	DD	00H
	DD	imagerel ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z+171
	DD	0ffffffffH
	DD	imagerel ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z+272
	DD	01H
	DD	imagerel ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z+328
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z
	DD	0228H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z DD 025054311H
	DD	011c2321H
	DD	070150049H
	DD	05014H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ImMax@F@@YAFFF@Z DD 05052d01H
	DD	01130316H
	DD	0700c001bH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ImSwap@F@@YAXAEAF0@Z DD 05052d01H
	DD	01130316H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ImClamp@M@@YAMMMM@Z DD 015052f01H
	DD	011b1320H
	DD	07014001dH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z DD 025053401H
	DD	0118231dH
	DD	070110031H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetSpan@UImGuiTableCellData@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableCellData@@@@@Z DD 025053301H
	DD	0117231cH
	DD	07010001fH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetSpan@F@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@F@@@Z DD 025053301H
	DD	0117231cH
	DD	07010001fH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetSpan@UImGuiTableColumn@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableColumn@@@@@Z DD 025053301H
	DD	0117231cH
	DD	07010001fH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSpanPtrEnd@?$ImSpanAllocator@$05@@QEAAPEAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetArenaBasePtr@?$ImSpanAllocator@$05@@QEAAXPEAX@Z DD 05052d01H
	DD	01130316H
	DD	0700c0019H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetArenaSizeInBytes@?$ImSpanAllocator@$05@@QEAAHXZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImSpanAllocator@$05@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableFixFlags@@YAHHPEAUImGuiWindow@@@Z DD 05052b01H
	DD	01120315H
	DD	0700b001bH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DebugNodeTableSettings@ImGui@@YAXPEAUImGuiTableSettings@@@Z DD 055052a01H
	DD	010e5313H
	DD	070070031H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z DD 0f51b8e19H
	DD	07cf866H
	DD	07de85eH
	DD	07ed856H
	DD	07fc84eH
	DD	080b846H
	DD	081a83eH
	DD	0829836H
	DD	083882eH
	DD	0847826H
	DD	085681fH
	DD	0110f318H
	DD	07009010dH
	DD	030076008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	07b8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0 DB 062H ; ImGui::DebugNodeTable
	DB	075H
	DB	066H
	DB	00H
?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$1 DB 072H ; ImGui::DebugNodeTable
	DB	00H
	ORG $+10
?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc DD 0498H ; ImGui::DebugNodeTable
	DD	010H
	DQ	FLAT:?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$1
	DD	0140H
	DD	0200H
	DQ	FLAT:?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0
	ORG $+96
?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData DD 02H ; ImGui::DebugNodeTable
	DD	00H
	DQ	FLAT:?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z DD 025052801H
	DD	010d2312H
	DD	070060025H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z DD 025052c01H
	DD	01112316H
	DD	0700a0025H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsAddSettingsHandler@ImGui@@YAXXZ DD 025052f19H
	DD	010a230fH
	DD	07003002bH
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0148H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableSettingsAddSettingsHandler@ImGui@@YAXXZ$rtcName$0 DB 069H ; ImGui::TableSettingsAddSettingsHandler
	DB	06eH
	DB	069H
	DB	05fH
	DB	068H
	DB	061H
	DB	06eH
	DB	064H
	DB	06cH
	DB	065H
	DB	072H
	DB	00H
	ORG $+4
?TableSettingsAddSettingsHandler@ImGui@@YAXXZ$rtcVarDesc DD 030H ; ImGui::TableSettingsAddSettingsHandler
	DD	048H
	DQ	FLAT:?TableSettingsAddSettingsHandler@ImGui@@YAXXZ$rtcName$0
	ORG $+48
?TableSettingsAddSettingsHandler@ImGui@@YAXXZ$rtcFrameData DD 01H ; ImGui::TableSettingsAddSettingsHandler
	DD	00H
	DQ	FLAT:?TableSettingsAddSettingsHandler@ImGui@@YAXXZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableResetSettings@ImGui@@YAXPEAUImGuiTable@@@Z DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070039H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableLoadSettings@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070047H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?TableGcCompactSettings@ImGui@@YAXXZ DD imagerel ?TableGcCompactSettings@ImGui@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ?TableGcCompactSettings@ImGui@@YAXXZ+199
	DD	00H
	DD	imagerel ?TableGcCompactSettings@ImGui@@YAXXZ+398
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?TableGcCompactSettings@ImGui@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGcCompactSettings@ImGui@@YAXXZ DD 025053a19H
	DD	010a230fH
	DD	070030039H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?TableGcCompactSettings@ImGui@@YAXXZ
	DD	01b2H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableGcCompactSettings@ImGui@@YAXXZ$rtcName$0 DB 06eH	; ImGui::TableGcCompactSettings
	DB	065H
	DB	077H
	DB	05fH
	DB	063H
	DB	068H
	DB	075H
	DB	06eH
	DB	06bH
	DB	05fH
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	00H
	ORG $+15
?TableGcCompactSettings@ImGui@@YAXXZ$rtcVarDesc DD 088H	; ImGui::TableGcCompactSettings
	DD	010H
	DQ	FLAT:?TableGcCompactSettings@ImGui@@YAXXZ$rtcName$0
	ORG $+48
?TableGcCompactSettings@ImGui@@YAXXZ$rtcFrameData DD 01H ; ImGui::TableGcCompactSettings
	DD	00H
	DQ	FLAT:?TableGcCompactSettings@ImGui@@YAXXZ$rtcVarDesc
$cppxdata$?TableGcCompactSettings@ImGui@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?TableGcCompactSettings@ImGui@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?TableGcCompactSettings@ImGui@@YAXXZ
	DD	0198H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableRemove@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetColumnWidthAutoAll@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetMaxColumnWidth@ImGui@@YAMPEBUImGuiTable@@H@Z DD 035052e01H
	DD	01123317H
	DD	0700b002bH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z DD 025053301H
	DD	0117231cH
	DD	070100021H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z DD 035053401H
	DD	0118331dH
	DD	07011002bH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b0031H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 035063c19H
	DD	010f3314H
	DD	0700800aeH
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	0560H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0 DB 072H ; ImGui::TableEndRow
	DB	06fH
	DB	077H
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
	ORG $+7
?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$1 DB 063H ; ImGui::TableEndRow
	DB	065H
	DB	06cH
	DB	06cH
	DB	05fH
	DB	062H
	DB	067H
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
	ORG $+3
?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc DD 0268H ; ImGui::TableEndRow
	DD	010H
	DQ	FLAT:?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$1
	DD	01d8H
	DD	010H
	DQ	FLAT:?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0
	ORG $+96
?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData DD 02H ; ImGui::TableEndRow
	DD	00H
	DQ	FLAT:?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetColumnWidthAuto@ImGui@@YAMPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z DD 035052f01H
	DD	01133318H
	DD	0700c002bH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z DD 025052f01H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070033H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070053H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z DD 035063c19H
	DD	010f3314H
	DD	0700800fcH
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	07d0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0 DB 06dH ; ImGui::TableMergeDrawChannels
	DB	065H
	DB	072H
	DB	067H
	DB	065H
	DB	05fH
	DB	067H
	DB	072H
	DB	06fH
	DB	075H
	DB	070H
	DB	073H
	DB	00H
	ORG $+3
?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$1 DB 068H ; ImGui::TableMergeDrawChannels
	DB	06fH
	DB	073H
	DB	074H
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
	ORG $+6
?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$2 DB 06dH ; ImGui::TableMergeDrawChannels
	DB	065H
	DB	072H
	DB	067H
	DB	065H
	DB	05fH
	DB	063H
	DB	06cH
	DB	069H
	DB	070H
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc DD 0408H ; ImGui::TableMergeDrawChannels
	DD	010H
	DQ	FLAT:?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$2
	DD	0378H
	DD	010H
	DQ	FLAT:?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$1
	DD	0e0H
	DD	080H
	DQ	FLAT:?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0
	ORG $+144
?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData DD 03H ; ImGui::TableMergeDrawChannels
	DD	00H
	DQ	FLAT:?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableBeginContextMenuPopup@ImGui@@YA_NPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableDrawContextMenu@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070049H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z DD 045063c19H
	DD	010f4314H
	DD	0700800a8H
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	0530H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0 DB 06fH ; ImGui::TableDrawBorders
	DB	075H
	DB	074H
	DB	065H
	DB	072H
	DB	05fH
	DB	062H
	DB	06fH
	DB	072H
	DB	064H
	DB	065H
	DB	072H
	DB	00H
	ORG $+3
?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc DD 0248H ; ImGui::TableDrawBorders
	DD	010H
	DQ	FLAT:?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0
	ORG $+48
?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData DD 01H ; ImGui::TableDrawBorders
	DD	00H
	DQ	FLAT:?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	070070035H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z DD 035053b19H
	DD	010e3313H
	DD	07007005fH
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	02e0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0 DB 068H ; ImGui::TableUpdateBorders
	DB	069H
	DB	074H
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
	ORG $+7
?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$1 DB 068H ; ImGui::TableUpdateBorders
	DB	06fH
	DB	076H
	DB	065H
	DB	072H
	DB	065H
	DB	064H
	DB	00H
?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$2 DB 068H ; ImGui::TableUpdateBorders
	DB	065H
	DB	06cH
	DB	064H
	DB	00H
	ORG $+3
?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc DD 01e4H ; ImGui::TableUpdateBorders
	DD	01H
	DQ	FLAT:?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$2
	DD	01c4H
	DD	01H
	DQ	FLAT:?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$1
	DD	0198H
	DD	010H
	DQ	FLAT:?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0
	ORG $+144
?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData DD 03H ; ImGui::TableUpdateBorders
	DD	00H
	DQ	FLAT:?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z DD 035063c19H
	DD	010f3314H
	DD	07008010eH
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	0860H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0 DB 077H ; ImGui::TableUpdateLayout
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
	ORG $+6
?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$1 DB 06dH ; ImGui::TableUpdateLayout
	DB	06fH
	DB	075H
	DB	073H
	DB	065H
	DB	05fH
	DB	068H
	DB	069H
	DB	074H
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
	ORG $+1
?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$2 DB 068H ; ImGui::TableUpdateLayout
	DB	06fH
	DB	073H
	DB	074H
	DB	05fH
	DB	063H
	DB	06cH
	DB	069H
	DB	070H
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
	ORG $+1
?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc DD 0518H ; ImGui::TableUpdateLayout
	DD	010H
	DQ	FLAT:?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$2
	DD	0448H
	DD	010H
	DQ	FLAT:?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$1
	DD	02b8H
	DD	010H
	DQ	FLAT:?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z$rtcName$0
	ORG $+144
?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData DD 03H ; ImGui::TableUpdateLayout
	DD	00H
	DQ	FLAT:?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z DD 025062b01H
	DD	010f2314H
	DD	07008003cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z DD 025052a01H
	DD	010e2313H
	DD	07007003dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z DD 025053f19H
	DD	01122317H
	DD	0700b0031H
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	0178H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z$rtcName$0 DB 073H ; ImGui::TableBeginInitMemory
	DB	070H
	DB	061H
	DB	06eH
	DB	05fH
	DB	061H
	DB	06cH
	DB	06cH
	DB	06fH
	DB	063H
	DB	061H
	DB	074H
	DB	06fH
	DB	072H
	DB	00H
	ORG $+1
?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z$rtcVarDesc DD 050H ; ImGui::TableBeginInitMemory
	DD	040H
	DQ	FLAT:?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z$rtcName$0
	ORG $+48
?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z$rtcFrameData DD 01H ; ImGui::TableBeginInitMemory
	DD	00H
	DQ	FLAT:?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z DD imagerel ?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z
	DD	0ffffffffH
	DD	imagerel ?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z+836
	DD	00H
	DD	imagerel ?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z+872
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z DD 035065519H
	DD	011d3322H
	DD	070160134H
	DD	050146015H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z
	DD	099aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcName$0 DB 061H ; ImGui::BeginTableEx
	DB	076H
	DB	061H
	DB	069H
	DB	06cH
	DB	05fH
	DB	073H
	DB	069H
	DB	07aH
	DB	065H
	DB	00H
	ORG $+5
?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcName$1 DB 061H ; ImGui::BeginTableEx
	DB	063H
	DB	074H
	DB	075H
	DB	061H
	DB	06cH
	DB	05fH
	DB	06fH
	DB	075H
	DB	074H
	DB	065H
	DB	072H
	DB	05fH
	DB	073H
	DB	069H
	DB	07aH
	DB	065H
	DB	00H
	ORG $+6
?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcName$2 DB 06fH ; ImGui::BeginTableEx
	DB	075H
	DB	074H
	DB	065H
	DB	072H
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
	ORG $+5
?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcName$3 DB 06fH ; ImGui::BeginTableEx
	DB	076H
	DB	065H
	DB	072H
	DB	072H
	DB	069H
	DB	064H
	DB	065H
	DB	05fH
	DB	063H
	DB	06fH
	DB	06eH
	DB	074H
	DB	065H
	DB	06eH
	DB	074H
	DB	05fH
	DB	073H
	DB	069H
	DB	07aH
	DB	065H
	DB	00H
	ORG $+2
?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcVarDesc DD 01c8H ; ImGui::BeginTableEx
	DD	08H
	DQ	FLAT:?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcName$3
	DD	0d8H
	DD	010H
	DQ	FLAT:?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcName$2
	DD	0b8H
	DD	08H
	DQ	FLAT:?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcName$1
	DD	098H
	DD	08H
	DQ	FLAT:?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcName$0
	ORG $+192
?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcFrameData DD 04H ; ImGui::BeginTableEx
	DD	00H
	DQ	FLAT:?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcVarDesc
$cppxdata$?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z
	DD	0978H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableFindByID@ImGui@@YAPEAUImGuiTable@@I@Z DD 025052801H
	DD	010d2312H
	DD	070060021H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TablePopBackgroundChannel@ImGui@@YAXXZ DD 025051e01H
	DD	010a230fH
	DD	07003002dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TablePushBackgroundChannel@ImGui@@YAXXZ DD 025061f01H
	DD	010b2310H
	DD	070040028H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetHeaderRowHeight@ImGui@@YAMXZ DD 045051e01H
	DD	010a430fH
	DD	070030035H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetHoveredColumn@ImGui@@YAHXZ DD 05051c01H
	DD	010a030dH
	DD	070030021H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetColumnSortDirection@ImGui@@YAXHH_N@Z DD 025053101H
	DD	0116231bH
	DD	0700f0039H
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetColumnWidth@ImGui@@YAXHM@Z DD 025052e01H
	DD	01132318H
	DD	0700c003dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableOpenContextMenu@ImGui@@YAXH@Z DD 025052801H
	DD	010d2312H
	DD	070060029H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z DD 015053001H
	DD	01141319H
	DD	0700d001bH
	DD	0500cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z DD 015053001H
	DD	01141319H
	DD	0700d001bH
	DD	0500cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z DD imagerel ?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
	DD	0ffffffffH
	DD	imagerel ?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z+187
	DD	00H
	DD	imagerel ?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z+216
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
	DD	01c8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z DD 025053911H
	DD	01122317H
	DD	0700b003fH
	DD	0500aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetColumnsID@ImGui@@YAIPEBDH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0025H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PopColumnsBackground@ImGui@@YAXXZ DD 025051e01H
	DD	010a230fH
	DD	070030025H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PushColumnsBackground@ImGui@@YAXXZ DD 025061f01H
	DD	010b2310H
	DD	070040024H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PushColumnClipRect@ImGui@@YAXH@Z DD 025052801H
	DD	010d2312H
	DD	070060029H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EndColumns@ImGui@@YAXXZ DD 035063019H
	DD	010b3310H
	DD	07004009aH
	DD	050026003H
	DD	imagerel __GSHandlerCheck
	DD	04c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?EndColumns@ImGui@@YAXXZ$rtcName$0 DB 063H		; ImGui::EndColumns
	DB	06fH
	DB	06cH
	DB	075H
	DB	06dH
	DB	06eH
	DB	05fH
	DB	068H
	DB	069H
	DB	074H
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
?EndColumns@ImGui@@YAXXZ$rtcName$1 DB 068H		; ImGui::EndColumns
	DB	06fH
	DB	076H
	DB	065H
	DB	072H
	DB	065H
	DB	064H
	DB	00H
?EndColumns@ImGui@@YAXXZ$rtcName$2 DB 068H		; ImGui::EndColumns
	DB	065H
	DB	06cH
	DB	064H
	DB	00H
	ORG $+3
?EndColumns@ImGui@@YAXXZ$rtcVarDesc DD 0224H		; ImGui::EndColumns
	DD	01H
	DQ	FLAT:?EndColumns@ImGui@@YAXXZ$rtcName$2
	DD	0204H
	DD	01H
	DQ	FLAT:?EndColumns@ImGui@@YAXXZ$rtcName$1
	DD	01d8H
	DD	010H
	DQ	FLAT:?EndColumns@ImGui@@YAXXZ$rtcName$0
	ORG $+144
?EndColumns@ImGui@@YAXXZ$rtcFrameData DD 03H		; ImGui::EndColumns
	DD	00H
	DQ	FLAT:?EndColumns@ImGui@@YAXXZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginColumns@ImGui@@YAXPEBDHH@Z DD 035064519H
	DD	0118331dH
	DD	070110086H
	DD	0500f6010H
	DD	imagerel __GSHandlerCheck
	DD	0420H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?BeginColumns@ImGui@@YAXPEBDHH@Z$rtcName$0 DB 063H	; ImGui::BeginColumns
	DB	06fH
	DB	06cH
	DB	075H
	DB	06dH
	DB	06eH
	DB	00H
	ORG $+9
?BeginColumns@ImGui@@YAXPEBDHH@Z$rtcVarDesc DD 0158H	; ImGui::BeginColumns
	DD	01cH
	DQ	FLAT:?BeginColumns@ImGui@@YAXPEBDHH@Z$rtcName$0
	ORG $+48
?BeginColumns@ImGui@@YAXPEBDHH@Z$rtcFrameData DD 01H	; ImGui::BeginColumns
	DD	00H
	DQ	FLAT:?BeginColumns@ImGui@@YAXPEBDHH@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z DD 025064119H
	DD	01142319H
	DD	0700d0022H
	DD	0500b600cH
	DD	imagerel __GSHandlerCheck
	DD	0108H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z$rtcName$0 DB 063H ; ImGui::SetWindowClipRectBeforeSetChannel
	DB	06cH
	DB	069H
	DB	070H
	DB	05fH
	DB	072H
	DB	065H
	DB	063H
	DB	074H
	DB	05fH
	DB	076H
	DB	065H
	DB	063H
	DB	034H
	DB	00H
	ORG $+1
?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z$rtcVarDesc DD 028H ; ImGui::SetWindowClipRectBeforeSetChannel
	DD	010H
	DQ	FLAT:?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z$rtcName$0
	ORG $+48
?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z$rtcFrameData DD 01H ; ImGui::SetWindowClipRectBeforeSetChannel
	DD	00H
	DQ	FLAT:?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ItemSize@ImGui@@YAXAEBUImRect@@M@Z DD 025053001H
	DD	01142319H
	DD	0700d0021H
	DD	0500cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z DD 05052601H
	DD	010d0310H
	DD	070060021H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ DD 05051c01H
	DD	010a030dH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ DD 05051c01H
	DD	010a030dH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiTableSettings@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiTableColumnSettings@@QEAA@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiTableTempData@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImGuiTableTempData@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImGuiTableTempData@@QEAA@XZ DD imagerel ??0ImGuiTableTempData@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0ImGuiTableTempData@@QEAA@XZ+92
	DD	00H
	DD	imagerel ??0ImGuiTableTempData@@QEAA@XZ+246
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImGuiTableTempData@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0ImGuiTableTempData@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ImGuiTableTempData@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0ImGuiTableTempData@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0ImGuiTableTempData@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiTableTempData@@QEAA@XZ DD 025053511H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ImGuiTableTempData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImGuiTable@@QEAAPEAXI@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImGuiTable@@QEAA@XZ DD imagerel ??1ImGuiTable@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1ImGuiTable@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1ImGuiTable@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiTable@@QEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1ImGuiTable@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0ImGuiTable@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ImGuiTable@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImGuiTable@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImGuiTable@@QEAA@XZ DD imagerel ??0ImGuiTable@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0ImGuiTable@@QEAA@XZ+321
	DD	00H
	DD	imagerel ??0ImGuiTable@@QEAA@XZ+364
	DD	01H
	DD	imagerel ??0ImGuiTable@@QEAA@XZ+407
	DD	02H
	DD	imagerel ??0ImGuiTable@@QEAA@XZ+462
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImGuiTable@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0ImGuiTable@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0ImGuiTable@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0ImGuiTable@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ImGuiTable@@QEAA@XZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0ImGuiTable@@QEAA@XZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0ImGuiTable@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiTable@@QEAA@XZ DD 025053511H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ImGuiTable@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEBAHH@Z DD 05052c01H
	DD	01120315H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ DD imagerel ??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiTableInstanceData@@@@QEAAXAEBUImGuiTableInstanceData@@@Z DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiTableInstanceData@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiTableInstanceData@@@@QEBAHH@Z DD 05052c01H
	DD	01120315H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImGuiTableInstanceData@@@@QEAAAEAUImGuiTableInstanceData@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ DD imagerel ??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?set@?$ImSpan@UImGuiTableCellData@@@@QEAAXPEAUImGuiTableCellData@@0@Z DD 05053201H
	DD	0118031bH
	DD	070110019H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImSpan@UImGuiTableCellData@@@@QEAA@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImSpan@F@@QEAAAEAFH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?set@?$ImSpan@F@@QEAAXPEAF0@Z DD 05053201H
	DD	0118031bH
	DD	070110019H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImSpan@F@@QEAA@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?index_from_ptr@?$ImSpan@UImGuiTableColumn@@@@QEBAHPEBUImGuiTableColumn@@@Z DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$ImSpan@UImGuiTableColumn@@@@QEBAHXZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?set@?$ImSpan@UImGuiTableColumn@@@@QEAAXPEAUImGuiTableColumn@@0@Z DD 05053201H
	DD	0118031bH
	DD	070110019H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImSpan@UImGuiTableColumn@@@@QEAA@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiTableInstanceData@@QEAA@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiTableColumn@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ DD 035052f01H
	DD	01133318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z DD 05052c01H
	DD	01120315H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ptr_from_offset@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?offset_from_ptr@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?chunk_size@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z DD 05052d01H
	DD	01130316H
	DD	0700c0019H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ DD 05052801H
	DD	010e0311H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z DD 025052f01H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TryGetMapData@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetMapSize@?$ImPool@UImGuiTable@@@@QEBAHXZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Remove@?$ImPool@UImGuiTable@@@@QEAAXIH@Z DD 025053301H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Remove@?$ImPool@UImGuiTable@@@@QEAAXIPEBUImGuiTable@@@Z DD 025053301H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ DD imagerel ?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ
	DD	0ffffffffH
	DD	imagerel ?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ+232
	DD	00H
	DD	imagerel ?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ+288
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ
	DD	01a8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ DD 025053511H
	DD	010e2313H
	DD	070070039H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetOrAddByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetByIndex@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiTable@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiTable@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiTable@@@@QEBAHH@Z DD 05052c01H
	DD	01120315H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiTableTempData@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiTableTempData@@@@QEAAXHAEBUImGuiTableTempData@@@Z DD 025053301H
	DD	0117231cH
	DD	070100021H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiTableTempData@@@@QEBAHH@Z DD 05052c01H
	DD	01120315H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImGuiTableTempData@@@@QEAAAEAUImGuiTableTempData@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiSettingsHandler@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiOldColumns@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ImGuiOldColumns@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImGuiOldColumns@@QEAA@XZ DD imagerel ??0ImGuiOldColumns@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0ImGuiOldColumns@@QEAA@XZ+130
	DD	00H
	DD	imagerel ??0ImGuiOldColumns@@QEAA@XZ+170
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImGuiOldColumns@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0ImGuiOldColumns@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ImGuiOldColumns@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0ImGuiOldColumns@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0ImGuiOldColumns@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiOldColumns@@QEAA@XZ DD 025053511H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ImGuiOldColumns@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z DD 05052c01H
	DD	01120315H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ DD imagerel ??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiOldColumnData@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ImMin@H@@YAHHH@Z DD 05052a01H
	DD	01110314H
	DD	0700a001bH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImBitArraySetBitRange@@YAXPEAIHH@Z DD 05031601H
	DD	0b2130316H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImBitArraySetBit@@YAXPEAIH@Z DD 05031101H
	DD	0920e0311H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImBitArrayClearBit@@YAXPEAIH@Z DD 05031101H
	DD	0920e0311H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImBitArrayClearAllBits@@YAXPEAIH@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z DD 05030c01H
	DD	07209030cH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ToVec4@ImRect@@QEBA?AUImVec4@@XZ DD 035031401H
	DD	0d20f3314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClipWithFull@ImRect@@QEAAXAEBU1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClipWith@ImRect@@QEAAXAEBU1@@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Add@ImRect@@QEAAXAEBU1@@Z DD 05031201H
	DD	0720f0312H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Overlaps@ImRect@@QEBA_NAEBU1@@Z DD 05031201H
	DD	0920f0312H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Contains@ImRect@@QEBA_NAEBU1@@Z DD 05031201H
	DD	0920f0312H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetHeight@ImRect@@QEBAMXZ DD 05030d01H
	DD	0720a030dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetWidth@ImRect@@QEBAMXZ DD 05030d01H
	DD	0720a030dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSize@ImRect@@QEBA?AUImVec2@@XZ DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImRect@@QEAA@MMMM@Z DD 025032101H
	DD	0b21c2321H
	DD	05018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImRect@@QEAA@AEBUImVec4@@@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImRect@@QEAA@AEBUImVec2@@0@Z DD 05031701H
	DD	072140317H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImRect@@QEAA@XZ DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImVec1@@QEAA@XZ DD 05030d01H
	DD	0720a030dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ImMax@M@@YAMMM@Z DD 015052901H
	DD	0115131aH
	DD	0700e001dH
	DD	0500dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ImMin@M@@YAMMM@Z DD 015052901H
	DD	0115131aH
	DD	0700e001dH
	DD	0500dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImFloor@@YAMM@Z DD 05030e01H
	DD	0720b030eH
	DD	05007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImMax@@YA?AUImVec2@@AEBU1@0@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImMin@@YA?AUImVec2@@AEBU1@0@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??H@YA?AUImVec2@@AEBU0@0@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImIsPowerOfTwo@@YA_NH@Z DD 05052601H
	DD	010d0310H
	DD	07006001bH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 025054a19H
	DD	011d2322H
	DD	070160025H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sscanf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sscanf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:sscanf$rtcName$0
	ORG $+48
sscanf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sscanf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 035053901H
	DD	011d3322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD 05051c01H
	DD	010a030dH
	DD	070030019H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_scanf_options DD 05051c01H
	DD	010a030dH
	DD	070030019H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@M@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@M@@QEAAXHAEBM@Z DD 025053301H
	DD	0117231cH
	DD	070100021H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@M@@QEBAHH@Z DD 05052c01H
	DD	01120315H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@M@@QEAAAEAMH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$ImVector@I@@QEAAAEAIXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImDrawListSplitter@@QEAAXXZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImDrawListSplitter@@QEAA@XZ DD imagerel ??1ImDrawListSplitter@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1ImDrawListSplitter@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1ImDrawListSplitter@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImDrawListSplitter@@QEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1ImDrawListSplitter@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImDrawListSplitter@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z DD 05052c01H
	DD	01120315H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DD imagerel ??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImVector@UImDrawChannel@@@@QEAA@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImGuiStoragePair@ImGuiStorage@@@@QEAAAEAUImGuiStoragePair@ImGuiStorage@@H@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiTextBuffer@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@ImGuiTextBuffer@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@ImGuiTextBuffer@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@ImGuiTextBuffer@@QEBAHXZ DD 05052801H
	DD	010e0311H
	DD	07007001bH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiTextBuffer@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@D@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@D@@QEAAXH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@D@@QEBAHH@Z DD 05052c01H
	DD	01120315H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?swap@?$ImVector@D@@QEAAXAEAU1@@Z DD 05052d01H
	DD	01130316H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@D@@QEBAAEBDH@Z DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@D@@QEAAXXZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@D@@QEAA@XZ DD imagerel ??1?$ImVector@D@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$ImVector@D@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$ImVector@D@@QEAA@XZ
	DD	0e8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@D@@QEAA@XZ DD 025053519H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$ImVector@D@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImVector@D@@QEAA@XZ DD 05052801H
	DD	010e0311H
	DD	070070019H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiTableSortSpecs@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiTableColumnSortSpecs@@QEAA@XZ DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??3@YAXPEAXUImNewWrapper@@0@Z DD 05053101H
	DD	0117031aH
	DD	070100019H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??2@YAPEAX_KUImNewWrapper@@PEAX@Z DD 05053101H
	DD	0117031aH
	DD	070100019H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetColumnsCount@ImGui@@YAHXZ DD 025051e01H
	DD	010a230fH
	DD	070030021H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetColumnOffset@ImGui@@YAXHM@Z DD 025052e01H
	DD	01132318H
	DD	0700c0031H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetColumnOffset@ImGui@@YAMH@Z DD 035052801H
	DD	010d3312H
	DD	07006002fH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetColumnWidth@ImGui@@YAXHM@Z DD 025052e01H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetColumnWidth@ImGui@@YAMH@Z DD 035052801H
	DD	010d3312H
	DD	07006002fH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetColumnIndex@ImGui@@YAHXZ DD 025051e01H
	DD	010a230fH
	DD	070030021H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?NextColumn@ImGui@@YAXXZ DD 025051e01H
	DD	010a230fH
	DD	070030041H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Columns@ImGui@@YAXHPEBD_N@Z DD 025053201H
	DD	0117231cH
	DD	070100029H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetBgColor@ImGui@@YAXHIH@Z DD 025053101H
	DD	0116231bH
	DD	0700f002dH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetColumnEnabled@ImGui@@YAXH_N@Z DD 025052c01H
	DD	01112316H
	DD	0700a0029H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetColumnFlags@ImGui@@YAHH@Z DD 025052801H
	DD	010d2312H
	DD	070060025H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetColumnName@ImGui@@YAPEBDH@Z DD 025052801H
	DD	010d2312H
	DD	070060025H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetRowIndex@ImGui@@YAHXZ DD 05051c01H
	DD	010a030dH
	DD	070030021H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetColumnIndex@ImGui@@YAHXZ DD 05051c01H
	DD	010a030dH
	DD	070030021H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetColumnCount@ImGui@@YAHXZ DD 05051c01H
	DD	010a030dH
	DD	070030021H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ DD 025051e01H
	DD	010a230fH
	DD	070030025H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableHeader@ImGui@@YAXPEBD@Z DD 045053b19H
	DD	010e4313H
	DD	0700700dfH
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	06e0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableHeader@ImGui@@YAXPEBD@Z$rtcName$0 DB 06cH		; ImGui::TableHeader
	DB	061H
	DB	062H
	DB	065H
	DB	06cH
	DB	05fH
	DB	073H
	DB	069H
	DB	07aH
	DB	065H
	DB	00H
	ORG $+5
?TableHeader@ImGui@@YAXPEBD@Z$rtcName$1 DB 06cH		; ImGui::TableHeader
	DB	061H
	DB	062H
	DB	065H
	DB	06cH
	DB	05fH
	DB	070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+2
?TableHeader@ImGui@@YAXPEBD@Z$rtcName$2 DB 063H		; ImGui::TableHeader
	DB	065H
	DB	06cH
	DB	06cH
	DB	05fH
	DB	072H
	DB	00H
	ORG $+1
?TableHeader@ImGui@@YAXPEBD@Z$rtcName$4 DB 062H		; ImGui::TableHeader
	DB	062H
	DB	00H
	ORG $+1
?TableHeader@ImGui@@YAXPEBD@Z$rtcName$3 DB 073H		; ImGui::TableHeader
	DB	06fH
	DB	072H
	DB	074H
	DB	05fH
	DB	06fH
	DB	072H
	DB	064H
	DB	065H
	DB	072H
	DB	05fH
	DB	073H
	DB	075H
	DB	066H
	DB	00H
	ORG $+1
?TableHeader@ImGui@@YAXPEBD@Z$rtcName$5 DB 068H		; ImGui::TableHeader
	DB	06fH
	DB	076H
	DB	065H
	DB	072H
	DB	065H
	DB	064H
	DB	00H
?TableHeader@ImGui@@YAXPEBD@Z$rtcName$6 DB 068H		; ImGui::TableHeader
	DB	065H
	DB	06cH
	DB	064H
	DB	00H
	ORG $+3
?TableHeader@ImGui@@YAXPEBD@Z$rtcFrameData DD 07H	; ImGui::TableHeader
	DD	00H
	DQ	FLAT:?TableHeader@ImGui@@YAXPEBD@Z$rtcVarDesc
	ORG $+8
?TableHeader@ImGui@@YAXPEBD@Z$rtcVarDesc DD 02c4H	; ImGui::TableHeader
	DD	01H
	DQ	FLAT:?TableHeader@ImGui@@YAXPEBD@Z$rtcName$6
	DD	02a4H
	DD	01H
	DQ	FLAT:?TableHeader@ImGui@@YAXPEBD@Z$rtcName$5
	DD	0278H
	DD	010H
	DQ	FLAT:?TableHeader@ImGui@@YAXPEBD@Z$rtcName$4
	DD	01d4H
	DD	04H
	DQ	FLAT:?TableHeader@ImGui@@YAXPEBD@Z$rtcName$3
	DD	0148H
	DD	010H
	DQ	FLAT:?TableHeader@ImGui@@YAXPEBD@Z$rtcName$2
	DD	0128H
	DD	08H
	DQ	FLAT:?TableHeader@ImGui@@YAXPEBD@Z$rtcName$1
	DD	0108H
	DD	08H
	DQ	FLAT:?TableHeader@ImGui@@YAXPEBD@Z$rtcName$0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableHeadersRow@ImGui@@YAXXZ DD 025052f19H
	DD	010a230fH
	DD	070030043H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0200H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?TableHeadersRow@ImGui@@YAXXZ$rtcName$0 DB 06dH		; ImGui::TableHeadersRow
	DB	06fH
	DB	075H
	DB	073H
	DB	065H
	DB	05fH
	DB	070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+6
?TableHeadersRow@ImGui@@YAXXZ$rtcVarDesc DD 0108H	; ImGui::TableHeadersRow
	DD	08H
	DQ	FLAT:?TableHeadersRow@ImGui@@YAXXZ$rtcName$0
	ORG $+48
?TableHeadersRow@ImGui@@YAXXZ$rtcFrameData DD 01H	; ImGui::TableHeadersRow
	DD	00H
	DQ	FLAT:?TableHeadersRow@ImGui@@YAXXZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetupScrollFreeze@ImGui@@YAXHH@Z DD 025052c01H
	DD	01112316H
	DD	0700a002dH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetupColumn@ImGui@@YAXPEBDHMI@Z DD 025053901H
	DD	011d2322H
	DD	070160029H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSetColumnIndex@ImGui@@YA_NH@Z DD 025052801H
	DD	010d2312H
	DD	070060025H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableNextColumn@ImGui@@YA_NXZ DD 025051e01H
	DD	010a230fH
	DD	070030025H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableNextRow@ImGui@@YAXHM@Z DD 025052e01H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EndTable@ImGui@@YAXXZ DD 025063019H
	DD	010b2310H
	DD	0700400a8H
	DD	050026003H
	DD	imagerel __GSHandlerCheck
	DD	0530H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?EndTable@ImGui@@YAXXZ$rtcName$0 DB 062H		; ImGui::EndTable
	DB	061H
	DB	063H
	DB	06bH
	DB	075H
	DB	070H
	DB	05fH
	DB	06fH
	DB	075H
	DB	074H
	DB	065H
	DB	072H
	DB	05fH
	DB	06dH
	DB	061H
	DB	078H
	DB	05fH
	DB	070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+11
?EndTable@ImGui@@YAXXZ$rtcVarDesc DD 0308H		; ImGui::EndTable
	DD	08H
	DQ	FLAT:?EndTable@ImGui@@YAXXZ$rtcName$0
	ORG $+48
?EndTable@ImGui@@YAXXZ$rtcFrameData DD 01H		; ImGui::EndTable
	DD	00H
	DQ	FLAT:?EndTable@ImGui@@YAXXZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z DD 035053801H
	DD	011c3321H
	DD	070150023H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImVec4@@QEAA@MMMM@Z DD 05031f01H
	DD	0721c031fH
	DD	05018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImVec2@@QEAA@MM@Z DD 05031901H
	DD	072160319H
	DD	05012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImVec2@@QEAA@XZ DD 05030d01H
	DD	0720a030dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 025053901H
	DD	011d2322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z
_TEXT	SEGMENT
offset_norm$ = 4
tv82 = 216
tv70 = 216
columns$ = 256
column_index$ = 264
before_resize$ = 272
?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z PROC	; GetColumnWidthEx, COMDAT

; 3757 : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00017	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR [rsp+312]

; 3758 :     if (column_index < 0)

  00033	83 bd 08 01 00
	00 00		 cmp	 DWORD PTR column_index$[rbp], 0
  0003a	7d 10		 jge	 SHORT $LN2@GetColumnW

; 3759 :         column_index = columns->Current;

  0003c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR columns$[rbp]
  00043	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00046	89 85 08 01 00
	00		 mov	 DWORD PTR column_index$[rbp], eax
$LN2@GetColumnW:

; 3760 : 
; 3761 :     float offset_norm;
; 3762 :     if (before_resize)

  0004c	0f b6 85 10 01
	00 00		 movzx	 eax, BYTE PTR before_resize$[rbp]
  00053	85 c0		 test	 eax, eax
  00055	74 4f		 je	 SHORT $LN3@GetColumnW

; 3763 :         offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;

  00057	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR column_index$[rbp]
  0005d	ff c0		 inc	 eax
  0005f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR columns$[rbp]
  00066	48 83 c1 60	 add	 rcx, 96			; 00000060H
  0006a	8b d0		 mov	 edx, eax
  0006c	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  00071	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv70[rbp], rax
  00078	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR columns$[rbp]
  0007f	48 83 c1 60	 add	 rcx, 96			; 00000060H
  00083	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR column_index$[rbp]
  00089	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  0008e	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR tv70[rbp]
  00095	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [rcx+4]
  0009a	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [rax+4]
  0009f	f3 0f 11 45 04	 movss	 DWORD PTR offset_norm$[rbp], xmm0

; 3764 :     else

  000a4	eb 4b		 jmp	 SHORT $LN4@GetColumnW
$LN3@GetColumnW:

; 3765 :         offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;

  000a6	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR column_index$[rbp]
  000ac	ff c0		 inc	 eax
  000ae	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR columns$[rbp]
  000b5	48 83 c1 60	 add	 rcx, 96			; 00000060H
  000b9	8b d0		 mov	 edx, eax
  000bb	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  000c0	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv82[rbp], rax
  000c7	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR columns$[rbp]
  000ce	48 83 c1 60	 add	 rcx, 96			; 00000060H
  000d2	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR column_index$[rbp]
  000d8	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  000dd	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR tv82[rbp]
  000e4	f3 0f 10 01	 movss	 xmm0, DWORD PTR [rcx]
  000e8	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [rax]
  000ec	f3 0f 11 45 04	 movss	 DWORD PTR offset_norm$[rbp], xmm0
$LN4@GetColumnW:

; 3766 :     return ImGui::GetColumnOffsetFromNorm(columns, offset_norm);

  000f1	f3 0f 10 4d 04	 movss	 xmm1, DWORD PTR offset_norm$[rbp]
  000f6	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR columns$[rbp]
  000fd	e8 00 00 00 00	 call	 ?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ; ImGui::GetColumnOffsetFromNorm

; 3767 : }

  00102	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00109	5f		 pop	 rdi
  0010a	5d		 pop	 rbp
  0010b	c3		 ret	 0
?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z ENDP	; GetColumnWidthEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@M@@YAMMMM@Z
_TEXT	SEGMENT
a$ = 224
b$ = 232
t$ = 240
??$ImLerp@M@@YAMMMM@Z PROC				; ImLerp<float>, COMDAT

; 455  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  0000c	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00012	55		 push	 rbp
  00013	57		 push	 rdi
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0001b	48 8d 6c 24 10	 lea	 rbp, QWORD PTR [rsp+16]
  00020	48 8b fc	 mov	 rdi, rsp
  00023	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	f3 0f 10 85 e8
	00 00 00	 movss	 xmm0, DWORD PTR b$[rbp]
  00037	f3 0f 5c 85 e0
	00 00 00	 subss	 xmm0, DWORD PTR a$[rbp]
  0003f	f3 0f 59 85 f0
	00 00 00	 mulss	 xmm0, DWORD PTR t$[rbp]
  00047	f3 0f 10 8d e0
	00 00 00	 movss	 xmm1, DWORD PTR a$[rbp]
  0004f	f3 0f 58 c8	 addss	 xmm1, xmm0
  00053	0f 28 c1	 movaps	 xmm0, xmm1
  00056	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005d	5f		 pop	 rdi
  0005e	5d		 pop	 rbp
  0005f	c3		 ret	 0
??$ImLerp@M@@YAMMMM@Z ENDP				; ImLerp<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z
_TEXT	SEGMENT
g$ = 8
window$ = 40
x$ = 68
columns$ = 320
column_index$ = 328
?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z PROC ; GetDraggedColumnOffset, COMDAT

; 3724 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00012	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR [rsp+376]

; 3725 :     // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
; 3726 :     // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
; 3727 :     ImGuiContext& g = *GImGui;

  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00035	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3728 :     ImGuiWindow* window = g.CurrentWindow;

  00039	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003d	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  00044	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 3729 :     IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.

  00048	83 bd 48 01 00
	00 00		 cmp	 DWORD PTR column_index$[rbp], 0
  0004f	7f 22		 jg	 SHORT $LN4@GetDragged
  00051	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z@4JA
  00057	83 c0 05	 add	 eax, 5
  0005a	44 8b c0	 mov	 r8d, eax
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@HNMGCLDB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00071	33 c0		 xor	 eax, eax
$LN4@GetDragged:

; 3730 :     IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

  00073	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR columns$[rbp]
  0007a	8b 00		 mov	 eax, DWORD PTR [rax]
  0007c	03 85 48 01 00
	00		 add	 eax, DWORD PTR column_index$[rbp]
  00082	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00086	39 81 00 3f 00
	00		 cmp	 DWORD PTR [rcx+16128], eax
  0008c	74 22		 je	 SHORT $LN5@GetDragged
  0008e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z@4JA
  00094	83 c0 06	 add	 eax, 6
  00097	44 8b c0	 mov	 r8d, eax
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GE@CFLLPKGA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$CL?$AA?5?$AAI?$AAm?$AAG?$AAu@
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ae	33 c0		 xor	 eax, eax
$LN5@GetDragged:

; 3731 : 
; 3732 :     float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;

  000b0	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  000b4	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  000b8	f3 0f 10 80 fc
	0d 00 00	 movss	 xmm0, DWORD PTR [rax+3580]
  000c0	f3 0f 5c 81 14
	3f 00 00	 subss	 xmm0, DWORD PTR [rcx+16148]
  000c8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40800000
  000d0	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000d4	f3 0f 5c 40 18	 subss	 xmm0, DWORD PTR [rax+24]
  000d9	f3 0f 11 45 44	 movss	 DWORD PTR x$[rbp], xmm0

; 3733 :     x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);

  000de	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR column_index$[rbp]
  000e4	ff c8		 dec	 eax
  000e6	8b c8		 mov	 ecx, eax
  000e8	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  000ed	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  000f1	f3 0f 58 80 50
	38 00 00	 addss	 xmm0, DWORD PTR [rax+14416]
  000f9	0f 28 c8	 movaps	 xmm1, xmm0
  000fc	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR x$[rbp]
  00101	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00106	f3 0f 11 45 44	 movss	 DWORD PTR x$[rbp], xmm0

; 3734 :     if ((columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths))

  0010b	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR columns$[rbp]
  00112	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00115	83 e0 04	 and	 eax, 4
  00118	85 c0		 test	 eax, eax
  0011a	74 2d		 je	 SHORT $LN2@GetDragged

; 3735 :         x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

  0011c	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR column_index$[rbp]
  00122	ff c0		 inc	 eax
  00124	8b c8		 mov	 ecx, eax
  00126	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  0012b	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0012f	f3 0f 5c 80 50
	38 00 00	 subss	 xmm0, DWORD PTR [rax+14416]
  00137	0f 28 c8	 movaps	 xmm1, xmm0
  0013a	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR x$[rbp]
  0013f	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00144	f3 0f 11 45 44	 movss	 DWORD PTR x$[rbp], xmm0
$LN2@GetDragged:

; 3736 : 
; 3737 :     return x;

  00149	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR x$[rbp]

; 3738 : }

  0014e	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00155	5f		 pop	 rdi
  00156	5d		 pop	 rbp
  00157	c3		 ret	 0
?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z ENDP ; GetDraggedColumnOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?DebugNodeTableGetSizingPolicyDesc@@YAPEBDH@Z
_TEXT	SEGMENT
sizing_policy$ = 224
?DebugNodeTableGetSizingPolicyDesc@@YAPEBDH@Z PROC	; DebugNodeTableGetSizingPolicyDesc, COMDAT

; 3564 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000d	48 8b ec	 mov	 rbp, rsp
  00010	48 8b fc	 mov	 rdi, rsp
  00013	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR [rsp+232]

; 3565 :     sizing_policy &= ImGuiTableFlags_SizingMask_;

  00026	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR sizing_policy$[rbp]
  0002c	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  00031	89 85 e0 00 00
	00		 mov	 DWORD PTR sizing_policy$[rbp], eax

; 3566 :     if (sizing_policy == ImGuiTableFlags_SizingFixedFit)    { return "FixedFit"; }

  00037	81 bd e0 00 00
	00 00 20 00 00	 cmp	 DWORD PTR sizing_policy$[rbp], 8192 ; 00002000H
  00041	75 09		 jne	 SHORT $LN2@DebugNodeT
  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08CCPMLANI@FixedFit?$AA@
  0004a	eb 46		 jmp	 SHORT $LN1@DebugNodeT
$LN2@DebugNodeT:

; 3567 :     if (sizing_policy == ImGuiTableFlags_SizingFixedSame)   { return "FixedSame"; }

  0004c	81 bd e0 00 00
	00 00 40 00 00	 cmp	 DWORD PTR sizing_policy$[rbp], 16384 ; 00004000H
  00056	75 09		 jne	 SHORT $LN3@DebugNodeT
  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09OOODJBFG@FixedSame?$AA@
  0005f	eb 31		 jmp	 SHORT $LN1@DebugNodeT
$LN3@DebugNodeT:

; 3568 :     if (sizing_policy == ImGuiTableFlags_SizingStretchProp) { return "StretchProp"; }

  00061	81 bd e0 00 00
	00 00 60 00 00	 cmp	 DWORD PTR sizing_policy$[rbp], 24576 ; 00006000H
  0006b	75 09		 jne	 SHORT $LN4@DebugNodeT
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@IGAOBHEB@StretchProp?$AA@
  00074	eb 1c		 jmp	 SHORT $LN1@DebugNodeT
$LN4@DebugNodeT:

; 3569 :     if (sizing_policy == ImGuiTableFlags_SizingStretchSame) { return "StretchSame"; }

  00076	81 bd e0 00 00
	00 00 80 00 00	 cmp	 DWORD PTR sizing_policy$[rbp], 32768 ; 00008000H
  00080	75 09		 jne	 SHORT $LN5@DebugNodeT
  00082	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@LHDDKHJK@StretchSame?$AA@
  00089	eb 07		 jmp	 SHORT $LN1@DebugNodeT
$LN5@DebugNodeT:

; 3570 :     return "N/A";

  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03HPADHAHE@N?1A?$AA@
$LN1@DebugNodeT:

; 3571 : }

  00092	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00099	5f		 pop	 rdi
  0009a	5d		 pop	 rbp
  0009b	c3		 ret	 0
?DebugNodeTableGetSizingPolicyDesc@@YAPEBDH@Z ENDP	; DebugNodeTableGetSizingPolicyDesc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
_TEXT	SEGMENT
g$ = 8
settings$1 = 40
save_size$2 = 68
save_visible$3 = 100
save_order$4 = 132
save_sort$5 = 164
column$6 = 200
column_n$7 = 228
save_column$8 = 260
tv238 = 468
tv175 = 468
tv89 = 468
tv85 = 468
tv81 = 468
tv77 = 468
ctx$ = 512
handler$ = 520
buf$ = 528
?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z PROC ; TableSettingsHandler_WriteAll, COMDAT

; 3441 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 18 02
	00 00		 sub	 rsp, 536		; 00000218H
  00018	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001d	48 8b fc	 mov	 rdi, rsp
  00020	b9 86 00 00 00	 mov	 ecx, 134		; 00000086H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR [rsp+568]

; 3442 :     ImGuiContext& g = *ctx;

  00034	48 8b 85 00 02
	00 00		 mov	 rax, QWORD PTR ctx$[rbp]
  0003b	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3443 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

  0003f	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00043	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  00049	48 8b c8	 mov	 rcx, rax
  0004c	e8 00 00 00 00	 call	 ?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::begin
  00051	48 89 45 28	 mov	 QWORD PTR settings$1[rbp], rax
  00055	eb 1a		 jmp	 SHORT $LN4@TableSetti
$LN2@TableSetti:
  00057	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0005b	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  00061	48 8b 55 28	 mov	 rdx, QWORD PTR settings$1[rbp]
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 ?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z ; ImChunkStream<ImGuiTableSettings>::next_chunk
  0006d	48 89 45 28	 mov	 QWORD PTR settings$1[rbp], rax
$LN4@TableSetti:
  00071	48 83 7d 28 00	 cmp	 QWORD PTR settings$1[rbp], 0
  00076	0f 84 fb 03 00
	00		 je	 $LN3@TableSetti

; 3444 :     {
; 3445 :         if (settings->ID == 0) // Skip ditched settings

  0007c	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  00080	83 38 00	 cmp	 DWORD PTR [rax], 0
  00083	75 02		 jne	 SHORT $LN8@TableSetti

; 3446 :             continue;

  00085	eb d0		 jmp	 SHORT $LN2@TableSetti
$LN8@TableSetti:

; 3447 : 
; 3448 :         // TableSaveSettings() may clear some of those flags when we establish that the data can be stripped
; 3449 :         // (e.g. Order was unchanged)
; 3450 :         const bool save_size    = (settings->SaveFlags & ImGuiTableFlags_Resizable) != 0;

  00087	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  0008b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0008e	83 e0 01	 and	 eax, 1
  00091	85 c0		 test	 eax, eax
  00093	74 09		 je	 SHORT $LN19@TableSetti
  00095	c6 85 d4 01 00
	00 01		 mov	 BYTE PTR tv77[rbp], 1
  0009c	eb 07		 jmp	 SHORT $LN20@TableSetti
$LN19@TableSetti:
  0009e	c6 85 d4 01 00
	00 00		 mov	 BYTE PTR tv77[rbp], 0
$LN20@TableSetti:
  000a5	0f b6 85 d4 01
	00 00		 movzx	 eax, BYTE PTR tv77[rbp]
  000ac	88 45 44	 mov	 BYTE PTR save_size$2[rbp], al

; 3451 :         const bool save_visible = (settings->SaveFlags & ImGuiTableFlags_Hideable) != 0;

  000af	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  000b3	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000b6	83 e0 04	 and	 eax, 4
  000b9	85 c0		 test	 eax, eax
  000bb	74 09		 je	 SHORT $LN21@TableSetti
  000bd	c6 85 d4 01 00
	00 01		 mov	 BYTE PTR tv81[rbp], 1
  000c4	eb 07		 jmp	 SHORT $LN22@TableSetti
$LN21@TableSetti:
  000c6	c6 85 d4 01 00
	00 00		 mov	 BYTE PTR tv81[rbp], 0
$LN22@TableSetti:
  000cd	0f b6 85 d4 01
	00 00		 movzx	 eax, BYTE PTR tv81[rbp]
  000d4	88 45 64	 mov	 BYTE PTR save_visible$3[rbp], al

; 3452 :         const bool save_order   = (settings->SaveFlags & ImGuiTableFlags_Reorderable) != 0;

  000d7	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  000db	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000de	83 e0 02	 and	 eax, 2
  000e1	85 c0		 test	 eax, eax
  000e3	74 09		 je	 SHORT $LN23@TableSetti
  000e5	c6 85 d4 01 00
	00 01		 mov	 BYTE PTR tv85[rbp], 1
  000ec	eb 07		 jmp	 SHORT $LN24@TableSetti
$LN23@TableSetti:
  000ee	c6 85 d4 01 00
	00 00		 mov	 BYTE PTR tv85[rbp], 0
$LN24@TableSetti:
  000f5	0f b6 85 d4 01
	00 00		 movzx	 eax, BYTE PTR tv85[rbp]
  000fc	88 85 84 00 00
	00		 mov	 BYTE PTR save_order$4[rbp], al

; 3453 :         const bool save_sort    = (settings->SaveFlags & ImGuiTableFlags_Sortable) != 0;

  00102	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  00106	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00109	83 e0 08	 and	 eax, 8
  0010c	85 c0		 test	 eax, eax
  0010e	74 09		 je	 SHORT $LN25@TableSetti
  00110	c6 85 d4 01 00
	00 01		 mov	 BYTE PTR tv89[rbp], 1
  00117	eb 07		 jmp	 SHORT $LN26@TableSetti
$LN25@TableSetti:
  00119	c6 85 d4 01 00
	00 00		 mov	 BYTE PTR tv89[rbp], 0
$LN26@TableSetti:
  00120	0f b6 85 d4 01
	00 00		 movzx	 eax, BYTE PTR tv89[rbp]
  00127	88 85 a4 00 00
	00		 mov	 BYTE PTR save_sort$5[rbp], al

; 3454 :         if (!save_size && !save_visible && !save_order && !save_sort)

  0012d	0f b6 45 44	 movzx	 eax, BYTE PTR save_size$2[rbp]
  00131	85 c0		 test	 eax, eax
  00133	75 23		 jne	 SHORT $LN9@TableSetti
  00135	0f b6 45 64	 movzx	 eax, BYTE PTR save_visible$3[rbp]
  00139	85 c0		 test	 eax, eax
  0013b	75 1b		 jne	 SHORT $LN9@TableSetti
  0013d	0f b6 85 84 00
	00 00		 movzx	 eax, BYTE PTR save_order$4[rbp]
  00144	85 c0		 test	 eax, eax
  00146	75 10		 jne	 SHORT $LN9@TableSetti
  00148	0f b6 85 a4 00
	00 00		 movzx	 eax, BYTE PTR save_sort$5[rbp]
  0014f	85 c0		 test	 eax, eax
  00151	75 05		 jne	 SHORT $LN9@TableSetti

; 3455 :             continue;

  00153	e9 ff fe ff ff	 jmp	 $LN2@TableSetti
$LN9@TableSetti:

; 3456 : 
; 3457 :         buf->reserve(buf->size() + 30 + settings->ColumnsCount * 50); // ballpark reserve

  00158	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  0015f	e8 00 00 00 00	 call	 ?size@ImGuiTextBuffer@@QEBAHXZ ; ImGuiTextBuffer::size
  00164	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$1[rbp]
  00168	0f bf 49 0c	 movsx	 ecx, WORD PTR [rcx+12]
  0016c	6b c9 32	 imul	 ecx, ecx, 50		; 00000032H
  0016f	8d 44 08 1e	 lea	 eax, DWORD PTR [rax+rcx+30]
  00173	8b d0		 mov	 edx, eax
  00175	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  0017c	e8 00 00 00 00	 call	 ?reserve@ImGuiTextBuffer@@QEAAXH@Z ; ImGuiTextBuffer::reserve

; 3458 :         buf->appendf("[%s][0x%08X,%d]\n", handler->TypeName, settings->ID, settings->ColumnsCount);

  00181	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  00185	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  00189	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0018d	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  00191	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00194	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR handler$[rbp]
  0019b	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0019e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@PGHPBJD@?$FL?$CFs?$FN?$FL0x?$CF08X?0?$CFd?$FN?6?$AA@
  001a5	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  001ac	e8 00 00 00 00	 call	 ?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ ; ImGuiTextBuffer::appendf

; 3459 :         if (settings->RefScale != 0.0f)

  001b1	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  001b5	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  001ba	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  001c1	7a 02		 jp	 SHORT $LN32@TableSetti
  001c3	74 24		 je	 SHORT $LN10@TableSetti
$LN32@TableSetti:

; 3460 :             buf->appendf("RefScale=%g\n", settings->RefScale);

  001c5	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  001c9	f3 0f 5a 40 08	 cvtss2sd xmm0, DWORD PTR [rax+8]
  001ce	0f 28 d0	 movaps	 xmm2, xmm0
  001d1	66 49 0f 7e d0	 movq	 r8, xmm2
  001d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NHEEPCEH@RefScale?$DN?$CFg?6?$AA@
  001dd	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  001e4	e8 00 00 00 00	 call	 ?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ ; ImGuiTextBuffer::appendf
$LN10@TableSetti:

; 3461 :         ImGuiTableColumnSettings* column = settings->GetColumnSettings();

  001e9	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$1[rbp]
  001ed	e8 00 00 00 00	 call	 ?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ ; ImGuiTableSettings::GetColumnSettings
  001f2	48 89 85 c8 00
	00 00		 mov	 QWORD PTR column$6[rbp], rax

; 3462 :         for (int column_n = 0; column_n < settings->ColumnsCount; column_n++, column++)

  001f9	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$7[rbp], 0
  00203	eb 20		 jmp	 SHORT $LN7@TableSetti
$LN5@TableSetti:
  00205	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR column_n$7[rbp]
  0020b	ff c0		 inc	 eax
  0020d	89 85 e4 00 00
	00		 mov	 DWORD PTR column_n$7[rbp], eax
  00213	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  0021a	48 83 c0 10	 add	 rax, 16
  0021e	48 89 85 c8 00
	00 00		 mov	 QWORD PTR column$6[rbp], rax
$LN7@TableSetti:
  00225	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  00229	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  0022d	39 85 e4 00 00
	00		 cmp	 DWORD PTR column_n$7[rbp], eax
  00233	0f 8d 23 02 00
	00		 jge	 $LN6@TableSetti

; 3463 :         {
; 3464 :             // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
; 3465 :             bool save_column = column->UserID != 0 || save_size || save_visible || save_order || (save_sort && column->SortOrder != -1);

  00239	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  00240	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00244	75 42		 jne	 SHORT $LN27@TableSetti
  00246	0f b6 45 44	 movzx	 eax, BYTE PTR save_size$2[rbp]
  0024a	85 c0		 test	 eax, eax
  0024c	75 3a		 jne	 SHORT $LN27@TableSetti
  0024e	0f b6 45 64	 movzx	 eax, BYTE PTR save_visible$3[rbp]
  00252	85 c0		 test	 eax, eax
  00254	75 32		 jne	 SHORT $LN27@TableSetti
  00256	0f b6 85 84 00
	00 00		 movzx	 eax, BYTE PTR save_order$4[rbp]
  0025d	85 c0		 test	 eax, eax
  0025f	75 27		 jne	 SHORT $LN27@TableSetti
  00261	0f b6 85 a4 00
	00 00		 movzx	 eax, BYTE PTR save_sort$5[rbp]
  00268	85 c0		 test	 eax, eax
  0026a	74 10		 je	 SHORT $LN28@TableSetti
  0026c	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  00273	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  00277	83 f8 ff	 cmp	 eax, -1
  0027a	75 0c		 jne	 SHORT $LN27@TableSetti
$LN28@TableSetti:
  0027c	c7 85 d4 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv175[rbp], 0
  00286	eb 0a		 jmp	 SHORT $LN29@TableSetti
$LN27@TableSetti:
  00288	c7 85 d4 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv175[rbp], 1
$LN29@TableSetti:
  00292	0f b6 85 d4 01
	00 00		 movzx	 eax, BYTE PTR tv175[rbp]
  00299	88 85 04 01 00
	00		 mov	 BYTE PTR save_column$8[rbp], al

; 3466 :             if (!save_column)

  0029f	0f b6 85 04 01
	00 00		 movzx	 eax, BYTE PTR save_column$8[rbp]
  002a6	85 c0		 test	 eax, eax
  002a8	75 05		 jne	 SHORT $LN11@TableSetti

; 3467 :                 continue;

  002aa	e9 56 ff ff ff	 jmp	 $LN5@TableSetti
$LN11@TableSetti:

; 3468 :             buf->appendf("Column %-2d", column_n);

  002af	44 8b 85 e4 00
	00 00		 mov	 r8d, DWORD PTR column_n$7[rbp]
  002b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@JLNIJDCE@Column?5?$CF?92d?$AA@
  002bd	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  002c4	e8 00 00 00 00	 call	 ?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ ; ImGuiTextBuffer::appendf

; 3469 :             if (column->UserID != 0)                    buf->appendf(" UserID=%08X", column->UserID);

  002c9	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  002d0	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  002d4	74 1e		 je	 SHORT $LN12@TableSetti
  002d6	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  002dd	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  002e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@PGBEGIHP@?5UserID?$DN?$CF08X?$AA@
  002e8	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  002ef	e8 00 00 00 00	 call	 ?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ ; ImGuiTextBuffer::appendf
$LN12@TableSetti:

; 3470 :             if (save_size && column->IsStretch)         buf->appendf(" Weight=%.4f", column->WidthOrWeight);

  002f4	0f b6 45 44	 movzx	 eax, BYTE PTR save_size$2[rbp]
  002f8	85 c0		 test	 eax, eax
  002fa	74 3d		 je	 SHORT $LN13@TableSetti
  002fc	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  00303	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  00307	c0 e8 03	 shr	 al, 3
  0030a	24 01		 and	 al, 1
  0030c	0f b6 c0	 movzx	 eax, al
  0030f	85 c0		 test	 eax, eax
  00311	74 26		 je	 SHORT $LN13@TableSetti
  00313	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  0031a	f3 0f 5a 00	 cvtss2sd xmm0, DWORD PTR [rax]
  0031e	0f 28 d0	 movaps	 xmm2, xmm0
  00321	66 49 0f 7e d0	 movq	 r8, xmm2
  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@MFKBBKPH@?5Weight?$DN?$CF?44f?$AA@
  0032d	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  00334	e8 00 00 00 00	 call	 ?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ ; ImGuiTextBuffer::appendf
$LN13@TableSetti:

; 3471 :             if (save_size && !column->IsStretch)        buf->appendf(" Width=%d", (int)column->WidthOrWeight);

  00339	0f b6 45 44	 movzx	 eax, BYTE PTR save_size$2[rbp]
  0033d	85 c0		 test	 eax, eax
  0033f	74 38		 je	 SHORT $LN14@TableSetti
  00341	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  00348	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  0034c	c0 e8 03	 shr	 al, 3
  0034f	24 01		 and	 al, 1
  00351	0f b6 c0	 movzx	 eax, al
  00354	85 c0		 test	 eax, eax
  00356	75 21		 jne	 SHORT $LN14@TableSetti
  00358	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  0035f	f3 0f 2c 00	 cvttss2si eax, DWORD PTR [rax]
  00363	44 8b c0	 mov	 r8d, eax
  00366	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09PBOBBCAP@?5Width?$DN?$CFd?$AA@
  0036d	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  00374	e8 00 00 00 00	 call	 ?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ ; ImGuiTextBuffer::appendf
$LN14@TableSetti:

; 3472 :             if (save_visible)                           buf->appendf(" Visible=%d", column->IsEnabled);

  00379	0f b6 45 64	 movzx	 eax, BYTE PTR save_visible$3[rbp]
  0037d	85 c0		 test	 eax, eax
  0037f	74 29		 je	 SHORT $LN15@TableSetti
  00381	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  00388	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  0038c	c0 e8 02	 shr	 al, 2
  0038f	24 01		 and	 al, 1
  00391	0f b6 c0	 movzx	 eax, al
  00394	44 8b c0	 mov	 r8d, eax
  00397	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@CIPDPODB@?5Visible?$DN?$CFd?$AA@
  0039e	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  003a5	e8 00 00 00 00	 call	 ?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ ; ImGuiTextBuffer::appendf
$LN15@TableSetti:

; 3473 :             if (save_order)                             buf->appendf(" Order=%d", column->DisplayOrder);

  003aa	0f b6 85 84 00
	00 00		 movzx	 eax, BYTE PTR save_order$4[rbp]
  003b1	85 c0		 test	 eax, eax
  003b3	74 21		 je	 SHORT $LN16@TableSetti
  003b5	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  003bc	0f bf 40 0a	 movsx	 eax, WORD PTR [rax+10]
  003c0	44 8b c0	 mov	 r8d, eax
  003c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09CFPCIBAG@?5Order?$DN?$CFd?$AA@
  003ca	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  003d1	e8 00 00 00 00	 call	 ?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ ; ImGuiTextBuffer::appendf
$LN16@TableSetti:

; 3474 :             if (save_sort && column->SortOrder != -1)   buf->appendf(" Sort=%d%c", column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? 'v' : '^');

  003d6	0f b6 85 a4 00
	00 00		 movzx	 eax, BYTE PTR save_sort$5[rbp]
  003dd	85 c0		 test	 eax, eax
  003df	74 60		 je	 SHORT $LN17@TableSetti
  003e1	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  003e8	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  003ec	83 f8 ff	 cmp	 eax, -1
  003ef	74 50		 je	 SHORT $LN17@TableSetti
  003f1	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  003f8	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  003fc	24 03		 and	 al, 3
  003fe	0f b6 c0	 movzx	 eax, al
  00401	83 f8 01	 cmp	 eax, 1
  00404	75 09		 jne	 SHORT $LN30@TableSetti
  00406	c6 85 d4 01 00
	00 76		 mov	 BYTE PTR tv238[rbp], 118 ; 00000076H
  0040d	eb 07		 jmp	 SHORT $LN31@TableSetti
$LN30@TableSetti:
  0040f	c6 85 d4 01 00
	00 5e		 mov	 BYTE PTR tv238[rbp], 94	; 0000005eH
$LN31@TableSetti:
  00416	0f be 85 d4 01
	00 00		 movsx	 eax, BYTE PTR tv238[rbp]
  0041d	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column$6[rbp]
  00424	0f bf 49 0c	 movsx	 ecx, WORD PTR [rcx+12]
  00428	44 8b c8	 mov	 r9d, eax
  0042b	44 8b c1	 mov	 r8d, ecx
  0042e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@EAJILIBD@?5Sort?$DN?$CFd?$CFc?$AA@
  00435	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  0043c	e8 00 00 00 00	 call	 ?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ ; ImGuiTextBuffer::appendf
$LN17@TableSetti:

; 3475 :             buf->append("\n");

  00441	45 33 c0	 xor	 r8d, r8d
  00444	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  0044b	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  00452	e8 00 00 00 00	 call	 ?append@ImGuiTextBuffer@@QEAAXPEBD0@Z ; ImGuiTextBuffer::append

; 3476 :         }

  00457	e9 a9 fd ff ff	 jmp	 $LN5@TableSetti
$LN6@TableSetti:

; 3477 :         buf->append("\n");

  0045c	45 33 c0	 xor	 r8d, r8d
  0045f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00466	48 8b 8d 10 02
	00 00		 mov	 rcx, QWORD PTR buf$[rbp]
  0046d	e8 00 00 00 00	 call	 ?append@ImGuiTextBuffer@@QEAAXPEBD0@Z ; ImGuiTextBuffer::append

; 3478 :     }

  00472	e9 e0 fb ff ff	 jmp	 $LN2@TableSetti
$LN3@TableSetti:

; 3479 : }

  00477	48 8d a5 e8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+488]
  0047e	5f		 pop	 rdi
  0047f	5d		 pop	 rbp
  00480	c3		 ret	 0
?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z ENDP ; TableSettingsHandler_WriteAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
_TEXT	SEGMENT
settings$ = 8
f$ = 36
column_n$ = 68
r$ = 100
n$ = 132
c$8 = 164
column$9 = 200
tv216 = 404
__$ArrayPad$ = 408
__formal$ = 448
__formal$ = 456
entry$ = 464
line$ = 472
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z PROC ; TableSettingsHandler_ReadLine, COMDAT

; 3415 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec d8 01
	00 00		 sub	 rsp, 472		; 000001d8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8b fc	 mov	 rdi, rsp
  00025	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+504]
  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00040	48 33 c5	 xor	 rax, rbp
  00043	48 89 85 98 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 3416 :     // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
; 3417 :     ImGuiTableSettings* settings = (ImGuiTableSettings*)entry;

  0004a	48 8b 85 d0 01
	00 00		 mov	 rax, QWORD PTR entry$[rbp]
  00051	48 89 45 08	 mov	 QWORD PTR settings$[rbp], rax

; 3418 :     float f = 0.0f;

  00055	0f 57 c0	 xorps	 xmm0, xmm0
  00058	f3 0f 11 45 24	 movss	 DWORD PTR f$[rbp], xmm0

; 3419 :     int column_n = 0, r = 0, n = 0;

  0005d	c7 45 44 00 00
	00 00		 mov	 DWORD PTR column_n$[rbp], 0
  00064	c7 45 64 00 00
	00 00		 mov	 DWORD PTR r$[rbp], 0
  0006b	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR n$[rbp], 0

; 3420 : 
; 3421 :     if (sscanf(line, "RefScale=%f", &f) == 1) { settings->RefScale = f; return; }

  00075	4c 8d 45 24	 lea	 r8, QWORD PTR f$[rbp]
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@LAOOHBLO@RefScale?$DN?$CFf?$AA@
  00080	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  00087	e8 00 00 00 00	 call	 sscanf
  0008c	83 f8 01	 cmp	 eax, 1
  0008f	75 13		 jne	 SHORT $LN2@TableSetti
  00091	48 8b 45 08	 mov	 rax, QWORD PTR settings$[rbp]
  00095	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR f$[rbp]
  0009a	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0
  0009f	e9 77 03 00 00	 jmp	 $LN1@TableSetti
$LN2@TableSetti:

; 3422 : 
; 3423 :     if (sscanf(line, "Column %d%n", &column_n, &r) == 1)

  000a4	4c 8d 4d 64	 lea	 r9, QWORD PTR r$[rbp]
  000a8	4c 8d 45 44	 lea	 r8, QWORD PTR column_n$[rbp]
  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@JOECNJOM@Column?5?$CFd?$CFn?$AA@
  000b3	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  000ba	e8 00 00 00 00	 call	 sscanf
  000bf	83 f8 01	 cmp	 eax, 1
  000c2	0f 85 53 03 00
	00		 jne	 $LN3@TableSetti

; 3424 :     {
; 3425 :         if (column_n < 0 || column_n >= settings->ColumnsCount)

  000c8	83 7d 44 00	 cmp	 DWORD PTR column_n$[rbp], 0
  000cc	7c 0d		 jl	 SHORT $LN5@TableSetti
  000ce	48 8b 45 08	 mov	 rax, QWORD PTR settings$[rbp]
  000d2	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  000d6	39 45 44	 cmp	 DWORD PTR column_n$[rbp], eax
  000d9	7c 05		 jl	 SHORT $LN4@TableSetti
$LN5@TableSetti:

; 3426 :             return;

  000db	e9 3b 03 00 00	 jmp	 $LN1@TableSetti
$LN4@TableSetti:

; 3427 :         line = ImStrSkipBlank(line + r);

  000e0	48 63 45 64	 movsxd	 rax, DWORD PTR r$[rbp]
  000e4	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  000eb	48 03 c8	 add	 rcx, rax
  000ee	48 8b c1	 mov	 rax, rcx
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	e8 00 00 00 00	 call	 ?ImStrSkipBlank@@YAPEBDPEBD@Z ; ImStrSkipBlank
  000f9	48 89 85 d8 01
	00 00		 mov	 QWORD PTR line$[rbp], rax

; 3428 :         char c = 0;

  00100	c6 85 a4 00 00
	00 00		 mov	 BYTE PTR c$8[rbp], 0

; 3429 :         ImGuiTableColumnSettings* column = settings->GetColumnSettings() + column_n;

  00107	48 8b 4d 08	 mov	 rcx, QWORD PTR settings$[rbp]
  0010b	e8 00 00 00 00	 call	 ?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ ; ImGuiTableSettings::GetColumnSettings
  00110	48 63 4d 44	 movsxd	 rcx, DWORD PTR column_n$[rbp]
  00114	48 6b c9 10	 imul	 rcx, rcx, 16
  00118	48 03 c1	 add	 rax, rcx
  0011b	48 89 85 c8 00
	00 00		 mov	 QWORD PTR column$9[rbp], rax

; 3430 :         column->Index = (ImGuiTableColumnIdx)column_n;

  00122	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$9[rbp]
  00129	0f b7 4d 44	 movzx	 ecx, WORD PTR column_n$[rbp]
  0012d	66 89 48 08	 mov	 WORD PTR [rax+8], cx

; 3431 :         if (sscanf(line, "UserID=0x%08X%n", (ImU32*)&n, &r)==1) { line = ImStrSkipBlank(line + r); column->UserID = (ImGuiID)n; }

  00131	4c 8d 4d 64	 lea	 r9, QWORD PTR r$[rbp]
  00135	4c 8d 85 84 00
	00 00		 lea	 r8, QWORD PTR n$[rbp]
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@KAIOJKEL@UserID?$DN0x?$CF08X?$CFn?$AA@
  00143	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  0014a	e8 00 00 00 00	 call	 sscanf
  0014f	83 f8 01	 cmp	 eax, 1
  00152	75 30		 jne	 SHORT $LN6@TableSetti
  00154	48 63 45 64	 movsxd	 rax, DWORD PTR r$[rbp]
  00158	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  0015f	48 03 c8	 add	 rcx, rax
  00162	48 8b c1	 mov	 rax, rcx
  00165	48 8b c8	 mov	 rcx, rax
  00168	e8 00 00 00 00	 call	 ?ImStrSkipBlank@@YAPEBDPEBD@Z ; ImStrSkipBlank
  0016d	48 89 85 d8 01
	00 00		 mov	 QWORD PTR line$[rbp], rax
  00174	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$9[rbp]
  0017b	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  00181	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN6@TableSetti:

; 3432 :         if (sscanf(line, "Width=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->WidthOrWeight = (float)n; column->IsStretch = 0; settings->SaveFlags |= ImGuiTableFlags_Resizable; }

  00184	4c 8d 4d 64	 lea	 r9, QWORD PTR r$[rbp]
  00188	4c 8d 85 84 00
	00 00		 lea	 r8, QWORD PTR n$[rbp]
  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@LJLKPCDP@Width?$DN?$CFd?$CFn?$AA@
  00196	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  0019d	e8 00 00 00 00	 call	 sscanf
  001a2	83 f8 01	 cmp	 eax, 1
  001a5	75 5b		 jne	 SHORT $LN7@TableSetti
  001a7	48 63 45 64	 movsxd	 rax, DWORD PTR r$[rbp]
  001ab	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  001b2	48 03 c8	 add	 rcx, rax
  001b5	48 8b c1	 mov	 rax, rcx
  001b8	48 8b c8	 mov	 rcx, rax
  001bb	e8 00 00 00 00	 call	 ?ImStrSkipBlank@@YAPEBDPEBD@Z ; ImStrSkipBlank
  001c0	48 89 85 d8 01
	00 00		 mov	 QWORD PTR line$[rbp], rax
  001c7	f3 0f 2a 85 84
	00 00 00	 cvtsi2ss xmm0, DWORD PTR n$[rbp]
  001cf	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$9[rbp]
  001d6	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  001da	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$9[rbp]
  001e1	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  001e5	24 f7		 and	 al, 247			; 000000f7H
  001e7	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column$9[rbp]
  001ee	88 41 0e	 mov	 BYTE PTR [rcx+14], al
  001f1	48 8b 45 08	 mov	 rax, QWORD PTR settings$[rbp]
  001f5	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001f8	83 c8 01	 or	 eax, 1
  001fb	48 8b 4d 08	 mov	 rcx, QWORD PTR settings$[rbp]
  001ff	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN7@TableSetti:

; 3433 :         if (sscanf(line, "Weight=%f%n", &f, &r) == 1)           { line = ImStrSkipBlank(line + r); column->WidthOrWeight = f; column->IsStretch = 1; settings->SaveFlags |= ImGuiTableFlags_Resizable; }

  00202	4c 8d 4d 64	 lea	 r9, QWORD PTR r$[rbp]
  00206	4c 8d 45 24	 lea	 r8, QWORD PTR f$[rbp]
  0020a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@IJODOCHC@Weight?$DN?$CFf?$CFn?$AA@
  00211	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  00218	e8 00 00 00 00	 call	 sscanf
  0021d	83 f8 01	 cmp	 eax, 1
  00220	75 58		 jne	 SHORT $LN8@TableSetti
  00222	48 63 45 64	 movsxd	 rax, DWORD PTR r$[rbp]
  00226	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  0022d	48 03 c8	 add	 rcx, rax
  00230	48 8b c1	 mov	 rax, rcx
  00233	48 8b c8	 mov	 rcx, rax
  00236	e8 00 00 00 00	 call	 ?ImStrSkipBlank@@YAPEBDPEBD@Z ; ImStrSkipBlank
  0023b	48 89 85 d8 01
	00 00		 mov	 QWORD PTR line$[rbp], rax
  00242	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$9[rbp]
  00249	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR f$[rbp]
  0024e	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00252	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$9[rbp]
  00259	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  0025d	0c 08		 or	 al, 8
  0025f	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column$9[rbp]
  00266	88 41 0e	 mov	 BYTE PTR [rcx+14], al
  00269	48 8b 45 08	 mov	 rax, QWORD PTR settings$[rbp]
  0026d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00270	83 c8 01	 or	 eax, 1
  00273	48 8b 4d 08	 mov	 rcx, QWORD PTR settings$[rbp]
  00277	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN8@TableSetti:

; 3434 :         if (sscanf(line, "Visible=%d%n", &n, &r) == 1)          { line = ImStrSkipBlank(line + r); column->IsEnabled = (ImU8)n; settings->SaveFlags |= ImGuiTableFlags_Hideable; }

  0027a	4c 8d 4d 64	 lea	 r9, QWORD PTR r$[rbp]
  0027e	4c 8d 85 84 00
	00 00		 lea	 r8, QWORD PTR n$[rbp]
  00285	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EKALHFOF@Visible?$DN?$CFd?$CFn?$AA@
  0028c	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  00293	e8 00 00 00 00	 call	 sscanf
  00298	83 f8 01	 cmp	 eax, 1
  0029b	75 5a		 jne	 SHORT $LN9@TableSetti
  0029d	48 63 45 64	 movsxd	 rax, DWORD PTR r$[rbp]
  002a1	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  002a8	48 03 c8	 add	 rcx, rax
  002ab	48 8b c1	 mov	 rax, rcx
  002ae	48 8b c8	 mov	 rcx, rax
  002b1	e8 00 00 00 00	 call	 ?ImStrSkipBlank@@YAPEBDPEBD@Z ; ImStrSkipBlank
  002b6	48 89 85 d8 01
	00 00		 mov	 QWORD PTR line$[rbp], rax
  002bd	0f b6 85 84 00
	00 00		 movzx	 eax, BYTE PTR n$[rbp]
  002c4	24 01		 and	 al, 1
  002c6	c0 e0 02	 shl	 al, 2
  002c9	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column$9[rbp]
  002d0	0f b6 49 0e	 movzx	 ecx, BYTE PTR [rcx+14]
  002d4	80 e1 fb	 and	 cl, 251			; 000000fbH
  002d7	0a c8		 or	 cl, al
  002d9	0f b6 c1	 movzx	 eax, cl
  002dc	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column$9[rbp]
  002e3	88 41 0e	 mov	 BYTE PTR [rcx+14], al
  002e6	48 8b 45 08	 mov	 rax, QWORD PTR settings$[rbp]
  002ea	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002ed	83 c8 04	 or	 eax, 4
  002f0	48 8b 4d 08	 mov	 rcx, QWORD PTR settings$[rbp]
  002f4	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN9@TableSetti:

; 3435 :         if (sscanf(line, "Order=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->DisplayOrder = (ImGuiTableColumnIdx)n; settings->SaveFlags |= ImGuiTableFlags_Reorderable; }

  002f7	4c 8d 4d 64	 lea	 r9, QWORD PTR r$[rbp]
  002fb	4c 8d 85 84 00
	00 00		 lea	 r8, QWORD PTR n$[rbp]
  00302	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@BHOFPJL@Order?$DN?$CFd?$CFn?$AA@
  00309	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  00310	e8 00 00 00 00	 call	 sscanf
  00315	83 f8 01	 cmp	 eax, 1
  00318	75 43		 jne	 SHORT $LN10@TableSetti
  0031a	48 63 45 64	 movsxd	 rax, DWORD PTR r$[rbp]
  0031e	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  00325	48 03 c8	 add	 rcx, rax
  00328	48 8b c1	 mov	 rax, rcx
  0032b	48 8b c8	 mov	 rcx, rax
  0032e	e8 00 00 00 00	 call	 ?ImStrSkipBlank@@YAPEBDPEBD@Z ; ImStrSkipBlank
  00333	48 89 85 d8 01
	00 00		 mov	 QWORD PTR line$[rbp], rax
  0033a	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$9[rbp]
  00341	0f b7 8d 84 00
	00 00		 movzx	 ecx, WORD PTR n$[rbp]
  00348	66 89 48 0a	 mov	 WORD PTR [rax+10], cx
  0034c	48 8b 45 08	 mov	 rax, QWORD PTR settings$[rbp]
  00350	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00353	83 c8 02	 or	 eax, 2
  00356	48 8b 4d 08	 mov	 rcx, QWORD PTR settings$[rbp]
  0035a	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN10@TableSetti:

; 3436 :         if (sscanf(line, "Sort=%d%c%n", &n, &c, &r) == 2)       { line = ImStrSkipBlank(line + r); column->SortOrder = (ImGuiTableColumnIdx)n; column->SortDirection = (c == '^') ? ImGuiSortDirection_Descending : ImGuiSortDirection_Ascending; settings->SaveFlags |= ImGuiTableFlags_Sortable; }

  0035d	48 8d 45 64	 lea	 rax, QWORD PTR r$[rbp]
  00361	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00366	4c 8d 8d a4 00
	00 00		 lea	 r9, QWORD PTR c$8[rbp]
  0036d	4c 8d 85 84 00
	00 00		 lea	 r8, QWORD PTR n$[rbp]
  00374	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@KGHCDDIO@Sort?$DN?$CFd?$CFc?$CFn?$AA@
  0037b	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  00382	e8 00 00 00 00	 call	 sscanf
  00387	83 f8 02	 cmp	 eax, 2
  0038a	0f 85 8b 00 00
	00		 jne	 $LN11@TableSetti
  00390	48 63 45 64	 movsxd	 rax, DWORD PTR r$[rbp]
  00394	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR line$[rbp]
  0039b	48 03 c8	 add	 rcx, rax
  0039e	48 8b c1	 mov	 rax, rcx
  003a1	48 8b c8	 mov	 rcx, rax
  003a4	e8 00 00 00 00	 call	 ?ImStrSkipBlank@@YAPEBDPEBD@Z ; ImStrSkipBlank
  003a9	48 89 85 d8 01
	00 00		 mov	 QWORD PTR line$[rbp], rax
  003b0	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$9[rbp]
  003b7	0f b7 8d 84 00
	00 00		 movzx	 ecx, WORD PTR n$[rbp]
  003be	66 89 48 0c	 mov	 WORD PTR [rax+12], cx
  003c2	0f be 85 a4 00
	00 00		 movsx	 eax, BYTE PTR c$8[rbp]
  003c9	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  003cc	75 0c		 jne	 SHORT $LN13@TableSetti
  003ce	c7 85 94 01 00
	00 02 00 00 00	 mov	 DWORD PTR tv216[rbp], 2
  003d8	eb 0a		 jmp	 SHORT $LN14@TableSetti
$LN13@TableSetti:
  003da	c7 85 94 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv216[rbp], 1
$LN14@TableSetti:
  003e4	0f b6 85 94 01
	00 00		 movzx	 eax, BYTE PTR tv216[rbp]
  003eb	24 03		 and	 al, 3
  003ed	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column$9[rbp]
  003f4	0f b6 49 0e	 movzx	 ecx, BYTE PTR [rcx+14]
  003f8	80 e1 fc	 and	 cl, 252			; 000000fcH
  003fb	0a c8		 or	 cl, al
  003fd	0f b6 c1	 movzx	 eax, cl
  00400	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column$9[rbp]
  00407	88 41 0e	 mov	 BYTE PTR [rcx+14], al
  0040a	48 8b 45 08	 mov	 rax, QWORD PTR settings$[rbp]
  0040e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00411	83 c8 08	 or	 eax, 8
  00414	48 8b 4d 08	 mov	 rcx, QWORD PTR settings$[rbp]
  00418	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN11@TableSetti:
$LN3@TableSetti:
$LN1@TableSetti:

; 3437 :     }
; 3438 : }

  0041b	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  0041f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z$rtcFrameData
  00426	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0042b	48 8b 8d 98 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00432	48 33 cd	 xor	 rcx, rbp
  00435	e8 00 00 00 00	 call	 __security_check_cookie
  0043a	48 8d a5 a8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+424]
  00441	5f		 pop	 rdi
  00442	5d		 pop	 rbp
  00443	c3		 ret	 0
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z ENDP ; TableSettingsHandler_ReadLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z
_TEXT	SEGMENT
id$ = 4
columns_count$ = 36
settings$5 = 72
__$ArrayPad$ = 280
__formal$ = 320
__formal$ = 328
name$ = 336
?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z PROC ; TableSettingsHandler_ReadOpen, COMDAT

; 3396 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8b fc	 mov	 rdi, rsp
  00020	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR [rsp+360]
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003b	48 33 c5	 xor	 rax, rbp
  0003e	48 89 85 18 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 3397 :     ImGuiID id = 0;

  00045	c7 45 04 00 00
	00 00		 mov	 DWORD PTR id$[rbp], 0

; 3398 :     int columns_count = 0;

  0004c	c7 45 24 00 00
	00 00		 mov	 DWORD PTR columns_count$[rbp], 0

; 3399 :     if (sscanf(name, "0x%08X,%d", &id, &columns_count) < 2)

  00053	4c 8d 4d 24	 lea	 r9, QWORD PTR columns_count$[rbp]
  00057	4c 8d 45 04	 lea	 r8, QWORD PTR id$[rbp]
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09BDLBIGPI@0x?$CF08X?0?$CFd?$AA@
  00062	48 8b 8d 50 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  00069	e8 00 00 00 00	 call	 sscanf
  0006e	83 f8 02	 cmp	 eax, 2
  00071	7d 04		 jge	 SHORT $LN2@TableSetti

; 3400 :         return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	eb 56		 jmp	 SHORT $LN1@TableSetti
$LN2@TableSetti:

; 3401 : 
; 3402 :     if (ImGuiTableSettings* settings = ImGui::TableSettingsFindByID(id))

  00077	8b 4d 04	 mov	 ecx, DWORD PTR id$[rbp]
  0007a	e8 00 00 00 00	 call	 ?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z ; ImGui::TableSettingsFindByID
  0007f	48 89 45 48	 mov	 QWORD PTR settings$5[rbp], rax
  00083	48 83 7d 48 00	 cmp	 QWORD PTR settings$5[rbp], 0
  00088	74 38		 je	 SHORT $LN3@TableSetti

; 3403 :     {
; 3404 :         if (settings->ColumnsCountMax >= columns_count)

  0008a	48 8b 45 48	 mov	 rax, QWORD PTR settings$5[rbp]
  0008e	0f bf 40 0e	 movsx	 eax, WORD PTR [rax+14]
  00092	3b 45 24	 cmp	 eax, DWORD PTR columns_count$[rbp]
  00095	7c 21		 jl	 SHORT $LN4@TableSetti

; 3405 :         {
; 3406 :             TableSettingsInit(settings, id, columns_count, settings->ColumnsCountMax); // Recycle

  00097	48 8b 45 48	 mov	 rax, QWORD PTR settings$5[rbp]
  0009b	0f bf 40 0e	 movsx	 eax, WORD PTR [rax+14]
  0009f	44 8b c8	 mov	 r9d, eax
  000a2	44 8b 45 24	 mov	 r8d, DWORD PTR columns_count$[rbp]
  000a6	8b 55 04	 mov	 edx, DWORD PTR id$[rbp]
  000a9	48 8b 4d 48	 mov	 rcx, QWORD PTR settings$5[rbp]
  000ad	e8 00 00 00 00	 call	 ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z ; TableSettingsInit

; 3407 :             return settings;

  000b2	48 8b 45 48	 mov	 rax, QWORD PTR settings$5[rbp]
  000b6	eb 15		 jmp	 SHORT $LN1@TableSetti
$LN4@TableSetti:

; 3408 :         }
; 3409 :         settings->ID = 0; // Invalidate storage, we won't fit because of a count change

  000b8	48 8b 45 48	 mov	 rax, QWORD PTR settings$5[rbp]
  000bc	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN3@TableSetti:

; 3410 :     }
; 3411 :     return ImGui::TableSettingsCreate(id, columns_count);

  000c2	8b 55 24	 mov	 edx, DWORD PTR columns_count$[rbp]
  000c5	8b 4d 04	 mov	 ecx, DWORD PTR id$[rbp]
  000c8	e8 00 00 00 00	 call	 ?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z ; ImGui::TableSettingsCreate
$LN1@TableSetti:

; 3412 : }

  000cd	48 8b f8	 mov	 rdi, rax
  000d0	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z$rtcFrameData
  000db	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000e0	48 8b c7	 mov	 rax, rdi
  000e3	48 8b 8d 18 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000ea	48 33 cd	 xor	 rcx, rbp
  000ed	e8 00 00 00 00	 call	 __security_check_cookie
  000f2	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000f9	5f		 pop	 rdi
  000fa	5d		 pop	 rbp
  000fb	c3		 ret	 0
?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z ENDP ; TableSettingsHandler_ReadOpen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z
_TEXT	SEGMENT
g$ = 8
i$1 = 36
table$2 = 72
ctx$ = 320
__formal$ = 328
?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z PROC ; TableSettingsHandler_ApplyAll, COMDAT

; 3385 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR [rsp+360]

; 3386 :     ImGuiContext& g = *ctx;

  0002f	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR ctx$[rbp]
  00036	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3387 :     for (int i = 0; i != g.Tables.GetMapSize(); i++)

  0003a	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$1[rbp], 0
  00041	eb 08		 jmp	 SHORT $LN4@TableSetti
$LN2@TableSetti:
  00043	8b 45 24	 mov	 eax, DWORD PTR i$1[rbp]
  00046	ff c0		 inc	 eax
  00048	89 45 24	 mov	 DWORD PTR i$1[rbp], eax
$LN4@TableSetti:
  0004b	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0004f	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 ?GetMapSize@?$ImPool@UImGuiTable@@@@QEBAHXZ ; ImPool<ImGuiTable>::GetMapSize
  0005d	39 45 24	 cmp	 DWORD PTR i$1[rbp], eax
  00060	74 38		 je	 SHORT $LN3@TableSetti

; 3388 :         if (ImGuiTable* table = g.Tables.TryGetMapData(i))

  00062	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00066	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  0006c	8b 55 24	 mov	 edx, DWORD PTR i$1[rbp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 ?TryGetMapData@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z ; ImPool<ImGuiTable>::TryGetMapData
  00077	48 89 45 48	 mov	 QWORD PTR table$2[rbp], rax
  0007b	48 83 7d 48 00	 cmp	 QWORD PTR table$2[rbp], 0
  00080	74 16		 je	 SHORT $LN5@TableSetti

; 3389 :         {
; 3390 :             table->IsSettingsRequestLoad = true;

  00082	48 8b 45 48	 mov	 rax, QWORD PTR table$2[rbp]
  00086	c6 80 28 02 00
	00 01		 mov	 BYTE PTR [rax+552], 1

; 3391 :             table->SettingsOffset = -1;

  0008d	48 8b 45 48	 mov	 rax, QWORD PTR table$2[rbp]
  00091	c7 40 64 ff ff
	ff ff		 mov	 DWORD PTR [rax+100], -1
$LN5@TableSetti:

; 3392 :         }
; 3393 : }

  00098	eb a9		 jmp	 SHORT $LN2@TableSetti
$LN3@TableSetti:
  0009a	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000a1	5f		 pop	 rdi
  000a2	5d		 pop	 rbp
  000a3	c3		 ret	 0
?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z ENDP ; TableSettingsHandler_ApplyAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z
_TEXT	SEGMENT
g$ = 8
i$1 = 36
table$2 = 72
ctx$ = 320
__formal$ = 328
?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z PROC ; TableSettingsHandler_ClearAll, COMDAT

; 3375 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR [rsp+360]

; 3376 :     ImGuiContext& g = *ctx;

  0002f	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR ctx$[rbp]
  00036	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3377 :     for (int i = 0; i != g.Tables.GetMapSize(); i++)

  0003a	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$1[rbp], 0
  00041	eb 08		 jmp	 SHORT $LN4@TableSetti
$LN2@TableSetti:
  00043	8b 45 24	 mov	 eax, DWORD PTR i$1[rbp]
  00046	ff c0		 inc	 eax
  00048	89 45 24	 mov	 DWORD PTR i$1[rbp], eax
$LN4@TableSetti:
  0004b	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0004f	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 ?GetMapSize@?$ImPool@UImGuiTable@@@@QEBAHXZ ; ImPool<ImGuiTable>::GetMapSize
  0005d	39 45 24	 cmp	 DWORD PTR i$1[rbp], eax
  00060	74 2d		 je	 SHORT $LN3@TableSetti

; 3378 :         if (ImGuiTable* table = g.Tables.TryGetMapData(i))

  00062	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00066	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  0006c	8b 55 24	 mov	 edx, DWORD PTR i$1[rbp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 ?TryGetMapData@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z ; ImPool<ImGuiTable>::TryGetMapData
  00077	48 89 45 48	 mov	 QWORD PTR table$2[rbp], rax
  0007b	48 83 7d 48 00	 cmp	 QWORD PTR table$2[rbp], 0
  00080	74 0b		 je	 SHORT $LN5@TableSetti

; 3379 :             table->SettingsOffset = -1;

  00082	48 8b 45 48	 mov	 rax, QWORD PTR table$2[rbp]
  00086	c7 40 64 ff ff
	ff ff		 mov	 DWORD PTR [rax+100], -1
$LN5@TableSetti:

; 3380 :     g.SettingsTables.clear();

  0008d	eb b4		 jmp	 SHORT $LN2@TableSetti
$LN3@TableSetti:
  0008f	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00093	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  00099	48 8b c8	 mov	 rcx, rax
  0009c	e8 00 00 00 00	 call	 ?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ ; ImChunkStream<ImGuiTableSettings>::clear

; 3381 : }

  000a1	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000a8	5f		 pop	 rdi
  000a9	5d		 pop	 rbp
  000aa	c3		 ret	 0
?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z ENDP ; TableSettingsHandler_ClearAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsCalcChunkSize@@YA_KH@Z
_TEXT	SEGMENT
columns_count$ = 224
?TableSettingsCalcChunkSize@@YA_KH@Z PROC		; TableSettingsCalcChunkSize, COMDAT

; 3207 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000d	48 8b ec	 mov	 rbp, rsp
  00010	48 8b fc	 mov	 rdi, rsp
  00013	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR [rsp+232]

; 3208 :     return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);

  00026	48 63 85 e0 00
	00 00		 movsxd	 rax, DWORD PTR columns_count$[rbp]
  0002d	48 6b c0 10	 imul	 rax, rax, 16
  00031	48 83 c0 14	 add	 rax, 20

; 3209 : }

  00035	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0003c	5f		 pop	 rdi
  0003d	5d		 pop	 rbp
  0003e	c3		 ret	 0
?TableSettingsCalcChunkSize@@YA_KH@Z ENDP		; TableSettingsCalcChunkSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z
_TEXT	SEGMENT
settings_column$ = 8
n$1 = 36
$T2 = 264
$T3 = 296
$T4 = 328
$T5 = 356
$T6 = 392
$T7 = 424
$T8 = 456
$T9 = 484
$T10 = 520
tv129 = 536
tv78 = 536
settings$ = 576
id$ = 584
columns_count$ = 592
columns_count_max$ = 600
?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z PROC ; TableSettingsInit, COMDAT

; 3195 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8b fc	 mov	 rdi, rsp
  00024	b9 92 00 00 00	 mov	 ecx, 146		; 00000092H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR [rsp+616]
  00038	48 c7 85 08 02
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T10[rbp], -2

; 3196 :     IM_PLACEMENT_NEW(settings) ImGuiTableSettings();

  00043	48 8d 85 64 01
	00 00		 lea	 rax, QWORD PTR $T5[rbp]
  0004a	48 89 85 48 01
	00 00		 mov	 QWORD PTR $T4[rbp], rax
  00051	4c 8b 85 40 02
	00 00		 mov	 r8, QWORD PTR settings$[rbp]
  00058	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR $T4[rbp]
  0005f	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00062	b9 14 00 00 00	 mov	 ecx, 20
  00067	e8 00 00 00 00	 call	 ??2@YAPEAX_KUImNewWrapper@@PEAX@Z ; operator new
  0006c	48 89 85 28 01
	00 00		 mov	 QWORD PTR $T3[rbp], rax
  00073	48 83 bd 28 01
	00 00 00	 cmp	 QWORD PTR $T3[rbp], 0
  0007b	74 15		 je	 SHORT $LN6@TableSetti
  0007d	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR $T3[rbp]
  00084	e8 00 00 00 00	 call	 ??0ImGuiTableSettings@@QEAA@XZ ; ImGuiTableSettings::ImGuiTableSettings
  00089	48 89 85 18 02
	00 00		 mov	 QWORD PTR tv78[rbp], rax
  00090	eb 0b		 jmp	 SHORT $LN7@TableSetti
$LN6@TableSetti:
  00092	48 c7 85 18 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv78[rbp], 0
$LN7@TableSetti:
  0009d	48 8b 85 18 02
	00 00		 mov	 rax, QWORD PTR tv78[rbp]
  000a4	48 89 85 08 01
	00 00		 mov	 QWORD PTR $T2[rbp], rax

; 3197 :     ImGuiTableColumnSettings* settings_column = settings->GetColumnSettings();

  000ab	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR settings$[rbp]
  000b2	e8 00 00 00 00	 call	 ?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ ; ImGuiTableSettings::GetColumnSettings
  000b7	48 89 45 08	 mov	 QWORD PTR settings_column$[rbp], rax

; 3198 :     for (int n = 0; n < columns_count_max; n++, settings_column++)

  000bb	c7 45 24 00 00
	00 00		 mov	 DWORD PTR n$1[rbp], 0
  000c2	eb 14		 jmp	 SHORT $LN4@TableSetti
$LN2@TableSetti:
  000c4	8b 45 24	 mov	 eax, DWORD PTR n$1[rbp]
  000c7	ff c0		 inc	 eax
  000c9	89 45 24	 mov	 DWORD PTR n$1[rbp], eax
  000cc	48 8b 45 08	 mov	 rax, QWORD PTR settings_column$[rbp]
  000d0	48 83 c0 10	 add	 rax, 16
  000d4	48 89 45 08	 mov	 QWORD PTR settings_column$[rbp], rax
$LN4@TableSetti:
  000d8	8b 85 58 02 00
	00		 mov	 eax, DWORD PTR columns_count_max$[rbp]
  000de	39 45 24	 cmp	 DWORD PTR n$1[rbp], eax
  000e1	7d 6a		 jge	 SHORT $LN3@TableSetti

; 3199 :         IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();

  000e3	48 8d 85 e4 01
	00 00		 lea	 rax, QWORD PTR $T9[rbp]
  000ea	48 89 85 c8 01
	00 00		 mov	 QWORD PTR $T8[rbp], rax
  000f1	4c 8b 45 08	 mov	 r8, QWORD PTR settings_column$[rbp]
  000f5	48 8b 85 c8 01
	00 00		 mov	 rax, QWORD PTR $T8[rbp]
  000fc	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000ff	b9 10 00 00 00	 mov	 ecx, 16
  00104	e8 00 00 00 00	 call	 ??2@YAPEAX_KUImNewWrapper@@PEAX@Z ; operator new
  00109	48 89 85 a8 01
	00 00		 mov	 QWORD PTR $T7[rbp], rax
  00110	48 83 bd a8 01
	00 00 00	 cmp	 QWORD PTR $T7[rbp], 0
  00118	74 15		 je	 SHORT $LN8@TableSetti
  0011a	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR $T7[rbp]
  00121	e8 00 00 00 00	 call	 ??0ImGuiTableColumnSettings@@QEAA@XZ ; ImGuiTableColumnSettings::ImGuiTableColumnSettings
  00126	48 89 85 18 02
	00 00		 mov	 QWORD PTR tv129[rbp], rax
  0012d	eb 0b		 jmp	 SHORT $LN9@TableSetti
$LN8@TableSetti:
  0012f	48 c7 85 18 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv129[rbp], 0
$LN9@TableSetti:
  0013a	48 8b 85 18 02
	00 00		 mov	 rax, QWORD PTR tv129[rbp]
  00141	48 89 85 88 01
	00 00		 mov	 QWORD PTR $T6[rbp], rax
  00148	e9 77 ff ff ff	 jmp	 $LN2@TableSetti
$LN3@TableSetti:

; 3200 :     settings->ID = id;

  0014d	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR settings$[rbp]
  00154	8b 8d 48 02 00
	00		 mov	 ecx, DWORD PTR id$[rbp]
  0015a	89 08		 mov	 DWORD PTR [rax], ecx

; 3201 :     settings->ColumnsCount = (ImGuiTableColumnIdx)columns_count;

  0015c	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR settings$[rbp]
  00163	0f b7 8d 50 02
	00 00		 movzx	 ecx, WORD PTR columns_count$[rbp]
  0016a	66 89 48 0c	 mov	 WORD PTR [rax+12], cx

; 3202 :     settings->ColumnsCountMax = (ImGuiTableColumnIdx)columns_count_max;

  0016e	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR settings$[rbp]
  00175	0f b7 8d 58 02
	00 00		 movzx	 ecx, WORD PTR columns_count_max$[rbp]
  0017c	66 89 48 0e	 mov	 WORD PTR [rax+14], cx

; 3203 :     settings->WantApply = true;

  00180	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR settings$[rbp]
  00187	c6 40 10 01	 mov	 BYTE PTR [rax+16], 1

; 3204 : }

  0018b	48 8d a5 28 02
	00 00		 lea	 rsp, QWORD PTR [rbp+552]
  00192	5f		 pop	 rdi
  00193	5d		 pop	 rbp
  00194	c3		 ret	 0
?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z ENDP ; TableSettingsInit
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
settings_column$ = 8
n$1 = 36
$T2 = 264
$T3 = 296
$T4 = 328
$T5 = 356
$T6 = 392
$T7 = 424
$T8 = 456
$T9 = 484
$T10 = 520
tv129 = 536
tv78 = 536
settings$ = 576
id$ = 584
columns_count$ = 592
columns_count_max$ = 600
?dtor$0@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA PROC ; `TableSettingsInit'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	4c 8b 85 40 02
	00 00		 mov	 r8, QWORD PTR settings$[rbp]
  0001b	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR $T4[rbp]
  00022	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00025	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR $T3[rbp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAXUImNewWrapper@@0@Z ; operator delete
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?dtor$0@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA ENDP ; `TableSettingsInit'::`1'::dtor$0
settings_column$ = 8
n$1 = 36
$T2 = 264
$T3 = 296
$T4 = 328
$T5 = 356
$T6 = 392
$T7 = 424
$T8 = 456
$T9 = 484
$T10 = 520
tv129 = 536
tv78 = 536
settings$ = 576
id$ = 584
columns_count$ = 592
columns_count_max$ = 600
?dtor$1@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA PROC ; `TableSettingsInit'::`1'::dtor$1
  00038	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0003d	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00042	55		 push	 rbp
  00043	57		 push	 rdi
  00044	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00048	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0004c	4c 8b 45 08	 mov	 r8, QWORD PTR settings_column$[rbp]
  00050	48 8b 85 c8 01
	00 00		 mov	 rax, QWORD PTR $T8[rbp]
  00057	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0005a	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR $T7[rbp]
  00061	e8 00 00 00 00	 call	 ??3@YAXPEAXUImNewWrapper@@0@Z ; operator delete
  00066	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006a	5f		 pop	 rdi
  0006b	5d		 pop	 rbp
  0006c	c3		 ret	 0
?dtor$1@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA ENDP ; `TableSettingsInit'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
settings_column$ = 8
n$1 = 36
$T2 = 264
$T3 = 296
$T4 = 328
$T5 = 356
$T6 = 392
$T7 = 424
$T8 = 456
$T9 = 484
$T10 = 520
tv129 = 536
tv78 = 536
settings$ = 576
id$ = 584
columns_count$ = 592
columns_count_max$ = 600
?dtor$0@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA PROC ; `TableSettingsInit'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	4c 8b 85 40 02
	00 00		 mov	 r8, QWORD PTR settings$[rbp]
  0001b	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR $T4[rbp]
  00022	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00025	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR $T3[rbp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAXUImNewWrapper@@0@Z ; operator delete
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?dtor$0@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA ENDP ; `TableSettingsInit'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
settings_column$ = 8
n$1 = 36
$T2 = 264
$T3 = 296
$T4 = 328
$T5 = 356
$T6 = 392
$T7 = 424
$T8 = 456
$T9 = 484
$T10 = 520
tv129 = 536
tv78 = 536
settings$ = 576
id$ = 584
columns_count$ = 592
columns_count_max$ = 600
?dtor$1@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA PROC ; `TableSettingsInit'::`1'::dtor$1
  00038	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0003d	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00042	55		 push	 rbp
  00043	57		 push	 rdi
  00044	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00048	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  0004c	4c 8b 45 08	 mov	 r8, QWORD PTR settings_column$[rbp]
  00050	48 8b 85 c8 01
	00 00		 mov	 rax, QWORD PTR $T8[rbp]
  00057	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0005a	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR $T7[rbp]
  00061	e8 00 00 00 00	 call	 ??3@YAXPEAXUImNewWrapper@@0@Z ; operator delete
  00066	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006a	5f		 pop	 rdi
  0006b	5d		 pop	 rbp
  0006c	c3		 ret	 0
?dtor$1@?0??TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z@4HA ENDP ; `TableSettingsInit'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??$ImMax@F@@YAFFF@Z
_TEXT	SEGMENT
tv67 = 192
lhs$ = 240
rhs$ = 248
??$ImMax@F@@YAFFF@Z PROC				; ImMax<short>, COMDAT

; 453  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00013	48 8b ec	 mov	 rbp, rsp
  00016	48 8b fc	 mov	 rdi, rsp
  00019	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	0f b7 8c 24 f8
	00 00 00	 movzx	 ecx, WORD PTR [rsp+248]
  0002d	0f bf 85 f0 00
	00 00		 movsx	 eax, WORD PTR lhs$[rbp]
  00034	0f bf 8d f8 00
	00 00		 movsx	 ecx, WORD PTR rhs$[rbp]
  0003b	3b c1		 cmp	 eax, ecx
  0003d	7c 10		 jl	 SHORT $LN3@ImMax
  0003f	0f b7 85 f0 00
	00 00		 movzx	 eax, WORD PTR lhs$[rbp]
  00046	66 89 85 c0 00
	00 00		 mov	 WORD PTR tv67[rbp], ax
  0004d	eb 0e		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  0004f	0f b7 85 f8 00
	00 00		 movzx	 eax, WORD PTR rhs$[rbp]
  00056	66 89 85 c0 00
	00 00		 mov	 WORD PTR tv67[rbp], ax
$LN4@ImMax:
  0005d	0f b7 85 c0 00
	00 00		 movzx	 eax, WORD PTR tv67[rbp]
  00064	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0006b	5f		 pop	 rdi
  0006c	5d		 pop	 rbp
  0006d	c3		 ret	 0
??$ImMax@F@@YAFFF@Z ENDP				; ImMax<short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z
_TEXT	SEGMENT
column$ = 224
n$ = 232
?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z PROC ; TableGetColumnAvailSortDirection, COMDAT

; 2663 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]

; 2664 :     IM_ASSERT(n < column->SortDirectionsAvailCount);

  0002e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00035	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  00039	c0 e8 02	 shr	 al, 2
  0003c	24 03		 and	 al, 3
  0003e	0f b6 c0	 movzx	 eax, al
  00041	39 85 e8 00 00
	00		 cmp	 DWORD PTR n$[rbp], eax
  00047	7c 21		 jl	 SHORT $LN3@TableGetCo
  00049	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z@4JA
  0004f	ff c0		 inc	 eax
  00051	44 8b c0	 mov	 r8d, eax
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@EKGOAIAF@?$AAn?$AA?5?$AA?$DM?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AAA?$AAv?$AAa?$AAi?$AAl?$AAC@
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00068	33 c0		 xor	 eax, eax
$LN3@TableGetCo:

; 2665 :     return (column->SortDirectionsAvailList >> (n << 1)) & 0x03;

  0006a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00071	0f b6 40 6e	 movzx	 eax, BYTE PTR [rax+110]
  00075	8b 8d e8 00 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  0007b	d1 e1		 shl	 ecx, 1
  0007d	d3 f8		 sar	 eax, cl
  0007f	83 e0 03	 and	 eax, 3

; 2666 : }

  00082	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00089	5f		 pop	 rdi
  0008a	5d		 pop	 rbp
  0008b	c3		 ret	 0
?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z ENDP ; TableGetColumnAvailSortDirection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ PROC ; `ImGui::TableMergeDrawChannels'::`2'::MergeGroup::MergeGroup, COMDAT
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  00039	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00047	5f		 pop	 rdi
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ ENDP ; `ImGui::TableMergeDrawChannels'::`2'::MergeGroup::MergeGroup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??$ImSwap@F@@YAXAEAF0@Z
_TEXT	SEGMENT
tmp$ = 4
a$ = 256
b$ = 264
??$ImSwap@F@@YAXAEAF0@Z PROC				; ImSwap<short>, COMDAT

; 456  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8b ec	 mov	 rbp, rsp
  00016	48 8b fc	 mov	 rdi, rsp
  00019	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002d	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00034	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00037	66 89 45 04	 mov	 WORD PTR tmp$[rbp], ax
  0003b	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00042	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR b$[rbp]
  00049	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0004c	66 89 08	 mov	 WORD PTR [rax], cx
  0004f	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR b$[rbp]
  00056	0f b7 4d 04	 movzx	 ecx, WORD PTR tmp$[rbp]
  0005a	66 89 08	 mov	 WORD PTR [rax], cx
  0005d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00064	5f		 pop	 rdi
  00065	5d		 pop	 rbp
  00066	c3		 ret	 0
??$ImSwap@F@@YAXAEAF0@Z ENDP				; ImSwap<short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@M@@YAMMMM@Z
_TEXT	SEGMENT
tv67 = 192
tv66 = 196
v$ = 240
mn$ = 248
mx$ = 256
??$ImClamp@M@@YAMMMM@Z PROC				; ImClamp<float>, COMDAT

; 454  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  0000c	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00012	55		 push	 rbp
  00013	57		 push	 rdi
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001b	48 8d 6c 24 10	 lea	 rbp, QWORD PTR [rsp+16]
  00020	48 8b fc	 mov	 rdi, rsp
  00023	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	f3 0f 10 85 f8
	00 00 00	 movss	 xmm0, DWORD PTR mn$[rbp]
  00037	0f 2f 85 f0 00
	00 00		 comiss	 xmm0, DWORD PTR v$[rbp]
  0003e	76 12		 jbe	 SHORT $LN5@ImClamp
  00040	f3 0f 10 85 f8
	00 00 00	 movss	 xmm0, DWORD PTR mn$[rbp]
  00048	f3 0f 11 85 c0
	00 00 00	 movss	 DWORD PTR tv67[rbp], xmm0
  00050	eb 43		 jmp	 SHORT $LN6@ImClamp
$LN5@ImClamp:
  00052	f3 0f 10 85 f0
	00 00 00	 movss	 xmm0, DWORD PTR v$[rbp]
  0005a	0f 2f 85 00 01
	00 00		 comiss	 xmm0, DWORD PTR mx$[rbp]
  00061	76 12		 jbe	 SHORT $LN3@ImClamp
  00063	f3 0f 10 85 00
	01 00 00	 movss	 xmm0, DWORD PTR mx$[rbp]
  0006b	f3 0f 11 85 c4
	00 00 00	 movss	 DWORD PTR tv66[rbp], xmm0
  00073	eb 10		 jmp	 SHORT $LN4@ImClamp
$LN3@ImClamp:
  00075	f3 0f 10 85 f0
	00 00 00	 movss	 xmm0, DWORD PTR v$[rbp]
  0007d	f3 0f 11 85 c4
	00 00 00	 movss	 DWORD PTR tv66[rbp], xmm0
$LN4@ImClamp:
  00085	f3 0f 10 85 c4
	00 00 00	 movss	 xmm0, DWORD PTR tv66[rbp]
  0008d	f3 0f 11 85 c0
	00 00 00	 movss	 DWORD PTR tv67[rbp], xmm0
$LN6@ImClamp:
  00095	f3 0f 10 85 c0
	00 00 00	 movss	 xmm0, DWORD PTR tv67[rbp]
  0009d	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000a4	5f		 pop	 rdi
  000a5	5d		 pop	 rbp
  000a6	c3		 ret	 0
??$ImClamp@M@@YAMMMM@Z ENDP				; ImClamp<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z
_TEXT	SEGMENT
flags$ = 4
table_sizing_policy$1 = 36
count$2 = 68
mask$3 = 100
list$4 = 132
tv278 = 340
tv269 = 340
tv260 = 340
tv251 = 340
tv130 = 340
table$ = 384
column$ = 392
flags_in$ = 400
?TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z PROC ; TableSetupColumnFlags, COMDAT

; 672  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8b fc	 mov	 rdi, rsp
  00020	b9 62 00 00 00	 mov	 ecx, 98			; 00000062H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+424]

; 673  :     ImGuiTableColumnFlags flags = flags_in;

  00034	8b 85 90 01 00
	00		 mov	 eax, DWORD PTR flags_in$[rbp]
  0003a	89 45 04	 mov	 DWORD PTR flags$[rbp], eax

; 674  : 
; 675  :     // Sizing Policy
; 676  :     if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0)

  0003d	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  00040	83 e0 18	 and	 eax, 24
  00043	85 c0		 test	 eax, eax
  00045	75 3a		 jne	 SHORT $LN2@TableSetup

; 677  :     {
; 678  :         const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);

  00047	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0004e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00051	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  00056	89 45 24	 mov	 DWORD PTR table_sizing_policy$1[rbp], eax

; 679  :         if (table_sizing_policy == ImGuiTableFlags_SizingFixedFit || table_sizing_policy == ImGuiTableFlags_SizingFixedSame)

  00059	81 7d 24 00 20
	00 00		 cmp	 DWORD PTR table_sizing_policy$1[rbp], 8192 ; 00002000H
  00060	74 09		 je	 SHORT $LN6@TableSetup
  00062	81 7d 24 00 40
	00 00		 cmp	 DWORD PTR table_sizing_policy$1[rbp], 16384 ; 00004000H
  00069	75 0b		 jne	 SHORT $LN4@TableSetup
$LN6@TableSetup:

; 680  :             flags |= ImGuiTableColumnFlags_WidthFixed;

  0006b	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  0006e	83 c8 10	 or	 eax, 16
  00071	89 45 04	 mov	 DWORD PTR flags$[rbp], eax

; 681  :         else

  00074	eb 09		 jmp	 SHORT $LN5@TableSetup
$LN4@TableSetup:

; 682  :             flags |= ImGuiTableColumnFlags_WidthStretch;

  00076	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  00079	83 c8 08	 or	 eax, 8
  0007c	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
$LN5@TableSetup:

; 683  :     }
; 684  :     else

  0007f	eb 36		 jmp	 SHORT $LN3@TableSetup
$LN2@TableSetup:

; 685  :     {
; 686  :         IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_WidthMask_)); // Check that only 1 of each set is used.

  00081	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  00084	83 e0 18	 and	 eax, 24
  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  0008e	0f b6 c0	 movzx	 eax, al
  00091	85 c0		 test	 eax, eax
  00093	75 22		 jne	 SHORT $LN18@TableSetup
  00095	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z@4JA
  0009b	83 c0 0e	 add	 eax, 14
  0009e	44 8b c0	 mov	 r8d, eax
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HC@EONHDNHI@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl@
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b5	33 c0		 xor	 eax, eax
$LN18@TableSetup:
$LN3@TableSetup:

; 687  :     }
; 688  : 
; 689  :     // Resize
; 690  :     if ((table->Flags & ImGuiTableFlags_Resizable) == 0)

  000b7	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000be	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000c1	83 e0 01	 and	 eax, 1
  000c4	85 c0		 test	 eax, eax
  000c6	75 09		 jne	 SHORT $LN7@TableSetup

; 691  :         flags |= ImGuiTableColumnFlags_NoResize;

  000c8	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  000cb	83 c8 20	 or	 eax, 32			; 00000020H
  000ce	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
$LN7@TableSetup:

; 692  : 
; 693  :     // Sorting
; 694  :     if ((flags & ImGuiTableColumnFlags_NoSortAscending) && (flags & ImGuiTableColumnFlags_NoSortDescending))

  000d1	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  000d4	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  000d9	85 c0		 test	 eax, eax
  000db	74 16		 je	 SHORT $LN8@TableSetup
  000dd	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  000e0	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  000e5	85 c0		 test	 eax, eax
  000e7	74 0a		 je	 SHORT $LN8@TableSetup

; 695  :         flags |= ImGuiTableColumnFlags_NoSort;

  000e9	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  000ec	0f ba e8 09	 bts	 eax, 9
  000f0	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
$LN8@TableSetup:

; 696  : 
; 697  :     // Indentation
; 698  :     if ((flags & ImGuiTableColumnFlags_IndentMask_) == 0)

  000f3	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  000f6	25 00 00 03 00	 and	 eax, 196608		; 00030000H
  000fb	85 c0		 test	 eax, eax
  000fd	75 44		 jne	 SHORT $LN9@TableSetup

; 699  :         flags |= (table->Columns.index_from_ptr(column) == 0) ? ImGuiTableColumnFlags_IndentEnable : ImGuiTableColumnFlags_IndentDisable;

  000ff	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00106	48 83 c0 18	 add	 rax, 24
  0010a	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR column$[rbp]
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 ?index_from_ptr@?$ImSpan@UImGuiTableColumn@@@@QEBAHPEBUImGuiTableColumn@@@Z ; ImSpan<ImGuiTableColumn>::index_from_ptr
  00119	85 c0		 test	 eax, eax
  0011b	75 0c		 jne	 SHORT $LN19@TableSetup
  0011d	c7 85 54 01 00
	00 00 00 01 00	 mov	 DWORD PTR tv130[rbp], 65536 ; 00010000H
  00127	eb 0a		 jmp	 SHORT $LN20@TableSetup
$LN19@TableSetup:
  00129	c7 85 54 01 00
	00 00 00 02 00	 mov	 DWORD PTR tv130[rbp], 131072 ; 00020000H
$LN20@TableSetup:
  00133	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv130[rbp]
  00139	8b 4d 04	 mov	 ecx, DWORD PTR flags$[rbp]
  0013c	0b c8		 or	 ecx, eax
  0013e	8b c1		 mov	 eax, ecx
  00140	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
$LN9@TableSetup:

; 700  : 
; 701  :     // Alignment
; 702  :     //if ((flags & ImGuiTableColumnFlags_AlignMask_) == 0)
; 703  :     //    flags |= ImGuiTableColumnFlags_AlignCenter;
; 704  :     //IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_AlignMask_)); // Check that only 1 of each set is used.
; 705  : 
; 706  :     // Preserve status flags
; 707  :     column->Flags = flags | (column->Flags & ImGuiTableColumnFlags_StatusMask_);

  00143	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0014a	8b 00		 mov	 eax, DWORD PTR [rax]
  0014c	25 00 00 00 0f	 and	 eax, 251658240		; 0f000000H
  00151	8b 4d 04	 mov	 ecx, DWORD PTR flags$[rbp]
  00154	0b c8		 or	 ecx, eax
  00156	8b c1		 mov	 eax, ecx
  00158	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  0015f	89 01		 mov	 DWORD PTR [rcx], eax

; 708  : 
; 709  :     // Build an ordered list of available sort directions
; 710  :     column->SortDirectionsAvailCount = column->SortDirectionsAvailMask = column->SortDirectionsAvailList = 0;

  00161	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00168	c6 40 6e 00	 mov	 BYTE PTR [rax+110], 0
  0016c	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00173	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  00177	24 0f		 and	 al, 15
  00179	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  00180	88 41 6d	 mov	 BYTE PTR [rcx+109], al
  00183	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0018a	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  0018e	24 f3		 and	 al, 243			; 000000f3H
  00190	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  00197	88 41 6d	 mov	 BYTE PTR [rcx+109], al

; 711  :     if (table->Flags & ImGuiTableFlags_Sortable)

  0019a	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001a1	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001a4	83 e0 08	 and	 eax, 8
  001a7	85 c0		 test	 eax, eax
  001a9	0f 84 02 02 00
	00		 je	 $LN10@TableSetup

; 712  :     {
; 713  :         int count = 0, mask = 0, list = 0;

  001af	c7 45 44 00 00
	00 00		 mov	 DWORD PTR count$2[rbp], 0
  001b6	c7 45 64 00 00
	00 00		 mov	 DWORD PTR mask$3[rbp], 0
  001bd	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR list$4[rbp], 0

; 714  :         if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  != 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }

  001c7	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  001ca	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  001cf	85 c0		 test	 eax, eax
  001d1	74 48		 je	 SHORT $LN11@TableSetup
  001d3	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  001d6	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  001db	85 c0		 test	 eax, eax
  001dd	75 3c		 jne	 SHORT $LN11@TableSetup
  001df	8b 45 64	 mov	 eax, DWORD PTR mask$3[rbp]
  001e2	83 c8 02	 or	 eax, 2
  001e5	89 45 64	 mov	 DWORD PTR mask$3[rbp], eax
  001e8	8b 45 44	 mov	 eax, DWORD PTR count$2[rbp]
  001eb	d1 e0		 shl	 eax, 1
  001ed	b9 01 00 00 00	 mov	 ecx, 1
  001f2	89 8d 54 01 00
	00		 mov	 DWORD PTR tv251[rbp], ecx
  001f8	0f b6 c8	 movzx	 ecx, al
  001fb	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv251[rbp]
  00201	d3 e0		 shl	 eax, cl
  00203	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR list$4[rbp]
  00209	0b c8		 or	 ecx, eax
  0020b	8b c1		 mov	 eax, ecx
  0020d	89 85 84 00 00
	00		 mov	 DWORD PTR list$4[rbp], eax
  00213	8b 45 44	 mov	 eax, DWORD PTR count$2[rbp]
  00216	ff c0		 inc	 eax
  00218	89 45 44	 mov	 DWORD PTR count$2[rbp], eax
$LN11@TableSetup:

; 715  :         if ((flags & ImGuiTableColumnFlags_PreferSortDescending) != 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }

  0021b	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  0021e	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00223	85 c0		 test	 eax, eax
  00225	74 48		 je	 SHORT $LN12@TableSetup
  00227	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  0022a	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0022f	85 c0		 test	 eax, eax
  00231	75 3c		 jne	 SHORT $LN12@TableSetup
  00233	8b 45 64	 mov	 eax, DWORD PTR mask$3[rbp]
  00236	83 c8 04	 or	 eax, 4
  00239	89 45 64	 mov	 DWORD PTR mask$3[rbp], eax
  0023c	8b 45 44	 mov	 eax, DWORD PTR count$2[rbp]
  0023f	d1 e0		 shl	 eax, 1
  00241	b9 02 00 00 00	 mov	 ecx, 2
  00246	89 8d 54 01 00
	00		 mov	 DWORD PTR tv260[rbp], ecx
  0024c	0f b6 c8	 movzx	 ecx, al
  0024f	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv260[rbp]
  00255	d3 e0		 shl	 eax, cl
  00257	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR list$4[rbp]
  0025d	0b c8		 or	 ecx, eax
  0025f	8b c1		 mov	 eax, ecx
  00261	89 85 84 00 00
	00		 mov	 DWORD PTR list$4[rbp], eax
  00267	8b 45 44	 mov	 eax, DWORD PTR count$2[rbp]
  0026a	ff c0		 inc	 eax
  0026c	89 45 44	 mov	 DWORD PTR count$2[rbp], eax
$LN12@TableSetup:

; 716  :         if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  == 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }

  0026f	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  00272	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00277	85 c0		 test	 eax, eax
  00279	75 48		 jne	 SHORT $LN13@TableSetup
  0027b	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  0027e	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00283	85 c0		 test	 eax, eax
  00285	75 3c		 jne	 SHORT $LN13@TableSetup
  00287	8b 45 64	 mov	 eax, DWORD PTR mask$3[rbp]
  0028a	83 c8 02	 or	 eax, 2
  0028d	89 45 64	 mov	 DWORD PTR mask$3[rbp], eax
  00290	8b 45 44	 mov	 eax, DWORD PTR count$2[rbp]
  00293	d1 e0		 shl	 eax, 1
  00295	b9 01 00 00 00	 mov	 ecx, 1
  0029a	89 8d 54 01 00
	00		 mov	 DWORD PTR tv269[rbp], ecx
  002a0	0f b6 c8	 movzx	 ecx, al
  002a3	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv269[rbp]
  002a9	d3 e0		 shl	 eax, cl
  002ab	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR list$4[rbp]
  002b1	0b c8		 or	 ecx, eax
  002b3	8b c1		 mov	 eax, ecx
  002b5	89 85 84 00 00
	00		 mov	 DWORD PTR list$4[rbp], eax
  002bb	8b 45 44	 mov	 eax, DWORD PTR count$2[rbp]
  002be	ff c0		 inc	 eax
  002c0	89 45 44	 mov	 DWORD PTR count$2[rbp], eax
$LN13@TableSetup:

; 717  :         if ((flags & ImGuiTableColumnFlags_PreferSortDescending) == 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }

  002c3	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  002c6	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  002cb	85 c0		 test	 eax, eax
  002cd	75 48		 jne	 SHORT $LN14@TableSetup
  002cf	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  002d2	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  002d7	85 c0		 test	 eax, eax
  002d9	75 3c		 jne	 SHORT $LN14@TableSetup
  002db	8b 45 64	 mov	 eax, DWORD PTR mask$3[rbp]
  002de	83 c8 04	 or	 eax, 4
  002e1	89 45 64	 mov	 DWORD PTR mask$3[rbp], eax
  002e4	8b 45 44	 mov	 eax, DWORD PTR count$2[rbp]
  002e7	d1 e0		 shl	 eax, 1
  002e9	b9 02 00 00 00	 mov	 ecx, 2
  002ee	89 8d 54 01 00
	00		 mov	 DWORD PTR tv278[rbp], ecx
  002f4	0f b6 c8	 movzx	 ecx, al
  002f7	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR tv278[rbp]
  002fd	d3 e0		 shl	 eax, cl
  002ff	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR list$4[rbp]
  00305	0b c8		 or	 ecx, eax
  00307	8b c1		 mov	 eax, ecx
  00309	89 85 84 00 00
	00		 mov	 DWORD PTR list$4[rbp], eax
  0030f	8b 45 44	 mov	 eax, DWORD PTR count$2[rbp]
  00312	ff c0		 inc	 eax
  00314	89 45 44	 mov	 DWORD PTR count$2[rbp], eax
$LN14@TableSetup:

; 718  :         if ((table->Flags & ImGuiTableFlags_SortTristate) || count == 0) { mask |= 1 << ImGuiSortDirection_None; count++; }

  00317	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0031e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00321	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00326	85 c0		 test	 eax, eax
  00328	75 06		 jne	 SHORT $LN16@TableSetup
  0032a	83 7d 44 00	 cmp	 DWORD PTR count$2[rbp], 0
  0032e	75 11		 jne	 SHORT $LN15@TableSetup
$LN16@TableSetup:
  00330	8b 45 64	 mov	 eax, DWORD PTR mask$3[rbp]
  00333	83 c8 01	 or	 eax, 1
  00336	89 45 64	 mov	 DWORD PTR mask$3[rbp], eax
  00339	8b 45 44	 mov	 eax, DWORD PTR count$2[rbp]
  0033c	ff c0		 inc	 eax
  0033e	89 45 44	 mov	 DWORD PTR count$2[rbp], eax
$LN15@TableSetup:

; 719  :         column->SortDirectionsAvailList = (ImU8)list;

  00341	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00348	0f b6 8d 84 00
	00 00		 movzx	 ecx, BYTE PTR list$4[rbp]
  0034f	88 48 6e	 mov	 BYTE PTR [rax+110], cl

; 720  :         column->SortDirectionsAvailMask = (ImU8)mask;

  00352	0f b6 45 64	 movzx	 eax, BYTE PTR mask$3[rbp]
  00356	24 0f		 and	 al, 15
  00358	c0 e0 04	 shl	 al, 4
  0035b	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  00362	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  00366	80 e1 0f	 and	 cl, 15
  00369	0a c8		 or	 cl, al
  0036b	0f b6 c1	 movzx	 eax, cl
  0036e	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  00375	88 41 6d	 mov	 BYTE PTR [rcx+109], al

; 721  :         column->SortDirectionsAvailCount = (ImU8)count;

  00378	0f b6 45 44	 movzx	 eax, BYTE PTR count$2[rbp]
  0037c	24 03		 and	 al, 3
  0037e	c0 e0 02	 shl	 al, 2
  00381	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  00388	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  0038c	80 e1 f3	 and	 cl, 243			; 000000f3H
  0038f	0a c8		 or	 cl, al
  00391	0f b6 c1	 movzx	 eax, cl
  00394	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  0039b	88 41 6d	 mov	 BYTE PTR [rcx+109], al

; 722  :         ImGui::TableFixColumnSortDirection(table, column);

  0039e	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR column$[rbp]
  003a5	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  003ac	e8 00 00 00 00	 call	 ?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z ; ImGui::TableFixColumnSortDirection
$LN10@TableSetup:

; 723  :     }
; 724  : }

  003b1	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  003b8	5f		 pop	 rdi
  003b9	5d		 pop	 rbp
  003ba	c3		 ret	 0
?TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z ENDP ; TableSetupColumnFlags
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??$GetSpan@UImGuiTableCellData@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableCellData@@@@@Z
_TEXT	SEGMENT
tv66 = 192
this$ = 240
n$ = 248
span$ = 256
??$GetSpan@UImGuiTableCellData@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableCellData@@@@@Z PROC ; ImSpanAllocator<6>::GetSpan<ImGuiTableCellData>, COMDAT

; 652  :     inline void  GetSpan(int n, ImSpan<T>* span)    { span->set((T*)GetSpanPtrBegin(n), (T*)GetSpanPtrEnd(n)); }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR [rsp+280]
  00033	8b 95 f8 00 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  00039	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00040	e8 00 00 00 00	 call	 ?GetSpanPtrEnd@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrEnd
  00045	48 89 85 c0 00
	00 00		 mov	 QWORD PTR tv66[rbp], rax
  0004c	8b 95 f8 00 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  00052	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	e8 00 00 00 00	 call	 ?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrBegin
  0005e	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR tv66[rbp]
  00065	4c 8b c1	 mov	 r8, rcx
  00068	48 8b d0	 mov	 rdx, rax
  0006b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR span$[rbp]
  00072	e8 00 00 00 00	 call	 ?set@?$ImSpan@UImGuiTableCellData@@@@QEAAXPEAUImGuiTableCellData@@0@Z ; ImSpan<ImGuiTableCellData>::set
  00077	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0007e	5f		 pop	 rdi
  0007f	5d		 pop	 rbp
  00080	c3		 ret	 0
??$GetSpan@UImGuiTableCellData@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableCellData@@@@@Z ENDP ; ImSpanAllocator<6>::GetSpan<ImGuiTableCellData>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??$GetSpan@F@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@F@@@Z
_TEXT	SEGMENT
tv66 = 192
this$ = 240
n$ = 248
span$ = 256
??$GetSpan@F@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@F@@@Z PROC ; ImSpanAllocator<6>::GetSpan<short>, COMDAT

; 652  :     inline void  GetSpan(int n, ImSpan<T>* span)    { span->set((T*)GetSpanPtrBegin(n), (T*)GetSpanPtrEnd(n)); }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR [rsp+280]
  00033	8b 95 f8 00 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  00039	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00040	e8 00 00 00 00	 call	 ?GetSpanPtrEnd@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrEnd
  00045	48 89 85 c0 00
	00 00		 mov	 QWORD PTR tv66[rbp], rax
  0004c	8b 95 f8 00 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  00052	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	e8 00 00 00 00	 call	 ?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrBegin
  0005e	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR tv66[rbp]
  00065	4c 8b c1	 mov	 r8, rcx
  00068	48 8b d0	 mov	 rdx, rax
  0006b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR span$[rbp]
  00072	e8 00 00 00 00	 call	 ?set@?$ImSpan@F@@QEAAXPEAF0@Z ; ImSpan<short>::set
  00077	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0007e	5f		 pop	 rdi
  0007f	5d		 pop	 rbp
  00080	c3		 ret	 0
??$GetSpan@F@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@F@@@Z ENDP ; ImSpanAllocator<6>::GetSpan<short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??$GetSpan@UImGuiTableColumn@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableColumn@@@@@Z
_TEXT	SEGMENT
tv66 = 192
this$ = 240
n$ = 248
span$ = 256
??$GetSpan@UImGuiTableColumn@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableColumn@@@@@Z PROC ; ImSpanAllocator<6>::GetSpan<ImGuiTableColumn>, COMDAT

; 652  :     inline void  GetSpan(int n, ImSpan<T>* span)    { span->set((T*)GetSpanPtrBegin(n), (T*)GetSpanPtrEnd(n)); }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR [rsp+280]
  00033	8b 95 f8 00 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  00039	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00040	e8 00 00 00 00	 call	 ?GetSpanPtrEnd@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrEnd
  00045	48 89 85 c0 00
	00 00		 mov	 QWORD PTR tv66[rbp], rax
  0004c	8b 95 f8 00 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  00052	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	e8 00 00 00 00	 call	 ?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrBegin
  0005e	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR tv66[rbp]
  00065	4c 8b c1	 mov	 r8, rcx
  00068	48 8b d0	 mov	 rdx, rax
  0006b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR span$[rbp]
  00072	e8 00 00 00 00	 call	 ?set@?$ImSpan@UImGuiTableColumn@@@@QEAAXPEAUImGuiTableColumn@@0@Z ; ImSpan<ImGuiTableColumn>::set
  00077	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0007e	5f		 pop	 rdi
  0007f	5d		 pop	 rbp
  00080	c3		 ret	 0
??$GetSpan@UImGuiTableColumn@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableColumn@@@@@Z ENDP ; ImSpanAllocator<6>::GetSpan<ImGuiTableColumn>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetSpanPtrEnd@?$ImSpanAllocator@$05@@QEAAPEAXH@Z
_TEXT	SEGMENT
this$ = 224
n$ = 232
?GetSpanPtrEnd@?$ImSpanAllocator@$05@@QEAAPEAXH@Z PROC	; ImSpanAllocator<6>::GetSpanPtrEnd, COMDAT

; 650  :     inline void* GetSpanPtrEnd(int n)               { IM_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS); return (void*)(BasePtr + Offsets[n] + Sizes[n]); }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR n$[rbp], 0
  00035	7c 16		 jl	 SHORT $LN3@GetSpanPtr
  00037	83 bd e8 00 00
	00 06		 cmp	 DWORD PTR n$[rbp], 6
  0003e	7d 0d		 jge	 SHORT $LN3@GetSpanPtr
  00040	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00047	83 78 0c 06	 cmp	 DWORD PTR [rax+12], 6
  0004b	74 1c		 je	 SHORT $LN4@GetSpanPtr
$LN3@GetSpanPtr:
  0004d	41 b8 8a 02 00
	00		 mov	 r8d, 650		; 0000028aH
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@GEHGFLGL@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AAC?$AAH?$AAU?$AAN?$AAK?$AAS?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAC?$AAu?$AAr?$AAr?$AAI?$AAd?$AAx?$AA?5@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00067	33 c0		 xor	 eax, eax
$LN4@GetSpanPtr:
  00069	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  00070	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00077	48 63 44 81 10	 movsxd	 rax, DWORD PTR [rcx+rax*4+16]
  0007c	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00083	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00086	48 03 c8	 add	 rcx, rax
  00089	48 8b c1	 mov	 rax, rcx
  0008c	48 63 8d e8 00
	00 00		 movsxd	 rcx, DWORD PTR n$[rbp]
  00093	48 8b 95 e0 00
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0009a	48 63 4c 8a 28	 movsxd	 rcx, DWORD PTR [rdx+rcx*4+40]
  0009f	48 03 c1	 add	 rax, rcx
  000a2	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000a9	5f		 pop	 rdi
  000aa	5d		 pop	 rbp
  000ab	c3		 ret	 0
?GetSpanPtrEnd@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ENDP	; ImSpanAllocator<6>::GetSpanPtrEnd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z
_TEXT	SEGMENT
this$ = 224
n$ = 232
?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z PROC ; ImSpanAllocator<6>::GetSpanPtrBegin, COMDAT

; 649  :     inline void* GetSpanPtrBegin(int n)             { IM_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS); return (void*)(BasePtr + Offsets[n]); }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR n$[rbp], 0
  00035	7c 16		 jl	 SHORT $LN3@GetSpanPtr
  00037	83 bd e8 00 00
	00 06		 cmp	 DWORD PTR n$[rbp], 6
  0003e	7d 0d		 jge	 SHORT $LN3@GetSpanPtr
  00040	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00047	83 78 0c 06	 cmp	 DWORD PTR [rax+12], 6
  0004b	74 1c		 je	 SHORT $LN4@GetSpanPtr
$LN3@GetSpanPtr:
  0004d	41 b8 89 02 00
	00		 mov	 r8d, 649		; 00000289H
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@GEHGFLGL@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AAC?$AAH?$AAU?$AAN?$AAK?$AAS?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAC?$AAu?$AAr?$AAr?$AAI?$AAd?$AAx?$AA?5@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00067	33 c0		 xor	 eax, eax
$LN4@GetSpanPtr:
  00069	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  00070	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00077	48 63 44 81 10	 movsxd	 rax, DWORD PTR [rcx+rax*4+16]
  0007c	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00083	48 03 01	 add	 rax, QWORD PTR [rcx]
  00086	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0008d	5f		 pop	 rdi
  0008e	5d		 pop	 rbp
  0008f	c3		 ret	 0
?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ENDP ; ImSpanAllocator<6>::GetSpanPtrBegin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?SetArenaBasePtr@?$ImSpanAllocator@$05@@QEAAXPEAX@Z
_TEXT	SEGMENT
this$ = 224
base_ptr$ = 232
?SetArenaBasePtr@?$ImSpanAllocator@$05@@QEAAXPEAX@Z PROC ; ImSpanAllocator<6>::SetArenaBasePtr, COMDAT

; 648  :     inline void  SetArenaBasePtr(void* base_ptr)    { BasePtr = (char*)base_ptr; }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b ec	 mov	 rbp, rsp
  00016	48 8b fc	 mov	 rdi, rsp
  00019	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  0002d	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00034	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR base_ptr$[rbp]
  0003b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0003e	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00045	5f		 pop	 rdi
  00046	5d		 pop	 rbp
  00047	c3		 ret	 0
?SetArenaBasePtr@?$ImSpanAllocator@$05@@QEAAXPEAX@Z ENDP ; ImSpanAllocator<6>::SetArenaBasePtr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetArenaSizeInBytes@?$ImSpanAllocator@$05@@QEAAHXZ
_TEXT	SEGMENT
this$ = 224
?GetArenaSizeInBytes@?$ImSpanAllocator@$05@@QEAAHXZ PROC ; ImSpanAllocator<6>::GetArenaSizeInBytes, COMDAT

; 647  :     inline int   GetArenaSizeInBytes()              { return CurrOff; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00032	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00039	5f		 pop	 rdi
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
?GetArenaSizeInBytes@?$ImSpanAllocator@$05@@QEAAHXZ ENDP ; ImSpanAllocator<6>::GetArenaSizeInBytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z
_TEXT	SEGMENT
this$ = 224
n$ = 232
sz$ = 240
a$ = 248
?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z PROC	; ImSpanAllocator<6>::Reserve, COMDAT

; 646  :     inline void  Reserve(int n, size_t sz, int a=4) { IM_ASSERT(n == CurrIdx && n < CHUNKS); CurrOff = IM_MEMALIGN(CurrOff, a); Offsets[n] = CurrOff; Sizes[n] = (int)sz; CurrIdx++; CurrOff += (int)sz; }

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8b fc	 mov	 rdi, rsp
  00024	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  00038	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003f	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00042	39 85 e8 00 00
	00		 cmp	 DWORD PTR n$[rbp], eax
  00048	75 09		 jne	 SHORT $LN3@Reserve
  0004a	83 bd e8 00 00
	00 06		 cmp	 DWORD PTR n$[rbp], 6
  00051	7c 1c		 jl	 SHORT $LN4@Reserve
$LN3@Reserve:
  00053	41 b8 86 02 00
	00		 mov	 r8d, 646		; 00000286H
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@BODLFGJA@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAC?$AAu?$AAr?$AAr?$AAI?$AAd?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AAC?$AAH?$AAU?$AAN?$AAK?$AAS?$AA?$AA@
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006d	33 c0		 xor	 eax, eax
$LN4@Reserve:
  0006f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00076	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00079	8b 8d f8 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  0007f	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00083	8b 8d f8 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00089	ff c9		 dec	 ecx
  0008b	f7 d1		 not	 ecx
  0008d	23 c1		 and	 eax, ecx
  0008f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00096	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00099	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  000a0	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a7	48 8b 95 e0 00
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  000ae	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  000b1	89 54 81 10	 mov	 DWORD PTR [rcx+rax*4+16], edx
  000b5	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR n$[rbp]
  000bc	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c3	8b 95 f0 00 00
	00		 mov	 edx, DWORD PTR sz$[rbp]
  000c9	89 54 81 28	 mov	 DWORD PTR [rcx+rax*4+40], edx
  000cd	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000d4	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000d7	ff c0		 inc	 eax
  000d9	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000e0	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
  000e3	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000ea	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ed	03 85 f0 00 00
	00		 add	 eax, DWORD PTR sz$[rbp]
  000f3	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fa	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  000fd	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00104	5f		 pop	 rdi
  00105	5d		 pop	 rbp
  00106	c3		 ret	 0
?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z ENDP	; ImSpanAllocator<6>::Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0?$ImSpanAllocator@$05@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$ImSpanAllocator@$05@@QEAA@XZ PROC			; ImSpanAllocator<6>::ImSpanAllocator<6>, COMDAT

; 645  :     ImSpanAllocator()                               { memset(this, 0, sizeof(*this)); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00030	33 d2		 xor	 edx, edx
  00032	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00039	e8 00 00 00 00	 call	 memset
  0003e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004c	5f		 pop	 rdi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??0?$ImSpanAllocator@$05@@QEAA@XZ ENDP			; ImSpanAllocator<6>::ImSpanAllocator<6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableFixFlags@@YAHHPEAUImGuiWindow@@@Z
_TEXT	SEGMENT
tv71 = 192
flags$ = 240
outer_window$ = 248
?TableFixFlags@@YAHHPEAUImGuiWindow@@@Z PROC		; TableFixFlags, COMDAT

; 265  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 8b fc	 mov	 rdi, rsp
  00018	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR [rsp+248]

; 266  :     // Adjust flags: set default sizing policy
; 267  :     if ((flags & ImGuiTableFlags_SizingMask_) == 0)

  0002b	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00031	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  00036	85 c0		 test	 eax, eax
  00038	75 4c		 jne	 SHORT $LN2@TableFixFl

; 268  :         flags |= ((flags & ImGuiTableFlags_ScrollX) || (outer_window->Flags & ImGuiWindowFlags_AlwaysAutoResize)) ? ImGuiTableFlags_SizingFixedFit : ImGuiTableFlags_SizingStretchSame;

  0003a	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00040	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00045	85 c0		 test	 eax, eax
  00047	75 1d		 jne	 SHORT $LN10@TableFixFl
  00049	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00050	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00053	83 e0 40	 and	 eax, 64			; 00000040H
  00056	85 c0		 test	 eax, eax
  00058	75 0c		 jne	 SHORT $LN10@TableFixFl
  0005a	c7 85 c0 00 00
	00 00 80 00 00	 mov	 DWORD PTR tv71[rbp], 32768 ; 00008000H
  00064	eb 0a		 jmp	 SHORT $LN11@TableFixFl
$LN10@TableFixFl:
  00066	c7 85 c0 00 00
	00 00 20 00 00	 mov	 DWORD PTR tv71[rbp], 8192 ; 00002000H
$LN11@TableFixFl:
  00070	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv71[rbp]
  00076	8b 8d f0 00 00
	00		 mov	 ecx, DWORD PTR flags$[rbp]
  0007c	0b c8		 or	 ecx, eax
  0007e	8b c1		 mov	 eax, ecx
  00080	89 85 f0 00 00
	00		 mov	 DWORD PTR flags$[rbp], eax
$LN2@TableFixFl:

; 269  : 
; 270  :     // Adjust flags: enable NoKeepColumnsVisible when using ImGuiTableFlags_SizingFixedSame
; 271  :     if ((flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)

  00086	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  0008c	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  00091	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00096	75 10		 jne	 SHORT $LN3@TableFixFl

; 272  :         flags |= ImGuiTableFlags_NoKeepColumnsVisible;

  00098	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  0009e	0f ba e8 12	 bts	 eax, 18
  000a2	89 85 f0 00 00
	00		 mov	 DWORD PTR flags$[rbp], eax
$LN3@TableFixFl:

; 273  : 
; 274  :     // Adjust flags: enforce borders when resizable
; 275  :     if (flags & ImGuiTableFlags_Resizable)

  000a8	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  000ae	83 e0 01	 and	 eax, 1
  000b1	85 c0		 test	 eax, eax
  000b3	74 10		 je	 SHORT $LN4@TableFixFl

; 276  :         flags |= ImGuiTableFlags_BordersInnerV;

  000b5	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  000bb	0f ba e8 09	 bts	 eax, 9
  000bf	89 85 f0 00 00
	00		 mov	 DWORD PTR flags$[rbp], eax
$LN4@TableFixFl:

; 277  : 
; 278  :     // Adjust flags: disable NoHostExtendX/NoHostExtendY if we have any scrolling going on
; 279  :     if (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY))

  000c5	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  000cb	25 00 00 00 03	 and	 eax, 50331648		; 03000000H
  000d0	85 c0		 test	 eax, eax
  000d2	74 11		 je	 SHORT $LN5@TableFixFl

; 280  :         flags &= ~(ImGuiTableFlags_NoHostExtendX | ImGuiTableFlags_NoHostExtendY);

  000d4	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  000da	25 ff ff fc ff	 and	 eax, -196609		; fffffffffffcffffH
  000df	89 85 f0 00 00
	00		 mov	 DWORD PTR flags$[rbp], eax
$LN5@TableFixFl:

; 281  : 
; 282  :     // Adjust flags: NoBordersInBodyUntilResize takes priority over NoBordersInBody
; 283  :     if (flags & ImGuiTableFlags_NoBordersInBodyUntilResize)

  000e5	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  000eb	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  000f0	85 c0		 test	 eax, eax
  000f2	74 10		 je	 SHORT $LN6@TableFixFl

; 284  :         flags &= ~ImGuiTableFlags_NoBordersInBody;

  000f4	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  000fa	0f ba f0 0b	 btr	 eax, 11
  000fe	89 85 f0 00 00
	00		 mov	 DWORD PTR flags$[rbp], eax
$LN6@TableFixFl:

; 285  : 
; 286  :     // Adjust flags: disable saved settings if there's nothing to save
; 287  :     if ((flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Sortable)) == 0)

  00104	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  0010a	83 e0 0f	 and	 eax, 15
  0010d	85 c0		 test	 eax, eax
  0010f	75 0f		 jne	 SHORT $LN7@TableFixFl

; 288  :         flags |= ImGuiTableFlags_NoSavedSettings;

  00111	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00117	83 c8 10	 or	 eax, 16
  0011a	89 85 f0 00 00
	00		 mov	 DWORD PTR flags$[rbp], eax
$LN7@TableFixFl:

; 289  : 
; 290  :     // Inherit _NoSavedSettings from top-level window (child windows always have _NoSavedSettings set)
; 291  :     if (outer_window->RootWindow->Flags & ImGuiWindowFlags_NoSavedSettings)

  00120	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00127	48 8b 80 70 03
	00 00		 mov	 rax, QWORD PTR [rax+880]
  0012e	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00131	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00136	85 c0		 test	 eax, eax
  00138	74 0f		 je	 SHORT $LN8@TableFixFl

; 292  :         flags |= ImGuiTableFlags_NoSavedSettings;

  0013a	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00140	83 c8 10	 or	 eax, 16
  00143	89 85 f0 00 00
	00		 mov	 DWORD PTR flags$[rbp], eax
$LN8@TableFixFl:

; 293  : 
; 294  :     return flags;

  00149	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR flags$[rbp]

; 295  : }

  0014f	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00156	5f		 pop	 rdi
  00157	5d		 pop	 rbp
  00158	c3		 ret	 0
?TableFixFlags@@YAHHPEAUImGuiWindow@@@Z ENDP		; TableFixFlags
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?DebugNodeTableSettings@ImGui@@YAXPEAUImGuiTableSettings@@@Z
_TEXT	SEGMENT
n$1 = 4
column_settings$2 = 40
sort_dir$3 = 68
tv133 = 276
tv144 = 280
tv154 = 288
tv153 = 296
settings$ = 336
?DebugNodeTableSettings@ImGui@@YAXPEAUImGuiTableSettings@@@Z PROC ; ImGui::DebugNodeTableSettings, COMDAT

; 3638 : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0000e	48 8d 6c 24 50	 lea	 rbp, QWORD PTR [rsp+80]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 62 00 00 00	 mov	 ecx, 98			; 00000062H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+424]

; 3639 :     if (!TreeNode((void*)(intptr_t)settings->ID, "Settings 0x%08X (%d columns)", settings->ID, settings->ColumnsCount))

  0002a	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR settings$[rbp]
  00031	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  00035	48 8b 8d 50 01
	00 00		 mov	 rcx, QWORD PTR settings$[rbp]
  0003c	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0003e	44 8b c8	 mov	 r9d, eax
  00041	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR settings$[rbp]
  00048	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@LNKMILO@Settings?50x?$CF08X?5?$CI?$CFd?5columns?$CJ?$AA@
  00052	e8 00 00 00 00	 call	 ?TreeNode@ImGui@@YA_NPEBXPEBDZZ ; ImGui::TreeNode
  00057	0f b6 c0	 movzx	 eax, al
  0005a	85 c0		 test	 eax, eax
  0005c	75 05		 jne	 SHORT $LN5@DebugNodeT

; 3640 :         return;

  0005e	e9 a2 01 00 00	 jmp	 $LN1@DebugNodeT
$LN5@DebugNodeT:

; 3641 :     BulletText("SaveFlags: 0x%08X", settings->SaveFlags);

  00063	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR settings$[rbp]
  0006a	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@LJHOAHJA@SaveFlags?3?50x?$CF08X?$AA@
  00074	e8 00 00 00 00	 call	 ?BulletText@ImGui@@YAXPEBDZZ ; ImGui::BulletText

; 3642 :     BulletText("ColumnsCount: %d (max %d)", settings->ColumnsCount, settings->ColumnsCountMax);

  00079	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR settings$[rbp]
  00080	0f bf 40 0e	 movsx	 eax, WORD PTR [rax+14]
  00084	48 8b 8d 50 01
	00 00		 mov	 rcx, QWORD PTR settings$[rbp]
  0008b	0f bf 49 0c	 movsx	 ecx, WORD PTR [rcx+12]
  0008f	44 8b c0	 mov	 r8d, eax
  00092	8b d1		 mov	 edx, ecx
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@OLKPLDMA@ColumnsCount?3?5?$CFd?5?$CImax?5?$CFd?$CJ?$AA@
  0009b	e8 00 00 00 00	 call	 ?BulletText@ImGui@@YAXPEBDZZ ; ImGui::BulletText

; 3643 :     for (int n = 0; n < settings->ColumnsCount; n++)

  000a0	c7 45 04 00 00
	00 00		 mov	 DWORD PTR n$1[rbp], 0
  000a7	eb 08		 jmp	 SHORT $LN4@DebugNodeT
$LN2@DebugNodeT:
  000a9	8b 45 04	 mov	 eax, DWORD PTR n$1[rbp]
  000ac	ff c0		 inc	 eax
  000ae	89 45 04	 mov	 DWORD PTR n$1[rbp], eax
$LN4@DebugNodeT:
  000b1	48 8b 85 50 01
	00 00		 mov	 rax, QWORD PTR settings$[rbp]
  000b8	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  000bc	39 45 04	 cmp	 DWORD PTR n$1[rbp], eax
  000bf	0f 8d 3b 01 00
	00		 jge	 $LN3@DebugNodeT

; 3644 :     {
; 3645 :         ImGuiTableColumnSettings* column_settings = &settings->GetColumnSettings()[n];

  000c5	48 8b 8d 50 01
	00 00		 mov	 rcx, QWORD PTR settings$[rbp]
  000cc	e8 00 00 00 00	 call	 ?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ ; ImGuiTableSettings::GetColumnSettings
  000d1	48 63 4d 04	 movsxd	 rcx, DWORD PTR n$1[rbp]
  000d5	48 6b c9 10	 imul	 rcx, rcx, 16
  000d9	48 03 c1	 add	 rax, rcx
  000dc	48 89 45 28	 mov	 QWORD PTR column_settings$2[rbp], rax

; 3646 :         ImGuiSortDirection sort_dir = (column_settings->SortOrder != -1) ? (ImGuiSortDirection)column_settings->SortDirection : ImGuiSortDirection_None;

  000e0	48 8b 45 28	 mov	 rax, QWORD PTR column_settings$2[rbp]
  000e4	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  000e8	83 f8 ff	 cmp	 eax, -1
  000eb	74 15		 je	 SHORT $LN7@DebugNodeT
  000ed	48 8b 45 28	 mov	 rax, QWORD PTR column_settings$2[rbp]
  000f1	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  000f5	24 03		 and	 al, 3
  000f7	0f b6 c0	 movzx	 eax, al
  000fa	89 85 14 01 00
	00		 mov	 DWORD PTR tv133[rbp], eax
  00100	eb 0a		 jmp	 SHORT $LN8@DebugNodeT
$LN7@DebugNodeT:
  00102	c7 85 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv133[rbp], 0
$LN8@DebugNodeT:
  0010c	8b 85 14 01 00
	00		 mov	 eax, DWORD PTR tv133[rbp]
  00112	89 45 44	 mov	 DWORD PTR sort_dir$3[rbp], eax

; 3647 :         BulletText("Column %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X",

  00115	48 8b 45 28	 mov	 rax, QWORD PTR column_settings$2[rbp]
  00119	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  0011d	c0 e8 03	 shr	 al, 3
  00120	24 01		 and	 al, 1
  00122	0f b6 c0	 movzx	 eax, al
  00125	85 c0		 test	 eax, eax
  00127	74 10		 je	 SHORT $LN9@DebugNodeT
  00129	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06ODJMJFLN@Weight?$AA@
  00130	48 89 85 18 01
	00 00		 mov	 QWORD PTR tv144[rbp], rax
  00137	eb 0e		 jmp	 SHORT $LN10@DebugNodeT
$LN9@DebugNodeT:
  00139	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06PALFPBFG@Width?5?$AA@
  00140	48 89 85 18 01
	00 00		 mov	 QWORD PTR tv144[rbp], rax
$LN10@DebugNodeT:
  00147	83 7d 44 01	 cmp	 DWORD PTR sort_dir$3[rbp], 1
  0014b	75 10		 jne	 SHORT $LN13@DebugNodeT
  0014d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03OFHEPBNG@Asc?$AA@
  00154	48 89 85 20 01
	00 00		 mov	 QWORD PTR tv154[rbp], rax
  0015b	eb 32		 jmp	 SHORT $LN14@DebugNodeT
$LN13@DebugNodeT:
  0015d	83 7d 44 02	 cmp	 DWORD PTR sort_dir$3[rbp], 2
  00161	75 10		 jne	 SHORT $LN11@DebugNodeT
  00163	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03IAMDMMHH@Des?$AA@
  0016a	48 89 85 28 01
	00 00		 mov	 QWORD PTR tv153[rbp], rax
  00171	eb 0e		 jmp	 SHORT $LN12@DebugNodeT
$LN11@DebugNodeT:
  00173	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03JMFMNIFM@?9?9?9?$AA@
  0017a	48 89 85 28 01
	00 00		 mov	 QWORD PTR tv153[rbp], rax
$LN12@DebugNodeT:
  00181	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR tv153[rbp]
  00188	48 89 85 20 01
	00 00		 mov	 QWORD PTR tv154[rbp], rax
$LN14@DebugNodeT:
  0018f	48 8b 45 28	 mov	 rax, QWORD PTR column_settings$2[rbp]
  00193	f3 0f 5a 00	 cvtss2sd xmm0, DWORD PTR [rax]
  00197	48 8b 45 28	 mov	 rax, QWORD PTR column_settings$2[rbp]
  0019b	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  0019f	c0 e8 02	 shr	 al, 2
  001a2	24 01		 and	 al, 1
  001a4	0f b6 c0	 movzx	 eax, al
  001a7	48 8b 4d 28	 mov	 rcx, QWORD PTR column_settings$2[rbp]
  001ab	0f bf 49 0c	 movsx	 ecx, WORD PTR [rcx+12]
  001af	48 8b 55 28	 mov	 rdx, QWORD PTR column_settings$2[rbp]
  001b3	0f bf 52 0a	 movsx	 edx, WORD PTR [rdx+10]
  001b7	4c 8b 45 28	 mov	 r8, QWORD PTR column_settings$2[rbp]
  001bb	45 8b 40 04	 mov	 r8d, DWORD PTR [r8+4]
  001bf	44 89 44 24 40	 mov	 DWORD PTR [rsp+64], r8d
  001c4	f2 0f 11 44 24
	38		 movsd	 QWORD PTR [rsp+56], xmm0
  001ca	4c 8b 85 18 01
	00 00		 mov	 r8, QWORD PTR tv144[rbp]
  001d1	4c 89 44 24 30	 mov	 QWORD PTR [rsp+48], r8
  001d6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001da	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR tv154[rbp]
  001e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e6	44 8b c9	 mov	 r9d, ecx
  001e9	44 8b c2	 mov	 r8d, edx
  001ec	8b 55 04	 mov	 edx, DWORD PTR n$1[rbp]
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EB@CNABLLAJ@Column?5?$CFd?5Order?5?$CFd?5SortOrder?5?$CFd?5@
  001f6	e8 00 00 00 00	 call	 ?BulletText@ImGui@@YAXPEBDZZ ; ImGui::BulletText

; 3648 :             n, column_settings->DisplayOrder, column_settings->SortOrder,
; 3649 :             (sort_dir == ImGuiSortDirection_Ascending) ? "Asc" : (sort_dir == ImGuiSortDirection_Descending) ? "Des" : "---",
; 3650 :             column_settings->IsEnabled, column_settings->IsStretch ? "Weight" : "Width ", column_settings->WidthOrWeight, column_settings->UserID);
; 3651 :     }

  001fb	e9 a9 fe ff ff	 jmp	 $LN2@DebugNodeT
$LN3@DebugNodeT:

; 3652 :     TreePop();

  00200	e8 00 00 00 00	 call	 ?TreePop@ImGui@@YAXXZ	; ImGui::TreePop
$LN1@DebugNodeT:

; 3653 : }

  00205	48 8d a5 38 01
	00 00		 lea	 rsp, QWORD PTR [rbp+312]
  0020c	5f		 pop	 rdi
  0020d	5d		 pop	 rbp
  0020e	c3		 ret	 0
?DebugNodeTableSettings@ImGui@@YAXPEAUImGuiTableSettings@@@Z ENDP ; ImGui::DebugNodeTableSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
buf$ = 80
p$ = 616
buf_end$ = 648
is_active$ = 676
open$ = 708
clear_settings$ = 740
sum_weights$ = 772
n$5 = 804
n$6 = 836
column$7 = 872
name$8 = 904
r$9 = 936
settings$10 = 984
$T11 = 1588
$T12 = 1620
$T13 = 1652
tv69 = 1668
tv275 = 1672
tv225 = 1672
tv203 = 1672
tv176 = 1672
tv158 = 1672
tv141 = 1672
tv73 = 1672
tv280 = 1680
tv212 = 1680
tv183 = 1680
tv161 = 1680
tv144 = 1680
tv285 = 1688
tv198 = 1688
tv300 = 1696
tv299 = 1704
tv360 = 1712
tv399 = 1720
tv406 = 1728
__$ArrayPad$ = 1736
table$ = 1952
?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z PROC	; ImGui::DebugNodeTable, COMDAT

; 3574 : {

$LN39:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	48 81 ec 68 08
	00 00		 sub	 rsp, 2152		; 00000868H
  00010	48 8d ac 24 f0
	00 00 00	 lea	 rbp, QWORD PTR [rsp+240]
  00018	0f 29 b5 60 07
	00 00		 movaps	 XMMWORD PTR [rbp+1888], xmm6
  0001f	0f 29 bd 50 07
	00 00		 movaps	 XMMWORD PTR [rbp+1872], xmm7
  00026	44 0f 29 85 40
	07 00 00	 movaps	 XMMWORD PTR [rbp+1856], xmm8
  0002e	44 0f 29 8d 30
	07 00 00	 movaps	 XMMWORD PTR [rbp+1840], xmm9
  00036	44 0f 29 95 20
	07 00 00	 movaps	 XMMWORD PTR [rbp+1824], xmm10
  0003e	44 0f 29 9d 10
	07 00 00	 movaps	 XMMWORD PTR [rbp+1808], xmm11
  00046	44 0f 29 a5 00
	07 00 00	 movaps	 XMMWORD PTR [rbp+1792], xmm12
  0004e	44 0f 29 ad f0
	06 00 00	 movaps	 XMMWORD PTR [rbp+1776], xmm13
  00056	44 0f 29 b5 e0
	06 00 00	 movaps	 XMMWORD PTR [rbp+1760], xmm14
  0005e	44 0f 29 bd d0
	06 00 00	 movaps	 XMMWORD PTR [rbp+1744], xmm15
  00066	48 8b fc	 mov	 rdi, rsp
  00069	b9 f0 01 00 00	 mov	 ecx, 496		; 000001f0H
  0006e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00073	f3 ab		 rep stosd
  00075	48 8b 8c 24 98
	08 00 00	 mov	 rcx, QWORD PTR [rsp+2200]
  0007d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00084	48 33 c5	 xor	 rax, rbp
  00087	48 89 85 c8 06
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 3575 :     char buf[512];
; 3576 :     char* p = buf;

  0008e	48 8d 45 50	 lea	 rax, QWORD PTR buf$[rbp]
  00092	48 89 85 68 02
	00 00		 mov	 QWORD PTR p$[rbp], rax

; 3577 :     const char* buf_end = buf + IM_ARRAYSIZE(buf);

  00099	48 8d 85 50 02
	00 00		 lea	 rax, QWORD PTR buf$[rbp+512]
  000a0	48 89 85 88 02
	00 00		 mov	 QWORD PTR buf_end$[rbp], rax

; 3578 :     const bool is_active = (table->LastFrameActive >= ImGui::GetFrameCount() - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.

  000a7	e8 00 00 00 00	 call	 ?GetFrameCount@ImGui@@YAHXZ ; ImGui::GetFrameCount
  000ac	83 e8 02	 sub	 eax, 2
  000af	48 8b 8d a0 07
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000b6	39 41 68	 cmp	 DWORD PTR [rcx+104], eax
  000b9	7c 09		 jl	 SHORT $LN19@DebugNodeT
  000bb	c6 85 84 06 00
	00 01		 mov	 BYTE PTR tv69[rbp], 1
  000c2	eb 07		 jmp	 SHORT $LN20@DebugNodeT
$LN19@DebugNodeT:
  000c4	c6 85 84 06 00
	00 00		 mov	 BYTE PTR tv69[rbp], 0
$LN20@DebugNodeT:
  000cb	0f b6 85 84 06
	00 00		 movzx	 eax, BYTE PTR tv69[rbp]
  000d2	88 85 a4 02 00
	00		 mov	 BYTE PTR is_active$[rbp], al

; 3579 :     ImFormatString(p, buf_end - p, "Table 0x%08X (%d columns, in '%s')%s", table->ID, table->ColumnsCount, table->OuterWindow->Name, is_active ? "" : " *Inactive*");

  000d8	0f b6 85 a4 02
	00 00		 movzx	 eax, BYTE PTR is_active$[rbp]
  000df	85 c0		 test	 eax, eax
  000e1	74 10		 je	 SHORT $LN21@DebugNodeT
  000e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000ea	48 89 85 88 06
	00 00		 mov	 QWORD PTR tv73[rbp], rax
  000f1	eb 0e		 jmp	 SHORT $LN22@DebugNodeT
$LN21@DebugNodeT:
  000f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@MDILNFHC@?5?$CKInactive?$CK?$AA@
  000fa	48 89 85 88 06
	00 00		 mov	 QWORD PTR tv73[rbp], rax
$LN22@DebugNodeT:
  00101	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00108	48 8b 80 78 01
	00 00		 mov	 rax, QWORD PTR [rax+376]
  0010f	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  00116	48 8b 95 88 02
	00 00		 mov	 rdx, QWORD PTR buf_end$[rbp]
  0011d	48 2b d1	 sub	 rdx, rcx
  00120	48 8b ca	 mov	 rcx, rdx
  00123	48 8b 95 88 06
	00 00		 mov	 rdx, QWORD PTR tv73[rbp]
  0012a	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  0012f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00132	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00137	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0013e	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00141	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00145	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0014c	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  0014f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@DAHKPIHJ@Table?50x?$CF08X?5?$CI?$CFd?5columns?0?5in?5?8?$CFs@
  00156	48 8b d1	 mov	 rdx, rcx
  00159	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  00160	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPEAD_KPEBDZZ ; ImFormatString

; 3580 :     if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }

  00165	0f b6 85 a4 02
	00 00		 movzx	 eax, BYTE PTR is_active$[rbp]
  0016c	85 c0		 test	 eax, eax
  0016e	75 14		 jne	 SHORT $LN8@DebugNodeT
  00170	b9 01 00 00 00	 mov	 ecx, 1
  00175	e8 00 00 00 00	 call	 ?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z ; ImGui::GetStyleColorVec4
  0017a	48 8b d0	 mov	 rdx, rax
  0017d	33 c9		 xor	 ecx, ecx
  0017f	e8 00 00 00 00	 call	 ?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor
$LN8@DebugNodeT:

; 3581 :     bool open = TreeNode(table, "%s", buf);

  00184	4c 8d 45 50	 lea	 r8, QWORD PTR buf$[rbp]
  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  0018f	48 8b 8d a0 07
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00196	e8 00 00 00 00	 call	 ?TreeNode@ImGui@@YA_NPEBXPEBDZZ ; ImGui::TreeNode
  0019b	88 85 c4 02 00
	00		 mov	 BYTE PTR open$[rbp], al

; 3582 :     if (!is_active) { PopStyleColor(); }

  001a1	0f b6 85 a4 02
	00 00		 movzx	 eax, BYTE PTR is_active$[rbp]
  001a8	85 c0		 test	 eax, eax
  001aa	75 0a		 jne	 SHORT $LN9@DebugNodeT
  001ac	b9 01 00 00 00	 mov	 ecx, 1
  001b1	e8 00 00 00 00	 call	 ?PopStyleColor@ImGui@@YAXH@Z ; ImGui::PopStyleColor
$LN9@DebugNodeT:

; 3583 :     if (IsItemHovered())

  001b6	33 c9		 xor	 ecx, ecx
  001b8	e8 00 00 00 00	 call	 ?IsItemHovered@ImGui@@YA_NH@Z ; ImGui::IsItemHovered
  001bd	0f b6 c0	 movzx	 eax, al
  001c0	85 c0		 test	 eax, eax
  001c2	74 6f		 je	 SHORT $LN10@DebugNodeT

; 3584 :         GetForegroundDrawList()->AddRect(table->OuterRect.Min, table->OuterRect.Max, IM_COL32(255, 255, 0, 255));

  001c4	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001cb	48 05 f0 00 00
	00		 add	 rax, 240		; 000000f0H
  001d1	48 89 85 88 06
	00 00		 mov	 QWORD PTR tv141[rbp], rax
  001d8	48 8b 8d a0 07
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  001df	48 81 c1 e8 00
	00 00		 add	 rcx, 232		; 000000e8H
  001e6	48 89 8d 90 06
	00 00		 mov	 QWORD PTR tv144[rbp], rcx
  001ed	e8 00 00 00 00	 call	 ?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@XZ ; ImGui::GetForegroundDrawList
  001f2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001fa	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00200	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00208	0f 57 c0	 xorps	 xmm0, xmm0
  0020b	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00211	41 b9 ff ff 00
	ff		 mov	 r9d, -16711681		; ff00ffffH
  00217	48 8b 8d 88 06
	00 00		 mov	 rcx, QWORD PTR tv141[rbp]
  0021e	4c 8b c1	 mov	 r8, rcx
  00221	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR tv144[rbp]
  00228	48 8b d1	 mov	 rdx, rcx
  0022b	48 8b c8	 mov	 rcx, rax
  0022e	e8 00 00 00 00	 call	 ?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
$LN10@DebugNodeT:

; 3585 :     if (IsItemVisible() && table->HoveredColumnBody != -1)

  00233	e8 00 00 00 00	 call	 ?IsItemVisible@ImGui@@YA_NXZ ; ImGui::IsItemVisible
  00238	0f b6 c0	 movzx	 eax, al
  0023b	85 c0		 test	 eax, eax
  0023d	74 7f		 je	 SHORT $LN11@DebugNodeT
  0023f	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00246	0f bf 80 f8 01
	00 00		 movsx	 eax, WORD PTR [rax+504]
  0024d	83 f8 ff	 cmp	 eax, -1
  00250	74 6c		 je	 SHORT $LN11@DebugNodeT

; 3586 :         GetForegroundDrawList()->AddRect(GetItemRectMin(), GetItemRectMax(), IM_COL32(255, 255, 0, 255));

  00252	48 8d 8d 34 06
	00 00		 lea	 rcx, QWORD PTR $T11[rbp]
  00259	e8 00 00 00 00	 call	 ?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetItemRectMax
  0025e	48 89 85 88 06
	00 00		 mov	 QWORD PTR tv158[rbp], rax
  00265	48 8d 8d 54 06
	00 00		 lea	 rcx, QWORD PTR $T12[rbp]
  0026c	e8 00 00 00 00	 call	 ?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetItemRectMin
  00271	48 89 85 90 06
	00 00		 mov	 QWORD PTR tv161[rbp], rax
  00278	e8 00 00 00 00	 call	 ?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@XZ ; ImGui::GetForegroundDrawList
  0027d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00285	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0028b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00293	0f 57 c0	 xorps	 xmm0, xmm0
  00296	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0029c	41 b9 ff ff 00
	ff		 mov	 r9d, -16711681		; ff00ffffH
  002a2	48 8b 8d 88 06
	00 00		 mov	 rcx, QWORD PTR tv158[rbp]
  002a9	4c 8b c1	 mov	 r8, rcx
  002ac	48 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR tv161[rbp]
  002b3	48 8b d1	 mov	 rdx, rcx
  002b6	48 8b c8	 mov	 rcx, rax
  002b9	e8 00 00 00 00	 call	 ?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
$LN11@DebugNodeT:

; 3587 :     if (!open)

  002be	0f b6 85 c4 02
	00 00		 movzx	 eax, BYTE PTR open$[rbp]
  002c5	85 c0		 test	 eax, eax
  002c7	75 05		 jne	 SHORT $LN12@DebugNodeT

; 3588 :         return;

  002c9	e9 0b 09 00 00	 jmp	 $LN1@DebugNodeT
$LN12@DebugNodeT:

; 3589 :     if (table->InstanceCurrent > 0)

  002ce	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002d5	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  002d9	85 c0		 test	 eax, eax
  002db	7e 1b		 jle	 SHORT $LN13@DebugNodeT

; 3590 :         ImGui::Text("** %d instances of same table! Some data below will refer to last instance.", table->InstanceCurrent + 1);

  002dd	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002e4	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  002e8	ff c0		 inc	 eax
  002ea	8b d0		 mov	 edx, eax
  002ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EM@JLKLPOOK@?$CK?$CK?5?$CFd?5instances?5of?5same?5table?$CB?5S@
  002f3	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPEBDZZ	; ImGui::Text
$LN13@DebugNodeT:

; 3591 :     bool clear_settings = SmallButton("Clear settings");

  002f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@MDFKNKGM@Clear?5settings?$AA@
  002ff	e8 00 00 00 00	 call	 ?SmallButton@ImGui@@YA_NPEBD@Z ; ImGui::SmallButton
  00304	88 85 e4 02 00
	00		 mov	 BYTE PTR clear_settings$[rbp], al

; 3592 :     BulletText("OuterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: '%s'", table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.GetWidth(), table->OuterRect.GetHeight(), DebugNodeTableGetSizingPolicyDesc(table->Flags));

  0030a	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00311	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00314	e8 00 00 00 00	 call	 ?DebugNodeTableGetSizingPolicyDesc@@YAPEBDH@Z ; DebugNodeTableGetSizingPolicyDesc
  00319	48 89 85 88 06
	00 00		 mov	 QWORD PTR tv176[rbp], rax
  00320	48 8b 8d a0 07
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00327	48 81 c1 e8 00
	00 00		 add	 rcx, 232		; 000000e8H
  0032e	e8 00 00 00 00	 call	 ?GetHeight@ImRect@@QEBAMXZ ; ImRect::GetHeight
  00333	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00337	f2 0f 11 85 90
	06 00 00	 movsd	 QWORD PTR tv183[rbp], xmm0
  0033f	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00346	48 05 e8 00 00
	00		 add	 rax, 232		; 000000e8H
  0034c	48 8b c8	 mov	 rcx, rax
  0034f	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QEBAMXZ ; ImRect::GetWidth
  00354	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00358	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0035f	f3 0f 5a 88 ec
	00 00 00	 cvtss2sd xmm1, DWORD PTR [rax+236]
  00367	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0036e	f3 0f 5a 90 e8
	00 00 00	 cvtss2sd xmm2, DWORD PTR [rax+232]
  00376	f2 0f 11 95 98
	06 00 00	 movsd	 QWORD PTR tv198[rbp], xmm2
  0037e	48 8b 85 88 06
	00 00		 mov	 rax, QWORD PTR tv176[rbp]
  00385	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0038a	f2 0f 10 9d 90
	06 00 00	 movsd	 xmm3, QWORD PTR tv183[rbp]
  00392	f2 0f 11 5c 24
	20		 movsd	 QWORD PTR [rsp+32], xmm3
  00398	0f 28 d8	 movaps	 xmm3, xmm0
  0039b	66 49 0f 7e d9	 movq	 r9, xmm3
  003a0	0f 28 d1	 movaps	 xmm2, xmm1
  003a3	66 49 0f 7e d0	 movq	 r8, xmm2
  003a8	f2 0f 10 85 98
	06 00 00	 movsd	 xmm0, QWORD PTR tv198[rbp]
  003b0	0f 28 c8	 movaps	 xmm1, xmm0
  003b3	66 48 0f 7e ca	 movq	 rdx, xmm1
  003b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DL@BMMMGOOI@OuterRect?3?5Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?5Size@
  003bf	e8 00 00 00 00	 call	 ?BulletText@ImGui@@YAXPEBDZZ ; ImGui::BulletText

; 3593 :     BulletText("ColumnsGivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s", table->ColumnsGivenWidth, table->ColumnsAutoFitWidth, table->InnerWidth, table->InnerWidth == 0.0f ? " (auto)" : "");

  003c4	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003cb	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+204]
  003d3	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  003da	7a 12		 jp	 SHORT $LN23@DebugNodeT
  003dc	75 10		 jne	 SHORT $LN23@DebugNodeT
  003de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07IOPDKCEG@?5?$CIauto?$CJ?$AA@
  003e5	48 89 85 88 06
	00 00		 mov	 QWORD PTR tv203[rbp], rax
  003ec	eb 0e		 jmp	 SHORT $LN24@DebugNodeT
$LN23@DebugNodeT:
  003ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  003f5	48 89 85 88 06
	00 00		 mov	 QWORD PTR tv203[rbp], rax
$LN24@DebugNodeT:
  003fc	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00403	f3 0f 5a 80 cc
	00 00 00	 cvtss2sd xmm0, DWORD PTR [rax+204]
  0040b	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00412	f3 0f 5a 88 d4
	00 00 00	 cvtss2sd xmm1, DWORD PTR [rax+212]
  0041a	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00421	f3 0f 5a 90 d0
	00 00 00	 cvtss2sd xmm2, DWORD PTR [rax+208]
  00429	f2 0f 11 95 90
	06 00 00	 movsd	 QWORD PTR tv212[rbp], xmm2
  00431	48 8b 85 88 06
	00 00		 mov	 rax, QWORD PTR tv203[rbp]
  00438	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043d	0f 28 d8	 movaps	 xmm3, xmm0
  00440	66 49 0f 7e d9	 movq	 r9, xmm3
  00445	0f 28 d1	 movaps	 xmm2, xmm1
  00448	66 49 0f 7e d0	 movq	 r8, xmm2
  0044d	f2 0f 10 85 90
	06 00 00	 movsd	 xmm0, QWORD PTR tv212[rbp]
  00455	0f 28 c8	 movaps	 xmm1, xmm0
  00458	66 48 0f 7e ca	 movq	 rdx, xmm1
  0045d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EH@GODPECNO@ColumnsGivenWidth?3?5?$CF?41f?0?5Columns@
  00464	e8 00 00 00 00	 call	 ?BulletText@ImGui@@YAXPEBDZZ ; ImGui::BulletText

; 3594 :     BulletText("CellPaddingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f", table->CellPaddingX, table->CellSpacingX1, table->CellSpacingX2, table->OuterPaddingX);

  00469	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00470	f3 0f 5a 80 b8
	00 00 00	 cvtss2sd xmm0, DWORD PTR [rax+184]
  00478	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0047f	f3 0f 5a 88 c8
	00 00 00	 cvtss2sd xmm1, DWORD PTR [rax+200]
  00487	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0048e	f3 0f 5a 90 c4
	00 00 00	 cvtss2sd xmm2, DWORD PTR [rax+196]
  00496	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0049d	f3 0f 5a 98 bc
	00 00 00	 cvtss2sd xmm3, DWORD PTR [rax+188]
  004a5	f2 0f 11 9d 88
	06 00 00	 movsd	 QWORD PTR tv225[rbp], xmm3
  004ad	f2 0f 11 44 24
	20		 movsd	 QWORD PTR [rsp+32], xmm0
  004b3	0f 28 d9	 movaps	 xmm3, xmm1
  004b6	66 49 0f 7e d9	 movq	 r9, xmm3
  004bb	66 49 0f 7e d0	 movq	 r8, xmm2
  004c0	f2 0f 10 85 88
	06 00 00	 movsd	 xmm0, QWORD PTR tv225[rbp]
  004c8	0f 28 c8	 movaps	 xmm1, xmm0
  004cb	66 48 0f 7e ca	 movq	 rdx, xmm1
  004d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EB@FOKPBOFF@CellPaddingX?3?5?$CF?41f?0?5CellSpacingX@
  004d7	e8 00 00 00 00	 call	 ?BulletText@ImGui@@YAXPEBDZZ ; ImGui::BulletText

; 3595 :     BulletText("HoveredColumnBody: %d, HoveredColumnBorder: %d", table->HoveredColumnBody, table->HoveredColumnBorder);

  004dc	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004e3	0f bf 80 fa 01
	00 00		 movsx	 eax, WORD PTR [rax+506]
  004ea	48 8b 8d a0 07
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  004f1	0f bf 89 f8 01
	00 00		 movsx	 ecx, WORD PTR [rcx+504]
  004f8	44 8b c0	 mov	 r8d, eax
  004fb	8b d1		 mov	 edx, ecx
  004fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@NOMNLPPG@HoveredColumnBody?3?5?$CFd?0?5HoveredCo@
  00504	e8 00 00 00 00	 call	 ?BulletText@ImGui@@YAXPEBDZZ ; ImGui::BulletText

; 3596 :     BulletText("ResizedColumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d", table->ResizedColumn, table->ReorderColumn, table->HeldHeaderColumn);

  00509	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00510	0f bf 80 02 02
	00 00		 movsx	 eax, WORD PTR [rax+514]
  00517	48 8b 8d a0 07
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0051e	0f bf 89 04 02
	00 00		 movsx	 ecx, WORD PTR [rcx+516]
  00525	48 8b 95 a0 07
	00 00		 mov	 rdx, QWORD PTR table$[rbp]
  0052c	0f bf 92 fe 01
	00 00		 movsx	 edx, WORD PTR [rdx+510]
  00533	44 8b c8	 mov	 r9d, eax
  00536	44 8b c1	 mov	 r8d, ecx
  00539	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DL@PBPICJCB@ResizedColumn?3?5?$CFd?0?5ReorderColumn@
  00540	e8 00 00 00 00	 call	 ?BulletText@ImGui@@YAXPEBDZZ ; ImGui::BulletText

; 3597 :     //BulletText("BgDrawChannels: %d/%d", 0, table->BgDrawChannelUnfrozen);
; 3598 :     float sum_weights = 0.0f;

  00545	0f 57 c0	 xorps	 xmm0, xmm0
  00548	f3 0f 11 85 04
	03 00 00	 movss	 DWORD PTR sum_weights$[rbp], xmm0

; 3599 :     for (int n = 0; n < table->ColumnsCount; n++)

  00550	c7 85 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR n$5[rbp], 0
  0055a	eb 0e		 jmp	 SHORT $LN4@DebugNodeT
$LN2@DebugNodeT:
  0055c	8b 85 24 03 00
	00		 mov	 eax, DWORD PTR n$5[rbp]
  00562	ff c0		 inc	 eax
  00564	89 85 24 03 00
	00		 mov	 DWORD PTR n$5[rbp], eax
$LN4@DebugNodeT:
  0056a	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00571	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00574	39 85 24 03 00
	00		 cmp	 DWORD PTR n$5[rbp], eax
  0057a	7d 52		 jge	 SHORT $LN3@DebugNodeT

; 3600 :         if (table->Columns[n].Flags & ImGuiTableColumnFlags_WidthStretch)

  0057c	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00583	48 83 c0 18	 add	 rax, 24
  00587	8b 95 24 03 00
	00		 mov	 edx, DWORD PTR n$5[rbp]
  0058d	48 8b c8	 mov	 rcx, rax
  00590	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00595	8b 00		 mov	 eax, DWORD PTR [rax]
  00597	83 e0 08	 and	 eax, 8
  0059a	85 c0		 test	 eax, eax
  0059c	74 2e		 je	 SHORT $LN14@DebugNodeT

; 3601 :             sum_weights += table->Columns[n].StretchWeight;

  0059e	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  005a5	48 83 c0 18	 add	 rax, 24
  005a9	8b 95 24 03 00
	00		 mov	 edx, DWORD PTR n$5[rbp]
  005af	48 8b c8	 mov	 rcx, rax
  005b2	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  005b7	f3 0f 10 85 04
	03 00 00	 movss	 xmm0, DWORD PTR sum_weights$[rbp]
  005bf	f3 0f 58 40 18	 addss	 xmm0, DWORD PTR [rax+24]
  005c4	f3 0f 11 85 04
	03 00 00	 movss	 DWORD PTR sum_weights$[rbp], xmm0
$LN14@DebugNodeT:

; 3602 :     for (int n = 0; n < table->ColumnsCount; n++)

  005cc	eb 8e		 jmp	 SHORT $LN2@DebugNodeT
$LN3@DebugNodeT:
  005ce	c7 85 44 03 00
	00 00 00 00 00	 mov	 DWORD PTR n$6[rbp], 0
  005d8	eb 0e		 jmp	 SHORT $LN7@DebugNodeT
$LN5@DebugNodeT:
  005da	8b 85 44 03 00
	00		 mov	 eax, DWORD PTR n$6[rbp]
  005e0	ff c0		 inc	 eax
  005e2	89 85 44 03 00
	00		 mov	 DWORD PTR n$6[rbp], eax
$LN7@DebugNodeT:
  005e8	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  005ef	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  005f2	39 85 44 03 00
	00		 cmp	 DWORD PTR n$6[rbp], eax
  005f8	0f 8d 94 05 00
	00		 jge	 $LN6@DebugNodeT

; 3603 :     {
; 3604 :         ImGuiTableColumn* column = &table->Columns[n];

  005fe	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00605	48 83 c0 18	 add	 rax, 24
  00609	8b 95 44 03 00
	00		 mov	 edx, DWORD PTR n$6[rbp]
  0060f	48 8b c8	 mov	 rcx, rax
  00612	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00617	48 89 85 68 03
	00 00		 mov	 QWORD PTR column$7[rbp], rax

; 3605 :         const char* name = TableGetColumnName(table, n);

  0061e	8b 95 44 03 00
	00		 mov	 edx, DWORD PTR n$6[rbp]
  00624	48 8b 8d a0 07
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0062b	e8 00 00 00 00	 call	 ?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z ; ImGui::TableGetColumnName
  00630	48 89 85 88 03
	00 00		 mov	 QWORD PTR name$8[rbp], rax

; 3606 :         ImFormatString(buf, IM_ARRAYSIZE(buf),

  00637	48 8b 85 68 03
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  0063e	8b 00		 mov	 eax, DWORD PTR [rax]
  00640	83 e0 20	 and	 eax, 32			; 00000020H
  00643	85 c0		 test	 eax, eax
  00645	74 10		 je	 SHORT $LN25@DebugNodeT
  00647	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09BHNPHONE@NoResize?5?$AA@
  0064e	48 89 85 88 06
	00 00		 mov	 QWORD PTR tv275[rbp], rax
  00655	eb 0e		 jmp	 SHORT $LN26@DebugNodeT
$LN25@DebugNodeT:
  00657	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0065e	48 89 85 88 06
	00 00		 mov	 QWORD PTR tv275[rbp], rax
$LN26@DebugNodeT:
  00665	48 8b 85 68 03
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  0066c	8b 00		 mov	 eax, DWORD PTR [rax]
  0066e	83 e0 10	 and	 eax, 16
  00671	85 c0		 test	 eax, eax
  00673	74 10		 je	 SHORT $LN27@DebugNodeT
  00675	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@IGDNFKMD@WidthFixed?5?$AA@
  0067c	48 89 85 90 06
	00 00		 mov	 QWORD PTR tv280[rbp], rax
  00683	eb 0e		 jmp	 SHORT $LN28@DebugNodeT
$LN27@DebugNodeT:
  00685	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0068c	48 89 85 90 06
	00 00		 mov	 QWORD PTR tv280[rbp], rax
$LN28@DebugNodeT:
  00693	48 8b 85 68 03
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  0069a	8b 00		 mov	 eax, DWORD PTR [rax]
  0069c	83 e0 08	 and	 eax, 8
  0069f	85 c0		 test	 eax, eax
  006a1	74 10		 je	 SHORT $LN29@DebugNodeT
  006a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@PEPBBILL@WidthStretch?5?$AA@
  006aa	48 89 85 98 06
	00 00		 mov	 QWORD PTR tv285[rbp], rax
  006b1	eb 0e		 jmp	 SHORT $LN30@DebugNodeT
$LN29@DebugNodeT:
  006b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  006ba	48 89 85 98 06
	00 00		 mov	 QWORD PTR tv285[rbp], rax
$LN30@DebugNodeT:
  006c1	48 8b 85 68 03
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  006c8	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  006cc	24 03		 and	 al, 3
  006ce	0f b6 c0	 movzx	 eax, al
  006d1	83 f8 01	 cmp	 eax, 1
  006d4	75 10		 jne	 SHORT $LN33@DebugNodeT
  006d6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06FEBPAKFP@?5?$CIAsc?$CJ?$AA@
  006dd	48 89 85 a0 06
	00 00		 mov	 QWORD PTR tv300[rbp], rax
  006e4	eb 41		 jmp	 SHORT $LN34@DebugNodeT
$LN33@DebugNodeT:
  006e6	48 8b 85 68 03
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  006ed	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  006f1	24 03		 and	 al, 3
  006f3	0f b6 c0	 movzx	 eax, al
  006f6	83 f8 02	 cmp	 eax, 2
  006f9	75 10		 jne	 SHORT $LN31@DebugNodeT
  006fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06PFKLCOBM@?5?$CIDes?$CJ?$AA@
  00702	48 89 85 a8 06
	00 00		 mov	 QWORD PTR tv299[rbp], rax
  00709	eb 0e		 jmp	 SHORT $LN32@DebugNodeT
$LN31@DebugNodeT:
  0070b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00712	48 89 85 a8 06
	00 00		 mov	 QWORD PTR tv299[rbp], rax
$LN32@DebugNodeT:
  00719	48 8b 85 a8 06
	00 00		 mov	 rax, QWORD PTR tv299[rbp]
  00720	48 89 85 a0 06
	00 00		 mov	 QWORD PTR tv300[rbp], rax
$LN34@DebugNodeT:
  00727	48 8b 85 68 03
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  0072e	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  00733	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0073a	76 26		 jbe	 SHORT $LN35@DebugNodeT
  0073c	48 8b 85 68 03
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  00743	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  00748	f3 0f 5e 85 04
	03 00 00	 divss	 xmm0, DWORD PTR sum_weights$[rbp]
  00750	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42c80000
  00758	f3 0f 11 85 b0
	06 00 00	 movss	 DWORD PTR tv360[rbp], xmm0
  00760	eb 0b		 jmp	 SHORT $LN36@DebugNodeT
$LN35@DebugNodeT:
  00762	0f 57 c0	 xorps	 xmm0, xmm0
  00765	f3 0f 11 85 b0
	06 00 00	 movss	 DWORD PTR tv360[rbp], xmm0
$LN36@DebugNodeT:
  0076d	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00774	0f bf 80 16 02
	00 00		 movsx	 eax, WORD PTR [rax+534]
  0077b	39 85 44 03 00
	00		 cmp	 DWORD PTR n$6[rbp], eax
  00781	7d 10		 jge	 SHORT $LN37@DebugNodeT
  00783	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09LODDIFJL@?5?$CIFrozen?$CJ?$AA@
  0078a	48 89 85 b8 06
	00 00		 mov	 QWORD PTR tv399[rbp], rax
  00791	eb 0e		 jmp	 SHORT $LN38@DebugNodeT
$LN37@DebugNodeT:
  00793	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0079a	48 89 85 b8 06
	00 00		 mov	 QWORD PTR tv399[rbp], rax
$LN38@DebugNodeT:
  007a1	48 8b 85 68 03
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  007a8	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  007ac	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  007b3	48 8b 95 68 03
	00 00		 mov	 rdx, QWORD PTR column$7[rbp]
  007ba	f3 0f 10 41 4c	 movss	 xmm0, DWORD PTR [rcx+76]
  007bf	f3 0f 5c 42 34	 subss	 xmm0, DWORD PTR [rdx+52]
  007c4	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  007c8	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  007cf	48 8b 95 68 03
	00 00		 mov	 rdx, QWORD PTR column$7[rbp]
  007d6	f3 0f 10 49 48	 movss	 xmm1, DWORD PTR [rcx+72]
  007db	f3 0f 5c 4a 34	 subss	 xmm1, DWORD PTR [rdx+52]
  007e0	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  007e4	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  007eb	48 8b 95 68 03
	00 00		 mov	 rdx, QWORD PTR column$7[rbp]
  007f2	f3 0f 10 51 44	 movss	 xmm2, DWORD PTR [rcx+68]
  007f7	f3 0f 5c 52 34	 subss	 xmm2, DWORD PTR [rdx+52]
  007fc	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  00800	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  00807	48 8b 95 68 03
	00 00		 mov	 rdx, QWORD PTR column$7[rbp]
  0080e	f3 0f 10 59 40	 movss	 xmm3, DWORD PTR [rcx+64]
  00813	f3 0f 5c 5a 34	 subss	 xmm3, DWORD PTR [rdx+52]
  00818	f3 0f 5a db	 cvtss2sd xmm3, xmm3
  0081c	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  00823	48 8b 95 68 03
	00 00		 mov	 rdx, QWORD PTR column$7[rbp]
  0082a	f3 0f 10 61 28	 movss	 xmm4, DWORD PTR [rcx+40]
  0082f	f3 0f 5c 62 20	 subss	 xmm4, DWORD PTR [rdx+32]
  00834	f3 0f 5a e4	 cvtss2sd xmm4, xmm4
  00838	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  0083f	f3 0f 5a 69 28	 cvtss2sd xmm5, DWORD PTR [rcx+40]
  00844	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  0084b	f3 0f 5a 71 20	 cvtss2sd xmm6, DWORD PTR [rcx+32]
  00850	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  00857	48 8b 95 68 03
	00 00		 mov	 rdx, QWORD PTR column$7[rbp]
  0085e	f3 0f 10 79 0c	 movss	 xmm7, DWORD PTR [rcx+12]
  00863	f3 0f 5c 7a 08	 subss	 xmm7, DWORD PTR [rdx+8]
  00868	f3 0f 5a ff	 cvtss2sd xmm7, xmm7
  0086c	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  00873	f3 44 0f 5a 41
	0c		 cvtss2sd xmm8, DWORD PTR [rcx+12]
  00879	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  00880	f3 44 0f 5a 49
	08		 cvtss2sd xmm9, DWORD PTR [rcx+8]
  00886	f3 44 0f 5a 95
	b0 06 00 00	 cvtss2sd xmm10, DWORD PTR tv360[rbp]
  0088f	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  00896	f3 44 0f 5a 59
	18		 cvtss2sd xmm11, DWORD PTR [rcx+24]
  0089c	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  008a3	f3 44 0f 5a 61
	14		 cvtss2sd xmm12, DWORD PTR [rcx+20]
  008a9	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  008b0	f3 44 0f 5a 69
	10		 cvtss2sd xmm13, DWORD PTR [rcx+16]
  008b6	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  008bd	f3 44 0f 5a 71
	04		 cvtss2sd xmm14, DWORD PTR [rcx+4]
  008c3	48 8b 8d 68 03
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  008ca	0f b7 49 60	 movzx	 ecx, WORD PTR [rcx+96]
  008ce	48 8b 95 68 03
	00 00		 mov	 rdx, QWORD PTR column$7[rbp]
  008d5	0f b7 52 5e	 movzx	 edx, WORD PTR [rdx+94]
  008d9	4c 8b 85 68 03
	00 00		 mov	 r8, QWORD PTR column$7[rbp]
  008e0	45 0f b6 40 68	 movzx	 r8d, BYTE PTR [r8+104]
  008e5	4c 8b 8d 68 03
	00 00		 mov	 r9, QWORD PTR column$7[rbp]
  008ec	45 0f b6 49 67	 movzx	 r9d, BYTE PTR [r9+103]
  008f1	4c 8b 95 68 03
	00 00		 mov	 r10, QWORD PTR column$7[rbp]
  008f8	45 0f b6 52 66	 movzx	 r10d, BYTE PTR [r10+102]
  008fd	4c 8b 9d 68 03
	00 00		 mov	 r11, QWORD PTR column$7[rbp]
  00904	45 0f b6 5b 65	 movzx	 r11d, BYTE PTR [r11+101]
  00909	48 8b 9d 68 03
	00 00		 mov	 rbx, QWORD PTR column$7[rbp]
  00910	0f b6 5b 62	 movzx	 ebx, BYTE PTR [rbx+98]
  00914	48 8b bd 68 03
	00 00		 mov	 rdi, QWORD PTR column$7[rbp]
  0091b	48 8b b5 a0 07
	00 00		 mov	 rsi, QWORD PTR table$[rbp]
  00922	f3 44 0f 10 7f
	0c		 movss	 xmm15, DWORD PTR [rdi+12]
  00928	f3 44 0f 5c be
	08 01 00 00	 subss	 xmm15, DWORD PTR [rsi+264]
  00931	f3 45 0f 5a ff	 cvtss2sd xmm15, xmm15
  00936	f2 44 0f 11 bd
	c0 06 00 00	 movsd	 QWORD PTR tv406[rbp], xmm15
  0093f	48 8b bd 68 03
	00 00		 mov	 rdi, QWORD PTR column$7[rbp]
  00946	48 8b b5 a0 07
	00 00		 mov	 rsi, QWORD PTR table$[rbp]
  0094d	f3 44 0f 10 7f
	08		 movss	 xmm15, DWORD PTR [rdi+8]
  00953	f3 44 0f 5c be
	08 01 00 00	 subss	 xmm15, DWORD PTR [rsi+264]
  0095c	f3 45 0f 5a ff	 cvtss2sd xmm15, xmm15
  00961	48 8b bd 68 03
	00 00		 mov	 rdi, QWORD PTR column$7[rbp]
  00968	0f bf 7f 52	 movsx	 edi, WORD PTR [rdi+82]
  0096c	48 8b b5 88 06
	00 00		 mov	 rsi, QWORD PTR tv275[rbp]
  00973	48 89 b4 24 28
	01 00 00	 mov	 QWORD PTR [rsp+296], rsi
  0097b	48 8b b5 90 06
	00 00		 mov	 rsi, QWORD PTR tv280[rbp]
  00982	48 89 b4 24 20
	01 00 00	 mov	 QWORD PTR [rsp+288], rsi
  0098a	48 8b b5 98 06
	00 00		 mov	 rsi, QWORD PTR tv285[rbp]
  00991	48 89 b4 24 18
	01 00 00	 mov	 QWORD PTR [rsp+280], rsi
  00999	48 8b b5 68 03
	00 00		 mov	 rsi, QWORD PTR column$7[rbp]
  009a0	8b 36		 mov	 esi, DWORD PTR [rsi]
  009a2	89 b4 24 10 01
	00 00		 mov	 DWORD PTR [rsp+272], esi
  009a9	48 8b b5 68 03
	00 00		 mov	 rsi, QWORD PTR column$7[rbp]
  009b0	8b 76 30	 mov	 esi, DWORD PTR [rsi+48]
  009b3	89 b4 24 08 01
	00 00		 mov	 DWORD PTR [rsp+264], esi
  009ba	48 8b b5 a0 06
	00 00		 mov	 rsi, QWORD PTR tv300[rbp]
  009c1	48 89 b4 24 00
	01 00 00	 mov	 QWORD PTR [rsp+256], rsi
  009c9	89 84 24 f8 00
	00 00		 mov	 DWORD PTR [rsp+248], eax
  009d0	f2 0f 11 84 24
	f0 00 00 00	 movsd	 QWORD PTR [rsp+240], xmm0
  009d9	f2 0f 11 8c 24
	e8 00 00 00	 movsd	 QWORD PTR [rsp+232], xmm1
  009e2	f2 0f 11 94 24
	e0 00 00 00	 movsd	 QWORD PTR [rsp+224], xmm2
  009eb	f2 0f 11 9c 24
	d8 00 00 00	 movsd	 QWORD PTR [rsp+216], xmm3
  009f4	f2 0f 11 a4 24
	d0 00 00 00	 movsd	 QWORD PTR [rsp+208], xmm4
  009fd	f2 0f 11 ac 24
	c8 00 00 00	 movsd	 QWORD PTR [rsp+200], xmm5
  00a06	f2 0f 11 b4 24
	c0 00 00 00	 movsd	 QWORD PTR [rsp+192], xmm6
  00a0f	f2 0f 11 bc 24
	b8 00 00 00	 movsd	 QWORD PTR [rsp+184], xmm7
  00a18	f2 44 0f 11 84
	24 b0 00 00 00	 movsd	 QWORD PTR [rsp+176], xmm8
  00a22	f2 44 0f 11 8c
	24 a8 00 00 00	 movsd	 QWORD PTR [rsp+168], xmm9
  00a2c	f2 44 0f 11 94
	24 a0 00 00 00	 movsd	 QWORD PTR [rsp+160], xmm10
  00a36	f2 44 0f 11 9c
	24 98 00 00 00	 movsd	 QWORD PTR [rsp+152], xmm11
  00a40	f2 44 0f 11 a4
	24 90 00 00 00	 movsd	 QWORD PTR [rsp+144], xmm12
  00a4a	f2 44 0f 11 ac
	24 88 00 00 00	 movsd	 QWORD PTR [rsp+136], xmm13
  00a54	f2 44 0f 11 b4
	24 80 00 00 00	 movsd	 QWORD PTR [rsp+128], xmm14
  00a5e	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00a62	89 54 24 70	 mov	 DWORD PTR [rsp+112], edx
  00a66	44 89 44 24 68	 mov	 DWORD PTR [rsp+104], r8d
  00a6b	44 89 4c 24 60	 mov	 DWORD PTR [rsp+96], r9d
  00a70	44 89 54 24 58	 mov	 DWORD PTR [rsp+88], r10d
  00a75	44 89 5c 24 50	 mov	 DWORD PTR [rsp+80], r11d
  00a7a	89 5c 24 48	 mov	 DWORD PTR [rsp+72], ebx
  00a7e	48 8b 85 b8 06
	00 00		 mov	 rax, QWORD PTR tv399[rbp]
  00a85	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00a8a	f2 0f 10 85 c0
	06 00 00	 movsd	 xmm0, QWORD PTR tv406[rbp]
  00a92	f2 0f 11 44 24
	38		 movsd	 QWORD PTR [rsp+56], xmm0
  00a98	f2 44 0f 11 7c
	24 30		 movsd	 QWORD PTR [rsp+48], xmm15
  00a9f	48 8b 85 88 03
	00 00		 mov	 rax, QWORD PTR name$8[rbp]
  00aa6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00aab	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00aaf	44 8b 8d 44 03
	00 00		 mov	 r9d, DWORD PTR n$6[rbp]
  00ab6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BHH@CNHMONCM@Column?5?$CFd?5order?5?$CFd?5?8?$CFs?8?3?5offset?5@
  00abd	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00ac2	48 8d 4d 50	 lea	 rcx, QWORD PTR buf$[rbp]
  00ac6	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPEAD_KPEBDZZ ; ImFormatString

; 3607 :             "Column %d order %d '%s': offset %+.2f to %+.2f%s\n"
; 3608 :             "Enabled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d, DrawChannels: %d,%d\n"
; 3609 :             "WidthGiven: %.1f, Request/Auto: %.1f/%.1f, StretchWeight: %.3f (%.1f%%)\n"
; 3610 :             "MinX: %.1f, MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)\n"
; 3611 :             "ContentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f\n"
; 3612 :             "Sort: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..",
; 3613 :             n, column->DisplayOrder, name, column->MinX - table->WorkRect.Min.x, column->MaxX - table->WorkRect.Min.x, (n < table->FreezeColumnsRequest) ? " (Frozen)" : "",
; 3614 :             column->IsEnabled, column->IsVisibleX, column->IsVisibleY, column->IsRequestOutput, column->IsSkipItems, column->DrawChannelFrozen, column->DrawChannelUnfrozen,
; 3615 :             column->WidthGiven, column->WidthRequest, column->WidthAuto, column->StretchWeight, column->StretchWeight > 0.0f ? (column->StretchWeight / sum_weights) * 100.0f : 0.0f,
; 3616 :             column->MinX, column->MaxX, column->MaxX - column->MinX, column->ClipRect.Min.x, column->ClipRect.Max.x, column->ClipRect.Max.x - column->ClipRect.Min.x,
; 3617 :             column->ContentMaxXFrozen - column->WorkMinX, column->ContentMaxXUnfrozen - column->WorkMinX, column->ContentMaxXHeadersUsed - column->WorkMinX, column->ContentMaxXHeadersIdeal - column->WorkMinX,
; 3618 :             column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? " (Asc)" : (column->SortDirection == ImGuiSortDirection_Descending) ? " (Des)" : "", column->UserID, column->Flags,
; 3619 :             (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? "WidthStretch " : "",
; 3620 :             (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? "WidthFixed " : "",
; 3621 :             (column->Flags & ImGuiTableColumnFlags_NoResize) ? "NoResize " : "");
; 3622 :         Bullet();

  00acb	e8 00 00 00 00	 call	 ?Bullet@ImGui@@YAXXZ	; ImGui::Bullet

; 3623 :         Selectable(buf);

  00ad0	0f 57 d2	 xorps	 xmm2, xmm2
  00ad3	0f 57 c9	 xorps	 xmm1, xmm1
  00ad6	48 8d 8d 74 06
	00 00		 lea	 rcx, QWORD PTR $T13[rbp]
  00add	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00ae2	4c 8b c8	 mov	 r9, rax
  00ae5	45 33 c0	 xor	 r8d, r8d
  00ae8	33 d2		 xor	 edx, edx
  00aea	48 8d 4d 50	 lea	 rcx, QWORD PTR buf$[rbp]
  00aee	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable

; 3624 :         if (IsItemHovered())

  00af3	33 c9		 xor	 ecx, ecx
  00af5	e8 00 00 00 00	 call	 ?IsItemHovered@ImGui@@YA_NH@Z ; ImGui::IsItemHovered
  00afa	0f b6 c0	 movzx	 eax, al
  00afd	85 c0		 test	 eax, eax
  00aff	0f 84 88 00 00
	00		 je	 $LN15@DebugNodeT

; 3625 :         {
; 3626 :             ImRect r(column->MinX, table->OuterRect.Min.y, column->MaxX, table->OuterRect.Max.y);

  00b05	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00b0c	f3 0f 10 80 f4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+244]
  00b14	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00b1a	48 8b 85 68 03
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  00b21	f3 0f 10 58 0c	 movss	 xmm3, DWORD PTR [rax+12]
  00b26	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00b2d	f3 0f 10 90 ec
	00 00 00	 movss	 xmm2, DWORD PTR [rax+236]
  00b35	48 8b 85 68 03
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  00b3c	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  00b41	48 8d 8d a8 03
	00 00		 lea	 rcx, QWORD PTR r$9[rbp]
  00b48	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@MMMM@Z	; ImRect::ImRect

; 3627 :             GetForegroundDrawList()->AddRect(r.Min, r.Max, IM_COL32(255, 255, 0, 255));

  00b4d	e8 00 00 00 00	 call	 ?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@XZ ; ImGui::GetForegroundDrawList
  00b52	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b5a	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00b60	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00b68	0f 57 c0	 xorps	 xmm0, xmm0
  00b6b	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00b71	41 b9 ff ff 00
	ff		 mov	 r9d, -16711681		; ff00ffffH
  00b77	4c 8d 85 b0 03
	00 00		 lea	 r8, QWORD PTR r$9[rbp+8]
  00b7e	48 8d 95 a8 03
	00 00		 lea	 rdx, QWORD PTR r$9[rbp]
  00b85	48 8b c8	 mov	 rcx, rax
  00b88	e8 00 00 00 00	 call	 ?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
$LN15@DebugNodeT:

; 3628 :         }
; 3629 :     }

  00b8d	e9 48 fa ff ff	 jmp	 $LN5@DebugNodeT
$LN6@DebugNodeT:

; 3630 :     if (ImGuiTableSettings* settings = TableGetBoundSettings(table))

  00b92	48 8b 8d a0 07
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00b99	e8 00 00 00 00	 call	 ?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z ; ImGui::TableGetBoundSettings
  00b9e	48 89 85 d8 03
	00 00		 mov	 QWORD PTR settings$10[rbp], rax
  00ba5	48 83 bd d8 03
	00 00 00	 cmp	 QWORD PTR settings$10[rbp], 0
  00bad	74 0c		 je	 SHORT $LN16@DebugNodeT

; 3631 :         DebugNodeTableSettings(settings);

  00baf	48 8b 8d d8 03
	00 00		 mov	 rcx, QWORD PTR settings$10[rbp]
  00bb6	e8 00 00 00 00	 call	 ?DebugNodeTableSettings@ImGui@@YAXPEAUImGuiTableSettings@@@Z ; ImGui::DebugNodeTableSettings
$LN16@DebugNodeT:

; 3632 :     if (clear_settings)

  00bbb	0f b6 85 e4 02
	00 00		 movzx	 eax, BYTE PTR clear_settings$[rbp]
  00bc2	85 c0		 test	 eax, eax
  00bc4	74 0e		 je	 SHORT $LN17@DebugNodeT

; 3633 :         table->IsResetAllRequest = true;

  00bc6	48 8b 85 a0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00bcd	c6 80 2b 02 00
	00 01		 mov	 BYTE PTR [rax+555], 1
$LN17@DebugNodeT:

; 3634 :     TreePop();

  00bd4	e8 00 00 00 00	 call	 ?TreePop@ImGui@@YAXXZ	; ImGui::TreePop
$LN1@DebugNodeT:

; 3635 : }

  00bd9	48 8d 8d 10 ff
	ff ff		 lea	 rcx, QWORD PTR [rbp-240]
  00be0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData
  00be7	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00bec	48 8b 8d c8 06
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00bf3	48 33 cd	 xor	 rcx, rbp
  00bf6	e8 00 00 00 00	 call	 __security_check_cookie
  00bfb	0f 28 b5 60 07
	00 00		 movaps	 xmm6, XMMWORD PTR [rbp+1888]
  00c02	0f 28 bd 50 07
	00 00		 movaps	 xmm7, XMMWORD PTR [rbp+1872]
  00c09	44 0f 28 85 40
	07 00 00	 movaps	 xmm8, XMMWORD PTR [rbp+1856]
  00c11	44 0f 28 8d 30
	07 00 00	 movaps	 xmm9, XMMWORD PTR [rbp+1840]
  00c19	44 0f 28 95 20
	07 00 00	 movaps	 xmm10, XMMWORD PTR [rbp+1824]
  00c21	44 0f 28 9d 10
	07 00 00	 movaps	 xmm11, XMMWORD PTR [rbp+1808]
  00c29	44 0f 28 a5 00
	07 00 00	 movaps	 xmm12, XMMWORD PTR [rbp+1792]
  00c31	44 0f 28 ad f0
	06 00 00	 movaps	 xmm13, XMMWORD PTR [rbp+1776]
  00c39	44 0f 28 b5 e0
	06 00 00	 movaps	 xmm14, XMMWORD PTR [rbp+1760]
  00c41	44 0f 28 bd d0
	06 00 00	 movaps	 xmm15, XMMWORD PTR [rbp+1744]
  00c49	48 8d a5 78 07
	00 00		 lea	 rsp, QWORD PTR [rbp+1912]
  00c50	5f		 pop	 rdi
  00c51	5e		 pop	 rsi
  00c52	5b		 pop	 rbx
  00c53	5d		 pop	 rbp
  00c54	c3		 ret	 0
?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z ENDP	; ImGui::DebugNodeTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z
_TEXT	SEGMENT
g$ = 8
settings$1 = 40
id$ = 288
?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z PROC ; ImGui::TableSettingsFindByID, COMDAT

; 3221 : {

$LN7:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR [rsp+328]

; 3222 :     // FIXME-OPT: Might want to store a lookup map for this?
; 3223 :     ImGuiContext& g = *GImGui;

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0002f	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3224 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

  00033	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00037	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  0003d	48 8b c8	 mov	 rcx, rax
  00040	e8 00 00 00 00	 call	 ?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::begin
  00045	48 89 45 28	 mov	 QWORD PTR settings$1[rbp], rax
  00049	eb 1a		 jmp	 SHORT $LN4@TableSetti
$LN2@TableSetti:
  0004b	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0004f	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  00055	48 8b 55 28	 mov	 rdx, QWORD PTR settings$1[rbp]
  00059	48 8b c8	 mov	 rcx, rax
  0005c	e8 00 00 00 00	 call	 ?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z ; ImChunkStream<ImGuiTableSettings>::next_chunk
  00061	48 89 45 28	 mov	 QWORD PTR settings$1[rbp], rax
$LN4@TableSetti:
  00065	48 83 7d 28 00	 cmp	 QWORD PTR settings$1[rbp], 0
  0006a	74 16		 je	 SHORT $LN3@TableSetti

; 3225 :         if (settings->ID == id)

  0006c	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  00070	8b 8d 20 01 00
	00		 mov	 ecx, DWORD PTR id$[rbp]
  00076	39 08		 cmp	 DWORD PTR [rax], ecx
  00078	75 06		 jne	 SHORT $LN5@TableSetti

; 3226 :             return settings;

  0007a	48 8b 45 28	 mov	 rax, QWORD PTR settings$1[rbp]
  0007e	eb 04		 jmp	 SHORT $LN1@TableSetti
$LN5@TableSetti:

; 3227 :     return NULL;

  00080	eb c9		 jmp	 SHORT $LN2@TableSetti
$LN3@TableSetti:
  00082	33 c0		 xor	 eax, eax
$LN1@TableSetti:

; 3228 : }

  00084	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  0008b	5f		 pop	 rdi
  0008c	5d		 pop	 rbp
  0008d	c3		 ret	 0
?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z ENDP ; ImGui::TableSettingsFindByID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z
_TEXT	SEGMENT
g$ = 8
settings$ = 40
id$ = 288
columns_count$ = 296
?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z PROC ; ImGui::TableSettingsCreate, COMDAT

; 3212 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8b fc	 mov	 rdi, rsp
  00019	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR [rsp+328]

; 3213 :     ImGuiContext& g = *GImGui;

  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00033	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3214 :     ImGuiTableSettings* settings = g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));

  00037	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR columns_count$[rbp]
  0003d	e8 00 00 00 00	 call	 ?TableSettingsCalcChunkSize@@YA_KH@Z ; TableSettingsCalcChunkSize
  00042	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00046	48 81 c1 b0 5b
	00 00		 add	 rcx, 23472		; 00005bb0H
  0004d	48 8b d0	 mov	 rdx, rax
  00050	e8 00 00 00 00	 call	 ?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z ; ImChunkStream<ImGuiTableSettings>::alloc_chunk
  00055	48 89 45 28	 mov	 QWORD PTR settings$[rbp], rax

; 3215 :     TableSettingsInit(settings, id, columns_count, columns_count);

  00059	44 8b 8d 28 01
	00 00		 mov	 r9d, DWORD PTR columns_count$[rbp]
  00060	44 8b 85 28 01
	00 00		 mov	 r8d, DWORD PTR columns_count$[rbp]
  00067	8b 95 20 01 00
	00		 mov	 edx, DWORD PTR id$[rbp]
  0006d	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  00071	e8 00 00 00 00	 call	 ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z ; TableSettingsInit

; 3216 :     return settings;

  00076	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]

; 3217 : }

  0007a	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00081	5f		 pop	 rdi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z ENDP ; ImGui::TableSettingsCreate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsAddSettingsHandler@ImGui@@YAXXZ
_TEXT	SEGMENT
ini_handler$ = 16
__$ArrayPad$ = 296
?TableSettingsAddSettingsHandler@ImGui@@YAXXZ PROC	; ImGui::TableSettingsAddSettingsHandler, COMDAT

; 3482 : {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00025	48 33 c5	 xor	 rax, rbp
  00028	48 89 85 28 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 3483 :     ImGuiSettingsHandler ini_handler;

  0002f	48 8d 4d 10	 lea	 rcx, QWORD PTR ini_handler$[rbp]
  00033	e8 00 00 00 00	 call	 ??0ImGuiSettingsHandler@@QEAA@XZ ; ImGuiSettingsHandler::ImGuiSettingsHandler

; 3484 :     ini_handler.TypeName = "Table";

  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05LFBINIGO@Table?$AA@
  0003f	48 89 45 10	 mov	 QWORD PTR ini_handler$[rbp], rax

; 3485 :     ini_handler.TypeHash = ImHashStr("Table");

  00043	45 33 c0	 xor	 r8d, r8d
  00046	33 d2		 xor	 edx, edx
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LFBINIGO@Table?$AA@
  0004f	e8 00 00 00 00	 call	 ?ImHashStr@@YAIPEBD_KI@Z ; ImHashStr
  00054	89 45 18	 mov	 DWORD PTR ini_handler$[rbp+8], eax

; 3486 :     ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;

  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z ; TableSettingsHandler_ClearAll
  0005e	48 89 45 20	 mov	 QWORD PTR ini_handler$[rbp+16], rax

; 3487 :     ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;

  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z ; TableSettingsHandler_ReadOpen
  00069	48 89 45 30	 mov	 QWORD PTR ini_handler$[rbp+32], rax

; 3488 :     ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;

  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z ; TableSettingsHandler_ReadLine
  00074	48 89 45 38	 mov	 QWORD PTR ini_handler$[rbp+40], rax

; 3489 :     ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;

  00078	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z ; TableSettingsHandler_ApplyAll
  0007f	48 89 45 40	 mov	 QWORD PTR ini_handler$[rbp+48], rax

; 3490 :     ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;

  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z ; TableSettingsHandler_WriteAll
  0008a	48 89 45 48	 mov	 QWORD PTR ini_handler$[rbp+56], rax

; 3491 :     AddSettingsHandler(&ini_handler);

  0008e	48 8d 4d 10	 lea	 rcx, QWORD PTR ini_handler$[rbp]
  00092	e8 00 00 00 00	 call	 ?AddSettingsHandler@ImGui@@YAXPEBUImGuiSettingsHandler@@@Z ; ImGui::AddSettingsHandler

; 3492 : }

  00097	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableSettingsAddSettingsHandler@ImGui@@YAXXZ$rtcFrameData
  000a2	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a7	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000ae	48 33 cd	 xor	 rcx, rbp
  000b1	e8 00 00 00 00	 call	 __security_check_cookie
  000b6	48 8d a5 38 01
	00 00		 lea	 rsp, QWORD PTR [rbp+312]
  000bd	5f		 pop	 rdi
  000be	5d		 pop	 rbp
  000bf	c3		 ret	 0
?TableSettingsAddSettingsHandler@ImGui@@YAXXZ ENDP	; ImGui::TableSettingsAddSettingsHandler
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z
_TEXT	SEGMENT
g$1 = 8
settings$2 = 40
table$ = 288
?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z PROC ; ImGui::TableGetBoundSettings, COMDAT

; 3232 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]

; 3233 :     if (table->SettingsOffset != -1)

  0002a	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00031	83 78 64 ff	 cmp	 DWORD PTR [rax+100], -1
  00035	0f 84 82 00 00
	00		 je	 $LN2@TableGetBo

; 3234 :     {
; 3235 :         ImGuiContext& g = *GImGui;

  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00042	48 89 45 08	 mov	 QWORD PTR g$1[rbp], rax

; 3236 :         ImGuiTableSettings* settings = g.SettingsTables.ptr_from_offset(table->SettingsOffset);

  00046	48 8b 45 08	 mov	 rax, QWORD PTR g$1[rbp]
  0004a	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  00050	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00057	8b 51 64	 mov	 edx, DWORD PTR [rcx+100]
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	e8 00 00 00 00	 call	 ?ptr_from_offset@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@H@Z ; ImChunkStream<ImGuiTableSettings>::ptr_from_offset
  00062	48 89 45 28	 mov	 QWORD PTR settings$2[rbp], rax

; 3237 :         IM_ASSERT(settings->ID == table->ID);

  00066	48 8b 45 28	 mov	 rax, QWORD PTR settings$2[rbp]
  0006a	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00071	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00073	39 08		 cmp	 DWORD PTR [rax], ecx
  00075	74 22		 je	 SHORT $LN5@TableGetBo
  00077	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z@4JA
  0007d	83 c0 05	 add	 eax, 5
  00080	44 8b c0	 mov	 r8d, eax
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@KGKHJKNP@?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAD?$AA?$AA@
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00097	33 c0		 xor	 eax, eax
$LN5@TableGetBo:

; 3238 :         if (settings->ColumnsCountMax >= table->ColumnsCount)

  00099	48 8b 45 28	 mov	 rax, QWORD PTR settings$2[rbp]
  0009d	0f bf 40 0e	 movsx	 eax, WORD PTR [rax+14]
  000a1	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000a8	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  000ab	7c 06		 jl	 SHORT $LN3@TableGetBo

; 3239 :             return settings; // OK

  000ad	48 8b 45 28	 mov	 rax, QWORD PTR settings$2[rbp]
  000b1	eb 0c		 jmp	 SHORT $LN1@TableGetBo
$LN3@TableGetBo:

; 3240 :         settings->ID = 0; // Invalidate storage, we won't fit because of a count change

  000b3	48 8b 45 28	 mov	 rax, QWORD PTR settings$2[rbp]
  000b7	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN2@TableGetBo:

; 3241 :     }
; 3242 :     return NULL;

  000bd	33 c0		 xor	 eax, eax
$LN1@TableGetBo:

; 3243 : }

  000bf	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000c6	5f		 pop	 rdi
  000c7	5d		 pop	 rbp
  000c8	c3		 ret	 0
?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z ENDP ; ImGui::TableGetBoundSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableResetSettings@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
table$ = 224
?TableResetSettings@ImGui@@YAXPEAUImGuiTable@@@Z PROC	; ImGui::TableResetSettings, COMDAT

; 3247 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]

; 3248 :     table->IsInitializing = table->IsSettingsDirty = true;

  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0002f	c6 80 29 02 00
	00 01		 mov	 BYTE PTR [rax+553], 1
  00036	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0003d	c6 80 24 02 00
	00 01		 mov	 BYTE PTR [rax+548], 1

; 3249 :     table->IsResetAllRequest = false;

  00044	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0004b	c6 80 2b 02 00
	00 00		 mov	 BYTE PTR [rax+555], 0

; 3250 :     table->IsSettingsRequestLoad = false;                   // Don't reload from ini

  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00059	c6 80 28 02 00
	00 00		 mov	 BYTE PTR [rax+552], 0

; 3251 :     table->SettingsLoadedFlags = ImGuiTableFlags_None;      // Mark as nothing loaded so our initialized data becomes authoritative

  00060	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00067	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [rax+96], 0

; 3252 : }

  0006e	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00075	5f		 pop	 rdi
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
?TableResetSettings@ImGui@@YAXPEAUImGuiTable@@@Z ENDP	; ImGui::TableResetSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
g$ = 8
settings$ = 40
column$ = 72
column_settings$ = 104
save_ref_scale$ = 132
n$1 = 164
width_or_weight$2 = 196
tv222 = 404
tv209 = 404
tv177 = 404
tv152 = 404
table$ = 448
?TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z PROC	; ImGui::TableSaveSettings, COMDAT

; 3255 : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 72 00 00 00	 mov	 ecx, 114		; 00000072H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+488]

; 3256 :     table->IsSettingsDirty = false;

  0002a	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00031	c6 80 29 02 00
	00 00		 mov	 BYTE PTR [rax+553], 0

; 3257 :     if (table->Flags & ImGuiTableFlags_NoSavedSettings)

  00038	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0003f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00042	83 e0 10	 and	 eax, 16
  00045	85 c0		 test	 eax, eax
  00047	74 05		 je	 SHORT $LN5@TableSaveS

; 3258 :         return;

  00049	e9 91 03 00 00	 jmp	 $LN1@TableSaveS
$LN5@TableSaveS:

; 3259 : 
; 3260 :     // Bind or create settings data
; 3261 :     ImGuiContext& g = *GImGui;

  0004e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00055	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3262 :     ImGuiTableSettings* settings = TableGetBoundSettings(table);

  00059	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00060	e8 00 00 00 00	 call	 ?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z ; ImGui::TableGetBoundSettings
  00065	48 89 45 28	 mov	 QWORD PTR settings$[rbp], rax

; 3263 :     if (settings == NULL)

  00069	48 83 7d 28 00	 cmp	 QWORD PTR settings$[rbp], 0
  0006e	75 3c		 jne	 SHORT $LN6@TableSaveS

; 3264 :     {
; 3265 :         settings = TableSettingsCreate(table->ID, table->ColumnsCount);

  00070	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00077	8b 50 6c	 mov	 edx, DWORD PTR [rax+108]
  0007a	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00081	8b 08		 mov	 ecx, DWORD PTR [rax]
  00083	e8 00 00 00 00	 call	 ?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z ; ImGui::TableSettingsCreate
  00088	48 89 45 28	 mov	 QWORD PTR settings$[rbp], rax

; 3266 :         table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);

  0008c	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00090	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  00096	48 8b 55 28	 mov	 rdx, QWORD PTR settings$[rbp]
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 ?offset_from_ptr@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z ; ImChunkStream<ImGuiTableSettings>::offset_from_ptr
  000a2	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000a9	89 41 64	 mov	 DWORD PTR [rcx+100], eax
$LN6@TableSaveS:

; 3267 :     }
; 3268 :     settings->ColumnsCount = (ImGuiTableColumnIdx)table->ColumnsCount;

  000ac	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  000b0	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000b7	0f b7 49 6c	 movzx	 ecx, WORD PTR [rcx+108]
  000bb	66 89 48 0c	 mov	 WORD PTR [rax+12], cx

; 3269 : 
; 3270 :     // Serialize ImGuiTable/ImGuiTableColumn into ImGuiTableSettings/ImGuiTableColumnSettings
; 3271 :     IM_ASSERT(settings->ID == table->ID);

  000bf	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  000c3	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000ca	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000cc	39 08		 cmp	 DWORD PTR [rax], ecx
  000ce	74 22		 je	 SHORT $LN13@TableSaveS
  000d0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  000d6	83 c0 10	 add	 eax, 16
  000d9	44 8b c0	 mov	 r8d, eax
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@KGKHJKNP@?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAD?$AA?$AA@
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f0	33 c0		 xor	 eax, eax
$LN13@TableSaveS:

; 3272 :     IM_ASSERT(settings->ColumnsCount == table->ColumnsCount && settings->ColumnsCountMax >= settings->ColumnsCount);

  000f2	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  000f6	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  000fa	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00101	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  00104	75 14		 jne	 SHORT $LN14@TableSaveS
  00106	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  0010a	0f bf 40 0e	 movsx	 eax, WORD PTR [rax+14]
  0010e	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  00112	0f bf 49 0c	 movsx	 ecx, WORD PTR [rcx+12]
  00116	3b c1		 cmp	 eax, ecx
  00118	7d 22		 jge	 SHORT $LN15@TableSaveS
$LN14@TableSaveS:
  0011a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00120	83 c0 11	 add	 eax, 17
  00123	44 8b c0	 mov	 r8d, eax
  00126	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1MK@NEOBPBEE@?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9@
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0013a	33 c0		 xor	 eax, eax
$LN15@TableSaveS:

; 3273 :     ImGuiTableColumn* column = table->Columns.Data;

  0013c	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00143	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00147	48 89 45 48	 mov	 QWORD PTR column$[rbp], rax

; 3274 :     ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();

  0014b	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  0014f	e8 00 00 00 00	 call	 ?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ ; ImGuiTableSettings::GetColumnSettings
  00154	48 89 45 68	 mov	 QWORD PTR column_settings$[rbp], rax

; 3275 : 
; 3276 :     bool save_ref_scale = false;

  00158	c6 85 84 00 00
	00 00		 mov	 BYTE PTR save_ref_scale$[rbp], 0

; 3277 :     settings->SaveFlags = ImGuiTableFlags_None;

  0015f	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  00163	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 3278 :     for (int n = 0; n < table->ColumnsCount; n++, column++, column_settings++)

  0016a	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR n$1[rbp], 0
  00174	eb 26		 jmp	 SHORT $LN4@TableSaveS
$LN2@TableSaveS:
  00176	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR n$1[rbp]
  0017c	ff c0		 inc	 eax
  0017e	89 85 a4 00 00
	00		 mov	 DWORD PTR n$1[rbp], eax
  00184	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  00188	48 83 c0 70	 add	 rax, 112		; 00000070H
  0018c	48 89 45 48	 mov	 QWORD PTR column$[rbp], rax
  00190	48 8b 45 68	 mov	 rax, QWORD PTR column_settings$[rbp]
  00194	48 83 c0 10	 add	 rax, 16
  00198	48 89 45 68	 mov	 QWORD PTR column_settings$[rbp], rax
$LN4@TableSaveS:
  0019c	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001a3	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  001a6	39 85 a4 00 00
	00		 cmp	 DWORD PTR n$1[rbp], eax
  001ac	0f 8d ce 01 00
	00		 jge	 $LN3@TableSaveS

; 3279 :     {
; 3280 :         const float width_or_weight = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? column->StretchWeight : column->WidthRequest;

  001b2	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  001b6	8b 00		 mov	 eax, DWORD PTR [rax]
  001b8	83 e0 08	 and	 eax, 8
  001bb	85 c0		 test	 eax, eax
  001bd	74 13		 je	 SHORT $LN16@TableSaveS
  001bf	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  001c3	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  001c8	f3 0f 11 85 94
	01 00 00	 movss	 DWORD PTR tv152[rbp], xmm0
  001d0	eb 11		 jmp	 SHORT $LN17@TableSaveS
$LN16@TableSaveS:
  001d2	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  001d6	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  001db	f3 0f 11 85 94
	01 00 00	 movss	 DWORD PTR tv152[rbp], xmm0
$LN17@TableSaveS:
  001e3	f3 0f 10 85 94
	01 00 00	 movss	 xmm0, DWORD PTR tv152[rbp]
  001eb	f3 0f 11 85 c4
	00 00 00	 movss	 DWORD PTR width_or_weight$2[rbp], xmm0

; 3281 :         column_settings->WidthOrWeight = width_or_weight;

  001f3	48 8b 45 68	 mov	 rax, QWORD PTR column_settings$[rbp]
  001f7	f3 0f 10 85 c4
	00 00 00	 movss	 xmm0, DWORD PTR width_or_weight$2[rbp]
  001ff	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 3282 :         column_settings->Index = (ImGuiTableColumnIdx)n;

  00203	48 8b 45 68	 mov	 rax, QWORD PTR column_settings$[rbp]
  00207	0f b7 8d a4 00
	00 00		 movzx	 ecx, WORD PTR n$1[rbp]
  0020e	66 89 48 08	 mov	 WORD PTR [rax+8], cx

; 3283 :         column_settings->DisplayOrder = column->DisplayOrder;

  00212	48 8b 45 68	 mov	 rax, QWORD PTR column_settings$[rbp]
  00216	48 8b 4d 48	 mov	 rcx, QWORD PTR column$[rbp]
  0021a	0f b7 49 52	 movzx	 ecx, WORD PTR [rcx+82]
  0021e	66 89 48 0a	 mov	 WORD PTR [rax+10], cx

; 3284 :         column_settings->SortOrder = column->SortOrder;

  00222	48 8b 45 68	 mov	 rax, QWORD PTR column_settings$[rbp]
  00226	48 8b 4d 48	 mov	 rcx, QWORD PTR column$[rbp]
  0022a	0f b7 49 5a	 movzx	 ecx, WORD PTR [rcx+90]
  0022e	66 89 48 0c	 mov	 WORD PTR [rax+12], cx

; 3285 :         column_settings->SortDirection = column->SortDirection;

  00232	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  00236	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  0023a	24 03		 and	 al, 3
  0023c	24 03		 and	 al, 3
  0023e	48 8b 4d 68	 mov	 rcx, QWORD PTR column_settings$[rbp]
  00242	0f b6 49 0e	 movzx	 ecx, BYTE PTR [rcx+14]
  00246	80 e1 fc	 and	 cl, 252			; 000000fcH
  00249	0a c8		 or	 cl, al
  0024b	0f b6 c1	 movzx	 eax, cl
  0024e	48 8b 4d 68	 mov	 rcx, QWORD PTR column_settings$[rbp]
  00252	88 41 0e	 mov	 BYTE PTR [rcx+14], al

; 3286 :         column_settings->IsEnabled = column->IsUserEnabled;

  00255	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  00259	0f b6 40 63	 movzx	 eax, BYTE PTR [rax+99]
  0025d	24 01		 and	 al, 1
  0025f	c0 e0 02	 shl	 al, 2
  00262	48 8b 4d 68	 mov	 rcx, QWORD PTR column_settings$[rbp]
  00266	0f b6 49 0e	 movzx	 ecx, BYTE PTR [rcx+14]
  0026a	80 e1 fb	 and	 cl, 251			; 000000fbH
  0026d	0a c8		 or	 cl, al
  0026f	0f b6 c1	 movzx	 eax, cl
  00272	48 8b 4d 68	 mov	 rcx, QWORD PTR column_settings$[rbp]
  00276	88 41 0e	 mov	 BYTE PTR [rcx+14], al

; 3287 :         column_settings->IsStretch = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? 1 : 0;

  00279	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  0027d	8b 00		 mov	 eax, DWORD PTR [rax]
  0027f	83 e0 08	 and	 eax, 8
  00282	85 c0		 test	 eax, eax
  00284	74 0c		 je	 SHORT $LN18@TableSaveS
  00286	c7 85 94 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv177[rbp], 1
  00290	eb 0a		 jmp	 SHORT $LN19@TableSaveS
$LN18@TableSaveS:
  00292	c7 85 94 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv177[rbp], 0
$LN19@TableSaveS:
  0029c	0f b6 85 94 01
	00 00		 movzx	 eax, BYTE PTR tv177[rbp]
  002a3	24 01		 and	 al, 1
  002a5	c0 e0 03	 shl	 al, 3
  002a8	48 8b 4d 68	 mov	 rcx, QWORD PTR column_settings$[rbp]
  002ac	0f b6 49 0e	 movzx	 ecx, BYTE PTR [rcx+14]
  002b0	80 e1 f7	 and	 cl, 247			; 000000f7H
  002b3	0a c8		 or	 cl, al
  002b5	0f b6 c1	 movzx	 eax, cl
  002b8	48 8b 4d 68	 mov	 rcx, QWORD PTR column_settings$[rbp]
  002bc	88 41 0e	 mov	 BYTE PTR [rcx+14], al

; 3288 :         if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) == 0)

  002bf	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  002c3	8b 00		 mov	 eax, DWORD PTR [rax]
  002c5	83 e0 08	 and	 eax, 8
  002c8	85 c0		 test	 eax, eax
  002ca	75 07		 jne	 SHORT $LN7@TableSaveS

; 3289 :             save_ref_scale = true;

  002cc	c6 85 84 00 00
	00 01		 mov	 BYTE PTR save_ref_scale$[rbp], 1
$LN7@TableSaveS:

; 3290 : 
; 3291 :         // We skip saving some data in the .ini file when they are unnecessary to restore our state.
; 3292 :         // Note that fixed width where initial width was derived from auto-fit will always be saved as InitStretchWeightOrWidth will be 0.0f.
; 3293 :         // FIXME-TABLE: We don't have logic to easily compare SortOrder to DefaultSortOrder yet so it's always saved when present.
; 3294 :         if (width_or_weight != column->InitStretchWeightOrWidth)

  002d3	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  002d7	f3 0f 10 85 c4
	00 00 00	 movss	 xmm0, DWORD PTR width_or_weight$2[rbp]
  002df	0f 2e 40 1c	 ucomiss xmm0, DWORD PTR [rax+28]
  002e3	7a 02		 jp	 SHORT $LN24@TableSaveS
  002e5	74 11		 je	 SHORT $LN8@TableSaveS
$LN24@TableSaveS:

; 3295 :             settings->SaveFlags |= ImGuiTableFlags_Resizable;

  002e7	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  002eb	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002ee	83 c8 01	 or	 eax, 1
  002f1	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  002f5	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN8@TableSaveS:

; 3296 :         if (column->DisplayOrder != n)

  002f8	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  002fc	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  00300	3b 85 a4 00 00
	00		 cmp	 eax, DWORD PTR n$1[rbp]
  00306	74 11		 je	 SHORT $LN9@TableSaveS

; 3297 :             settings->SaveFlags |= ImGuiTableFlags_Reorderable;

  00308	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  0030c	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0030f	83 c8 02	 or	 eax, 2
  00312	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  00316	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN9@TableSaveS:

; 3298 :         if (column->SortOrder != -1)

  00319	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  0031d	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  00321	83 f8 ff	 cmp	 eax, -1
  00324	74 11		 je	 SHORT $LN10@TableSaveS

; 3299 :             settings->SaveFlags |= ImGuiTableFlags_Sortable;

  00326	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  0032a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0032d	83 c8 08	 or	 eax, 8
  00330	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  00334	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN10@TableSaveS:

; 3300 :         if (column->IsUserEnabled != ((column->Flags & ImGuiTableColumnFlags_DefaultHide) == 0))

  00337	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  0033b	8b 00		 mov	 eax, DWORD PTR [rax]
  0033d	83 e0 02	 and	 eax, 2
  00340	85 c0		 test	 eax, eax
  00342	75 0c		 jne	 SHORT $LN20@TableSaveS
  00344	c7 85 94 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv209[rbp], 1
  0034e	eb 0a		 jmp	 SHORT $LN21@TableSaveS
$LN20@TableSaveS:
  00350	c7 85 94 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv209[rbp], 0
$LN21@TableSaveS:
  0035a	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  0035e	0f b6 40 63	 movzx	 eax, BYTE PTR [rax+99]
  00362	3b 85 94 01 00
	00		 cmp	 eax, DWORD PTR tv209[rbp]
  00368	74 11		 je	 SHORT $LN11@TableSaveS

; 3301 :             settings->SaveFlags |= ImGuiTableFlags_Hideable;

  0036a	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  0036e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00371	83 c8 04	 or	 eax, 4
  00374	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  00378	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN11@TableSaveS:

; 3302 :     }

  0037b	e9 f6 fd ff ff	 jmp	 $LN2@TableSaveS
$LN3@TableSaveS:

; 3303 :     settings->SaveFlags &= table->Flags;

  00380	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  00384	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0038b	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0038e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00391	23 c1		 and	 eax, ecx
  00393	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  00397	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 3304 :     settings->RefScale = save_ref_scale ? table->RefScale : 0.0f;

  0039a	0f b6 85 84 00
	00 00		 movzx	 eax, BYTE PTR save_ref_scale$[rbp]
  003a1	85 c0		 test	 eax, eax
  003a3	74 19		 je	 SHORT $LN22@TableSaveS
  003a5	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003ac	f3 0f 10 80 e4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+228]
  003b4	f3 0f 11 85 94
	01 00 00	 movss	 DWORD PTR tv222[rbp], xmm0
  003bc	eb 0b		 jmp	 SHORT $LN23@TableSaveS
$LN22@TableSaveS:
  003be	0f 57 c0	 xorps	 xmm0, xmm0
  003c1	f3 0f 11 85 94
	01 00 00	 movss	 DWORD PTR tv222[rbp], xmm0
$LN23@TableSaveS:
  003c9	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  003cd	f3 0f 10 85 94
	01 00 00	 movss	 xmm0, DWORD PTR tv222[rbp]
  003d5	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 3305 : 
; 3306 :     MarkIniSettingsDirty();

  003da	e8 00 00 00 00	 call	 ?MarkIniSettingsDirty@ImGui@@YAXXZ ; ImGui::MarkIniSettingsDirty
$LN1@TableSaveS:

; 3307 : }

  003df	48 8d a5 a8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+424]
  003e6	5f		 pop	 rdi
  003e7	5d		 pop	 rbp
  003e8	c3		 ret	 0
?TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z ENDP	; ImGui::TableSaveSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableLoadSettings@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
g$ = 8
settings$ = 40
column_settings$ = 72
display_order_mask$ = 104
data_n$1 = 132
column_n$2 = 164
column$3 = 200
expected_display_order_mask$ = 232
column_n$4 = 260
column_n$5 = 292
tv165 = 500
tv262 = 504
tv182 = 504
tv285 = 512
table$ = 560
?TableLoadSettings@ImGui@@YAXPEAUImGuiTable@@@Z PROC	; ImGui::TableLoadSettings, COMDAT

; 3310 : {

$LN27:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 38 02
	00 00		 sub	 rsp, 568		; 00000238H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 8e 00 00 00	 mov	 ecx, 142		; 0000008eH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 58
	02 00 00	 mov	 rcx, QWORD PTR [rsp+600]

; 3311 :     ImGuiContext& g = *GImGui;

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00031	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3312 :     table->IsSettingsRequestLoad = false;

  00035	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0003c	c6 80 28 02 00
	00 00		 mov	 BYTE PTR [rax+552], 0

; 3313 :     if (table->Flags & ImGuiTableFlags_NoSavedSettings)

  00043	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0004a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0004d	83 e0 10	 and	 eax, 16
  00050	85 c0		 test	 eax, eax
  00052	74 05		 je	 SHORT $LN11@TableLoadS

; 3314 :         return;

  00054	e9 8f 03 00 00	 jmp	 $LN1@TableLoadS
$LN11@TableLoadS:

; 3315 : 
; 3316 :     // Bind settings
; 3317 :     ImGuiTableSettings* settings;
; 3318 :     if (table->SettingsOffset == -1)

  00059	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00060	83 78 64 ff	 cmp	 DWORD PTR [rax+100], -1
  00064	75 62		 jne	 SHORT $LN12@TableLoadS

; 3319 :     {
; 3320 :         settings = TableSettingsFindByID(table->ID);

  00066	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0006f	e8 00 00 00 00	 call	 ?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z ; ImGui::TableSettingsFindByID
  00074	48 89 45 28	 mov	 QWORD PTR settings$[rbp], rax

; 3321 :         if (settings == NULL)

  00078	48 83 7d 28 00	 cmp	 QWORD PTR settings$[rbp], 0
  0007d	75 05		 jne	 SHORT $LN14@TableLoadS

; 3322 :             return;

  0007f	e9 64 03 00 00	 jmp	 $LN1@TableLoadS
$LN14@TableLoadS:

; 3323 :         if (settings->ColumnsCount != table->ColumnsCount) // Allow settings if columns count changed. We could otherwise decide to return...

  00084	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  00088	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  0008c	48 8b 8d 30 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00093	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  00096	74 0e		 je	 SHORT $LN15@TableLoadS

; 3324 :             table->IsSettingsDirty = true;

  00098	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0009f	c6 80 29 02 00
	00 01		 mov	 BYTE PTR [rax+553], 1
$LN15@TableLoadS:

; 3325 :         table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);

  000a6	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  000aa	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  000b0	48 8b 55 28	 mov	 rdx, QWORD PTR settings$[rbp]
  000b4	48 8b c8	 mov	 rcx, rax
  000b7	e8 00 00 00 00	 call	 ?offset_from_ptr@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z ; ImChunkStream<ImGuiTableSettings>::offset_from_ptr
  000bc	48 8b 8d 30 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000c3	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 3326 :     }
; 3327 :     else

  000c6	eb 10		 jmp	 SHORT $LN13@TableLoadS
$LN12@TableLoadS:

; 3328 :     {
; 3329 :         settings = TableGetBoundSettings(table);

  000c8	48 8b 8d 30 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000cf	e8 00 00 00 00	 call	 ?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z ; ImGui::TableGetBoundSettings
  000d4	48 89 45 28	 mov	 QWORD PTR settings$[rbp], rax
$LN13@TableLoadS:

; 3330 :     }
; 3331 : 
; 3332 :     table->SettingsLoadedFlags = settings->SaveFlags;

  000d8	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000df	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  000e3	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000e6	89 48 60	 mov	 DWORD PTR [rax+96], ecx

; 3333 :     table->RefScale = settings->RefScale;

  000e9	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000f0	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  000f4	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [rcx+8]
  000f9	f3 0f 11 80 e4
	00 00 00	 movss	 DWORD PTR [rax+228], xmm0

; 3334 : 
; 3335 :     // Serialize ImGuiTableSettings/ImGuiTableColumnSettings into ImGuiTable/ImGuiTableColumn
; 3336 :     ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();

  00101	48 8b 4d 28	 mov	 rcx, QWORD PTR settings$[rbp]
  00105	e8 00 00 00 00	 call	 ?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ ; ImGuiTableSettings::GetColumnSettings
  0010a	48 89 45 48	 mov	 QWORD PTR column_settings$[rbp], rax

; 3337 :     ImU64 display_order_mask = 0;

  0010e	48 c7 45 68 00
	00 00 00	 mov	 QWORD PTR display_order_mask$[rbp], 0

; 3338 :     for (int data_n = 0; data_n < settings->ColumnsCount; data_n++, column_settings++)

  00116	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR data_n$1[rbp], 0
  00120	eb 1a		 jmp	 SHORT $LN4@TableLoadS
$LN2@TableLoadS:
  00122	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR data_n$1[rbp]
  00128	ff c0		 inc	 eax
  0012a	89 85 84 00 00
	00		 mov	 DWORD PTR data_n$1[rbp], eax
  00130	48 8b 45 48	 mov	 rax, QWORD PTR column_settings$[rbp]
  00134	48 83 c0 10	 add	 rax, 16
  00138	48 89 45 48	 mov	 QWORD PTR column_settings$[rbp], rax
$LN4@TableLoadS:
  0013c	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  00140	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  00144	39 85 84 00 00
	00		 cmp	 DWORD PTR data_n$1[rbp], eax
  0014a	0f 8d 7f 01 00
	00		 jge	 $LN3@TableLoadS

; 3339 :     {
; 3340 :         int column_n = column_settings->Index;

  00150	48 8b 45 48	 mov	 rax, QWORD PTR column_settings$[rbp]
  00154	0f bf 40 08	 movsx	 eax, WORD PTR [rax+8]
  00158	89 85 a4 00 00
	00		 mov	 DWORD PTR column_n$2[rbp], eax

; 3341 :         if (column_n < 0 || column_n >= table->ColumnsCount)

  0015e	83 bd a4 00 00
	00 00		 cmp	 DWORD PTR column_n$2[rbp], 0
  00165	7c 12		 jl	 SHORT $LN17@TableLoadS
  00167	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0016e	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00171	39 85 a4 00 00
	00		 cmp	 DWORD PTR column_n$2[rbp], eax
  00177	7c 02		 jl	 SHORT $LN16@TableLoadS
$LN17@TableLoadS:

; 3342 :             continue;

  00179	eb a7		 jmp	 SHORT $LN2@TableLoadS
$LN16@TableLoadS:

; 3343 : 
; 3344 :         ImGuiTableColumn* column = &table->Columns[column_n];

  0017b	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00182	48 83 c0 18	 add	 rax, 24
  00186	8b 95 a4 00 00
	00		 mov	 edx, DWORD PTR column_n$2[rbp]
  0018c	48 8b c8	 mov	 rcx, rax
  0018f	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00194	48 89 85 c8 00
	00 00		 mov	 QWORD PTR column$3[rbp], rax

; 3345 :         if (settings->SaveFlags & ImGuiTableFlags_Resizable)

  0019b	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  0019f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001a2	83 e0 01	 and	 eax, 1
  001a5	85 c0		 test	 eax, eax
  001a7	74 49		 je	 SHORT $LN18@TableLoadS

; 3346 :         {
; 3347 :             if (column_settings->IsStretch)

  001a9	48 8b 45 48	 mov	 rax, QWORD PTR column_settings$[rbp]
  001ad	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  001b1	c0 e8 03	 shr	 al, 3
  001b4	24 01		 and	 al, 1
  001b6	0f b6 c0	 movzx	 eax, al
  001b9	85 c0		 test	 eax, eax
  001bb	74 16		 je	 SHORT $LN19@TableLoadS

; 3348 :                 column->StretchWeight = column_settings->WidthOrWeight;

  001bd	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$3[rbp]
  001c4	48 8b 4d 48	 mov	 rcx, QWORD PTR column_settings$[rbp]
  001c8	f3 0f 10 01	 movss	 xmm0, DWORD PTR [rcx]
  001cc	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0

; 3349 :             else

  001d1	eb 14		 jmp	 SHORT $LN20@TableLoadS
$LN19@TableLoadS:

; 3350 :                 column->WidthRequest = column_settings->WidthOrWeight;

  001d3	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$3[rbp]
  001da	48 8b 4d 48	 mov	 rcx, QWORD PTR column_settings$[rbp]
  001de	f3 0f 10 01	 movss	 xmm0, DWORD PTR [rcx]
  001e2	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
$LN20@TableLoadS:

; 3351 :             column->AutoFitQueue = 0x00;

  001e7	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$3[rbp]
  001ee	c6 40 6b 00	 mov	 BYTE PTR [rax+107], 0
$LN18@TableLoadS:

; 3352 :         }
; 3353 :         if (settings->SaveFlags & ImGuiTableFlags_Reorderable)

  001f2	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  001f6	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001f9	83 e0 02	 and	 eax, 2
  001fc	85 c0		 test	 eax, eax
  001fe	74 15		 je	 SHORT $LN21@TableLoadS

; 3354 :             column->DisplayOrder = column_settings->DisplayOrder;

  00200	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$3[rbp]
  00207	48 8b 4d 48	 mov	 rcx, QWORD PTR column_settings$[rbp]
  0020b	0f b7 49 0a	 movzx	 ecx, WORD PTR [rcx+10]
  0020f	66 89 48 52	 mov	 WORD PTR [rax+82], cx

; 3355 :         else

  00213	eb 12		 jmp	 SHORT $LN22@TableLoadS
$LN21@TableLoadS:

; 3356 :             column->DisplayOrder = (ImGuiTableColumnIdx)column_n;

  00215	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$3[rbp]
  0021c	0f b7 8d a4 00
	00 00		 movzx	 ecx, WORD PTR column_n$2[rbp]
  00223	66 89 48 52	 mov	 WORD PTR [rax+82], cx
$LN22@TableLoadS:

; 3357 :         display_order_mask |= (ImU64)1 << column->DisplayOrder;

  00227	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$3[rbp]
  0022e	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  00232	b9 01 00 00 00	 mov	 ecx, 1
  00237	48 89 8d f8 01
	00 00		 mov	 QWORD PTR tv262[rbp], rcx
  0023e	0f b6 c8	 movzx	 ecx, al
  00241	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR tv262[rbp]
  00248	48 d3 e0	 shl	 rax, cl
  0024b	48 8b 4d 68	 mov	 rcx, QWORD PTR display_order_mask$[rbp]
  0024f	48 0b c8	 or	 rcx, rax
  00252	48 8b c1	 mov	 rax, rcx
  00255	48 89 45 68	 mov	 QWORD PTR display_order_mask$[rbp], rax

; 3358 :         column->IsUserEnabled = column->IsUserEnabledNextFrame = column_settings->IsEnabled;

  00259	48 8b 45 48	 mov	 rax, QWORD PTR column_settings$[rbp]
  0025d	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  00261	c0 e8 02	 shr	 al, 2
  00264	24 01		 and	 al, 1
  00266	88 85 f4 01 00
	00		 mov	 BYTE PTR tv165[rbp], al
  0026c	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$3[rbp]
  00273	0f b6 8d f4 01
	00 00		 movzx	 ecx, BYTE PTR tv165[rbp]
  0027a	88 48 64	 mov	 BYTE PTR [rax+100], cl
  0027d	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$3[rbp]
  00284	0f b6 8d f4 01
	00 00		 movzx	 ecx, BYTE PTR tv165[rbp]
  0028b	88 48 63	 mov	 BYTE PTR [rax+99], cl

; 3359 :         column->SortOrder = column_settings->SortOrder;

  0028e	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column$3[rbp]
  00295	48 8b 4d 48	 mov	 rcx, QWORD PTR column_settings$[rbp]
  00299	0f b7 49 0c	 movzx	 ecx, WORD PTR [rcx+12]
  0029d	66 89 48 5a	 mov	 WORD PTR [rax+90], cx

; 3360 :         column->SortDirection = column_settings->SortDirection;

  002a1	48 8b 45 48	 mov	 rax, QWORD PTR column_settings$[rbp]
  002a5	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  002a9	24 03		 and	 al, 3
  002ab	24 03		 and	 al, 3
  002ad	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column$3[rbp]
  002b4	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  002b8	80 e1 fc	 and	 cl, 252			; 000000fcH
  002bb	0a c8		 or	 cl, al
  002bd	0f b6 c1	 movzx	 eax, cl
  002c0	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column$3[rbp]
  002c7	88 41 6d	 mov	 BYTE PTR [rcx+109], al

; 3361 :     }

  002ca	e9 53 fe ff ff	 jmp	 $LN2@TableLoadS
$LN3@TableLoadS:

; 3362 : 
; 3363 :     // Validate and fix invalid display order data
; 3364 :     const ImU64 expected_display_order_mask = (settings->ColumnsCount == 64) ? ~0 : ((ImU64)1 << settings->ColumnsCount) - 1;

  002cf	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  002d3	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  002d7	83 f8 40	 cmp	 eax, 64			; 00000040H
  002da	75 0d		 jne	 SHORT $LN25@TableLoadS
  002dc	48 c7 85 f8 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR tv182[rbp], -1
  002e7	eb 2b		 jmp	 SHORT $LN26@TableLoadS
$LN25@TableLoadS:
  002e9	48 8b 45 28	 mov	 rax, QWORD PTR settings$[rbp]
  002ed	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  002f1	b9 01 00 00 00	 mov	 ecx, 1
  002f6	48 89 8d 00 02
	00 00		 mov	 QWORD PTR tv285[rbp], rcx
  002fd	0f b6 c8	 movzx	 ecx, al
  00300	48 8b 85 00 02
	00 00		 mov	 rax, QWORD PTR tv285[rbp]
  00307	48 d3 e0	 shl	 rax, cl
  0030a	48 ff c8	 dec	 rax
  0030d	48 89 85 f8 01
	00 00		 mov	 QWORD PTR tv182[rbp], rax
$LN26@TableLoadS:
  00314	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR tv182[rbp]
  0031b	48 89 85 e8 00
	00 00		 mov	 QWORD PTR expected_display_order_mask$[rbp], rax

; 3365 :     if (display_order_mask != expected_display_order_mask)

  00322	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR expected_display_order_mask$[rbp]
  00329	48 39 45 68	 cmp	 QWORD PTR display_order_mask$[rbp], rax
  0032d	74 52		 je	 SHORT $LN23@TableLoadS

; 3366 :         for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  0032f	c7 85 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$4[rbp], 0
  00339	eb 0e		 jmp	 SHORT $LN7@TableLoadS
$LN5@TableLoadS:
  0033b	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR column_n$4[rbp]
  00341	ff c0		 inc	 eax
  00343	89 85 04 01 00
	00		 mov	 DWORD PTR column_n$4[rbp], eax
$LN7@TableLoadS:
  00349	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00350	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00353	39 85 04 01 00
	00		 cmp	 DWORD PTR column_n$4[rbp], eax
  00359	7d 26		 jge	 SHORT $LN6@TableLoadS

; 3367 :             table->Columns[column_n].DisplayOrder = (ImGuiTableColumnIdx)column_n;

  0035b	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00362	48 83 c0 18	 add	 rax, 24
  00366	8b 95 04 01 00
	00		 mov	 edx, DWORD PTR column_n$4[rbp]
  0036c	48 8b c8	 mov	 rcx, rax
  0036f	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00374	0f b7 8d 04 01
	00 00		 movzx	 ecx, WORD PTR column_n$4[rbp]
  0037b	66 89 48 52	 mov	 WORD PTR [rax+82], cx
  0037f	eb ba		 jmp	 SHORT $LN5@TableLoadS
$LN6@TableLoadS:
$LN23@TableLoadS:

; 3368 : 
; 3369 :     // Rebuild index
; 3370 :     for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  00381	c7 85 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$5[rbp], 0
  0038b	eb 0e		 jmp	 SHORT $LN10@TableLoadS
$LN8@TableLoadS:
  0038d	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR column_n$5[rbp]
  00393	ff c0		 inc	 eax
  00395	89 85 24 01 00
	00		 mov	 DWORD PTR column_n$5[rbp], eax
$LN10@TableLoadS:
  0039b	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003a2	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  003a5	39 85 24 01 00
	00		 cmp	 DWORD PTR column_n$5[rbp], eax
  003ab	7d 3b		 jge	 SHORT $LN9@TableLoadS

; 3371 :         table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;

  003ad	48 8b 85 30 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003b4	48 83 c0 18	 add	 rax, 24
  003b8	8b 95 24 01 00
	00		 mov	 edx, DWORD PTR column_n$5[rbp]
  003be	48 8b c8	 mov	 rcx, rax
  003c1	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  003c6	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  003ca	48 8b 8d 30 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  003d1	48 83 c1 28	 add	 rcx, 40			; 00000028H
  003d5	8b d0		 mov	 edx, eax
  003d7	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  003dc	0f b7 8d 24 01
	00 00		 movzx	 ecx, WORD PTR column_n$5[rbp]
  003e3	66 89 08	 mov	 WORD PTR [rax], cx
  003e6	eb a5		 jmp	 SHORT $LN8@TableLoadS
$LN9@TableLoadS:
$LN1@TableLoadS:

; 3372 : }

  003e8	48 8d a5 18 02
	00 00		 lea	 rsp, QWORD PTR [rbp+536]
  003ef	5f		 pop	 rdi
  003f0	5d		 pop	 rbp
  003f1	c3		 ret	 0
?TableLoadSettings@ImGui@@YAXPEAUImGuiTable@@@Z ENDP	; ImGui::TableLoadSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGcCompactSettings@ImGui@@YAXXZ
_TEXT	SEGMENT
g$ = 8
required_memory$ = 36
settings$4 = 72
new_chunk_stream$ = 104
settings$5 = 152
$T6 = 376
tv132 = 392
__$ArrayPad$ = 400
?TableGcCompactSettings@ImGui@@YAXXZ PROC		; ImGui::TableGcCompactSettings, COMDAT

; 3538 : {

$LN13:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 72 00 00 00	 mov	 ecx, 114		; 00000072H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 c7 85 78 01
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T6[rbp], -2
  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00030	48 33 c5	 xor	 rax, rbp
  00033	48 89 85 90 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 3539 :     ImGuiContext& g = *GImGui;

  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00041	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3540 :     int required_memory = 0;

  00045	c7 45 24 00 00
	00 00		 mov	 DWORD PTR required_memory$[rbp], 0

; 3541 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

  0004c	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00050	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  00056	48 8b c8	 mov	 rcx, rax
  00059	e8 00 00 00 00	 call	 ?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::begin
  0005e	48 89 45 48	 mov	 QWORD PTR settings$4[rbp], rax
  00062	eb 1a		 jmp	 SHORT $LN4@TableGcCom
$LN2@TableGcCom:
  00064	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00068	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  0006e	48 8b 55 48	 mov	 rdx, QWORD PTR settings$4[rbp]
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 ?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z ; ImChunkStream<ImGuiTableSettings>::next_chunk
  0007a	48 89 45 48	 mov	 QWORD PTR settings$4[rbp], rax
$LN4@TableGcCom:
  0007e	48 83 7d 48 00	 cmp	 QWORD PTR settings$4[rbp], 0
  00083	74 24		 je	 SHORT $LN3@TableGcCom

; 3542 :         if (settings->ID != 0)

  00085	48 8b 45 48	 mov	 rax, QWORD PTR settings$4[rbp]
  00089	83 38 00	 cmp	 DWORD PTR [rax], 0
  0008c	74 19		 je	 SHORT $LN8@TableGcCom

; 3543 :             required_memory += (int)TableSettingsCalcChunkSize(settings->ColumnsCount);

  0008e	48 8b 45 48	 mov	 rax, QWORD PTR settings$4[rbp]
  00092	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  00096	8b c8		 mov	 ecx, eax
  00098	e8 00 00 00 00	 call	 ?TableSettingsCalcChunkSize@@YA_KH@Z ; TableSettingsCalcChunkSize
  0009d	8b 4d 24	 mov	 ecx, DWORD PTR required_memory$[rbp]
  000a0	03 c8		 add	 ecx, eax
  000a2	8b c1		 mov	 eax, ecx
  000a4	89 45 24	 mov	 DWORD PTR required_memory$[rbp], eax
$LN8@TableGcCom:

; 3544 :     if (required_memory == g.SettingsTables.Buf.Size)

  000a7	eb bb		 jmp	 SHORT $LN2@TableGcCom
$LN3@TableGcCom:
  000a9	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  000ad	8b 80 b0 5b 00
	00		 mov	 eax, DWORD PTR [rax+23472]
  000b3	39 45 24	 cmp	 DWORD PTR required_memory$[rbp], eax
  000b6	75 05		 jne	 SHORT $LN9@TableGcCom

; 3545 :         return;

  000b8	e9 da 00 00 00	 jmp	 $LN1@TableGcCom
$LN9@TableGcCom:

; 3546 :     ImChunkStream<ImGuiTableSettings> new_chunk_stream;

  000bd	48 8d 4d 68	 lea	 rcx, QWORD PTR new_chunk_stream$[rbp]
  000c1	e8 00 00 00 00	 call	 ??0?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ
  000c6	90		 npad	 1

; 3547 :     new_chunk_stream.Buf.reserve(required_memory);

  000c7	8b 55 24	 mov	 edx, DWORD PTR required_memory$[rbp]
  000ca	48 8d 4d 68	 lea	 rcx, QWORD PTR new_chunk_stream$[rbp]
  000ce	e8 00 00 00 00	 call	 ?reserve@?$ImVector@D@@QEAAXH@Z ; ImVector<char>::reserve

; 3548 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

  000d3	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  000d7	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  000dd	48 8b c8	 mov	 rcx, rax
  000e0	e8 00 00 00 00	 call	 ?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::begin
  000e5	48 89 85 98 00
	00 00		 mov	 QWORD PTR settings$5[rbp], rax
  000ec	eb 20		 jmp	 SHORT $LN7@TableGcCom
$LN5@TableGcCom:
  000ee	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  000f2	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  000f8	48 8b 95 98 00
	00 00		 mov	 rdx, QWORD PTR settings$5[rbp]
  000ff	48 8b c8	 mov	 rcx, rax
  00102	e8 00 00 00 00	 call	 ?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z ; ImChunkStream<ImGuiTableSettings>::next_chunk
  00107	48 89 85 98 00
	00 00		 mov	 QWORD PTR settings$5[rbp], rax
$LN7@TableGcCom:
  0010e	48 83 bd 98 00
	00 00 00	 cmp	 QWORD PTR settings$5[rbp], 0
  00116	74 5f		 je	 SHORT $LN6@TableGcCom

; 3549 :         if (settings->ID != 0)

  00118	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR settings$5[rbp]
  0011f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00122	74 4e		 je	 SHORT $LN10@TableGcCom

; 3550 :             memcpy(new_chunk_stream.alloc_chunk(TableSettingsCalcChunkSize(settings->ColumnsCount)), settings, TableSettingsCalcChunkSize(settings->ColumnsCount));

  00124	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR settings$5[rbp]
  0012b	0f bf 40 0c	 movsx	 eax, WORD PTR [rax+12]
  0012f	8b c8		 mov	 ecx, eax
  00131	e8 00 00 00 00	 call	 ?TableSettingsCalcChunkSize@@YA_KH@Z ; TableSettingsCalcChunkSize
  00136	48 89 85 88 01
	00 00		 mov	 QWORD PTR tv132[rbp], rax
  0013d	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR settings$5[rbp]
  00144	0f bf 49 0c	 movsx	 ecx, WORD PTR [rcx+12]
  00148	e8 00 00 00 00	 call	 ?TableSettingsCalcChunkSize@@YA_KH@Z ; TableSettingsCalcChunkSize
  0014d	48 8b d0	 mov	 rdx, rax
  00150	48 8d 4d 68	 lea	 rcx, QWORD PTR new_chunk_stream$[rbp]
  00154	e8 00 00 00 00	 call	 ?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z ; ImChunkStream<ImGuiTableSettings>::alloc_chunk
  00159	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR tv132[rbp]
  00160	4c 8b c1	 mov	 r8, rcx
  00163	48 8b 95 98 00
	00 00		 mov	 rdx, QWORD PTR settings$5[rbp]
  0016a	48 8b c8	 mov	 rcx, rax
  0016d	e8 00 00 00 00	 call	 memcpy
$LN10@TableGcCom:

; 3551 :     g.SettingsTables.swap(new_chunk_stream);

  00172	e9 77 ff ff ff	 jmp	 $LN5@TableGcCom
$LN6@TableGcCom:
  00177	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0017b	48 05 b0 5b 00
	00		 add	 rax, 23472		; 00005bb0H
  00181	48 8d 55 68	 lea	 rdx, QWORD PTR new_chunk_stream$[rbp]
  00185	48 8b c8	 mov	 rcx, rax
  00188	e8 00 00 00 00	 call	 ?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z ; ImChunkStream<ImGuiTableSettings>::swap
  0018d	90		 npad	 1

; 3552 : }

  0018e	48 8d 4d 68	 lea	 rcx, QWORD PTR new_chunk_stream$[rbp]
  00192	e8 00 00 00 00	 call	 ??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ
$LN1@TableGcCom:
  00197	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0019b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableGcCompactSettings@ImGui@@YAXXZ$rtcFrameData
  001a2	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001a7	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  001ae	48 33 cd	 xor	 rcx, rbp
  001b1	e8 00 00 00 00	 call	 __security_check_cookie
  001b6	48 8d a5 a8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+424]
  001bd	5f		 pop	 rdi
  001be	5d		 pop	 rbp
  001bf	c3		 ret	 0
?TableGcCompactSettings@ImGui@@YAXXZ ENDP		; ImGui::TableGcCompactSettings
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
g$ = 8
required_memory$ = 36
settings$4 = 72
new_chunk_stream$ = 104
settings$5 = 152
$T6 = 376
tv132 = 392
__$ArrayPad$ = 400
?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA PROC ; `ImGui::TableGcCompactSettings'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8d 4d 68	 lea	 rcx, QWORD PTR new_chunk_stream$[rbp]
  00018	e8 00 00 00 00	 call	 ??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ
  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	5f		 pop	 rdi
  00022	5d		 pop	 rbp
  00023	c3		 ret	 0
?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA ENDP ; `ImGui::TableGcCompactSettings'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
g$ = 8
required_memory$ = 36
settings$4 = 72
new_chunk_stream$ = 104
settings$5 = 152
$T6 = 376
tv132 = 392
__$ArrayPad$ = 400
?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA PROC ; `ImGui::TableGcCompactSettings'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8d 4d 68	 lea	 rcx, QWORD PTR new_chunk_stream$[rbp]
  00018	e8 00 00 00 00	 call	 ??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ
  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	5f		 pop	 rdi
  00022	5d		 pop	 rbp
  00023	c3		 ret	 0
?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA ENDP ; `ImGui::TableGcCompactSettings'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z
_TEXT	SEGMENT
temp_data$ = 224
?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z PROC ; ImGui::TableGcCompactTransientBuffers, COMDAT

; 3531 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]

; 3532 :     temp_data->DrawSplitter.ClearFreeMemory();

  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00031	48 83 c0 10	 add	 rax, 16
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ ; ImDrawListSplitter::ClearFreeMemory

; 3533 :     temp_data->LastTimeActive = -1.0f;

  0003d	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00044	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0004c	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 3534 : }

  00051	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00058	5f		 pop	 rdi
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z ENDP ; ImGui::TableGcCompactTransientBuffers
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
g$ = 8
n$1 = 36
table$ = 288
?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z PROC ; ImGui::TableGcCompactTransientBuffers, COMDAT

; 3516 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]

; 3517 :     //IMGUI_DEBUG_PRINT("TableGcCompactTransientBuffers() id=0x%08X\n", table->ID);
; 3518 :     ImGuiContext& g = *GImGui;

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00031	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3519 :     IM_ASSERT(table->MemoryCompacted == false);

  00035	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0003c	0f b6 80 31 02
	00 00		 movzx	 eax, BYTE PTR [rax+561]
  00043	85 c0		 test	 eax, eax
  00045	74 22		 je	 SHORT $LN6@TableGcCom
  00047	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  0004d	83 c0 03	 add	 eax, 3
  00050	44 8b c0	 mov	 r8d, eax
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@HDPGNILG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAC?$AAo?$AAm?$AAp?$AAa?$AAc?$AAt?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00067	33 c0		 xor	 eax, eax
$LN6@TableGcCom:

; 3520 :     table->SortSpecs.Specs = NULL;

  00069	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00070	48 c7 80 e0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+480], 0

; 3521 :     table->SortSpecsMulti.clear();

  0007b	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00082	48 05 d0 01 00
	00		 add	 rax, 464		; 000001d0H
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ ; ImVector<ImGuiTableColumnSortSpecs>::clear

; 3522 :     table->IsSortSpecsDirty = true; // FIXME: shouldn't have to leak into user performing a sort

  00090	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00097	c6 80 25 02 00
	00 01		 mov	 BYTE PTR [rax+549], 1

; 3523 :     table->ColumnsNames.clear();

  0009e	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000a5	48 05 88 01 00
	00		 add	 rax, 392		; 00000188H
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	e8 00 00 00 00	 call	 ?clear@ImGuiTextBuffer@@QEAAXXZ ; ImGuiTextBuffer::clear

; 3524 :     table->MemoryCompacted = true;

  000b3	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000ba	c6 80 31 02 00
	00 01		 mov	 BYTE PTR [rax+561], 1

; 3525 :     for (int n = 0; n < table->ColumnsCount; n++)

  000c1	c7 45 24 00 00
	00 00		 mov	 DWORD PTR n$1[rbp], 0
  000c8	eb 08		 jmp	 SHORT $LN4@TableGcCom
$LN2@TableGcCom:
  000ca	8b 45 24	 mov	 eax, DWORD PTR n$1[rbp]
  000cd	ff c0		 inc	 eax
  000cf	89 45 24	 mov	 DWORD PTR n$1[rbp], eax
$LN4@TableGcCom:
  000d2	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000d9	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000dc	39 45 24	 cmp	 DWORD PTR n$1[rbp], eax
  000df	7d 21		 jge	 SHORT $LN3@TableGcCom

; 3526 :         table->Columns[n].NameOffset = -1;

  000e1	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000e8	48 83 c0 18	 add	 rax, 24
  000ec	8b 55 24	 mov	 edx, DWORD PTR n$1[rbp]
  000ef	48 8b c8	 mov	 rcx, rax
  000f2	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  000f7	b9 ff ff ff ff	 mov	 ecx, -1
  000fc	66 89 48 50	 mov	 WORD PTR [rax+80], cx
  00100	eb c8		 jmp	 SHORT $LN2@TableGcCom
$LN3@TableGcCom:

; 3527 :     g.TablesLastTimeActive[g.Tables.GetIndex(table)] = -1.0f;

  00102	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00106	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  0010c	48 8b 95 20 01
	00 00		 mov	 rdx, QWORD PTR table$[rbp]
  00113	48 8b c8	 mov	 rcx, rax
  00116	e8 00 00 00 00	 call	 ?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z ; ImPool<ImGuiTable>::GetIndex
  0011b	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  0011f	48 81 c1 30 4b
	00 00		 add	 rcx, 19248		; 00004b30H
  00126	8b d0		 mov	 edx, eax
  00128	e8 00 00 00 00	 call	 ??A?$ImVector@M@@QEAAAEAMH@Z ; ImVector<float>::operator[]
  0012d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00135	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 3528 : }

  00139	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00140	5f		 pop	 rdi
  00141	5d		 pop	 rbp
  00142	c3		 ret	 0
?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z ENDP ; ImGui::TableGcCompactTransientBuffers
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableRemove@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
g$ = 8
table_idx$ = 36
table$ = 288
?TableRemove@ImGui@@YAXPEAUImGuiTable@@@Z PROC		; ImGui::TableRemove, COMDAT

; 3504 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]

; 3505 :     //IMGUI_DEBUG_PRINT("TableRemove() id=0x%08X\n", table->ID);
; 3506 :     ImGuiContext& g = *GImGui;

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00031	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3507 :     int table_idx = g.Tables.GetIndex(table);

  00035	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00039	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  0003f	48 8b 95 20 01
	00 00		 mov	 rdx, QWORD PTR table$[rbp]
  00046	48 8b c8	 mov	 rcx, rax
  00049	e8 00 00 00 00	 call	 ?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z ; ImPool<ImGuiTable>::GetIndex
  0004e	89 45 24	 mov	 DWORD PTR table_idx$[rbp], eax

; 3508 :     //memset(table->RawData.Data, 0, table->RawData.size_in_bytes());
; 3509 :     //memset(table, 0, sizeof(ImGuiTable));
; 3510 :     g.Tables.Remove(table->ID, table);

  00051	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00055	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  0005b	4c 8b 85 20 01
	00 00		 mov	 r8, QWORD PTR table$[rbp]
  00062	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00069	8b 11		 mov	 edx, DWORD PTR [rcx]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 ?Remove@?$ImPool@UImGuiTable@@@@QEAAXIPEBUImGuiTable@@@Z ; ImPool<ImGuiTable>::Remove

; 3511 :     g.TablesLastTimeActive[table_idx] = -1.0f;

  00073	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00077	48 05 30 4b 00
	00		 add	 rax, 19248		; 00004b30H
  0007d	8b 55 24	 mov	 edx, DWORD PTR table_idx$[rbp]
  00080	48 8b c8	 mov	 rcx, rax
  00083	e8 00 00 00 00	 call	 ??A?$ImVector@M@@QEAAAEAMH@Z ; ImVector<float>::operator[]
  00088	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00090	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 3512 : }

  00094	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  0009b	5f		 pop	 rdi
  0009c	5d		 pop	 rbp
  0009d	c3		 ret	 0
?TableRemove@ImGui@@YAXPEAUImGuiTable@@@Z ENDP		; ImGui::TableRemove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetColumnWidthAutoAll@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
column_n$1 = 4
column$2 = 40
table$ = 288
?TableSetColumnWidthAutoAll@ImGui@@YAXPEAUImGuiTable@@@Z PROC ; ImGui::TableSetColumnWidthAutoAll, COMDAT

; 2200 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]

; 2201 :     for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  0002a	c7 45 04 00 00
	00 00		 mov	 DWORD PTR column_n$1[rbp], 0
  00031	eb 08		 jmp	 SHORT $LN4@TableSetCo
$LN2@TableSetCo:
  00033	8b 45 04	 mov	 eax, DWORD PTR column_n$1[rbp]
  00036	ff c0		 inc	 eax
  00038	89 45 04	 mov	 DWORD PTR column_n$1[rbp], eax
$LN4@TableSetCo:
  0003b	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00042	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00045	39 45 04	 cmp	 DWORD PTR column_n$1[rbp], eax
  00048	7d 47		 jge	 SHORT $LN3@TableSetCo

; 2202 :     {
; 2203 :         ImGuiTableColumn* column = &table->Columns[column_n];

  0004a	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00051	48 83 c0 18	 add	 rax, 24
  00055	8b 55 04	 mov	 edx, DWORD PTR column_n$1[rbp]
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00060	48 89 45 28	 mov	 QWORD PTR column$2[rbp], rax

; 2204 :         if (!column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_WidthStretch)) // Cannot reset weight of hidden stretch column

  00064	48 8b 45 28	 mov	 rax, QWORD PTR column$2[rbp]
  00068	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  0006c	85 c0		 test	 eax, eax
  0006e	75 0f		 jne	 SHORT $LN5@TableSetCo
  00070	48 8b 45 28	 mov	 rax, QWORD PTR column$2[rbp]
  00074	8b 00		 mov	 eax, DWORD PTR [rax]
  00076	83 e0 08	 and	 eax, 8
  00079	85 c0		 test	 eax, eax
  0007b	75 02		 jne	 SHORT $LN5@TableSetCo

; 2205 :             continue;

  0007d	eb b4		 jmp	 SHORT $LN2@TableSetCo
$LN5@TableSetCo:

; 2206 :         column->CannotSkipItemsQueue = (1 << 0);

  0007f	48 8b 45 28	 mov	 rax, QWORD PTR column$2[rbp]
  00083	c6 40 6c 01	 mov	 BYTE PTR [rax+108], 1

; 2207 :         column->AutoFitQueue = (1 << 1);

  00087	48 8b 45 28	 mov	 rax, QWORD PTR column$2[rbp]
  0008b	c6 40 6b 02	 mov	 BYTE PTR [rax+107], 2

; 2208 :     }

  0008f	eb a2		 jmp	 SHORT $LN2@TableSetCo
$LN3@TableSetCo:

; 2209 : }

  00091	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00098	5f		 pop	 rdi
  00099	5d		 pop	 rbp
  0009a	c3		 ret	 0
?TableSetColumnWidthAutoAll@ImGui@@YAXPEAUImGuiTable@@@Z ENDP ; ImGui::TableSetColumnWidthAutoAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z
_TEXT	SEGMENT
column$ = 8
table$ = 256
column_n$ = 264
?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z PROC ; ImGui::TableSetColumnWidthAutoSingle, COMDAT

; 2190 : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]

; 2191 :     // Single auto width uses auto-fit
; 2192 :     ImGuiTableColumn* column = &table->Columns[column_n];

  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00035	48 83 c0 18	 add	 rax, 24
  00039	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00047	48 89 45 08	 mov	 QWORD PTR column$[rbp], rax

; 2193 :     if (!column->IsEnabled)

  0004b	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  0004f	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  00053	85 c0		 test	 eax, eax
  00055	75 02		 jne	 SHORT $LN2@TableSetCo

; 2194 :         return;

  00057	eb 1d		 jmp	 SHORT $LN1@TableSetCo
$LN2@TableSetCo:

; 2195 :     column->CannotSkipItemsQueue = (1 << 0);

  00059	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  0005d	c6 40 6c 01	 mov	 BYTE PTR [rax+108], 1

; 2196 :     table->AutoFitSingleColumn = (ImGuiTableColumnIdx)column_n;

  00061	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00068	0f b7 8d 08 01
	00 00		 movzx	 ecx, WORD PTR column_n$[rbp]
  0006f	66 89 88 fc 01
	00 00		 mov	 WORD PTR [rax+508], cx
$LN1@TableSetCo:

; 2197 : }

  00076	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0007d	5f		 pop	 rdi
  0007e	5d		 pop	 rbp
  0007f	c3		 ret	 0
?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z ENDP ; ImGui::TableSetColumnWidthAutoSingle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetMaxColumnWidth@ImGui@@YAMPEBUImGuiTable@@H@Z
_TEXT	SEGMENT
column$ = 8
max_width$ = 36
min_column_distance$ = 68
table$ = 320
column_n$ = 328
?TableGetMaxColumnWidth@ImGui@@YAMPEBUImGuiTable@@H@Z PROC ; ImGui::TableGetMaxColumnWidth, COMDAT

; 2058 : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00012	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR [rsp+376]

; 2059 :     const ImGuiTableColumn* column = &table->Columns[column_n];

  0002e	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00035	48 83 c0 18	 add	 rax, 24
  00039	8b 95 48 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00047	48 89 45 08	 mov	 QWORD PTR column$[rbp], rax

; 2060 :     float max_width = FLT_MAX;

  0004b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  00053	f3 0f 11 45 24	 movss	 DWORD PTR max_width$[rbp], xmm0

; 2061 :     const float min_column_distance = table->MinColumnWidth + table->CellPaddingX * 2.0f + table->CellSpacingX1 + table->CellSpacingX2;

  00058	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0005f	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+188]
  00067	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0006f	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00076	f3 0f 10 88 b4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+180]
  0007e	f3 0f 58 c8	 addss	 xmm1, xmm0
  00082	0f 28 c1	 movaps	 xmm0, xmm1
  00085	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0008c	f3 0f 58 80 c4
	00 00 00	 addss	 xmm0, DWORD PTR [rax+196]
  00094	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0009b	f3 0f 58 80 c8
	00 00 00	 addss	 xmm0, DWORD PTR [rax+200]
  000a3	f3 0f 11 45 44	 movss	 DWORD PTR min_column_distance$[rbp], xmm0

; 2062 :     if (table->Flags & ImGuiTableFlags_ScrollX)

  000a8	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000af	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000b2	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000b7	85 c0		 test	 eax, eax
  000b9	0f 84 9b 00 00
	00		 je	 $LN2@TableGetMa

; 2063 :     {
; 2064 :         // Frozen columns can't reach beyond visible width else scrolling will naturally break.
; 2065 :         // (we use DisplayOrder as within a set of multiple frozen column reordering is possible)
; 2066 :         if (column->DisplayOrder < table->FreezeColumnsRequest)

  000bf	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  000c3	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  000c7	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000ce	0f bf 89 16 02
	00 00		 movsx	 ecx, WORD PTR [rcx+534]
  000d5	3b c1		 cmp	 eax, ecx
  000d7	7d 7c		 jge	 SHORT $LN4@TableGetMa

; 2067 :         {
; 2068 :             max_width = (table->InnerClipRect.Max.x - (table->FreezeColumnsRequest - column->DisplayOrder) * min_column_distance) - column->MinX;

  000d9	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000e0	0f bf 80 16 02
	00 00		 movsx	 eax, WORD PTR [rax+534]
  000e7	48 8b 4d 08	 mov	 rcx, QWORD PTR column$[rbp]
  000eb	0f bf 49 52	 movsx	 ecx, WORD PTR [rcx+82]
  000ef	2b c1		 sub	 eax, ecx
  000f1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000f5	f3 0f 59 45 44	 mulss	 xmm0, DWORD PTR min_column_distance$[rbp]
  000fa	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00101	f3 0f 10 88 20
	01 00 00	 movss	 xmm1, DWORD PTR [rax+288]
  00109	f3 0f 5c c8	 subss	 xmm1, xmm0
  0010d	0f 28 c1	 movaps	 xmm0, xmm1
  00110	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  00114	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [rax+8]
  00119	f3 0f 11 45 24	 movss	 DWORD PTR max_width$[rbp], xmm0

; 2069 :             max_width = max_width - table->OuterPaddingX - table->CellPaddingX - table->CellSpacingX2;

  0011e	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00125	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR max_width$[rbp]
  0012a	f3 0f 5c 80 b8
	00 00 00	 subss	 xmm0, DWORD PTR [rax+184]
  00132	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00139	f3 0f 5c 80 bc
	00 00 00	 subss	 xmm0, DWORD PTR [rax+188]
  00141	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00148	f3 0f 5c 80 c8
	00 00 00	 subss	 xmm0, DWORD PTR [rax+200]
  00150	f3 0f 11 45 24	 movss	 DWORD PTR max_width$[rbp], xmm0
$LN4@TableGetMa:

; 2070 :         }
; 2071 :     }

  00155	e9 b8 00 00 00	 jmp	 $LN3@TableGetMa
$LN2@TableGetMa:

; 2072 :     else if ((table->Flags & ImGuiTableFlags_NoKeepColumnsVisible) == 0)

  0015a	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00161	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00164	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00169	85 c0		 test	 eax, eax
  0016b	0f 85 a1 00 00
	00		 jne	 $LN5@TableGetMa

; 2073 :     {
; 2074 :         // If horizontal scrolling if disabled, we apply a final lossless shrinking of columns in order to make
; 2075 :         // sure they are all visible. Because of this we also know that all of the columns will always fit in
; 2076 :         // table->WorkRect and therefore in table->InnerRect (because ScrollX is off)
; 2077 :         // FIXME-TABLE: This is solved incorrectly but also quite a difficult problem to fix as we also want ClipRect width to match.
; 2078 :         // See "table_width_distrib" and "table_width_keep_visible" tests
; 2079 :         max_width = table->WorkRect.Max.x - (table->ColumnsEnabledCount - column->IndexWithinEnabledSet - 1) * min_column_distance - column->MinX;

  00171	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00178	0f bf 80 f2 01
	00 00		 movsx	 eax, WORD PTR [rax+498]
  0017f	48 8b 4d 08	 mov	 rcx, QWORD PTR column$[rbp]
  00183	0f bf 49 54	 movsx	 ecx, WORD PTR [rcx+84]
  00187	2b c1		 sub	 eax, ecx
  00189	ff c8		 dec	 eax
  0018b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0018f	f3 0f 59 45 44	 mulss	 xmm0, DWORD PTR min_column_distance$[rbp]
  00194	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0019b	f3 0f 10 88 10
	01 00 00	 movss	 xmm1, DWORD PTR [rax+272]
  001a3	f3 0f 5c c8	 subss	 xmm1, xmm0
  001a7	0f 28 c1	 movaps	 xmm0, xmm1
  001aa	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  001ae	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [rax+8]
  001b3	f3 0f 11 45 24	 movss	 DWORD PTR max_width$[rbp], xmm0

; 2080 :         //max_width -= table->CellSpacingX1;
; 2081 :         max_width -= table->CellSpacingX2;

  001b8	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001bf	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR max_width$[rbp]
  001c4	f3 0f 5c 80 c8
	00 00 00	 subss	 xmm0, DWORD PTR [rax+200]
  001cc	f3 0f 11 45 24	 movss	 DWORD PTR max_width$[rbp], xmm0

; 2082 :         max_width -= table->CellPaddingX * 2.0f;

  001d1	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001d8	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+188]
  001e0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  001e8	f3 0f 10 4d 24	 movss	 xmm1, DWORD PTR max_width$[rbp]
  001ed	f3 0f 5c c8	 subss	 xmm1, xmm0
  001f1	0f 28 c1	 movaps	 xmm0, xmm1
  001f4	f3 0f 11 45 24	 movss	 DWORD PTR max_width$[rbp], xmm0

; 2083 :         max_width -= table->OuterPaddingX;

  001f9	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00200	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR max_width$[rbp]
  00205	f3 0f 5c 80 b8
	00 00 00	 subss	 xmm0, DWORD PTR [rax+184]
  0020d	f3 0f 11 45 24	 movss	 DWORD PTR max_width$[rbp], xmm0
$LN5@TableGetMa:
$LN3@TableGetMa:

; 2084 :     }
; 2085 :     return max_width;

  00212	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR max_width$[rbp]

; 2086 : }

  00217	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  0021e	5f		 pop	 rdi
  0021f	5d		 pop	 rbp
  00220	c3		 ret	 0
?TableGetMaxColumnWidth@ImGui@@YAMPEBUImGuiTable@@H@Z ENDP ; ImGui::TableGetMaxColumnWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z
_TEXT	SEGMENT
id$ = 4
table$ = 256
column_n$ = 264
instance_no$ = 272
?TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z PROC ; ImGui::TableGetColumnResizeID, COMDAT

; 1623 : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]

; 1624 :     IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);

  00033	83 bd 08 01 00
	00 00		 cmp	 DWORD PTR column_n$[rbp], 0
  0003a	7c 12		 jl	 SHORT $LN3@TableGetCo
  0003c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00043	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00046	39 85 08 01 00
	00		 cmp	 DWORD PTR column_n$[rbp], eax
  0004c	7c 21		 jl	 SHORT $LN4@TableGetCo
$LN3@TableGetCo:
  0004e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z@4JA
  00054	ff c0		 inc	 eax
  00056	44 8b c0	 mov	 r8d, eax
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GA@OFNPMLNE@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl@
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006d	33 c0		 xor	 eax, eax
$LN4@TableGetCo:

; 1625 :     ImGuiID id = table->ID + 1 + (instance_no * table->ColumnsCount) + column_n;

  0006f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00076	8b 8d 10 01 00
	00		 mov	 ecx, DWORD PTR instance_no$[rbp]
  0007c	0f af 48 6c	 imul	 ecx, DWORD PTR [rax+108]
  00080	8b c1		 mov	 eax, ecx
  00082	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00089	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0008b	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  00091	03 d1		 add	 edx, ecx
  00093	8b ca		 mov	 ecx, edx
  00095	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00099	89 45 04	 mov	 DWORD PTR id$[rbp], eax

; 1626 :     return id;

  0009c	8b 45 04	 mov	 eax, DWORD PTR id$[rbp]

; 1627 : }

  0009f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000a6	5f		 pop	 rdi
  000a7	5d		 pop	 rbp
  000a8	c3		 ret	 0
?TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z ENDP ; ImGui::TableGetColumnResizeID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z
_TEXT	SEGMENT
column$ = 8
table$ = 256
column_n$ = 264
?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z PROC ; ImGui::TableGetColumnName, COMDAT

; 1557 : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]

; 1558 :     if (table->IsLayoutLocked == false && column_n >= table->DeclColumnsCount)

  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00035	0f b6 80 22 02
	00 00		 movzx	 eax, BYTE PTR [rax+546]
  0003c	85 c0		 test	 eax, eax
  0003e	75 1f		 jne	 SHORT $LN2@TableGetCo
  00040	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00047	0f bf 80 f6 01
	00 00		 movsx	 eax, WORD PTR [rax+502]
  0004e	39 85 08 01 00
	00		 cmp	 DWORD PTR column_n$[rbp], eax
  00054	7c 09		 jl	 SHORT $LN2@TableGetCo

; 1559 :         return ""; // NameOffset is invalid at this point

  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0005d	eb 50		 jmp	 SHORT $LN1@TableGetCo
$LN2@TableGetCo:

; 1560 :     const ImGuiTableColumn* column = &table->Columns[column_n];

  0005f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00066	48 83 c0 18	 add	 rax, 24
  0006a	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  00070	48 8b c8	 mov	 rcx, rax
  00073	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00078	48 89 45 08	 mov	 QWORD PTR column$[rbp], rax

; 1561 :     if (column->NameOffset == -1)

  0007c	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  00080	0f bf 40 50	 movsx	 eax, WORD PTR [rax+80]
  00084	83 f8 ff	 cmp	 eax, -1
  00087	75 09		 jne	 SHORT $LN3@TableGetCo

; 1562 :         return "";

  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00090	eb 1d		 jmp	 SHORT $LN1@TableGetCo
$LN3@TableGetCo:

; 1563 :     return &table->ColumnsNames.Buf[column->NameOffset];

  00092	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  00096	0f bf 40 50	 movsx	 eax, WORD PTR [rax+80]
  0009a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000a1	48 81 c1 88 01
	00 00		 add	 rcx, 392		; 00000188H
  000a8	8b d0		 mov	 edx, eax
  000aa	e8 00 00 00 00	 call	 ??A?$ImVector@D@@QEBAAEBDH@Z ; ImVector<char>::operator[]
$LN1@TableGetCo:

; 1564 : }

  000af	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000b6	5f		 pop	 rdi
  000b7	5d		 pop	 rbp
  000b8	c3		 ret	 0
?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z ENDP ; ImGui::TableGetColumnName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z
_TEXT	SEGMENT
column$ = 8
x1$ = 36
x2$ = 68
__$ReturnUdt$ = 320
table$ = 328
column_n$ = 336
?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z PROC ; ImGui::TableGetCellBgRect, COMDAT

; 1608 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00018	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001d	48 8b fc	 mov	 rdi, rsp
  00020	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR [rsp+376]

; 1609 :     const ImGuiTableColumn* column = &table->Columns[column_n];

  00034	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0003b	48 83 c0 18	 add	 rax, 24
  0003f	8b 95 50 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  0004d	48 89 45 08	 mov	 QWORD PTR column$[rbp], rax

; 1610 :     float x1 = column->MinX;

  00051	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  00055	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  0005a	f3 0f 11 45 24	 movss	 DWORD PTR x1$[rbp], xmm0

; 1611 :     float x2 = column->MaxX;

  0005f	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  00063	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  00068	f3 0f 11 45 44	 movss	 DWORD PTR x2$[rbp], xmm0

; 1612 :     //if (column->PrevEnabledColumn == -1)
; 1613 :     //    x1 -= table->OuterPaddingX;
; 1614 :     //if (column->NextEnabledColumn == -1)
; 1615 :     //    x2 += table->OuterPaddingX;
; 1616 :     x1 = ImMax(x1, table->WorkRect.Min.x);

  0006d	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00074	f3 0f 10 88 08
	01 00 00	 movss	 xmm1, DWORD PTR [rax+264]
  0007c	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR x1$[rbp]
  00081	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00086	f3 0f 11 45 24	 movss	 DWORD PTR x1$[rbp], xmm0

; 1617 :     x2 = ImMin(x2, table->WorkRect.Max.x);

  0008b	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00092	f3 0f 10 88 10
	01 00 00	 movss	 xmm1, DWORD PTR [rax+272]
  0009a	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR x2$[rbp]
  0009f	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  000a4	f3 0f 11 45 44	 movss	 DWORD PTR x2$[rbp], xmm0

; 1618 :     return ImRect(x1, table->RowPosY1, x2, table->RowPosY2);

  000a9	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000b0	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  000b8	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  000be	f3 0f 10 5d 44	 movss	 xmm3, DWORD PTR x2$[rbp]
  000c3	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000ca	f3 0f 10 50 7c	 movss	 xmm2, DWORD PTR [rax+124]
  000cf	f3 0f 10 4d 24	 movss	 xmm1, DWORD PTR x1$[rbp]
  000d4	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000db	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@MMMM@Z	; ImRect::ImRect
  000e0	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 1619 : }

  000e7	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000ee	5f		 pop	 rdi
  000ef	5d		 pop	 rbp
  000f0	c3		 ret	 0
?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z ENDP ; ImGui::TableGetCellBgRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
column$ = 8
window$ = 40
p_max_pos_x$ = 72
tv85 = 280
table$ = 320
?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z PROC		; ImGui::TableEndCell, COMDAT

; 2023 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR [rsp+360]

; 2024 :     ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];

  0002a	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00031	48 83 c0 18	 add	 rax, 24
  00035	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0003c	8b 51 74	 mov	 edx, DWORD PTR [rcx+116]
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00047	48 89 45 08	 mov	 QWORD PTR column$[rbp], rax

; 2025 :     ImGuiWindow* window = table->InnerWindow;

  0004b	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00052	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00059	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 2026 : 
; 2027 :     if (window->DC.IsSetPos)

  0005d	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00061	0f b6 80 39 01
	00 00		 movzx	 eax, BYTE PTR [rax+313]
  00068	85 c0		 test	 eax, eax
  0006a	74 05		 je	 SHORT $LN2@TableEndCe

; 2028 :         ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

  0006c	e8 00 00 00 00	 call	 ?ErrorCheckUsingSetCursorPosToExtendParentBoundaries@ImGui@@YAXXZ ; ImGui::ErrorCheckUsingSetCursorPosToExtendParentBoundaries
$LN2@TableEndCe:

; 2029 : 
; 2030 :     // Report maximum position so we can infer content size per column.
; 2031 :     float* p_max_pos_x;
; 2032 :     if (table->RowFlags & ImGuiTableRowFlags_Headers)

  00071	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00078	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0007e	c1 e0 10	 shl	 eax, 16
  00081	c1 f8 10	 sar	 eax, 16
  00084	83 e0 01	 and	 eax, 1
  00087	85 c0		 test	 eax, eax
  00089	74 0e		 je	 SHORT $LN3@TableEndCe

; 2033 :         p_max_pos_x = &column->ContentMaxXHeadersUsed;  // Useful in case user submit contents in header row that is not a TableHeader() call

  0008b	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  0008f	48 83 c0 48	 add	 rax, 72			; 00000048H
  00093	48 89 45 48	 mov	 QWORD PTR p_max_pos_x$[rbp], rax

; 2034 :     else

  00097	eb 3d		 jmp	 SHORT $LN4@TableEndCe
$LN3@TableEndCe:

; 2035 :         p_max_pos_x = table->IsUnfrozenRows ? &column->ContentMaxXUnfrozen : &column->ContentMaxXFrozen;

  00099	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000a0	0f b6 80 2d 02
	00 00		 movzx	 eax, BYTE PTR [rax+557]
  000a7	85 c0		 test	 eax, eax
  000a9	74 11		 je	 SHORT $LN6@TableEndCe
  000ab	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  000af	48 83 c0 44	 add	 rax, 68			; 00000044H
  000b3	48 89 85 18 01
	00 00		 mov	 QWORD PTR tv85[rbp], rax
  000ba	eb 0f		 jmp	 SHORT $LN7@TableEndCe
$LN6@TableEndCe:
  000bc	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  000c0	48 83 c0 40	 add	 rax, 64			; 00000040H
  000c4	48 89 85 18 01
	00 00		 mov	 QWORD PTR tv85[rbp], rax
$LN7@TableEndCe:
  000cb	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR tv85[rbp]
  000d2	48 89 45 48	 mov	 QWORD PTR p_max_pos_x$[rbp], rax
$LN4@TableEndCe:

; 2036 :     *p_max_pos_x = ImMax(*p_max_pos_x, window->DC.CursorMaxPos.x);

  000d6	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000da	f3 0f 10 88 10
	01 00 00	 movss	 xmm1, DWORD PTR [rax+272]
  000e2	48 8b 45 48	 mov	 rax, QWORD PTR p_max_pos_x$[rbp]
  000e6	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  000ea	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000ef	48 8b 45 48	 mov	 rax, QWORD PTR p_max_pos_x$[rbp]
  000f3	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 2037 :     table->RowPosY2 = ImMax(table->RowPosY2, window->DC.CursorMaxPos.y + table->CellPaddingY);

  000f7	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000fb	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00102	f3 0f 10 80 14
	01 00 00	 movss	 xmm0, DWORD PTR [rax+276]
  0010a	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [rcx+192]
  00112	0f 28 c8	 movaps	 xmm1, xmm0
  00115	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0011c	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  00124	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00129	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00130	f3 0f 11 80 80
	00 00 00	 movss	 DWORD PTR [rax+128], xmm0

; 2038 :     column->ItemWidth = window->DC.ItemWidth;

  00138	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  0013c	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00140	f3 0f 10 81 b4
	01 00 00	 movss	 xmm0, DWORD PTR [rcx+436]
  00148	f3 0f 11 40 3c	 movss	 DWORD PTR [rax+60], xmm0

; 2039 : 
; 2040 :     // Propagate text baseline for the entire row
; 2041 :     // FIXME-TABLE: Here we propagate text baseline from the last line of the cell.. instead of the first one.
; 2042 :     table->RowTextBaseline = ImMax(table->RowTextBaseline, window->DC.PrevLineTextBaseOffset);

  0014d	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00151	f3 0f 10 88 34
	01 00 00	 movss	 xmm1, DWORD PTR [rax+308]
  00159	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00160	f3 0f 10 80 88
	00 00 00	 movss	 xmm0, DWORD PTR [rax+136]
  00168	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0016d	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00174	f3 0f 11 80 88
	00 00 00	 movss	 DWORD PTR [rax+136], xmm0

; 2043 : }

  0017c	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00183	5f		 pop	 rdi
  00184	5d		 pop	 rbp
  00185	c3		 ret	 0
?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z ENDP		; ImGui::TableEndCell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z
_TEXT	SEGMENT
column$ = 8
window$ = 40
start_x$ = 68
g$1 = 104
g$ = 136
table$ = 384
column_n$ = 392
?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z PROC	; ImGui::TableBeginCell, COMDAT

; 1965 : {

$LN9:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 62 00 00 00	 mov	 ecx, 98			; 00000062H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+424]

; 1966 :     ImGuiTableColumn* column = &table->Columns[column_n];

  0002e	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00035	48 83 c0 18	 add	 rax, 24
  00039	8b 95 88 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00047	48 89 45 08	 mov	 QWORD PTR column$[rbp], rax

; 1967 :     ImGuiWindow* window = table->InnerWindow;

  0004b	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00052	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00059	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 1968 :     table->CurrentColumn = column_n;

  0005d	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00064	8b 8d 88 01 00
	00		 mov	 ecx, DWORD PTR column_n$[rbp]
  0006a	89 48 74	 mov	 DWORD PTR [rax+116], ecx

; 1969 : 
; 1970 :     // Start position is roughly ~~ CellRect.Min + CellPadding + Indent
; 1971 :     float start_x = column->WorkMinX;

  0006d	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  00071	f3 0f 10 40 34	 movss	 xmm0, DWORD PTR [rax+52]
  00076	f3 0f 11 45 44	 movss	 DWORD PTR start_x$[rbp], xmm0

; 1972 :     if (column->Flags & ImGuiTableColumnFlags_IndentEnable)

  0007b	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  0007f	8b 00		 mov	 eax, DWORD PTR [rax]
  00081	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00086	85 c0		 test	 eax, eax
  00088	74 19		 je	 SHORT $LN2@TableBegin

; 1973 :         start_x += table->RowIndentOffsetX; // ~~ += window.DC.Indent.x - table->HostIndentX, except we locked it for the row.

  0008a	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00091	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR start_x$[rbp]
  00096	f3 0f 58 80 8c
	00 00 00	 addss	 xmm0, DWORD PTR [rax+140]
  0009e	f3 0f 11 45 44	 movss	 DWORD PTR start_x$[rbp], xmm0
$LN2@TableBegin:

; 1974 : 
; 1975 :     window->DC.CursorPos.x = start_x;

  000a3	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000a7	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR start_x$[rbp]
  000ac	f3 0f 11 80 f8
	00 00 00	 movss	 DWORD PTR [rax+248], xmm0

; 1976 :     window->DC.CursorPos.y = table->RowPosY1 + table->CellPaddingY;

  000b4	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000bb	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000c2	f3 0f 10 40 7c	 movss	 xmm0, DWORD PTR [rax+124]
  000c7	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [rcx+192]
  000cf	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000d3	f3 0f 11 80 fc
	00 00 00	 movss	 DWORD PTR [rax+252], xmm0

; 1977 :     window->DC.CursorMaxPos.x = window->DC.CursorPos.x;

  000db	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000df	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  000e3	f3 0f 10 81 f8
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+248]
  000eb	f3 0f 11 80 10
	01 00 00	 movss	 DWORD PTR [rax+272], xmm0

; 1978 :     window->DC.ColumnsOffset.x = start_x - window->Pos.x - window->DC.Indent.x; // FIXME-WORKRECT

  000f3	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000f7	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR start_x$[rbp]
  000fc	f3 0f 5c 40 18	 subss	 xmm0, DWORD PTR [rax+24]
  00101	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00105	f3 0f 5c 80 3c
	01 00 00	 subss	 xmm0, DWORD PTR [rax+316]
  0010d	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00111	f3 0f 11 80 40
	01 00 00	 movss	 DWORD PTR [rax+320], xmm0

; 1979 :     window->DC.CurrLineTextBaseOffset = table->RowTextBaseline;

  00119	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0011d	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00124	f3 0f 10 81 88
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+136]
  0012c	f3 0f 11 80 30
	01 00 00	 movss	 DWORD PTR [rax+304], xmm0

; 1980 :     window->DC.NavLayerCurrent = (ImGuiNavLayer)column->NavLayerCurrent;

  00134	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  00138	0f be 40 6a	 movsx	 eax, BYTE PTR [rax+106]
  0013c	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00140	89 81 50 01 00
	00		 mov	 DWORD PTR [rcx+336], eax

; 1981 : 
; 1982 :     window->WorkRect.Min.y = window->DC.CursorPos.y;

  00146	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0014a	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  0014e	f3 0f 10 81 fc
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+252]
  00156	f3 0f 11 80 14
	02 00 00	 movss	 DWORD PTR [rax+532], xmm0

; 1983 :     window->WorkRect.Min.x = column->WorkMinX;

  0015e	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00162	48 8b 4d 08	 mov	 rcx, QWORD PTR column$[rbp]
  00166	f3 0f 10 41 34	 movss	 xmm0, DWORD PTR [rcx+52]
  0016b	f3 0f 11 80 10
	02 00 00	 movss	 DWORD PTR [rax+528], xmm0

; 1984 :     window->WorkRect.Max.x = column->WorkMaxX;

  00173	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00177	48 8b 4d 08	 mov	 rcx, QWORD PTR column$[rbp]
  0017b	f3 0f 10 41 38	 movss	 xmm0, DWORD PTR [rcx+56]
  00180	f3 0f 11 80 18
	02 00 00	 movss	 DWORD PTR [rax+536], xmm0

; 1985 :     window->DC.ItemWidth = column->ItemWidth;

  00188	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0018c	48 8b 4d 08	 mov	 rcx, QWORD PTR column$[rbp]
  00190	f3 0f 10 41 3c	 movss	 xmm0, DWORD PTR [rcx+60]
  00195	f3 0f 11 80 b4
	01 00 00	 movss	 DWORD PTR [rax+436], xmm0

; 1986 : 
; 1987 :     // To allow ImGuiListClipper to function we propagate our row height
; 1988 :     if (!column->IsEnabled)

  0019d	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  001a1	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  001a5	85 c0		 test	 eax, eax
  001a7	75 2c		 jne	 SHORT $LN3@TableBegin

; 1989 :         window->DC.CursorPos.y = ImMax(window->DC.CursorPos.y, table->RowPosY2);

  001a9	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001b0	f3 0f 10 88 80
	00 00 00	 movss	 xmm1, DWORD PTR [rax+128]
  001b8	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  001bc	f3 0f 10 80 fc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+252]
  001c4	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001c9	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  001cd	f3 0f 11 80 fc
	00 00 00	 movss	 DWORD PTR [rax+252], xmm0
$LN3@TableBegin:

; 1990 : 
; 1991 :     window->SkipItems = column->IsSkipItems;

  001d5	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  001d9	48 8b 4d 08	 mov	 rcx, QWORD PTR column$[rbp]
  001dd	0f b6 49 68	 movzx	 ecx, BYTE PTR [rcx+104]
  001e1	88 88 b3 00 00
	00		 mov	 BYTE PTR [rax+179], cl

; 1992 :     if (column->IsSkipItems)

  001e7	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  001eb	0f b6 40 68	 movzx	 eax, BYTE PTR [rax+104]
  001ef	85 c0		 test	 eax, eax
  001f1	74 27		 je	 SHORT $LN4@TableBegin

; 1993 :     {
; 1994 :         ImGuiContext& g = *GImGui;

  001f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  001fa	48 89 45 68	 mov	 QWORD PTR g$1[rbp], rax

; 1995 :         g.LastItemData.ID = 0;

  001fe	48 8b 45 68	 mov	 rax, QWORD PTR g$1[rbp]
  00202	c7 80 3c 47 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18236], 0

; 1996 :         g.LastItemData.StatusFlags = 0;

  0020c	48 8b 45 68	 mov	 rax, QWORD PTR g$1[rbp]
  00210	c7 80 44 47 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18244], 0
$LN4@TableBegin:

; 1997 :     }
; 1998 : 
; 1999 :     if (table->Flags & ImGuiTableFlags_NoClip)

  0021a	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00221	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00224	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00229	85 c0		 test	 eax, eax
  0022b	74 26		 je	 SHORT $LN5@TableBegin

; 2000 :     {
; 2001 :         // FIXME: if we end up drawing all borders/bg in EndTable, could remove this and just assert that channel hasn't changed.
; 2002 :         table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);

  0022d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00233	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00237	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  0023e	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00245	48 8b 88 98 01
	00 00		 mov	 rcx, QWORD PTR [rax+408]
  0024c	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 2003 :         //IM_ASSERT(table->DrawSplitter._Current == TABLE_DRAW_CHANNEL_NOCLIP);
; 2004 :     }
; 2005 :     else

  00251	eb 3d		 jmp	 SHORT $LN6@TableBegin
$LN5@TableBegin:

; 2006 :     {
; 2007 :         // FIXME-TABLE: Could avoid this if draw channel is dummy channel?
; 2008 :         SetWindowClipRectBeforeSetChannel(window, column->ClipRect);

  00253	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  00257	48 83 c0 20	 add	 rax, 32			; 00000020H
  0025b	48 8b d0	 mov	 rdx, rax
  0025e	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00262	e8 00 00 00 00	 call	 ?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; ImGui::SetWindowClipRectBeforeSetChannel

; 2009 :         table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);

  00267	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  0026b	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  0026f	44 8b c0	 mov	 r8d, eax
  00272	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00276	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  0027d	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00284	48 8b 88 98 01
	00 00		 mov	 rcx, QWORD PTR [rax+408]
  0028b	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN6@TableBegin:

; 2010 :     }
; 2011 : 
; 2012 :     // Logging
; 2013 :     ImGuiContext& g = *GImGui;

  00290	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00297	48 89 85 88 00
	00 00		 mov	 QWORD PTR g$[rbp], rax

; 2014 :     if (g.LogEnabled && !column->IsSkipItems)

  0029e	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  002a5	0f b6 80 10 5c
	00 00		 movzx	 eax, BYTE PTR [rax+23568]
  002ac	85 c0		 test	 eax, eax
  002ae	74 3f		 je	 SHORT $LN7@TableBegin
  002b0	48 8b 45 08	 mov	 rax, QWORD PTR column$[rbp]
  002b4	0f b6 40 68	 movzx	 eax, BYTE PTR [rax+104]
  002b8	85 c0		 test	 eax, eax
  002ba	75 33		 jne	 SHORT $LN7@TableBegin

; 2015 :     {
; 2016 :         LogRenderedText(&window->DC.CursorPos, "|");

  002bc	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  002c0	48 05 f8 00 00
	00		 add	 rax, 248		; 000000f8H
  002c6	45 33 c0	 xor	 r8d, r8d
  002c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01DNKMNLPK@?$HM?$AA@
  002d0	48 8b c8	 mov	 rcx, rax
  002d3	e8 00 00 00 00	 call	 ?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z ; ImGui::LogRenderedText

; 2017 :         g.LogLinePosY = FLT_MAX;

  002d8	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR g$[rbp]
  002df	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  002e7	f3 0f 11 80 40
	5c 00 00	 movss	 DWORD PTR [rax+23616], xmm0
$LN7@TableBegin:

; 2018 :     }
; 2019 : }

  002ef	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  002f6	5f		 pop	 rdi
  002f7	5d		 pop	 rbp
  002f8	c3		 ret	 0
?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z ENDP	; ImGui::TableBeginCell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
g$ = 8
window$ = 40
bg_y1$ = 68
bg_y2$ = 100
unfreeze_rows_actual$ = 132
unfreeze_rows_request$ = 164
is_visible$ = 196
bg_col0$5 = 228
bg_col1$6 = 260
border_col$7 = 292
border_size$8 = 324
draw_cell_bg_color$9 = 356
draw_strong_bottom_border$10 = 388
row_rect$11 = 424
cell_data_end$12 = 472
cell_data$13 = 504
column$14 = 536
cell_bg_rect$15 = 568
column_n$16 = 612
y0$17 = 644
row_height$18 = 676
column_n$19 = 708
column$20 = 744
$T21 = 1156
$T22 = 1204
$T23 = 1236
$T24 = 1268
$T25 = 1300
tv482 = 1316
tv435 = 1316
tv428 = 1316
tv202 = 1316
tv198 = 1316
tv174 = 1316
tv156 = 1316
tv147 = 1316
tv138 = 1316
tv132 = 1316
tv347 = 1320
tv320 = 1320
__$ArrayPad$ = 1328
table$ = 1376
?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z PROC		; ImGui::TableEndRow, COMDAT

; 1762 : {

$LN52:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 81 ec 70 05
	00 00		 sub	 rsp, 1392		; 00000570H
  0000f	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 5c 01 00 00	 mov	 ecx, 348		; 0000015cH
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 98
	05 00 00	 mov	 rcx, QWORD PTR [rsp+1432]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c5	 xor	 rax, rbp
  00035	48 89 85 30 05
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 1763 :     ImGuiContext& g = *GImGui;

  0003c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00043	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1764 :     ImGuiWindow* window = g.CurrentWindow;

  00047	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0004b	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  00052	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 1765 :     IM_ASSERT(window == table->InnerWindow);

  00056	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0005d	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00064	48 39 45 28	 cmp	 QWORD PTR window$[rbp], rax
  00068	74 22		 je	 SHORT $LN36@TableEndRo
  0006a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00070	83 c0 03	 add	 eax, 3
  00073	44 8b c0	 mov	 r8d, eax
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@GFLHACMC@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAn?$AAn?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$AA@
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008a	33 c0		 xor	 eax, eax
$LN36@TableEndRo:

; 1766 :     IM_ASSERT(table->IsInsideRow);

  0008c	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00093	0f b6 80 23 02
	00 00		 movzx	 eax, BYTE PTR [rax+547]
  0009a	85 c0		 test	 eax, eax
  0009c	75 22		 jne	 SHORT $LN37@TableEndRo
  0009e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  000a4	83 c0 04	 add	 eax, 4
  000a7	44 8b c0	 mov	 r8d, eax
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@HHNDIFPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAI?$AAn?$AAs?$AAi?$AAd?$AAe?$AAR?$AAo?$AAw?$AA?$AA@
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000be	33 c0		 xor	 eax, eax
$LN37@TableEndRo:

; 1767 : 
; 1768 :     if (table->CurrentColumn != -1)

  000c0	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000c7	83 78 74 ff	 cmp	 DWORD PTR [rax+116], -1
  000cb	74 0c		 je	 SHORT $LN11@TableEndRo

; 1769 :         TableEndCell(table);

  000cd	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000d4	e8 00 00 00 00	 call	 ?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableEndCell
$LN11@TableEndRo:

; 1770 : 
; 1771 :     // Logging
; 1772 :     if (g.LogEnabled)

  000d9	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  000dd	0f b6 80 10 5c
	00 00		 movzx	 eax, BYTE PTR [rax+23568]
  000e4	85 c0		 test	 eax, eax
  000e6	74 11		 je	 SHORT $LN12@TableEndRo

; 1773 :         LogRenderedText(NULL, "|");

  000e8	45 33 c0	 xor	 r8d, r8d
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01DNKMNLPK@?$HM?$AA@
  000f2	33 c9		 xor	 ecx, ecx
  000f4	e8 00 00 00 00	 call	 ?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z ; ImGui::LogRenderedText
$LN12@TableEndRo:

; 1774 : 
; 1775 :     // Position cursor at the bottom of our row so it can be used for e.g. clipping calculation. However it is
; 1776 :     // likely that the next call to TableBeginCell() will reposition the cursor to take account of vertical padding.
; 1777 :     window->DC.CursorPos.y = table->RowPosY2;

  000f9	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000fd	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00104	f3 0f 10 81 80
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+128]
  0010c	f3 0f 11 80 fc
	00 00 00	 movss	 DWORD PTR [rax+252], xmm0

; 1778 : 
; 1779 :     // Row background fill
; 1780 :     const float bg_y1 = table->RowPosY1;

  00114	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0011b	f3 0f 10 40 7c	 movss	 xmm0, DWORD PTR [rax+124]
  00120	f3 0f 11 45 44	 movss	 DWORD PTR bg_y1$[rbp], xmm0

; 1781 :     const float bg_y2 = table->RowPosY2;

  00125	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0012c	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  00134	f3 0f 11 45 64	 movss	 DWORD PTR bg_y2$[rbp], xmm0

; 1782 :     const bool unfreeze_rows_actual = (table->CurrentRow + 1 == table->FreezeRowsCount);

  00139	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00140	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00143	ff c0		 inc	 eax
  00145	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0014c	0f bf 89 14 02
	00 00		 movsx	 ecx, WORD PTR [rcx+532]
  00153	3b c1		 cmp	 eax, ecx
  00155	75 09		 jne	 SHORT $LN38@TableEndRo
  00157	c6 85 24 05 00
	00 01		 mov	 BYTE PTR tv132[rbp], 1
  0015e	eb 07		 jmp	 SHORT $LN39@TableEndRo
$LN38@TableEndRo:
  00160	c6 85 24 05 00
	00 00		 mov	 BYTE PTR tv132[rbp], 0
$LN39@TableEndRo:
  00167	0f b6 85 24 05
	00 00		 movzx	 eax, BYTE PTR tv132[rbp]
  0016e	88 85 84 00 00
	00		 mov	 BYTE PTR unfreeze_rows_actual$[rbp], al

; 1783 :     const bool unfreeze_rows_request = (table->CurrentRow + 1 == table->FreezeRowsRequest);

  00174	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0017b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0017e	ff c0		 inc	 eax
  00180	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00187	0f bf 89 12 02
	00 00		 movsx	 ecx, WORD PTR [rcx+530]
  0018e	3b c1		 cmp	 eax, ecx
  00190	75 09		 jne	 SHORT $LN40@TableEndRo
  00192	c6 85 24 05 00
	00 01		 mov	 BYTE PTR tv138[rbp], 1
  00199	eb 07		 jmp	 SHORT $LN41@TableEndRo
$LN40@TableEndRo:
  0019b	c6 85 24 05 00
	00 00		 mov	 BYTE PTR tv138[rbp], 0
$LN41@TableEndRo:
  001a2	0f b6 85 24 05
	00 00		 movzx	 eax, BYTE PTR tv138[rbp]
  001a9	88 85 a4 00 00
	00		 mov	 BYTE PTR unfreeze_rows_request$[rbp], al

; 1784 :     if (table->CurrentRow == 0)

  001af	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001b6	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  001ba	75 38		 jne	 SHORT $LN13@TableEndRo

; 1785 :         TableGetInstanceData(table, table->InstanceCurrent)->LastFirstRowHeight = bg_y2 - bg_y1;

  001bc	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR bg_y2$[rbp]
  001c1	f3 0f 5c 45 44	 subss	 xmm0, DWORD PTR bg_y1$[rbp]
  001c6	f3 0f 11 85 24
	05 00 00	 movss	 DWORD PTR tv147[rbp], xmm0
  001ce	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001d5	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  001d9	8b d0		 mov	 edx, eax
  001db	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  001e2	e8 00 00 00 00	 call	 ?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z ; ImGui::TableGetInstanceData
  001e7	f3 0f 10 85 24
	05 00 00	 movss	 xmm0, DWORD PTR tv147[rbp]
  001ef	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
$LN13@TableEndRo:

; 1786 : 
; 1787 :     const bool is_visible = (bg_y2 >= table->InnerClipRect.Min.y && bg_y1 <= table->InnerClipRect.Max.y);

  001f4	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001fb	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR bg_y2$[rbp]
  00200	0f 2f 80 1c 01
	00 00		 comiss	 xmm0, DWORD PTR [rax+284]
  00207	72 1e		 jb	 SHORT $LN42@TableEndRo
  00209	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00210	f3 0f 10 80 24
	01 00 00	 movss	 xmm0, DWORD PTR [rax+292]
  00218	0f 2f 45 44	 comiss	 xmm0, DWORD PTR bg_y1$[rbp]
  0021c	72 09		 jb	 SHORT $LN42@TableEndRo
  0021e	c6 85 24 05 00
	00 01		 mov	 BYTE PTR tv156[rbp], 1
  00225	eb 07		 jmp	 SHORT $LN43@TableEndRo
$LN42@TableEndRo:
  00227	c6 85 24 05 00
	00 00		 mov	 BYTE PTR tv156[rbp], 0
$LN43@TableEndRo:
  0022e	0f b6 85 24 05
	00 00		 movzx	 eax, BYTE PTR tv156[rbp]
  00235	88 85 c4 00 00
	00		 mov	 BYTE PTR is_visible$[rbp], al

; 1788 :     if (is_visible)

  0023b	0f b6 85 c4 00
	00 00		 movzx	 eax, BYTE PTR is_visible$[rbp]
  00242	85 c0		 test	 eax, eax
  00244	0f 84 38 06 00
	00		 je	 $LN14@TableEndRo

; 1789 :     {
; 1790 :         // Decide of background color for the row
; 1791 :         ImU32 bg_col0 = 0;

  0024a	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR bg_col0$5[rbp], 0

; 1792 :         ImU32 bg_col1 = 0;

  00254	c7 85 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR bg_col1$6[rbp], 0

; 1793 :         if (table->RowBgColor[0] != IM_COL32_DISABLE)

  0025e	b8 04 00 00 00	 mov	 eax, 4
  00263	48 6b c0 00	 imul	 rax, rax, 0
  00267	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0026e	81 bc 01 98 00
	00 00 00 00 00
	01		 cmp	 DWORD PTR [rcx+rax+152], 16777216 ; 01000000H
  00279	74 1f		 je	 SHORT $LN15@TableEndRo

; 1794 :             bg_col0 = table->RowBgColor[0];

  0027b	b8 04 00 00 00	 mov	 eax, 4
  00280	48 6b c0 00	 imul	 rax, rax, 0
  00284	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0028b	8b 84 01 98 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax+152]
  00292	89 85 e4 00 00
	00		 mov	 DWORD PTR bg_col0$5[rbp], eax
  00298	eb 54		 jmp	 SHORT $LN16@TableEndRo
$LN15@TableEndRo:

; 1795 :         else if (table->Flags & ImGuiTableFlags_RowBg)

  0029a	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002a1	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002a4	83 e0 40	 and	 eax, 64			; 00000040H
  002a7	85 c0		 test	 eax, eax
  002a9	74 43		 je	 SHORT $LN17@TableEndRo

; 1796 :             bg_col0 = GetColorU32((table->RowBgColorCounter & 1) ? ImGuiCol_TableRowBgAlt : ImGuiCol_TableRowBg);

  002ab	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002b2	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  002b8	83 e0 01	 and	 eax, 1
  002bb	85 c0		 test	 eax, eax
  002bd	74 0c		 je	 SHORT $LN44@TableEndRo
  002bf	c7 85 24 05 00
	00 2e 00 00 00	 mov	 DWORD PTR tv174[rbp], 46 ; 0000002eH
  002c9	eb 0a		 jmp	 SHORT $LN45@TableEndRo
$LN44@TableEndRo:
  002cb	c7 85 24 05 00
	00 2d 00 00 00	 mov	 DWORD PTR tv174[rbp], 45 ; 0000002dH
$LN45@TableEndRo:
  002d5	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  002dd	8b 8d 24 05 00
	00		 mov	 ecx, DWORD PTR tv174[rbp]
  002e3	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  002e8	89 85 e4 00 00
	00		 mov	 DWORD PTR bg_col0$5[rbp], eax
$LN17@TableEndRo:
$LN16@TableEndRo:

; 1797 :         if (table->RowBgColor[1] != IM_COL32_DISABLE)

  002ee	b8 04 00 00 00	 mov	 eax, 4
  002f3	48 6b c0 01	 imul	 rax, rax, 1
  002f7	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  002fe	81 bc 01 98 00
	00 00 00 00 00
	01		 cmp	 DWORD PTR [rcx+rax+152], 16777216 ; 01000000H
  00309	74 1d		 je	 SHORT $LN18@TableEndRo

; 1798 :             bg_col1 = table->RowBgColor[1];

  0030b	b8 04 00 00 00	 mov	 eax, 4
  00310	48 6b c0 01	 imul	 rax, rax, 1
  00314	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0031b	8b 84 01 98 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax+152]
  00322	89 85 04 01 00
	00		 mov	 DWORD PTR bg_col1$6[rbp], eax
$LN18@TableEndRo:

; 1799 : 
; 1800 :         // Decide of top border color
; 1801 :         ImU32 border_col = 0;

  00328	c7 85 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR border_col$7[rbp], 0

; 1802 :         const float border_size = TABLE_BORDER_SIZE;

  00332	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0033a	f3 0f 11 85 44
	01 00 00	 movss	 DWORD PTR border_size$8[rbp], xmm0

; 1803 :         if (table->CurrentRow > 0 || table->InnerWindow == table->OuterWindow)

  00342	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00349	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  0034d	7f 1e		 jg	 SHORT $LN20@TableEndRo
  0034f	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00356	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0035d	48 8b 89 78 01
	00 00		 mov	 rcx, QWORD PTR [rcx+376]
  00364	48 39 88 80 01
	00 00		 cmp	 QWORD PTR [rax+384], rcx
  0036b	75 61		 jne	 SHORT $LN19@TableEndRo
$LN20@TableEndRo:

; 1804 :             if (table->Flags & ImGuiTableFlags_BordersInnerH)

  0036d	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00374	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00377	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0037c	85 c0		 test	 eax, eax
  0037e	74 4e		 je	 SHORT $LN21@TableEndRo

; 1805 :                 border_col = (table->LastRowFlags & ImGuiTableRowFlags_Headers) ? table->BorderColorStrong : table->BorderColorLight;

  00380	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00387	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0038d	c1 e0 00	 shl	 eax, 0
  00390	c1 f8 10	 sar	 eax, 16
  00393	83 e0 01	 and	 eax, 1
  00396	85 c0		 test	 eax, eax
  00398	74 15		 je	 SHORT $LN46@TableEndRo
  0039a	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003a1	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  003a7	89 85 24 05 00
	00		 mov	 DWORD PTR tv198[rbp], eax
  003ad	eb 13		 jmp	 SHORT $LN47@TableEndRo
$LN46@TableEndRo:
  003af	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003b6	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [rax+164]
  003bc	89 85 24 05 00
	00		 mov	 DWORD PTR tv198[rbp], eax
$LN47@TableEndRo:
  003c2	8b 85 24 05 00
	00		 mov	 eax, DWORD PTR tv198[rbp]
  003c8	89 85 24 01 00
	00		 mov	 DWORD PTR border_col$7[rbp], eax
$LN21@TableEndRo:
$LN19@TableEndRo:

; 1806 : 
; 1807 :         const bool draw_cell_bg_color = table->RowCellDataCurrent >= 0;

  003ce	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003d5	0f bf 80 1a 02
	00 00		 movsx	 eax, WORD PTR [rax+538]
  003dc	85 c0		 test	 eax, eax
  003de	7c 09		 jl	 SHORT $LN48@TableEndRo
  003e0	c6 85 24 05 00
	00 01		 mov	 BYTE PTR tv202[rbp], 1
  003e7	eb 07		 jmp	 SHORT $LN49@TableEndRo
$LN48@TableEndRo:
  003e9	c6 85 24 05 00
	00 00		 mov	 BYTE PTR tv202[rbp], 0
$LN49@TableEndRo:
  003f0	0f b6 85 24 05
	00 00		 movzx	 eax, BYTE PTR tv202[rbp]
  003f7	88 85 64 01 00
	00		 mov	 BYTE PTR draw_cell_bg_color$9[rbp], al

; 1808 :         const bool draw_strong_bottom_border = unfreeze_rows_actual;

  003fd	0f b6 85 84 00
	00 00		 movzx	 eax, BYTE PTR unfreeze_rows_actual$[rbp]
  00404	88 85 84 01 00
	00		 mov	 BYTE PTR draw_strong_bottom_border$10[rbp], al

; 1809 :         if ((bg_col0 | bg_col1 | border_col) != 0 || draw_strong_bottom_border || draw_cell_bg_color)

  0040a	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR bg_col1$6[rbp]
  00410	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR bg_col0$5[rbp]
  00416	0b c8		 or	 ecx, eax
  00418	8b c1		 mov	 eax, ecx
  0041a	0b 85 24 01 00
	00		 or	 eax, DWORD PTR border_col$7[rbp]
  00420	85 c0		 test	 eax, eax
  00422	75 16		 jne	 SHORT $LN23@TableEndRo
  00424	0f b6 85 84 01
	00 00		 movzx	 eax, BYTE PTR draw_strong_bottom_border$10[rbp]
  0042b	85 c0		 test	 eax, eax
  0042d	75 0b		 jne	 SHORT $LN23@TableEndRo
  0042f	0f b6 85 64 01
	00 00		 movzx	 eax, BYTE PTR draw_cell_bg_color$9[rbp]
  00436	85 c0		 test	 eax, eax
  00438	74 6c		 je	 SHORT $LN22@TableEndRo
$LN23@TableEndRo:

; 1810 :         {
; 1811 :             // In theory we could call SetWindowClipRectBeforeSetChannel() but since we know TableEndRow() is
; 1812 :             // always followed by a change of clipping rectangle we perform the smallest overwrite possible here.
; 1813 :             if ((table->Flags & ImGuiTableFlags_NoClip) == 0)

  0043a	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00441	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00444	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00449	85 c0		 test	 eax, eax
  0044b	75 38		 jne	 SHORT $LN24@TableEndRo

; 1814 :                 window->DrawList->_CmdHeader.ClipRect = table->Bg0ClipRectForDrawCmd.ToVec4();

  0044d	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00454	48 05 38 01 00
	00		 add	 rax, 312		; 00000138H
  0045a	48 8d 95 84 04
	00 00		 lea	 rdx, QWORD PTR $T21[rbp]
  00461	48 8b c8	 mov	 rcx, rax
  00464	e8 00 00 00 00	 call	 ?ToVec4@ImRect@@QEBA?AUImVec4@@XZ ; ImRect::ToVec4
  00469	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  0046d	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  00474	48 8d b9 88 00
	00 00		 lea	 rdi, QWORD PTR [rcx+136]
  0047b	48 8b f0	 mov	 rsi, rax
  0047e	b9 10 00 00 00	 mov	 ecx, 16
  00483	f3 a4		 rep movsb
$LN24@TableEndRo:

; 1815 :             table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_BG0);

  00485	45 33 c0	 xor	 r8d, r8d
  00488	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0048c	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  00493	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0049a	48 8b 88 98 01
	00 00		 mov	 rcx, QWORD PTR [rax+408]
  004a1	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN22@TableEndRo:

; 1816 :         }
; 1817 : 
; 1818 :         // Draw row background
; 1819 :         // We soft/cpu clip this so all backgrounds and borders can share the same clipping rectangle
; 1820 :         if (bg_col0 || bg_col1)

  004a6	83 bd e4 00 00
	00 00		 cmp	 DWORD PTR bg_col0$5[rbp], 0
  004ad	75 0d		 jne	 SHORT $LN26@TableEndRo
  004af	83 bd 04 01 00
	00 00		 cmp	 DWORD PTR bg_col1$6[rbp], 0
  004b6	0f 84 f6 00 00
	00		 je	 $LN25@TableEndRo
$LN26@TableEndRo:

; 1821 :         {
; 1822 :             ImRect row_rect(table->WorkRect.Min.x, bg_y1, table->WorkRect.Max.x, bg_y2);

  004bc	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR bg_y2$[rbp]
  004c1	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  004c7	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004ce	f3 0f 10 98 10
	01 00 00	 movss	 xmm3, DWORD PTR [rax+272]
  004d6	f3 0f 10 55 44	 movss	 xmm2, DWORD PTR bg_y1$[rbp]
  004db	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004e2	f3 0f 10 88 08
	01 00 00	 movss	 xmm1, DWORD PTR [rax+264]
  004ea	48 8d 8d a8 01
	00 00		 lea	 rcx, QWORD PTR row_rect$11[rbp]
  004f1	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@MMMM@Z	; ImRect::ImRect

; 1823 :             row_rect.ClipWith(table->BgClipRect);

  004f6	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004fd	48 05 28 01 00
	00		 add	 rax, 296		; 00000128H
  00503	48 8b d0	 mov	 rdx, rax
  00506	48 8d 8d a8 01
	00 00		 lea	 rcx, QWORD PTR row_rect$11[rbp]
  0050d	e8 00 00 00 00	 call	 ?ClipWith@ImRect@@QEAAXAEBU1@@Z ; ImRect::ClipWith

; 1824 :             if (bg_col0 != 0 && row_rect.Min.y < row_rect.Max.y)

  00512	83 bd e4 00 00
	00 00		 cmp	 DWORD PTR bg_col0$5[rbp], 0
  00519	74 47		 je	 SHORT $LN27@TableEndRo
  0051b	f3 0f 10 85 b4
	01 00 00	 movss	 xmm0, DWORD PTR row_rect$11[rbp+12]
  00523	0f 2f 85 ac 01
	00 00		 comiss	 xmm0, DWORD PTR row_rect$11[rbp+4]
  0052a	76 36		 jbe	 SHORT $LN27@TableEndRo

; 1825 :                 window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col0);

  0052c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00534	0f 57 c0	 xorps	 xmm0, xmm0
  00537	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0053d	44 8b 8d e4 00
	00 00		 mov	 r9d, DWORD PTR bg_col0$5[rbp]
  00544	4c 8d 85 b0 01
	00 00		 lea	 r8, QWORD PTR row_rect$11[rbp+8]
  0054b	48 8d 95 a8 01
	00 00		 lea	 rdx, QWORD PTR row_rect$11[rbp]
  00552	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00556	48 8b 88 90 02
	00 00		 mov	 rcx, QWORD PTR [rax+656]
  0055d	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN27@TableEndRo:

; 1826 :             if (bg_col1 != 0 && row_rect.Min.y < row_rect.Max.y)

  00562	83 bd 04 01 00
	00 00		 cmp	 DWORD PTR bg_col1$6[rbp], 0
  00569	74 47		 je	 SHORT $LN28@TableEndRo
  0056b	f3 0f 10 85 b4
	01 00 00	 movss	 xmm0, DWORD PTR row_rect$11[rbp+12]
  00573	0f 2f 85 ac 01
	00 00		 comiss	 xmm0, DWORD PTR row_rect$11[rbp+4]
  0057a	76 36		 jbe	 SHORT $LN28@TableEndRo

; 1827 :                 window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col1);

  0057c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00584	0f 57 c0	 xorps	 xmm0, xmm0
  00587	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0058d	44 8b 8d 04 01
	00 00		 mov	 r9d, DWORD PTR bg_col1$6[rbp]
  00594	4c 8d 85 b0 01
	00 00		 lea	 r8, QWORD PTR row_rect$11[rbp+8]
  0059b	48 8d 95 a8 01
	00 00		 lea	 rdx, QWORD PTR row_rect$11[rbp]
  005a2	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  005a6	48 8b 88 90 02
	00 00		 mov	 rcx, QWORD PTR [rax+656]
  005ad	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN28@TableEndRo:
$LN25@TableEndRo:

; 1828 :         }
; 1829 : 
; 1830 :         // Draw cell background color
; 1831 :         if (draw_cell_bg_color)

  005b2	0f b6 85 64 01
	00 00		 movzx	 eax, BYTE PTR draw_cell_bg_color$9[rbp]
  005b9	85 c0		 test	 eax, eax
  005bb	0f 84 4c 01 00
	00		 je	 $LN29@TableEndRo

; 1832 :         {
; 1833 :             ImGuiTableCellData* cell_data_end = &table->RowCellData[table->RowCellDataCurrent];

  005c1	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  005c8	0f bf 80 1a 02
	00 00		 movsx	 eax, WORD PTR [rax+538]
  005cf	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  005d6	48 83 c1 38	 add	 rcx, 56			; 00000038H
  005da	8b d0		 mov	 edx, eax
  005dc	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z ; ImSpan<ImGuiTableCellData>::operator[]
  005e1	48 89 85 d8 01
	00 00		 mov	 QWORD PTR cell_data_end$12[rbp], rax

; 1834 :             for (ImGuiTableCellData* cell_data = &table->RowCellData[0]; cell_data <= cell_data_end; cell_data++)

  005e8	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  005ef	48 83 c0 38	 add	 rax, 56			; 00000038H
  005f3	33 d2		 xor	 edx, edx
  005f5	48 8b c8	 mov	 rcx, rax
  005f8	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z ; ImSpan<ImGuiTableCellData>::operator[]
  005fd	48 89 85 f8 01
	00 00		 mov	 QWORD PTR cell_data$13[rbp], rax
  00604	eb 12		 jmp	 SHORT $LN4@TableEndRo
$LN2@TableEndRo:
  00606	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR cell_data$13[rbp]
  0060d	48 83 c0 08	 add	 rax, 8
  00611	48 89 85 f8 01
	00 00		 mov	 QWORD PTR cell_data$13[rbp], rax
$LN4@TableEndRo:
  00618	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR cell_data_end$12[rbp]
  0061f	48 39 85 f8 01
	00 00		 cmp	 QWORD PTR cell_data$13[rbp], rax
  00626	0f 87 e1 00 00
	00		 ja	 $LN3@TableEndRo

; 1835 :             {
; 1836 :                 // As we render the BG here we need to clip things (for layout we would not)
; 1837 :                 // FIXME: This cancels the OuterPadding addition done by TableGetCellBgRect(), need to keep it while rendering correctly while scrolling.
; 1838 :                 const ImGuiTableColumn* column = &table->Columns[cell_data->Column];

  0062c	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR cell_data$13[rbp]
  00633	0f bf 40 04	 movsx	 eax, WORD PTR [rax+4]
  00637	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0063e	48 83 c1 18	 add	 rcx, 24
  00642	8b d0		 mov	 edx, eax
  00644	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00649	48 89 85 18 02
	00 00		 mov	 QWORD PTR column$14[rbp], rax

; 1839 :                 ImRect cell_bg_rect = TableGetCellBgRect(table, cell_data->Column);

  00650	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR cell_data$13[rbp]
  00657	0f bf 40 04	 movsx	 eax, WORD PTR [rax+4]
  0065b	44 8b c0	 mov	 r8d, eax
  0065e	48 8b 95 60 05
	00 00		 mov	 rdx, QWORD PTR table$[rbp]
  00665	48 8d 8d 38 02
	00 00		 lea	 rcx, QWORD PTR cell_bg_rect$15[rbp]
  0066c	e8 00 00 00 00	 call	 ?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z ; ImGui::TableGetCellBgRect

; 1840 :                 cell_bg_rect.ClipWith(table->BgClipRect);

  00671	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00678	48 05 28 01 00
	00		 add	 rax, 296		; 00000128H
  0067e	48 8b d0	 mov	 rdx, rax
  00681	48 8d 8d 38 02
	00 00		 lea	 rcx, QWORD PTR cell_bg_rect$15[rbp]
  00688	e8 00 00 00 00	 call	 ?ClipWith@ImRect@@QEAAXAEBU1@@Z ; ImRect::ClipWith

; 1841 :                 cell_bg_rect.Min.x = ImMax(cell_bg_rect.Min.x, column->ClipRect.Min.x);     // So that first column after frozen one gets clipped when scrolling

  0068d	48 8b 85 18 02
	00 00		 mov	 rax, QWORD PTR column$14[rbp]
  00694	f3 0f 10 48 20	 movss	 xmm1, DWORD PTR [rax+32]
  00699	f3 0f 10 85 38
	02 00 00	 movss	 xmm0, DWORD PTR cell_bg_rect$15[rbp]
  006a1	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  006a6	f3 0f 11 85 38
	02 00 00	 movss	 DWORD PTR cell_bg_rect$15[rbp], xmm0

; 1842 :                 cell_bg_rect.Max.x = ImMin(cell_bg_rect.Max.x, column->MaxX);

  006ae	48 8b 85 18 02
	00 00		 mov	 rax, QWORD PTR column$14[rbp]
  006b5	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [rax+12]
  006ba	f3 0f 10 85 40
	02 00 00	 movss	 xmm0, DWORD PTR cell_bg_rect$15[rbp+8]
  006c2	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  006c7	f3 0f 11 85 40
	02 00 00	 movss	 DWORD PTR cell_bg_rect$15[rbp+8], xmm0

; 1843 :                 window->DrawList->AddRectFilled(cell_bg_rect.Min, cell_bg_rect.Max, cell_data->BgColor);

  006cf	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  006d7	0f 57 c0	 xorps	 xmm0, xmm0
  006da	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  006e0	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR cell_data$13[rbp]
  006e7	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  006ea	4c 8d 85 40 02
	00 00		 lea	 r8, QWORD PTR cell_bg_rect$15[rbp+8]
  006f1	48 8d 95 38 02
	00 00		 lea	 rdx, QWORD PTR cell_bg_rect$15[rbp]
  006f8	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  006fc	48 8b 88 90 02
	00 00		 mov	 rcx, QWORD PTR [rax+656]
  00703	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1844 :             }

  00708	e9 f9 fe ff ff	 jmp	 $LN2@TableEndRo
$LN3@TableEndRo:
$LN29@TableEndRo:

; 1845 :         }
; 1846 : 
; 1847 :         // Draw top border
; 1848 :         if (border_col && bg_y1 >= table->BgClipRect.Min.y && bg_y1 < table->BgClipRect.Max.y)

  0070d	83 bd 24 01 00
	00 00		 cmp	 DWORD PTR border_col$7[rbp], 0
  00714	0f 84 a7 00 00
	00		 je	 $LN30@TableEndRo
  0071a	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00721	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR bg_y1$[rbp]
  00726	0f 2f 80 2c 01
	00 00		 comiss	 xmm0, DWORD PTR [rax+300]
  0072d	0f 82 8e 00 00
	00		 jb	 $LN30@TableEndRo
  00733	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0073a	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [rax+308]
  00742	0f 2f 45 44	 comiss	 xmm0, DWORD PTR bg_y1$[rbp]
  00746	76 79		 jbe	 SHORT $LN30@TableEndRo

; 1849 :             window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y1), ImVec2(table->BorderX2, bg_y1), border_col, border_size);

  00748	f3 0f 10 55 44	 movss	 xmm2, DWORD PTR bg_y1$[rbp]
  0074d	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00754	f3 0f 10 88 ac
	00 00 00	 movss	 xmm1, DWORD PTR [rax+172]
  0075c	48 8d 8d b4 04
	00 00		 lea	 rcx, QWORD PTR $T22[rbp]
  00763	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00768	48 89 85 28 05
	00 00		 mov	 QWORD PTR tv320[rbp], rax
  0076f	f3 0f 10 55 44	 movss	 xmm2, DWORD PTR bg_y1$[rbp]
  00774	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0077b	f3 0f 10 89 a8
	00 00 00	 movss	 xmm1, DWORD PTR [rcx+168]
  00783	48 8d 8d d4 04
	00 00		 lea	 rcx, QWORD PTR $T23[rbp]
  0078a	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  0078f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00797	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0079d	44 8b 8d 24 01
	00 00		 mov	 r9d, DWORD PTR border_col$7[rbp]
  007a4	48 8b 8d 28 05
	00 00		 mov	 rcx, QWORD PTR tv320[rbp]
  007ab	4c 8b c1	 mov	 r8, rcx
  007ae	48 8b d0	 mov	 rdx, rax
  007b1	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  007b5	48 8b 88 90 02
	00 00		 mov	 rcx, QWORD PTR [rax+656]
  007bc	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN30@TableEndRo:

; 1850 : 
; 1851 :         // Draw bottom border at the row unfreezing mark (always strong)
; 1852 :         if (draw_strong_bottom_border && bg_y2 >= table->BgClipRect.Min.y && bg_y2 < table->BgClipRect.Max.y)

  007c1	0f b6 85 84 01
	00 00		 movzx	 eax, BYTE PTR draw_strong_bottom_border$10[rbp]
  007c8	85 c0		 test	 eax, eax
  007ca	0f 84 b2 00 00
	00		 je	 $LN31@TableEndRo
  007d0	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  007d7	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR bg_y2$[rbp]
  007dc	0f 2f 80 2c 01
	00 00		 comiss	 xmm0, DWORD PTR [rax+300]
  007e3	0f 82 99 00 00
	00		 jb	 $LN31@TableEndRo
  007e9	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  007f0	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [rax+308]
  007f8	0f 2f 45 64	 comiss	 xmm0, DWORD PTR bg_y2$[rbp]
  007fc	0f 86 80 00 00
	00		 jbe	 $LN31@TableEndRo

; 1853 :             window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y2), ImVec2(table->BorderX2, bg_y2), table->BorderColorStrong, border_size);

  00802	f3 0f 10 55 64	 movss	 xmm2, DWORD PTR bg_y2$[rbp]
  00807	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0080e	f3 0f 10 88 ac
	00 00 00	 movss	 xmm1, DWORD PTR [rax+172]
  00816	48 8d 8d f4 04
	00 00		 lea	 rcx, QWORD PTR $T24[rbp]
  0081d	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00822	48 89 85 28 05
	00 00		 mov	 QWORD PTR tv347[rbp], rax
  00829	f3 0f 10 55 64	 movss	 xmm2, DWORD PTR bg_y2$[rbp]
  0082e	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00835	f3 0f 10 89 a8
	00 00 00	 movss	 xmm1, DWORD PTR [rcx+168]
  0083d	48 8d 8d 14 05
	00 00		 lea	 rcx, QWORD PTR $T25[rbp]
  00844	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00849	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00851	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00857	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0085e	44 8b 89 a0 00
	00 00		 mov	 r9d, DWORD PTR [rcx+160]
  00865	48 8b 8d 28 05
	00 00		 mov	 rcx, QWORD PTR tv347[rbp]
  0086c	4c 8b c1	 mov	 r8, rcx
  0086f	48 8b d0	 mov	 rdx, rax
  00872	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00876	48 8b 88 90 02
	00 00		 mov	 rcx, QWORD PTR [rax+656]
  0087d	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN31@TableEndRo:
$LN14@TableEndRo:

; 1854 :     }
; 1855 : 
; 1856 :     // End frozen rows (when we are past the last frozen row line, teleport cursor and alter clipping rectangle)
; 1857 :     // We need to do that in TableEndRow() instead of TableBeginRow() so the list clipper can mark end of row and
; 1858 :     // get the new cursor position.
; 1859 :     if (unfreeze_rows_request)

  00882	0f b6 85 a4 00
	00 00		 movzx	 eax, BYTE PTR unfreeze_rows_request$[rbp]
  00889	85 c0		 test	 eax, eax
  0088b	74 4b		 je	 SHORT $LN32@TableEndRo

; 1860 :         for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  0088d	c7 85 64 02 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$16[rbp], 0
  00897	eb 0e		 jmp	 SHORT $LN7@TableEndRo
$LN5@TableEndRo:
  00899	8b 85 64 02 00
	00		 mov	 eax, DWORD PTR column_n$16[rbp]
  0089f	ff c0		 inc	 eax
  008a1	89 85 64 02 00
	00		 mov	 DWORD PTR column_n$16[rbp], eax
$LN7@TableEndRo:
  008a7	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  008ae	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  008b1	39 85 64 02 00
	00		 cmp	 DWORD PTR column_n$16[rbp], eax
  008b7	7d 1f		 jge	 SHORT $LN6@TableEndRo

; 1861 :             table->Columns[column_n].NavLayerCurrent = ImGuiNavLayer_Main;

  008b9	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  008c0	48 83 c0 18	 add	 rax, 24
  008c4	8b 95 64 02 00
	00		 mov	 edx, DWORD PTR column_n$16[rbp]
  008ca	48 8b c8	 mov	 rcx, rax
  008cd	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  008d2	c6 40 6a 00	 mov	 BYTE PTR [rax+106], 0
  008d6	eb c1		 jmp	 SHORT $LN5@TableEndRo
$LN6@TableEndRo:
$LN32@TableEndRo:

; 1862 :     if (unfreeze_rows_actual)

  008d8	0f b6 85 84 00
	00 00		 movzx	 eax, BYTE PTR unfreeze_rows_actual$[rbp]
  008df	85 c0		 test	 eax, eax
  008e1	0f 84 20 03 00
	00		 je	 $LN33@TableEndRo

; 1863 :     {
; 1864 :         IM_ASSERT(table->IsUnfrozenRows == false);

  008e7	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  008ee	0f b6 80 2d 02
	00 00		 movzx	 eax, BYTE PTR [rax+557]
  008f5	85 c0		 test	 eax, eax
  008f7	74 22		 je	 SHORT $LN50@TableEndRo
  008f9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  008ff	83 c0 66	 add	 eax, 102		; 00000066H
  00902	44 8b c0	 mov	 r8d, eax
  00905	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0090c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@BPCFJEPF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAU?$AAn?$AAf?$AAr?$AAo?$AAz?$AAe?$AAn?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
  00913	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00919	33 c0		 xor	 eax, eax
$LN50@TableEndRo:

; 1865 :         const float y0 = ImMax(table->RowPosY2 + 1, window->InnerClipRect.Min.y);

  0091b	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00922	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  0092a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00932	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00936	f3 0f 10 88 04
	02 00 00	 movss	 xmm1, DWORD PTR [rax+516]
  0093e	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00943	f3 0f 11 85 84
	02 00 00	 movss	 DWORD PTR y0$17[rbp], xmm0

; 1866 :         table->IsUnfrozenRows = true;

  0094b	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00952	c6 80 2d 02 00
	00 01		 mov	 BYTE PTR [rax+557], 1

; 1867 :         TableGetInstanceData(table, table->InstanceCurrent)->LastFrozenHeight = y0 - table->OuterRect.Min.y;

  00959	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00960	f3 0f 10 85 84
	02 00 00	 movss	 xmm0, DWORD PTR y0$17[rbp]
  00968	f3 0f 5c 80 ec
	00 00 00	 subss	 xmm0, DWORD PTR [rax+236]
  00970	f3 0f 11 85 24
	05 00 00	 movss	 DWORD PTR tv428[rbp], xmm0
  00978	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0097f	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  00983	8b d0		 mov	 edx, eax
  00985	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0098c	e8 00 00 00 00	 call	 ?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z ; ImGui::TableGetInstanceData
  00991	f3 0f 10 85 24
	05 00 00	 movss	 xmm0, DWORD PTR tv428[rbp]
  00999	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 1868 : 
; 1869 :         // BgClipRect starts as table->InnerClipRect, reduce it now and make BgClipRectForDrawCmd == BgClipRect
; 1870 :         table->BgClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y = ImMin(y0, window->InnerClipRect.Max.y);

  0099e	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  009a2	f3 0f 10 88 0c
	02 00 00	 movss	 xmm1, DWORD PTR [rax+524]
  009aa	f3 0f 10 85 84
	02 00 00	 movss	 xmm0, DWORD PTR y0$17[rbp]
  009b2	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  009b7	f3 0f 11 85 24
	05 00 00	 movss	 DWORD PTR tv435[rbp], xmm0
  009bf	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  009c6	f3 0f 10 85 24
	05 00 00	 movss	 xmm0, DWORD PTR tv435[rbp]
  009ce	f3 0f 11 80 4c
	01 00 00	 movss	 DWORD PTR [rax+332], xmm0
  009d6	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  009dd	f3 0f 10 85 24
	05 00 00	 movss	 xmm0, DWORD PTR tv435[rbp]
  009e5	f3 0f 11 80 2c
	01 00 00	 movss	 DWORD PTR [rax+300], xmm0

; 1871 :         table->BgClipRect.Max.y = table->Bg2ClipRectForDrawCmd.Max.y = window->InnerClipRect.Max.y;

  009ed	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  009f4	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  009f8	f3 0f 10 81 0c
	02 00 00	 movss	 xmm0, DWORD PTR [rcx+524]
  00a00	f3 0f 11 80 54
	01 00 00	 movss	 DWORD PTR [rax+340], xmm0
  00a08	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00a0f	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00a16	f3 0f 10 81 54
	01 00 00	 movss	 xmm0, DWORD PTR [rcx+340]
  00a1e	f3 0f 11 80 34
	01 00 00	 movss	 DWORD PTR [rax+308], xmm0

; 1872 :         table->Bg2DrawChannelCurrent = table->Bg2DrawChannelUnfrozen;

  00a26	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00a2d	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00a34	0f b7 89 20 02
	00 00		 movzx	 ecx, WORD PTR [rcx+544]
  00a3b	66 89 88 1e 02
	00 00		 mov	 WORD PTR [rax+542], cx

; 1873 :         IM_ASSERT(table->Bg2ClipRectForDrawCmd.Min.y <= table->Bg2ClipRectForDrawCmd.Max.y);

  00a42	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00a49	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00a50	f3 0f 10 80 54
	01 00 00	 movss	 xmm0, DWORD PTR [rax+340]
  00a58	0f 2f 81 4c 01
	00 00		 comiss	 xmm0, DWORD PTR [rcx+332]
  00a5f	73 22		 jae	 SHORT $LN51@TableEndRo
  00a61	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00a67	83 c0 6f	 add	 eax, 111		; 0000006fH
  00a6a	44 8b c0	 mov	 r8d, eax
  00a6d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00a74	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JC@PCOAPGIF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAB?$AAg?$AA2?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AAF?$AAo?$AAr?$AAD?$AAr?$AAa?$AAw?$AAC?$AAm?$AAd?$AA?4?$AAM?$AAi?$AAn@
  00a7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a81	33 c0		 xor	 eax, eax
$LN51@TableEndRo:

; 1874 : 
; 1875 :         float row_height = table->RowPosY2 - table->RowPosY1;

  00a83	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00a8a	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00a91	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  00a99	f3 0f 5c 41 7c	 subss	 xmm0, DWORD PTR [rcx+124]
  00a9e	f3 0f 11 85 a4
	02 00 00	 movss	 DWORD PTR row_height$18[rbp], xmm0

; 1876 :         table->RowPosY2 = window->DC.CursorPos.y = table->WorkRect.Min.y + table->RowPosY2 - table->OuterRect.Min.y;

  00aa6	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00aad	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00ab4	f3 0f 10 80 0c
	01 00 00	 movss	 xmm0, DWORD PTR [rax+268]
  00abc	f3 0f 58 81 80
	00 00 00	 addss	 xmm0, DWORD PTR [rcx+128]
  00ac4	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00acb	f3 0f 5c 80 ec
	00 00 00	 subss	 xmm0, DWORD PTR [rax+236]
  00ad3	f3 0f 11 85 24
	05 00 00	 movss	 DWORD PTR tv482[rbp], xmm0
  00adb	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00adf	f3 0f 10 85 24
	05 00 00	 movss	 xmm0, DWORD PTR tv482[rbp]
  00ae7	f3 0f 11 80 fc
	00 00 00	 movss	 DWORD PTR [rax+252], xmm0
  00aef	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00af6	f3 0f 10 85 24
	05 00 00	 movss	 xmm0, DWORD PTR tv482[rbp]
  00afe	f3 0f 11 80 80
	00 00 00	 movss	 DWORD PTR [rax+128], xmm0

; 1877 :         table->RowPosY1 = table->RowPosY2 - row_height;

  00b06	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00b0d	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  00b15	f3 0f 5c 85 a4
	02 00 00	 subss	 xmm0, DWORD PTR row_height$18[rbp]
  00b1d	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00b24	f3 0f 11 40 7c	 movss	 DWORD PTR [rax+124], xmm0

; 1878 :         for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  00b29	c7 85 c4 02 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$19[rbp], 0
  00b33	eb 0e		 jmp	 SHORT $LN10@TableEndRo
$LN8@TableEndRo:
  00b35	8b 85 c4 02 00
	00		 mov	 eax, DWORD PTR column_n$19[rbp]
  00b3b	ff c0		 inc	 eax
  00b3d	89 85 c4 02 00
	00		 mov	 DWORD PTR column_n$19[rbp], eax
$LN10@TableEndRo:
  00b43	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00b4a	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00b4d	39 85 c4 02 00
	00		 cmp	 DWORD PTR column_n$19[rbp], eax
  00b53	7d 53		 jge	 SHORT $LN9@TableEndRo

; 1879 :         {
; 1880 :             ImGuiTableColumn* column = &table->Columns[column_n];

  00b55	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00b5c	48 83 c0 18	 add	 rax, 24
  00b60	8b 95 c4 02 00
	00		 mov	 edx, DWORD PTR column_n$19[rbp]
  00b66	48 8b c8	 mov	 rcx, rax
  00b69	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00b6e	48 89 85 e8 02
	00 00		 mov	 QWORD PTR column$20[rbp], rax

; 1881 :             column->DrawChannelCurrent = column->DrawChannelUnfrozen;

  00b75	48 8b 85 e8 02
	00 00		 mov	 rax, QWORD PTR column$20[rbp]
  00b7c	48 8b 8d e8 02
	00 00		 mov	 rcx, QWORD PTR column$20[rbp]
  00b83	0f b7 49 60	 movzx	 ecx, WORD PTR [rcx+96]
  00b87	66 89 48 5c	 mov	 WORD PTR [rax+92], cx

; 1882 :             column->ClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y;

  00b8b	48 8b 85 e8 02
	00 00		 mov	 rax, QWORD PTR column$20[rbp]
  00b92	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00b99	f3 0f 10 81 4c
	01 00 00	 movss	 xmm0, DWORD PTR [rcx+332]
  00ba1	f3 0f 11 40 24	 movss	 DWORD PTR [rax+36], xmm0

; 1883 :         }

  00ba6	eb 8d		 jmp	 SHORT $LN8@TableEndRo
$LN9@TableEndRo:

; 1884 : 
; 1885 :         // Update cliprect ahead of TableBeginCell() so clipper can access to new ClipRect->Min.y
; 1886 :         SetWindowClipRectBeforeSetChannel(window, table->Columns[0].ClipRect);

  00ba8	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00baf	48 83 c0 18	 add	 rax, 24
  00bb3	33 d2		 xor	 edx, edx
  00bb5	48 8b c8	 mov	 rcx, rax
  00bb8	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00bbd	48 83 c0 20	 add	 rax, 32			; 00000020H
  00bc1	48 8b d0	 mov	 rdx, rax
  00bc4	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00bc8	e8 00 00 00 00	 call	 ?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; ImGui::SetWindowClipRectBeforeSetChannel

; 1887 :         table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Columns[0].DrawChannelCurrent);

  00bcd	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00bd4	48 83 c0 18	 add	 rax, 24
  00bd8	33 d2		 xor	 edx, edx
  00bda	48 8b c8	 mov	 rcx, rax
  00bdd	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00be2	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  00be6	44 8b c0	 mov	 r8d, eax
  00be9	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00bed	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  00bf4	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00bfb	48 8b 88 98 01
	00 00		 mov	 rcx, QWORD PTR [rax+408]
  00c02	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN33@TableEndRo:

; 1888 :     }
; 1889 : 
; 1890 :     if (!(table->RowFlags & ImGuiTableRowFlags_Headers))

  00c07	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c0e	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00c14	c1 e0 10	 shl	 eax, 16
  00c17	c1 f8 10	 sar	 eax, 16
  00c1a	83 e0 01	 and	 eax, 1
  00c1d	85 c0		 test	 eax, eax
  00c1f	75 1c		 jne	 SHORT $LN34@TableEndRo

; 1891 :         table->RowBgColorCounter++;

  00c21	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c28	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00c2e	ff c0		 inc	 eax
  00c30	48 8b 8d 60 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00c37	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax
$LN34@TableEndRo:

; 1892 :     table->IsInsideRow = false;

  00c3d	48 8b 85 60 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c44	c6 80 23 02 00
	00 00		 mov	 BYTE PTR [rax+547], 0

; 1893 : }

  00c4b	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  00c4f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData
  00c56	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00c5b	48 8b 8d 30 05
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00c62	48 33 cd	 xor	 rcx, rbp
  00c65	e8 00 00 00 00	 call	 __security_check_cookie
  00c6a	48 8d a5 40 05
	00 00		 lea	 rsp, QWORD PTR [rbp+1344]
  00c71	5f		 pop	 rdi
  00c72	5e		 pop	 rsi
  00c73	5d		 pop	 rbp
  00c74	c3		 ret	 0
?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z ENDP		; ImGui::TableEndRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
window$ = 8
next_y1$ = 36
$T1 = 260
table$ = 320
?TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z PROC	; ImGui::TableBeginRow, COMDAT

; 1727 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR [rsp+360]

; 1728 :     ImGuiWindow* window = table->InnerWindow;

  0002a	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00031	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00038	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 1729 :     IM_ASSERT(!table->IsInsideRow);

  0003c	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00043	0f b6 80 23 02
	00 00		 movzx	 eax, BYTE PTR [rax+547]
  0004a	85 c0		 test	 eax, eax
  0004c	74 22		 je	 SHORT $LN6@TableBegin
  0004e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00054	83 c0 02	 add	 eax, 2
  00057	44 8b c0	 mov	 r8d, eax
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@JLDNLAAM@?$AA?$CB?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAI?$AAn?$AAs?$AAi?$AAd?$AAe?$AAR?$AAo?$AAw?$AA?$AA@
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006e	33 c0		 xor	 eax, eax
$LN6@TableBegin:

; 1730 : 
; 1731 :     // New row
; 1732 :     table->CurrentRow++;

  00070	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00077	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0007a	ff c0		 inc	 eax
  0007c	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00083	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 1733 :     table->CurrentColumn = -1;

  00086	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0008d	c7 40 74 ff ff
	ff ff		 mov	 DWORD PTR [rax+116], -1

; 1734 :     table->RowBgColor[0] = table->RowBgColor[1] = IM_COL32_DISABLE;

  00094	b8 04 00 00 00	 mov	 eax, 4
  00099	48 6b c0 01	 imul	 rax, rax, 1
  0009d	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000a4	c7 84 01 98 00
	00 00 00 00 00
	01		 mov	 DWORD PTR [rcx+rax+152], 16777216 ; 01000000H
  000af	b8 04 00 00 00	 mov	 eax, 4
  000b4	48 6b c0 00	 imul	 rax, rax, 0
  000b8	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000bf	c7 84 01 98 00
	00 00 00 00 00
	01		 mov	 DWORD PTR [rcx+rax+152], 16777216 ; 01000000H

; 1735 :     table->RowCellDataCurrent = -1;

  000ca	b8 ff ff ff ff	 mov	 eax, -1
  000cf	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000d6	66 89 81 1a 02
	00 00		 mov	 WORD PTR [rcx+538], ax

; 1736 :     table->IsInsideRow = true;

  000dd	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000e4	c6 80 23 02 00
	00 01		 mov	 BYTE PTR [rax+547], 1

; 1737 : 
; 1738 :     // Begin frozen rows
; 1739 :     float next_y1 = table->RowPosY2;

  000eb	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000f2	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  000fa	f3 0f 11 45 24	 movss	 DWORD PTR next_y1$[rbp], xmm0

; 1740 :     if (table->CurrentRow == 0 && table->FreezeRowsCount > 0)

  000ff	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00106	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  0010a	75 3e		 jne	 SHORT $LN2@TableBegin
  0010c	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00113	0f bf 80 14 02
	00 00		 movsx	 eax, WORD PTR [rax+532]
  0011a	85 c0		 test	 eax, eax
  0011c	7e 2c		 jle	 SHORT $LN2@TableBegin

; 1741 :         next_y1 = window->DC.CursorPos.y = table->OuterRect.Min.y;

  0011e	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00122	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00129	f3 0f 10 81 ec
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+236]
  00131	f3 0f 11 80 fc
	00 00 00	 movss	 DWORD PTR [rax+252], xmm0
  00139	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0013d	f3 0f 10 80 fc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+252]
  00145	f3 0f 11 45 24	 movss	 DWORD PTR next_y1$[rbp], xmm0
$LN2@TableBegin:

; 1742 : 
; 1743 :     table->RowPosY1 = table->RowPosY2 = next_y1;

  0014a	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00151	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR next_y1$[rbp]
  00156	f3 0f 11 80 80
	00 00 00	 movss	 DWORD PTR [rax+128], xmm0
  0015e	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00165	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR next_y1$[rbp]
  0016a	f3 0f 11 40 7c	 movss	 DWORD PTR [rax+124], xmm0

; 1744 :     table->RowTextBaseline = 0.0f;

  0016f	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00176	0f 57 c0	 xorps	 xmm0, xmm0
  00179	f3 0f 11 80 88
	00 00 00	 movss	 DWORD PTR [rax+136], xmm0

; 1745 :     table->RowIndentOffsetX = window->DC.Indent.x - table->HostIndentX; // Lock indent

  00181	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00185	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0018c	f3 0f 10 80 3c
	01 00 00	 movss	 xmm0, DWORD PTR [rax+316]
  00194	f3 0f 5c 81 b0
	00 00 00	 subss	 xmm0, DWORD PTR [rcx+176]
  0019c	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001a3	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [rax+140], xmm0

; 1746 :     window->DC.PrevLineTextBaseOffset = 0.0f;

  001ab	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  001af	0f 57 c0	 xorps	 xmm0, xmm0
  001b2	f3 0f 11 80 34
	01 00 00	 movss	 DWORD PTR [rax+308], xmm0

; 1747 :     window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);

  001ba	0f 57 d2	 xorps	 xmm2, xmm2
  001bd	0f 57 c9	 xorps	 xmm1, xmm1
  001c0	48 8d 8d 04 01
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  001c7	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  001cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cf	48 8b 4d 08	 mov	 rcx, QWORD PTR window$[rbp]
  001d3	48 89 81 20 01
	00 00		 mov	 QWORD PTR [rcx+288], rax

; 1748 :     window->DC.IsSameLine = window->DC.IsSetPos = false;

  001da	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  001de	c6 80 39 01 00
	00 00		 mov	 BYTE PTR [rax+313], 0
  001e5	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  001e9	c6 80 38 01 00
	00 00		 mov	 BYTE PTR [rax+312], 0

; 1749 :     window->DC.CursorMaxPos.y = next_y1;

  001f0	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  001f4	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR next_y1$[rbp]
  001f9	f3 0f 11 80 14
	01 00 00	 movss	 DWORD PTR [rax+276], xmm0

; 1750 : 
; 1751 :     // Making the header BG color non-transparent will allow us to overlay it multiple times when handling smooth dragging.
; 1752 :     if (table->RowFlags & ImGuiTableRowFlags_Headers)

  00201	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00208	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0020e	c1 e0 10	 shl	 eax, 16
  00211	c1 f8 10	 sar	 eax, 16
  00214	83 e0 01	 and	 eax, 1
  00217	85 c0		 test	 eax, eax
  00219	74 3f		 je	 SHORT $LN3@TableBegin

; 1753 :     {
; 1754 :         TableSetBgColor(ImGuiTableBgTarget_RowBg0, GetColorU32(ImGuiCol_TableHeaderBg));

  0021b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00223	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00228	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0022d	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00233	8b d0		 mov	 edx, eax
  00235	b9 01 00 00 00	 mov	 ecx, 1
  0023a	e8 00 00 00 00	 call	 ?TableSetBgColor@ImGui@@YAXHIH@Z ; ImGui::TableSetBgColor

; 1755 :         if (table->CurrentRow == 0)

  0023f	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00246	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  0024a	75 0e		 jne	 SHORT $LN4@TableBegin

; 1756 :             table->IsUsingHeaders = true;

  0024c	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00253	c6 80 26 02 00
	00 01		 mov	 BYTE PTR [rax+550], 1
$LN4@TableBegin:
$LN3@TableBegin:

; 1757 :     }
; 1758 : }

  0025a	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00261	5f		 pop	 rdi
  00262	5d		 pop	 rbp
  00263	c3		 ret	 0
?TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z ENDP	; ImGui::TableBeginRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetColumnWidthAuto@ImGui@@YAMPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z
_TEXT	SEGMENT
content_width_body$ = 4
content_width_headers$ = 36
width_auto$ = 68
table$ = 320
column$ = 328
?TableGetColumnWidthAuto@ImGui@@YAMPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z PROC ; ImGui::TableGetColumnWidthAuto, COMDAT

; 2090 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00013	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR [rsp+376]

; 2091 :     const float content_width_body = ImMax(column->ContentMaxXFrozen, column->ContentMaxXUnfrozen) - column->WorkMinX;

  0002f	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00036	f3 0f 10 48 44	 movss	 xmm1, DWORD PTR [rax+68]
  0003b	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00042	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [rax+64]
  00047	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0004c	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00053	f3 0f 5c 40 34	 subss	 xmm0, DWORD PTR [rax+52]
  00058	f3 0f 11 45 04	 movss	 DWORD PTR content_width_body$[rbp], xmm0

; 2092 :     const float content_width_headers = column->ContentMaxXHeadersIdeal - column->WorkMinX;

  0005d	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00064	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  0006b	f3 0f 10 40 4c	 movss	 xmm0, DWORD PTR [rax+76]
  00070	f3 0f 5c 41 34	 subss	 xmm0, DWORD PTR [rcx+52]
  00075	f3 0f 11 45 24	 movss	 DWORD PTR content_width_headers$[rbp], xmm0

; 2093 :     float width_auto = content_width_body;

  0007a	f3 0f 10 45 04	 movss	 xmm0, DWORD PTR content_width_body$[rbp]
  0007f	f3 0f 11 45 44	 movss	 DWORD PTR width_auto$[rbp], xmm0

; 2094 :     if (!(column->Flags & ImGuiTableColumnFlags_NoHeaderWidth))

  00084	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0008b	8b 00		 mov	 eax, DWORD PTR [rax]
  0008d	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00092	85 c0		 test	 eax, eax
  00094	75 14		 jne	 SHORT $LN2@TableGetCo

; 2095 :         width_auto = ImMax(width_auto, content_width_headers);

  00096	f3 0f 10 4d 24	 movss	 xmm1, DWORD PTR content_width_headers$[rbp]
  0009b	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR width_auto$[rbp]
  000a0	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000a5	f3 0f 11 45 44	 movss	 DWORD PTR width_auto$[rbp], xmm0
$LN2@TableGetCo:

; 2096 : 
; 2097 :     // Non-resizable fixed columns preserve their requested width
; 2098 :     if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f)

  000aa	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  000b1	8b 00		 mov	 eax, DWORD PTR [rax]
  000b3	83 e0 10	 and	 eax, 16
  000b6	85 c0		 test	 eax, eax
  000b8	74 47		 je	 SHORT $LN3@TableGetCo
  000ba	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  000c1	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  000c6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000cd	76 32		 jbe	 SHORT $LN3@TableGetCo

; 2099 :         if (!(table->Flags & ImGuiTableFlags_Resizable) || (column->Flags & ImGuiTableColumnFlags_NoResize))

  000cf	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000d6	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 10		 je	 SHORT $LN5@TableGetCo
  000e0	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  000e7	8b 00		 mov	 eax, DWORD PTR [rax]
  000e9	83 e0 20	 and	 eax, 32			; 00000020H
  000ec	85 c0		 test	 eax, eax
  000ee	74 11		 je	 SHORT $LN4@TableGetCo
$LN5@TableGetCo:

; 2100 :             width_auto = column->InitStretchWeightOrWidth;

  000f0	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  000f7	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  000fc	f3 0f 11 45 44	 movss	 DWORD PTR width_auto$[rbp], xmm0
$LN4@TableGetCo:
$LN3@TableGetCo:

; 2101 : 
; 2102 :     return ImMax(width_auto, table->MinColumnWidth);

  00101	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00108	f3 0f 10 88 b4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+180]
  00110	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR width_auto$[rbp]
  00115	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>

; 2103 : }

  0011a	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00121	5f		 pop	 rdi
  00122	5d		 pop	 rbp
  00123	c3		 ret	 0
?TableGetColumnWidthAuto@ImGui@@YAMPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z ENDP ; ImGui::TableGetColumnWidthAuto
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z
_TEXT	SEGMENT
tv82 = 192
table$ = 240
column$ = 248
?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z PROC ; ImGui::TableFixColumnSortDirection, COMDAT

; 2670 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR [rsp+280]

; 2671 :     if (column->SortOrder == -1 || (column->SortDirectionsAvailMask & (1 << column->SortDirection)) != 0)

  0002f	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00036	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  0003a	83 f8 ff	 cmp	 eax, -1
  0003d	74 33		 je	 SHORT $LN3@TableFixCo
  0003f	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00046	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  0004a	c0 e8 04	 shr	 al, 4
  0004d	24 0f		 and	 al, 15
  0004f	0f b6 c0	 movzx	 eax, al
  00052	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  00059	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  0005d	80 e1 03	 and	 cl, 3
  00060	0f b6 c9	 movzx	 ecx, cl
  00063	ba 01 00 00 00	 mov	 edx, 1
  00068	d3 e2		 shl	 edx, cl
  0006a	8b ca		 mov	 ecx, edx
  0006c	23 c1		 and	 eax, ecx
  0006e	85 c0		 test	 eax, eax
  00070	74 02		 je	 SHORT $LN2@TableFixCo
$LN3@TableFixCo:

; 2672 :         return;

  00072	eb 48		 jmp	 SHORT $LN1@TableFixCo
$LN2@TableFixCo:

; 2673 :     column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);

  00074	33 d2		 xor	 edx, edx
  00076	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  0007d	e8 00 00 00 00	 call	 ?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z ; TableGetColumnAvailSortDirection
  00082	89 85 c0 00 00
	00		 mov	 DWORD PTR tv82[rbp], eax
  00088	0f b6 85 c0 00
	00 00		 movzx	 eax, BYTE PTR tv82[rbp]
  0008f	24 03		 and	 al, 3
  00091	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  00098	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  0009c	80 e1 fc	 and	 cl, 252			; 000000fcH
  0009f	0a c8		 or	 cl, al
  000a1	0f b6 c1	 movzx	 eax, cl
  000a4	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  000ab	88 41 6d	 mov	 BYTE PTR [rcx+109], al

; 2674 :     table->IsSortSpecsDirty = true;

  000ae	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000b5	c6 80 25 02 00
	00 01		 mov	 BYTE PTR [rax+549], 1
$LN1@TableFixCo:

; 2675 : }

  000bc	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000c3	5f		 pop	 rdi
  000c4	5d		 pop	 rbp
  000c5	c3		 ret	 0
?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z ENDP ; ImGui::TableFixColumnSortDirection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z
_TEXT	SEGMENT
n$1 = 4
tv84 = 212
column$ = 256
?TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z PROC ; ImGui::TableGetColumnNextSortDirection, COMDAT

; 2682 : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]

; 2683 :     IM_ASSERT(column->SortDirectionsAvailCount > 0);

  0002a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00031	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  00035	c0 e8 02	 shr	 al, 2
  00038	24 03		 and	 al, 3
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	85 c0		 test	 eax, eax
  0003f	7f 21		 jg	 SHORT $LN8@TableGetCo
  00041	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z@4JA
  00047	ff c0		 inc	 eax
  00049	44 8b c0	 mov	 r8d, eax
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@NEPNAPMF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AAA?$AAv?$AAa?$AAi?$AAl?$AAC?$AAo?$AAu?$AAn?$AAt@
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00060	33 c0		 xor	 eax, eax
$LN8@TableGetCo:

; 2684 :     if (column->SortOrder == -1)

  00062	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00069	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  0006d	83 f8 ff	 cmp	 eax, -1
  00070	75 13		 jne	 SHORT $LN5@TableGetCo

; 2685 :         return TableGetColumnAvailSortDirection(column, 0);

  00072	33 d2		 xor	 edx, edx
  00074	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  0007b	e8 00 00 00 00	 call	 ?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z ; TableGetColumnAvailSortDirection
  00080	e9 a0 00 00 00	 jmp	 $LN1@TableGetCo
$LN5@TableGetCo:

; 2686 :     for (int n = 0; n < 3; n++)

  00085	c7 45 04 00 00
	00 00		 mov	 DWORD PTR n$1[rbp], 0
  0008c	eb 08		 jmp	 SHORT $LN4@TableGetCo
$LN2@TableGetCo:
  0008e	8b 45 04	 mov	 eax, DWORD PTR n$1[rbp]
  00091	ff c0		 inc	 eax
  00093	89 45 04	 mov	 DWORD PTR n$1[rbp], eax
$LN4@TableGetCo:
  00096	83 7d 04 03	 cmp	 DWORD PTR n$1[rbp], 3
  0009a	7d 5f		 jge	 SHORT $LN3@TableGetCo

; 2687 :         if (column->SortDirection == TableGetColumnAvailSortDirection(column, n))

  0009c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  000a3	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  000a7	24 03		 and	 al, 3
  000a9	0f b6 c0	 movzx	 eax, al
  000ac	89 85 d4 00 00
	00		 mov	 DWORD PTR tv84[rbp], eax
  000b2	8b 55 04	 mov	 edx, DWORD PTR n$1[rbp]
  000b5	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  000bc	e8 00 00 00 00	 call	 ?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z ; TableGetColumnAvailSortDirection
  000c1	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR tv84[rbp]
  000c7	3b c8		 cmp	 ecx, eax
  000c9	75 2e		 jne	 SHORT $LN6@TableGetCo

; 2688 :             return TableGetColumnAvailSortDirection(column, (n + 1) % column->SortDirectionsAvailCount);

  000cb	8b 45 04	 mov	 eax, DWORD PTR n$1[rbp]
  000ce	ff c0		 inc	 eax
  000d0	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  000d7	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  000db	c0 e9 02	 shr	 cl, 2
  000de	80 e1 03	 and	 cl, 3
  000e1	0f b6 c9	 movzx	 ecx, cl
  000e4	99		 cdq
  000e5	f7 f9		 idiv	 ecx
  000e7	8b c2		 mov	 eax, edx
  000e9	8b d0		 mov	 edx, eax
  000eb	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  000f2	e8 00 00 00 00	 call	 ?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z ; TableGetColumnAvailSortDirection
  000f7	eb 2c		 jmp	 SHORT $LN1@TableGetCo
$LN6@TableGetCo:

; 2689 :     IM_ASSERT(0);

  000f9	eb 93		 jmp	 SHORT $LN2@TableGetCo
$LN3@TableGetCo:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 22		 jne	 SHORT $LN9@TableGetCo
  00101	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z@4JA
  00107	83 c0 07	 add	 eax, 7
  0010a	44 8b c0	 mov	 r8d, eax
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00121	33 c0		 xor	 eax, eax
$LN9@TableGetCo:

; 2690 :     return ImGuiSortDirection_None;

  00123	33 c0		 xor	 eax, eax
$LN1@TableGetCo:

; 2691 : }

  00125	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0012c	5f		 pop	 rdi
  0012d	5d		 pop	 rbp
  0012e	c3		 ret	 0
?TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z ENDP ; ImGui::TableGetColumnNextSortDirection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
dirty$ = 4
sort_specs$ = 40
column_n$1 = 68
column$2 = 104
sort_spec$3 = 136
tv75 = 340
tv90 = 344
tv89 = 352
table$ = 400
?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z PROC	; ImGui::TableSortSpecsBuild, COMDAT

; 2795 : {

$LN16:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 66 00 00 00	 mov	 ecx, 102		; 00000066H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+440]

; 2796 :     bool dirty = table->IsSortSpecsDirty;

  0002a	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00031	0f b6 80 25 02
	00 00		 movzx	 eax, BYTE PTR [rax+549]
  00038	88 45 04	 mov	 BYTE PTR dirty$[rbp], al

; 2797 :     if (dirty)

  0003b	0f b6 45 04	 movzx	 eax, BYTE PTR dirty$[rbp]
  0003f	85 c0		 test	 eax, eax
  00041	74 76		 je	 SHORT $LN5@TableSortS

; 2798 :     {
; 2799 :         TableSortSpecsSanitize(table);

  00043	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0004a	e8 00 00 00 00	 call	 ?TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableSortSpecsSanitize

; 2800 :         table->SortSpecsMulti.resize(table->SortSpecsCount <= 1 ? 0 : table->SortSpecsCount);

  0004f	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00056	0f bf 80 f0 01
	00 00		 movsx	 eax, WORD PTR [rax+496]
  0005d	83 f8 01	 cmp	 eax, 1
  00060	7f 0c		 jg	 SHORT $LN9@TableSortS
  00062	c7 85 54 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv75[rbp], 0
  0006c	eb 14		 jmp	 SHORT $LN10@TableSortS
$LN9@TableSortS:
  0006e	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00075	0f bf 80 f0 01
	00 00		 movsx	 eax, WORD PTR [rax+496]
  0007c	89 85 54 01 00
	00		 mov	 DWORD PTR tv75[rbp], eax
$LN10@TableSortS:
  00082	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00089	48 05 d0 01 00
	00		 add	 rax, 464		; 000001d0H
  0008f	8b 95 54 01 00
	00		 mov	 edx, DWORD PTR tv75[rbp]
  00095	48 8b c8	 mov	 rcx, rax
  00098	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z ; ImVector<ImGuiTableColumnSortSpecs>::resize

; 2801 :         table->SortSpecs.SpecsDirty = true; // Mark as dirty for user

  0009d	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000a4	c6 80 ec 01 00
	00 01		 mov	 BYTE PTR [rax+492], 1

; 2802 :         table->IsSortSpecsDirty = false; // Mark as not dirty for us

  000ab	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000b2	c6 80 25 02 00
	00 00		 mov	 BYTE PTR [rax+549], 0
$LN5@TableSortS:

; 2803 :     }
; 2804 : 
; 2805 :     // Write output
; 2806 :     ImGuiTableColumnSortSpecs* sort_specs = (table->SortSpecsCount == 0) ? NULL : (table->SortSpecsCount == 1) ? &table->SortSpecsSingle : table->SortSpecsMulti.Data;

  000b9	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000c0	0f bf 80 f0 01
	00 00		 movsx	 eax, WORD PTR [rax+496]
  000c7	85 c0		 test	 eax, eax
  000c9	75 0d		 jne	 SHORT $LN13@TableSortS
  000cb	48 c7 85 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv90[rbp], 0
  000d6	eb 4c		 jmp	 SHORT $LN14@TableSortS
$LN13@TableSortS:
  000d8	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000df	0f bf 80 f0 01
	00 00		 movsx	 eax, WORD PTR [rax+496]
  000e6	83 f8 01	 cmp	 eax, 1
  000e9	75 16		 jne	 SHORT $LN11@TableSortS
  000eb	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000f2	48 05 c0 01 00
	00		 add	 rax, 448		; 000001c0H
  000f8	48 89 85 60 01
	00 00		 mov	 QWORD PTR tv89[rbp], rax
  000ff	eb 15		 jmp	 SHORT $LN12@TableSortS
$LN11@TableSortS:
  00101	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00108	48 8b 80 d8 01
	00 00		 mov	 rax, QWORD PTR [rax+472]
  0010f	48 89 85 60 01
	00 00		 mov	 QWORD PTR tv89[rbp], rax
$LN12@TableSortS:
  00116	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR tv89[rbp]
  0011d	48 89 85 58 01
	00 00		 mov	 QWORD PTR tv90[rbp], rax
$LN14@TableSortS:
  00124	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv90[rbp]
  0012b	48 89 45 28	 mov	 QWORD PTR sort_specs$[rbp], rax

; 2807 :     if (dirty && sort_specs != NULL)

  0012f	0f b6 45 04	 movzx	 eax, BYTE PTR dirty$[rbp]
  00133	85 c0		 test	 eax, eax
  00135	0f 84 19 01 00
	00		 je	 $LN6@TableSortS
  0013b	48 83 7d 28 00	 cmp	 QWORD PTR sort_specs$[rbp], 0
  00140	0f 84 0e 01 00
	00		 je	 $LN6@TableSortS

; 2808 :         for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  00146	c7 45 44 00 00
	00 00		 mov	 DWORD PTR column_n$1[rbp], 0
  0014d	eb 08		 jmp	 SHORT $LN4@TableSortS
$LN2@TableSortS:
  0014f	8b 45 44	 mov	 eax, DWORD PTR column_n$1[rbp]
  00152	ff c0		 inc	 eax
  00154	89 45 44	 mov	 DWORD PTR column_n$1[rbp], eax
$LN4@TableSortS:
  00157	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0015e	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00161	39 45 44	 cmp	 DWORD PTR column_n$1[rbp], eax
  00164	0f 8d ea 00 00
	00		 jge	 $LN3@TableSortS

; 2809 :         {
; 2810 :             ImGuiTableColumn* column = &table->Columns[column_n];

  0016a	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00171	48 83 c0 18	 add	 rax, 24
  00175	8b 55 44	 mov	 edx, DWORD PTR column_n$1[rbp]
  00178	48 8b c8	 mov	 rcx, rax
  0017b	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00180	48 89 45 68	 mov	 QWORD PTR column$2[rbp], rax

; 2811 :             if (column->SortOrder == -1)

  00184	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  00188	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  0018c	83 f8 ff	 cmp	 eax, -1
  0018f	75 02		 jne	 SHORT $LN7@TableSortS

; 2812 :                 continue;

  00191	eb bc		 jmp	 SHORT $LN2@TableSortS
$LN7@TableSortS:

; 2813 :             IM_ASSERT(column->SortOrder < table->SortSpecsCount);

  00193	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  00197	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  0019b	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  001a2	0f bf 89 f0 01
	00 00		 movsx	 ecx, WORD PTR [rcx+496]
  001a9	3b c1		 cmp	 eax, ecx
  001ab	7c 22		 jl	 SHORT $LN15@TableSortS
  001ad	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  001b3	83 c0 12	 add	 eax, 18
  001b6	44 8b c0	 mov	 r8d, eax
  001b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@KLCJNJLO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAS?$AAo?$AAr?$AAt?$AAS@
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001cd	33 c0		 xor	 eax, eax
$LN15@TableSortS:

; 2814 :             ImGuiTableColumnSortSpecs* sort_spec = &sort_specs[column->SortOrder];

  001cf	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  001d3	48 0f bf 40 5a	 movsx	 rax, WORD PTR [rax+90]
  001d8	48 6b c0 0c	 imul	 rax, rax, 12
  001dc	48 8b 4d 28	 mov	 rcx, QWORD PTR sort_specs$[rbp]
  001e0	48 03 c8	 add	 rcx, rax
  001e3	48 8b c1	 mov	 rax, rcx
  001e6	48 89 85 88 00
	00 00		 mov	 QWORD PTR sort_spec$3[rbp], rax

; 2815 :             sort_spec->ColumnUserID = column->UserID;

  001ed	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR sort_spec$3[rbp]
  001f4	48 8b 4d 68	 mov	 rcx, QWORD PTR column$2[rbp]
  001f8	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  001fb	89 08		 mov	 DWORD PTR [rax], ecx

; 2816 :             sort_spec->ColumnIndex = (ImGuiTableColumnIdx)column_n;

  001fd	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR sort_spec$3[rbp]
  00204	0f b7 4d 44	 movzx	 ecx, WORD PTR column_n$1[rbp]
  00208	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 2817 :             sort_spec->SortOrder = (ImGuiTableColumnIdx)column->SortOrder;

  0020c	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR sort_spec$3[rbp]
  00213	48 8b 4d 68	 mov	 rcx, QWORD PTR column$2[rbp]
  00217	0f b7 49 5a	 movzx	 ecx, WORD PTR [rcx+90]
  0021b	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 2818 :             sort_spec->SortDirection = column->SortDirection;

  0021f	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  00223	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  00227	24 03		 and	 al, 3
  00229	0f b6 c0	 movzx	 eax, al
  0022c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00231	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR sort_spec$3[rbp]
  00238	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0023b	81 e1 00 ff ff
	ff		 and	 ecx, -256		; ffffffffffffff00H
  00241	0b c8		 or	 ecx, eax
  00243	8b c1		 mov	 eax, ecx
  00245	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR sort_spec$3[rbp]
  0024c	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 2819 :         }

  0024f	e9 fb fe ff ff	 jmp	 $LN2@TableSortS
$LN3@TableSortS:
$LN6@TableSortS:

; 2820 : 
; 2821 :     table->SortSpecs.Specs = sort_specs;

  00254	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0025b	48 8b 4d 28	 mov	 rcx, QWORD PTR sort_specs$[rbp]
  0025f	48 89 88 e0 01
	00 00		 mov	 QWORD PTR [rax+480], rcx

; 2822 :     table->SortSpecs.SpecsCount = table->SortSpecsCount;

  00266	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0026d	0f bf 80 f0 01
	00 00		 movsx	 eax, WORD PTR [rax+496]
  00274	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0027b	89 81 e8 01 00
	00		 mov	 DWORD PTR [rcx+488], eax

; 2823 : }

  00281	48 8d a5 78 01
	00 00		 lea	 rsp, QWORD PTR [rbp+376]
  00288	5f		 pop	 rdi
  00289	5d		 pop	 rbp
  0028a	c3		 ret	 0
?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z ENDP	; ImGui::TableSortSpecsBuild
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
sort_order_count$ = 4
sort_order_mask$ = 40
column_n$1 = 68
column$2 = 104
need_fix_linearize$ = 132
need_fix_single_sort_order$ = 164
fixed_mask$3 = 200
sort_n$4 = 228
column_with_smallest_sort_order$5 = 260
column_n$6 = 292
column_n$7 = 324
column_n$8 = 356
column$9 = 392
tv222 = 596
tv167 = 596
tv140 = 596
tv295 = 600
tv285 = 600
tv272 = 600
tv266 = 600
tv135 = 608
table$ = 656
?TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z PROC ; ImGui::TableSortSpecsSanitize, COMDAT

; 2729 : {

$LN36:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 98 02
	00 00		 sub	 rsp, 664		; 00000298H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 a6 00 00 00	 mov	 ecx, 166		; 000000a6H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR [rsp+696]

; 2730 :     IM_ASSERT(table->Flags & ImGuiTableFlags_Sortable);

  0002a	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00034	83 e0 08	 and	 eax, 8
  00037	85 c0		 test	 eax, eax
  00039	75 21		 jne	 SHORT $LN29@TableSortS
  0003b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00041	ff c0		 inc	 eax
  00043	44 8b c0	 mov	 r8d, eax
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@NLOFMGNH@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAS@
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005a	33 c0		 xor	 eax, eax
$LN29@TableSortS:

; 2731 : 
; 2732 :     // Clear SortOrder from hidden column and verify that there's no gap or duplicate.
; 2733 :     int sort_order_count = 0;

  0005c	c7 45 04 00 00
	00 00		 mov	 DWORD PTR sort_order_count$[rbp], 0

; 2734 :     ImU64 sort_order_mask = 0x00;

  00063	48 c7 45 28 00
	00 00 00	 mov	 QWORD PTR sort_order_mask$[rbp], 0

; 2735 :     for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  0006b	c7 45 44 00 00
	00 00		 mov	 DWORD PTR column_n$1[rbp], 0
  00072	eb 08		 jmp	 SHORT $LN4@TableSortS
$LN2@TableSortS:
  00074	8b 45 44	 mov	 eax, DWORD PTR column_n$1[rbp]
  00077	ff c0		 inc	 eax
  00079	89 45 44	 mov	 DWORD PTR column_n$1[rbp], eax
$LN4@TableSortS:
  0007c	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00083	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00086	39 45 44	 cmp	 DWORD PTR column_n$1[rbp], eax
  00089	0f 8d b3 00 00
	00		 jge	 $LN3@TableSortS

; 2736 :     {
; 2737 :         ImGuiTableColumn* column = &table->Columns[column_n];

  0008f	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00096	48 83 c0 18	 add	 rax, 24
  0009a	8b 55 44	 mov	 edx, DWORD PTR column_n$1[rbp]
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  000a5	48 89 45 68	 mov	 QWORD PTR column$2[rbp], rax

; 2738 :         if (column->SortOrder != -1 && !column->IsEnabled)

  000a9	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  000ad	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  000b1	83 f8 ff	 cmp	 eax, -1
  000b4	74 19		 je	 SHORT $LN17@TableSortS
  000b6	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  000ba	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  000be	85 c0		 test	 eax, eax
  000c0	75 0d		 jne	 SHORT $LN17@TableSortS

; 2739 :             column->SortOrder = -1;

  000c2	b8 ff ff ff ff	 mov	 eax, -1
  000c7	48 8b 4d 68	 mov	 rcx, QWORD PTR column$2[rbp]
  000cb	66 89 41 5a	 mov	 WORD PTR [rcx+90], ax
$LN17@TableSortS:

; 2740 :         if (column->SortOrder == -1)

  000cf	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  000d3	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  000d7	83 f8 ff	 cmp	 eax, -1
  000da	75 02		 jne	 SHORT $LN18@TableSortS

; 2741 :             continue;

  000dc	eb 96		 jmp	 SHORT $LN2@TableSortS
$LN18@TableSortS:

; 2742 :         sort_order_count++;

  000de	8b 45 04	 mov	 eax, DWORD PTR sort_order_count$[rbp]
  000e1	ff c0		 inc	 eax
  000e3	89 45 04	 mov	 DWORD PTR sort_order_count$[rbp], eax

; 2743 :         sort_order_mask |= ((ImU64)1 << column->SortOrder);

  000e6	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  000ea	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  000ee	b9 01 00 00 00	 mov	 ecx, 1
  000f3	48 89 8d 58 02
	00 00		 mov	 QWORD PTR tv266[rbp], rcx
  000fa	0f b6 c8	 movzx	 ecx, al
  000fd	48 8b 85 58 02
	00 00		 mov	 rax, QWORD PTR tv266[rbp]
  00104	48 d3 e0	 shl	 rax, cl
  00107	48 8b 4d 28	 mov	 rcx, QWORD PTR sort_order_mask$[rbp]
  0010b	48 0b c8	 or	 rcx, rax
  0010e	48 8b c1	 mov	 rax, rcx
  00111	48 89 45 28	 mov	 QWORD PTR sort_order_mask$[rbp], rax

; 2744 :         IM_ASSERT(sort_order_count < (int)sizeof(sort_order_mask) * 8);

  00115	83 7d 04 40	 cmp	 DWORD PTR sort_order_count$[rbp], 64 ; 00000040H
  00119	7c 22		 jl	 SHORT $LN30@TableSortS
  0011b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00121	83 c0 0f	 add	 eax, 15
  00124	44 8b c0	 mov	 r8d, eax
  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GI@FLDFCCLG@?$AAs?$AAo?$AAr?$AAt?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs@
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0013b	33 c0		 xor	 eax, eax
$LN30@TableSortS:

; 2745 :     }

  0013d	e9 32 ff ff ff	 jmp	 $LN2@TableSortS
$LN3@TableSortS:

; 2746 : 
; 2747 :     const bool need_fix_linearize = ((ImU64)1 << sort_order_count) != (sort_order_mask + 1);

  00142	8b 45 04	 mov	 eax, DWORD PTR sort_order_count$[rbp]
  00145	b9 01 00 00 00	 mov	 ecx, 1
  0014a	48 89 8d 58 02
	00 00		 mov	 QWORD PTR tv272[rbp], rcx
  00151	0f b6 c8	 movzx	 ecx, al
  00154	48 8b 85 58 02
	00 00		 mov	 rax, QWORD PTR tv272[rbp]
  0015b	48 d3 e0	 shl	 rax, cl
  0015e	48 8b 4d 28	 mov	 rcx, QWORD PTR sort_order_mask$[rbp]
  00162	48 ff c1	 inc	 rcx
  00165	48 3b c1	 cmp	 rax, rcx
  00168	74 09		 je	 SHORT $LN31@TableSortS
  0016a	c6 85 60 02 00
	00 01		 mov	 BYTE PTR tv135[rbp], 1
  00171	eb 07		 jmp	 SHORT $LN32@TableSortS
$LN31@TableSortS:
  00173	c6 85 60 02 00
	00 00		 mov	 BYTE PTR tv135[rbp], 0
$LN32@TableSortS:
  0017a	0f b6 85 60 02
	00 00		 movzx	 eax, BYTE PTR tv135[rbp]
  00181	88 85 84 00 00
	00		 mov	 BYTE PTR need_fix_linearize$[rbp], al

; 2748 :     const bool need_fix_single_sort_order = (sort_order_count > 1) && !(table->Flags & ImGuiTableFlags_SortMulti);

  00187	83 7d 04 01	 cmp	 DWORD PTR sort_order_count$[rbp], 1
  0018b	7e 1c		 jle	 SHORT $LN33@TableSortS
  0018d	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00194	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00197	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0019c	85 c0		 test	 eax, eax
  0019e	75 09		 jne	 SHORT $LN33@TableSortS
  001a0	c6 85 54 02 00
	00 01		 mov	 BYTE PTR tv140[rbp], 1
  001a7	eb 07		 jmp	 SHORT $LN34@TableSortS
$LN33@TableSortS:
  001a9	c6 85 54 02 00
	00 00		 mov	 BYTE PTR tv140[rbp], 0
$LN34@TableSortS:
  001b0	0f b6 85 54 02
	00 00		 movzx	 eax, BYTE PTR tv140[rbp]
  001b7	88 85 a4 00 00
	00		 mov	 BYTE PTR need_fix_single_sort_order$[rbp], al

; 2749 :     if (need_fix_linearize || need_fix_single_sort_order)

  001bd	0f b6 85 84 00
	00 00		 movzx	 eax, BYTE PTR need_fix_linearize$[rbp]
  001c4	85 c0		 test	 eax, eax
  001c6	75 0f		 jne	 SHORT $LN20@TableSortS
  001c8	0f b6 85 a4 00
	00 00		 movzx	 eax, BYTE PTR need_fix_single_sort_order$[rbp]
  001cf	85 c0		 test	 eax, eax
  001d1	0f 84 1c 02 00
	00		 je	 $LN19@TableSortS
$LN20@TableSortS:

; 2750 :     {
; 2751 :         ImU64 fixed_mask = 0x00;

  001d7	48 c7 85 c8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR fixed_mask$3[rbp], 0

; 2752 :         for (int sort_n = 0; sort_n < sort_order_count; sort_n++)

  001e2	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR sort_n$4[rbp], 0
  001ec	eb 0e		 jmp	 SHORT $LN7@TableSortS
$LN5@TableSortS:
  001ee	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR sort_n$4[rbp]
  001f4	ff c0		 inc	 eax
  001f6	89 85 e4 00 00
	00		 mov	 DWORD PTR sort_n$4[rbp], eax
$LN7@TableSortS:
  001fc	8b 45 04	 mov	 eax, DWORD PTR sort_order_count$[rbp]
  001ff	39 85 e4 00 00
	00		 cmp	 DWORD PTR sort_n$4[rbp], eax
  00205	0f 8d e8 01 00
	00		 jge	 $LN6@TableSortS

; 2753 :         {
; 2754 :             // Fix: Rewrite sort order fields if needed so they have no gap or duplicate.
; 2755 :             // (e.g. SortOrder 0 disappeared, SortOrder 1..2 exists --> rewrite then as SortOrder 0..1)
; 2756 :             int column_with_smallest_sort_order = -1;

  0020b	c7 85 04 01 00
	00 ff ff ff ff	 mov	 DWORD PTR column_with_smallest_sort_order$5[rbp], -1

; 2757 :             for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  00215	c7 85 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$6[rbp], 0
  0021f	eb 0e		 jmp	 SHORT $LN10@TableSortS
$LN8@TableSortS:
  00221	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR column_n$6[rbp]
  00227	ff c0		 inc	 eax
  00229	89 85 24 01 00
	00		 mov	 DWORD PTR column_n$6[rbp], eax
$LN10@TableSortS:
  0022f	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00236	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00239	39 85 24 01 00
	00		 cmp	 DWORD PTR column_n$6[rbp], eax
  0023f	0f 8d b5 00 00
	00		 jge	 $LN9@TableSortS

; 2758 :                 if ((fixed_mask & ((ImU64)1 << (ImU64)column_n)) == 0 && table->Columns[column_n].SortOrder != -1)

  00245	48 63 85 24 01
	00 00		 movsxd	 rax, DWORD PTR column_n$6[rbp]
  0024c	b9 01 00 00 00	 mov	 ecx, 1
  00251	48 89 8d 58 02
	00 00		 mov	 QWORD PTR tv285[rbp], rcx
  00258	0f b6 c8	 movzx	 ecx, al
  0025b	48 8b 85 58 02
	00 00		 mov	 rax, QWORD PTR tv285[rbp]
  00262	48 d3 e0	 shl	 rax, cl
  00265	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR fixed_mask$3[rbp]
  0026c	48 23 c8	 and	 rcx, rax
  0026f	48 8b c1	 mov	 rax, rcx
  00272	48 85 c0	 test	 rax, rax
  00275	75 7e		 jne	 SHORT $LN21@TableSortS
  00277	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0027e	48 83 c0 18	 add	 rax, 24
  00282	8b 95 24 01 00
	00		 mov	 edx, DWORD PTR column_n$6[rbp]
  00288	48 8b c8	 mov	 rcx, rax
  0028b	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00290	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  00294	83 f8 ff	 cmp	 eax, -1
  00297	74 5c		 je	 SHORT $LN21@TableSortS

; 2759 :                     if (column_with_smallest_sort_order == -1 || table->Columns[column_n].SortOrder < table->Columns[column_with_smallest_sort_order].SortOrder)

  00299	83 bd 04 01 00
	00 ff		 cmp	 DWORD PTR column_with_smallest_sort_order$5[rbp], -1
  002a0	74 47		 je	 SHORT $LN23@TableSortS
  002a2	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002a9	48 83 c0 18	 add	 rax, 24
  002ad	8b 95 24 01 00
	00		 mov	 edx, DWORD PTR column_n$6[rbp]
  002b3	48 8b c8	 mov	 rcx, rax
  002b6	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  002bb	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  002bf	89 85 54 02 00
	00		 mov	 DWORD PTR tv167[rbp], eax
  002c5	48 8b 8d 90 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  002cc	48 83 c1 18	 add	 rcx, 24
  002d0	8b 95 04 01 00
	00		 mov	 edx, DWORD PTR column_with_smallest_sort_order$5[rbp]
  002d6	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  002db	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  002df	8b 8d 54 02 00
	00		 mov	 ecx, DWORD PTR tv167[rbp]
  002e5	3b c8		 cmp	 ecx, eax
  002e7	7d 0c		 jge	 SHORT $LN22@TableSortS
$LN23@TableSortS:

; 2760 :                         column_with_smallest_sort_order = column_n;

  002e9	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR column_n$6[rbp]
  002ef	89 85 04 01 00
	00		 mov	 DWORD PTR column_with_smallest_sort_order$5[rbp], eax
$LN22@TableSortS:
$LN21@TableSortS:

; 2761 :             IM_ASSERT(column_with_smallest_sort_order != -1);

  002f5	e9 27 ff ff ff	 jmp	 $LN8@TableSortS
$LN9@TableSortS:
  002fa	83 bd 04 01 00
	00 ff		 cmp	 DWORD PTR column_with_smallest_sort_order$5[rbp], -1
  00301	75 22		 jne	 SHORT $LN35@TableSortS
  00303	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00309	83 c0 20	 add	 eax, 32			; 00000020H
  0030c	44 8b c0	 mov	 r8d, eax
  0030f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@BCBBNGI@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAw?$AAi?$AAt?$AAh?$AA_?$AAs?$AAm?$AAa?$AAl?$AAl?$AAe?$AAs?$AAt?$AA_?$AAs?$AAo?$AAr?$AAt?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?5@
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00323	33 c0		 xor	 eax, eax
$LN35@TableSortS:

; 2762 :             fixed_mask |= ((ImU64)1 << column_with_smallest_sort_order);

  00325	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR column_with_smallest_sort_order$5[rbp]
  0032b	b9 01 00 00 00	 mov	 ecx, 1
  00330	48 89 8d 58 02
	00 00		 mov	 QWORD PTR tv295[rbp], rcx
  00337	0f b6 c8	 movzx	 ecx, al
  0033a	48 8b 85 58 02
	00 00		 mov	 rax, QWORD PTR tv295[rbp]
  00341	48 d3 e0	 shl	 rax, cl
  00344	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR fixed_mask$3[rbp]
  0034b	48 0b c8	 or	 rcx, rax
  0034e	48 8b c1	 mov	 rax, rcx
  00351	48 89 85 c8 00
	00 00		 mov	 QWORD PTR fixed_mask$3[rbp], rax

; 2763 :             table->Columns[column_with_smallest_sort_order].SortOrder = (ImGuiTableColumnIdx)sort_n;

  00358	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0035f	48 83 c0 18	 add	 rax, 24
  00363	8b 95 04 01 00
	00		 mov	 edx, DWORD PTR column_with_smallest_sort_order$5[rbp]
  00369	48 8b c8	 mov	 rcx, rax
  0036c	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00371	0f b7 8d e4 00
	00 00		 movzx	 ecx, WORD PTR sort_n$4[rbp]
  00378	66 89 48 5a	 mov	 WORD PTR [rax+90], cx

; 2764 : 
; 2765 :             // Fix: Make sure only one column has a SortOrder if ImGuiTableFlags_MultiSortable is not set.
; 2766 :             if (need_fix_single_sort_order)

  0037c	0f b6 85 a4 00
	00 00		 movzx	 eax, BYTE PTR need_fix_single_sort_order$[rbp]
  00383	85 c0		 test	 eax, eax
  00385	74 67		 je	 SHORT $LN24@TableSortS

; 2767 :             {
; 2768 :                 sort_order_count = 1;

  00387	c7 45 04 01 00
	00 00		 mov	 DWORD PTR sort_order_count$[rbp], 1

; 2769 :                 for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  0038e	c7 85 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$7[rbp], 0
  00398	eb 0e		 jmp	 SHORT $LN13@TableSortS
$LN11@TableSortS:
  0039a	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR column_n$7[rbp]
  003a0	ff c0		 inc	 eax
  003a2	89 85 44 01 00
	00		 mov	 DWORD PTR column_n$7[rbp], eax
$LN13@TableSortS:
  003a8	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003af	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  003b2	39 85 44 01 00
	00		 cmp	 DWORD PTR column_n$7[rbp], eax
  003b8	7d 32		 jge	 SHORT $LN12@TableSortS

; 2770 :                     if (column_n != column_with_smallest_sort_order)

  003ba	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR column_with_smallest_sort_order$5[rbp]
  003c0	39 85 44 01 00
	00		 cmp	 DWORD PTR column_n$7[rbp], eax
  003c6	74 22		 je	 SHORT $LN25@TableSortS

; 2771 :                         table->Columns[column_n].SortOrder = -1;

  003c8	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003cf	48 83 c0 18	 add	 rax, 24
  003d3	8b 95 44 01 00
	00		 mov	 edx, DWORD PTR column_n$7[rbp]
  003d9	48 8b c8	 mov	 rcx, rax
  003dc	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  003e1	b9 ff ff ff ff	 mov	 ecx, -1
  003e6	66 89 48 5a	 mov	 WORD PTR [rax+90], cx
$LN25@TableSortS:

; 2772 :                 break;

  003ea	eb ae		 jmp	 SHORT $LN11@TableSortS
$LN12@TableSortS:
  003ec	eb 05		 jmp	 SHORT $LN6@TableSortS
$LN24@TableSortS:

; 2773 :             }
; 2774 :         }

  003ee	e9 fb fd ff ff	 jmp	 $LN5@TableSortS
$LN6@TableSortS:
$LN19@TableSortS:

; 2775 :     }
; 2776 : 
; 2777 :     // Fallback default sort order (if no column had the ImGuiTableColumnFlags_DefaultSort flag)
; 2778 :     if (sort_order_count == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))

  003f3	83 7d 04 00	 cmp	 DWORD PTR sort_order_count$[rbp], 0
  003f7	0f 85 dd 00 00
	00		 jne	 $LN26@TableSortS
  003fd	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00404	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00407	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0040c	85 c0		 test	 eax, eax
  0040e	0f 85 c6 00 00
	00		 jne	 $LN26@TableSortS

; 2779 :         for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  00414	c7 85 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$8[rbp], 0
  0041e	eb 0e		 jmp	 SHORT $LN16@TableSortS
$LN14@TableSortS:
  00420	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR column_n$8[rbp]
  00426	ff c0		 inc	 eax
  00428	89 85 64 01 00
	00		 mov	 DWORD PTR column_n$8[rbp], eax
$LN16@TableSortS:
  0042e	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00435	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00438	39 85 64 01 00
	00		 cmp	 DWORD PTR column_n$8[rbp], eax
  0043e	0f 8d 96 00 00
	00		 jge	 $LN15@TableSortS

; 2780 :         {
; 2781 :             ImGuiTableColumn* column = &table->Columns[column_n];

  00444	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0044b	48 83 c0 18	 add	 rax, 24
  0044f	8b 95 64 01 00
	00		 mov	 edx, DWORD PTR column_n$8[rbp]
  00455	48 8b c8	 mov	 rcx, rax
  00458	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  0045d	48 89 85 88 01
	00 00		 mov	 QWORD PTR column$9[rbp], rax

; 2782 :             if (column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_NoSort))

  00464	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR column$9[rbp]
  0046b	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  0046f	85 c0		 test	 eax, eax
  00471	74 62		 je	 SHORT $LN27@TableSortS
  00473	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR column$9[rbp]
  0047a	8b 00		 mov	 eax, DWORD PTR [rax]
  0047c	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00481	85 c0		 test	 eax, eax
  00483	75 50		 jne	 SHORT $LN27@TableSortS

; 2783 :             {
; 2784 :                 sort_order_count = 1;

  00485	c7 45 04 01 00
	00 00		 mov	 DWORD PTR sort_order_count$[rbp], 1

; 2785 :                 column->SortOrder = 0;

  0048c	33 c0		 xor	 eax, eax
  0048e	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$9[rbp]
  00495	66 89 41 5a	 mov	 WORD PTR [rcx+90], ax

; 2786 :                 column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);

  00499	33 d2		 xor	 edx, edx
  0049b	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$9[rbp]
  004a2	e8 00 00 00 00	 call	 ?TableGetColumnAvailSortDirection@@YAHPEAUImGuiTableColumn@@H@Z ; TableGetColumnAvailSortDirection
  004a7	89 85 54 02 00
	00		 mov	 DWORD PTR tv222[rbp], eax
  004ad	0f b6 85 54 02
	00 00		 movzx	 eax, BYTE PTR tv222[rbp]
  004b4	24 03		 and	 al, 3
  004b6	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$9[rbp]
  004bd	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  004c1	80 e1 fc	 and	 cl, 252			; 000000fcH
  004c4	0a c8		 or	 cl, al
  004c6	0f b6 c1	 movzx	 eax, cl
  004c9	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$9[rbp]
  004d0	88 41 6d	 mov	 BYTE PTR [rcx+109], al

; 2787 :                 break;

  004d3	eb 05		 jmp	 SHORT $LN15@TableSortS
$LN27@TableSortS:

; 2788 :             }
; 2789 :         }

  004d5	e9 46 ff ff ff	 jmp	 $LN14@TableSortS
$LN15@TableSortS:
$LN26@TableSortS:

; 2790 : 
; 2791 :     table->SortSpecsCount = (ImGuiTableColumnIdx)sort_order_count;

  004da	48 8b 85 90 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004e1	0f b7 4d 04	 movzx	 ecx, WORD PTR sort_order_count$[rbp]
  004e5	66 89 88 f0 01
	00 00		 mov	 WORD PTR [rax+496], cx

; 2792 : }

  004ec	48 8d a5 78 02
	00 00		 lea	 rsp, QWORD PTR [rbp+632]
  004f3	5f		 pop	 rdi
  004f4	5d		 pop	 rbp
  004f5	c3		 ret	 0
?TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z ENDP ; ImGui::TableSortSpecsSanitize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z
_TEXT	SEGMENT
table$ = 224
instance_no$ = 232
?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z PROC ; ImGui::TableGetInstanceData, COMDAT

; 3004 :     inline ImGuiTableInstanceData*   TableGetInstanceData(ImGuiTable* table, int instance_no) { if (instance_no == 0) return &table->InstanceDataFirst; return &table->InstanceDataExtra[instance_no - 1]; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR instance_no$[rbp], 0
  00035	75 0f		 jne	 SHORT $LN2@TableGetIn
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0003e	48 05 a0 01 00
	00		 add	 rax, 416		; 000001a0H
  00044	eb 1d		 jmp	 SHORT $LN1@TableGetIn
$LN2@TableGetIn:
  00046	8b 85 e8 00 00
	00		 mov	 eax, DWORD PTR instance_no$[rbp]
  0004c	ff c8		 dec	 eax
  0004e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00055	48 81 c1 b0 01
	00 00		 add	 rcx, 432		; 000001b0H
  0005c	8b d0		 mov	 edx, eax
  0005e	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTableInstanceData@@@@QEAAAEAUImGuiTableInstanceData@@H@Z ; ImVector<ImGuiTableInstanceData>::operator[]
$LN1@TableGetIn:
  00063	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0006a	5f		 pop	 rdi
  0006b	5d		 pop	 rbp
  0006c	c3		 ret	 0
?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z ENDP ; ImGui::TableGetInstanceData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
g$ = 8
splitter$ = 40
has_freeze_v$ = 68
has_freeze_h$ = 100
merge_group_mask$ = 132
merge_groups$ = 176
max_draw_channels$ = 324
size_for_masks_bitarrays_one$ = 356
n$6 = 388
remaining_mask$ = 424
column_n$7 = 452
column$8 = 488
merge_group_sub_count$9 = 516
merge_group_sub_n$10 = 548
channel_no$11 = 580
src_channel$12 = 616
content_max_x$13 = 644
merge_group_n$14 = 676
merge_group$15 = 712
LEADING_DRAW_CHANNELS$16 = 740
dst_tmp$17 = 776
remaining_count$18 = 804
host_rect$19 = 840
merge_group_n$20 = 884
merge_channels_count$21 = 916
merge_group$22 = 952
merge_clip_rect$23 = 984
n$24 = 1028
n$25 = 1060
channel$26 = 1096
n$27 = 1124
channel$28 = 1160
$T29 = 1764
$T30 = 1812
$T31 = 1860
$T32 = 1908
tv645 = 1940
tv301 = 1940
tv227 = 1940
tv177 = 1940
tv171 = 1940
tv72 = 1940
tv68 = 1940
tv530 = 1944
tv526 = 1944
tv525 = 1944
tv494 = 1944
tv473 = 1944
tv459 = 1944
tv452 = 1944
tv231 = 1944
__$ArrayPad$ = 1952
table$ = 2000
?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z PROC ; ImGui::TableMergeDrawChannels, COMDAT

; 2361 : {

$LN65:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 81 ec e0 07
	00 00		 sub	 rsp, 2016		; 000007e0H
  0000f	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 f8 01 00 00	 mov	 ecx, 504		; 000001f8H
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 08
	08 00 00	 mov	 rcx, QWORD PTR [rsp+2056]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c5	 xor	 rax, rbp
  00035	48 89 85 a0 07
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 2362 :     ImGuiContext& g = *GImGui;

  0003c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00043	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 2363 :     ImDrawListSplitter* splitter = table->DrawSplitter;

  00047	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0004e	48 8b 80 98 01
	00 00		 mov	 rax, QWORD PTR [rax+408]
  00055	48 89 45 28	 mov	 QWORD PTR splitter$[rbp], rax

; 2364 :     const bool has_freeze_v = (table->FreezeRowsCount > 0);

  00059	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00060	0f bf 80 14 02
	00 00		 movsx	 eax, WORD PTR [rax+532]
  00067	85 c0		 test	 eax, eax
  00069	7e 09		 jle	 SHORT $LN45@TableMerge
  0006b	c6 85 94 07 00
	00 01		 mov	 BYTE PTR tv68[rbp], 1
  00072	eb 07		 jmp	 SHORT $LN46@TableMerge
$LN45@TableMerge:
  00074	c6 85 94 07 00
	00 00		 mov	 BYTE PTR tv68[rbp], 0
$LN46@TableMerge:
  0007b	0f b6 85 94 07
	00 00		 movzx	 eax, BYTE PTR tv68[rbp]
  00082	88 45 44	 mov	 BYTE PTR has_freeze_v$[rbp], al

; 2365 :     const bool has_freeze_h = (table->FreezeColumnsCount > 0);

  00085	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0008c	0f bf 80 18 02
	00 00		 movsx	 eax, WORD PTR [rax+536]
  00093	85 c0		 test	 eax, eax
  00095	7e 09		 jle	 SHORT $LN47@TableMerge
  00097	c6 85 94 07 00
	00 01		 mov	 BYTE PTR tv72[rbp], 1
  0009e	eb 07		 jmp	 SHORT $LN48@TableMerge
$LN47@TableMerge:
  000a0	c6 85 94 07 00
	00 00		 mov	 BYTE PTR tv72[rbp], 0
$LN48@TableMerge:
  000a7	0f b6 85 94 07
	00 00		 movzx	 eax, BYTE PTR tv72[rbp]
  000ae	88 45 64	 mov	 BYTE PTR has_freeze_h$[rbp], al

; 2366 :     IM_ASSERT(splitter->_Current == 0);

  000b1	48 8b 45 28	 mov	 rax, QWORD PTR splitter$[rbp]
  000b5	83 38 00	 cmp	 DWORD PTR [rax], 0
  000b8	74 22		 je	 SHORT $LN49@TableMerge
  000ba	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  000c0	83 c0 05	 add	 eax, 5
  000c3	44 8b c0	 mov	 r8d, eax
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@GEHLCBHG@?$AAs?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000da	33 c0		 xor	 eax, eax
$LN49@TableMerge:

; 2367 : 
; 2368 :     // Track which groups we are going to attempt to merge, and which channels goes into each group.
; 2369 :     struct MergeGroup
; 2370 :     {
; 2371 :         ImRect          ClipRect;
; 2372 :         int             ChannelsCount;
; 2373 :         ImBitArrayPtr   ChannelsMask;
; 2374 :     };
; 2375 :     int merge_group_mask = 0x00;

  000dc	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR merge_group_mask$[rbp], 0

; 2376 :     MergeGroup merge_groups[4] = {};

  000e6	48 8d 85 b0 00
	00 00		 lea	 rax, QWORD PTR merge_groups$[rbp]
  000ed	48 8b f8	 mov	 rdi, rax
  000f0	33 c0		 xor	 eax, eax
  000f2	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000f7	f3 aa		 rep stosb
  000f9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ
  00100	41 b8 04 00 00
	00		 mov	 r8d, 4
  00106	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0010b	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR merge_groups$[rbp]
  00112	e8 00 00 00 00	 call	 ??_H@YAXPEAX_K1P6APEAX0@Z@Z

; 2377 : 
; 2378 :     // Use a reusable temp buffer for the merge masks as they are dynamically sized.
; 2379 :     const int max_draw_channels = (4 + table->ColumnsCount * 2);

  00117	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0011e	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00121	8d 44 00 04	 lea	 eax, DWORD PTR [rax+rax+4]
  00125	89 85 44 01 00
	00		 mov	 DWORD PTR max_draw_channels$[rbp], eax

; 2380 :     const int size_for_masks_bitarrays_one = (int)ImBitArrayGetStorageSizeInBytes(max_draw_channels);

  0012b	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR max_draw_channels$[rbp]
  00131	e8 00 00 00 00	 call	 ?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z ; ImBitArrayGetStorageSizeInBytes
  00136	89 85 64 01 00
	00		 mov	 DWORD PTR size_for_masks_bitarrays_one$[rbp], eax

; 2381 :     g.TempBuffer.reserve(size_for_masks_bitarrays_one * 5);

  0013c	6b 85 64 01 00
	00 05		 imul	 eax, DWORD PTR size_for_masks_bitarrays_one$[rbp], 5
  00143	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00147	48 81 c1 c8 5d
	00 00		 add	 rcx, 24008		; 00005dc8H
  0014e	8b d0		 mov	 edx, eax
  00150	e8 00 00 00 00	 call	 ?reserve@?$ImVector@D@@QEAAXH@Z ; ImVector<char>::reserve

; 2382 :     memset(g.TempBuffer.Data, 0, size_for_masks_bitarrays_one * 5);

  00155	6b 85 64 01 00
	00 05		 imul	 eax, DWORD PTR size_for_masks_bitarrays_one$[rbp], 5
  0015c	48 98		 cdqe
  0015e	4c 8b c0	 mov	 r8, rax
  00161	33 d2		 xor	 edx, edx
  00163	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00167	48 8b 88 d0 5d
	00 00		 mov	 rcx, QWORD PTR [rax+24016]
  0016e	e8 00 00 00 00	 call	 memset

; 2383 :     for (int n = 0; n < IM_ARRAYSIZE(merge_groups); n++)

  00173	c7 85 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR n$6[rbp], 0
  0017d	eb 0e		 jmp	 SHORT $LN4@TableMerge
$LN2@TableMerge:
  0017f	8b 85 84 01 00
	00		 mov	 eax, DWORD PTR n$6[rbp]
  00185	ff c0		 inc	 eax
  00187	89 85 84 01 00
	00		 mov	 DWORD PTR n$6[rbp], eax
$LN4@TableMerge:
  0018d	83 bd 84 01 00
	00 04		 cmp	 DWORD PTR n$6[rbp], 4
  00194	7d 2f		 jge	 SHORT $LN3@TableMerge

; 2384 :         merge_groups[n].ChannelsMask = (ImBitArrayPtr)(void*)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * n));

  00196	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR size_for_masks_bitarrays_one$[rbp]
  0019c	0f af 85 84 01
	00 00		 imul	 eax, DWORD PTR n$6[rbp]
  001a3	48 98		 cdqe
  001a5	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  001a9	48 03 81 d0 5d
	00 00		 add	 rax, QWORD PTR [rcx+24016]
  001b0	48 63 8d 84 01
	00 00		 movsxd	 rcx, DWORD PTR n$6[rbp]
  001b7	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  001bb	48 89 84 0d c8
	00 00 00	 mov	 QWORD PTR merge_groups$[rbp+rcx+24], rax
  001c3	eb ba		 jmp	 SHORT $LN2@TableMerge
$LN3@TableMerge:

; 2385 :     ImBitArrayPtr remaining_mask = (ImBitArrayPtr)(void*)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * 4));

  001c5	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR size_for_masks_bitarrays_one$[rbp]
  001cb	c1 e0 02	 shl	 eax, 2
  001ce	48 98		 cdqe
  001d0	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  001d4	48 03 81 d0 5d
	00 00		 add	 rax, QWORD PTR [rcx+24016]
  001db	48 89 85 a8 01
	00 00		 mov	 QWORD PTR remaining_mask$[rbp], rax

; 2386 : 
; 2387 :     // 1. Scan channels and take note of those which can be merged
; 2388 :     for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  001e2	c7 85 c4 01 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$7[rbp], 0
  001ec	eb 0e		 jmp	 SHORT $LN7@TableMerge
$LN5@TableMerge:
  001ee	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR column_n$7[rbp]
  001f4	ff c0		 inc	 eax
  001f6	89 85 c4 01 00
	00		 mov	 DWORD PTR column_n$7[rbp], eax
$LN7@TableMerge:
  001fc	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00203	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00206	39 85 c4 01 00
	00		 cmp	 DWORD PTR column_n$7[rbp], eax
  0020c	0f 8d c2 03 00
	00		 jge	 $LN6@TableMerge

; 2389 :     {
; 2390 :         if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))

  00212	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR column_n$7[rbp]
  00218	c1 f8 05	 sar	 eax, 5
  0021b	48 98		 cdqe
  0021d	48 8b 8d d0 07
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00224	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00228	48 89 8d 98 07
	00 00		 mov	 QWORD PTR tv530[rbp], rcx
  0022f	8b 95 c4 01 00
	00		 mov	 edx, DWORD PTR column_n$7[rbp]
  00235	83 e2 1f	 and	 edx, 31
  00238	bf 01 00 00 00	 mov	 edi, 1
  0023d	0f b6 ca	 movzx	 ecx, dl
  00240	8b d7		 mov	 edx, edi
  00242	d3 e2		 shl	 edx, cl
  00244	8b ca		 mov	 ecx, edx
  00246	48 8b 95 98 07
	00 00		 mov	 rdx, QWORD PTR tv530[rbp]
  0024d	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00250	23 c1		 and	 eax, ecx
  00252	85 c0		 test	 eax, eax
  00254	75 02		 jne	 SHORT $LN23@TableMerge

; 2391 :             continue;

  00256	eb 96		 jmp	 SHORT $LN5@TableMerge
$LN23@TableMerge:

; 2392 :         ImGuiTableColumn* column = &table->Columns[column_n];

  00258	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0025f	48 83 c0 18	 add	 rax, 24
  00263	8b 95 c4 01 00
	00		 mov	 edx, DWORD PTR column_n$7[rbp]
  00269	48 8b c8	 mov	 rcx, rax
  0026c	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00271	48 89 85 e8 01
	00 00		 mov	 QWORD PTR column$8[rbp], rax

; 2393 : 
; 2394 :         const int merge_group_sub_count = has_freeze_v ? 2 : 1;

  00278	0f b6 45 44	 movzx	 eax, BYTE PTR has_freeze_v$[rbp]
  0027c	85 c0		 test	 eax, eax
  0027e	74 0c		 je	 SHORT $LN50@TableMerge
  00280	c7 85 94 07 00
	00 02 00 00 00	 mov	 DWORD PTR tv171[rbp], 2
  0028a	eb 0a		 jmp	 SHORT $LN51@TableMerge
$LN50@TableMerge:
  0028c	c7 85 94 07 00
	00 01 00 00 00	 mov	 DWORD PTR tv171[rbp], 1
$LN51@TableMerge:
  00296	8b 85 94 07 00
	00		 mov	 eax, DWORD PTR tv171[rbp]
  0029c	89 85 04 02 00
	00		 mov	 DWORD PTR merge_group_sub_count$9[rbp], eax

; 2395 :         for (int merge_group_sub_n = 0; merge_group_sub_n < merge_group_sub_count; merge_group_sub_n++)

  002a2	c7 85 24 02 00
	00 00 00 00 00	 mov	 DWORD PTR merge_group_sub_n$10[rbp], 0
  002ac	eb 0e		 jmp	 SHORT $LN10@TableMerge
$LN8@TableMerge:
  002ae	8b 85 24 02 00
	00		 mov	 eax, DWORD PTR merge_group_sub_n$10[rbp]
  002b4	ff c0		 inc	 eax
  002b6	89 85 24 02 00
	00		 mov	 DWORD PTR merge_group_sub_n$10[rbp], eax
$LN10@TableMerge:
  002bc	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR merge_group_sub_count$9[rbp]
  002c2	39 85 24 02 00
	00		 cmp	 DWORD PTR merge_group_sub_n$10[rbp], eax
  002c8	0f 8d f1 02 00
	00		 jge	 $LN9@TableMerge

; 2396 :         {
; 2397 :             const int channel_no = (merge_group_sub_n == 0) ? column->DrawChannelFrozen : column->DrawChannelUnfrozen;

  002ce	83 bd 24 02 00
	00 00		 cmp	 DWORD PTR merge_group_sub_n$10[rbp], 0
  002d5	75 14		 jne	 SHORT $LN52@TableMerge
  002d7	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  002de	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  002e2	66 89 85 94 07
	00 00		 mov	 WORD PTR tv177[rbp], ax
  002e9	eb 12		 jmp	 SHORT $LN53@TableMerge
$LN52@TableMerge:
  002eb	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  002f2	0f b7 40 60	 movzx	 eax, WORD PTR [rax+96]
  002f6	66 89 85 94 07
	00 00		 mov	 WORD PTR tv177[rbp], ax
$LN53@TableMerge:
  002fd	0f b7 85 94 07
	00 00		 movzx	 eax, WORD PTR tv177[rbp]
  00304	89 85 44 02 00
	00		 mov	 DWORD PTR channel_no$11[rbp], eax

; 2398 : 
; 2399 :             // Don't attempt to merge if there are multiple draw calls within the column
; 2400 :             ImDrawChannel* src_channel = &splitter->_Channels[channel_no];

  0030a	48 8b 45 28	 mov	 rax, QWORD PTR splitter$[rbp]
  0030e	48 83 c0 08	 add	 rax, 8
  00312	8b 95 44 02 00
	00		 mov	 edx, DWORD PTR channel_no$11[rbp]
  00318	48 8b c8	 mov	 rcx, rax
  0031b	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  00320	48 89 85 68 02
	00 00		 mov	 QWORD PTR src_channel$12[rbp], rax

; 2401 :             if (src_channel->_CmdBuffer.Size > 0 && src_channel->_CmdBuffer.back().ElemCount == 0 && src_channel->_CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()

  00327	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR src_channel$12[rbp]
  0032e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00331	7e 3a		 jle	 SHORT $LN24@TableMerge
  00333	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR src_channel$12[rbp]
  0033a	48 8b c8	 mov	 rcx, rax
  0033d	e8 00 00 00 00	 call	 ?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
  00342	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00346	75 25		 jne	 SHORT $LN24@TableMerge
  00348	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR src_channel$12[rbp]
  0034f	48 8b c8	 mov	 rcx, rax
  00352	e8 00 00 00 00	 call	 ?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
  00357	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0035c	75 0f		 jne	 SHORT $LN24@TableMerge

; 2402 :                 src_channel->_CmdBuffer.pop_back();

  0035e	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR src_channel$12[rbp]
  00365	48 8b c8	 mov	 rcx, rax
  00368	e8 00 00 00 00	 call	 ?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ; ImVector<ImDrawCmd>::pop_back
$LN24@TableMerge:

; 2403 :             if (src_channel->_CmdBuffer.Size != 1)

  0036d	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR src_channel$12[rbp]
  00374	83 38 01	 cmp	 DWORD PTR [rax], 1
  00377	74 05		 je	 SHORT $LN25@TableMerge

; 2404 :                 continue;

  00379	e9 30 ff ff ff	 jmp	 $LN8@TableMerge
$LN25@TableMerge:

; 2405 : 
; 2406 :             // Find out the width of this merge group and check if it will fit in our column
; 2407 :             // (note that we assume that rendering didn't stray on the left direction. we should need a CursorMinPos to detect it)
; 2408 :             if (!(column->Flags & ImGuiTableColumnFlags_NoClip))

  0037e	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00385	8b 00		 mov	 eax, DWORD PTR [rax]
  00387	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0038c	85 c0		 test	 eax, eax
  0038e	0f 85 8d 00 00
	00		 jne	 $LN26@TableMerge

; 2409 :             {
; 2410 :                 float content_max_x;
; 2411 :                 if (!has_freeze_v)

  00394	0f b6 45 44	 movzx	 eax, BYTE PTR has_freeze_v$[rbp]
  00398	85 c0		 test	 eax, eax
  0039a	75 27		 jne	 SHORT $LN27@TableMerge

; 2412 :                     content_max_x = ImMax(column->ContentMaxXUnfrozen, column->ContentMaxXHeadersUsed); // No row freeze

  0039c	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  003a3	f3 0f 10 48 48	 movss	 xmm1, DWORD PTR [rax+72]
  003a8	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  003af	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [rax+68]
  003b4	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  003b9	f3 0f 11 85 84
	02 00 00	 movss	 DWORD PTR content_max_x$13[rbp], xmm0
  003c1	eb 44		 jmp	 SHORT $LN28@TableMerge
$LN27@TableMerge:

; 2413 :                 else if (merge_group_sub_n == 0)

  003c3	83 bd 24 02 00
	00 00		 cmp	 DWORD PTR merge_group_sub_n$10[rbp], 0
  003ca	75 27		 jne	 SHORT $LN29@TableMerge

; 2414 :                     content_max_x = ImMax(column->ContentMaxXFrozen, column->ContentMaxXHeadersUsed);   // Row freeze: use width before freeze

  003cc	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  003d3	f3 0f 10 48 48	 movss	 xmm1, DWORD PTR [rax+72]
  003d8	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  003df	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [rax+64]
  003e4	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  003e9	f3 0f 11 85 84
	02 00 00	 movss	 DWORD PTR content_max_x$13[rbp], xmm0

; 2415 :                 else

  003f1	eb 14		 jmp	 SHORT $LN30@TableMerge
$LN29@TableMerge:

; 2416 :                     content_max_x = column->ContentMaxXUnfrozen;                                        // Row freeze: use width after freeze

  003f3	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  003fa	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [rax+68]
  003ff	f3 0f 11 85 84
	02 00 00	 movss	 DWORD PTR content_max_x$13[rbp], xmm0
$LN30@TableMerge:
$LN28@TableMerge:

; 2417 :                 if (content_max_x > column->ClipRect.Max.x)

  00407	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  0040e	f3 0f 10 85 84
	02 00 00	 movss	 xmm0, DWORD PTR content_max_x$13[rbp]
  00416	0f 2f 40 28	 comiss	 xmm0, DWORD PTR [rax+40]
  0041a	76 05		 jbe	 SHORT $LN31@TableMerge

; 2418 :                     continue;

  0041c	e9 8d fe ff ff	 jmp	 $LN8@TableMerge
$LN31@TableMerge:
$LN26@TableMerge:

; 2419 :             }
; 2420 : 
; 2421 :             const int merge_group_n = (has_freeze_h && column_n < table->FreezeColumnsCount ? 0 : 1) + (has_freeze_v && merge_group_sub_n == 0 ? 0 : 2);

  00421	0f b6 45 64	 movzx	 eax, BYTE PTR has_freeze_h$[rbp]
  00425	85 c0		 test	 eax, eax
  00427	74 22		 je	 SHORT $LN54@TableMerge
  00429	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00430	0f bf 80 18 02
	00 00		 movsx	 eax, WORD PTR [rax+536]
  00437	39 85 c4 01 00
	00		 cmp	 DWORD PTR column_n$7[rbp], eax
  0043d	7d 0c		 jge	 SHORT $LN54@TableMerge
  0043f	c7 85 94 07 00
	00 00 00 00 00	 mov	 DWORD PTR tv227[rbp], 0
  00449	eb 0a		 jmp	 SHORT $LN55@TableMerge
$LN54@TableMerge:
  0044b	c7 85 94 07 00
	00 01 00 00 00	 mov	 DWORD PTR tv227[rbp], 1
$LN55@TableMerge:
  00455	0f b6 45 44	 movzx	 eax, BYTE PTR has_freeze_v$[rbp]
  00459	85 c0		 test	 eax, eax
  0045b	74 15		 je	 SHORT $LN56@TableMerge
  0045d	83 bd 24 02 00
	00 00		 cmp	 DWORD PTR merge_group_sub_n$10[rbp], 0
  00464	75 0c		 jne	 SHORT $LN56@TableMerge
  00466	c7 85 98 07 00
	00 00 00 00 00	 mov	 DWORD PTR tv231[rbp], 0
  00470	eb 0a		 jmp	 SHORT $LN57@TableMerge
$LN56@TableMerge:
  00472	c7 85 98 07 00
	00 02 00 00 00	 mov	 DWORD PTR tv231[rbp], 2
$LN57@TableMerge:
  0047c	8b 85 98 07 00
	00		 mov	 eax, DWORD PTR tv231[rbp]
  00482	8b 8d 94 07 00
	00		 mov	 ecx, DWORD PTR tv227[rbp]
  00488	03 c8		 add	 ecx, eax
  0048a	8b c1		 mov	 eax, ecx
  0048c	89 85 a4 02 00
	00		 mov	 DWORD PTR merge_group_n$14[rbp], eax

; 2422 :             IM_ASSERT(channel_no < max_draw_channels);

  00492	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR max_draw_channels$[rbp]
  00498	39 85 44 02 00
	00		 cmp	 DWORD PTR channel_no$11[rbp], eax
  0049e	7c 22		 jl	 SHORT $LN58@TableMerge
  004a0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  004a6	83 c0 3d	 add	 eax, 61			; 0000003dH
  004a9	44 8b c0	 mov	 r8d, eax
  004ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  004b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@EEGFHBNA@?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA_?$AAn?$AAo?$AA?5?$AA?$DM?$AA?5?$AAm?$AAa?$AAx?$AA_?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAs?$AA?$AA@
  004ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004c0	33 c0		 xor	 eax, eax
$LN58@TableMerge:

; 2423 :             MergeGroup* merge_group = &merge_groups[merge_group_n];

  004c2	48 63 85 a4 02
	00 00		 movsxd	 rax, DWORD PTR merge_group_n$14[rbp]
  004c9	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  004cd	48 8d 84 05 b0
	00 00 00	 lea	 rax, QWORD PTR merge_groups$[rbp+rax]
  004d5	48 89 85 c8 02
	00 00		 mov	 QWORD PTR merge_group$15[rbp], rax

; 2424 :             if (merge_group->ChannelsCount == 0)

  004dc	48 8b 85 c8 02
	00 00		 mov	 rax, QWORD PTR merge_group$15[rbp]
  004e3	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  004e7	75 43		 jne	 SHORT $LN32@TableMerge

; 2425 :                 merge_group->ClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);

  004e9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ff7fffff
  004f1	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  004f7	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@ff7fffff
  004ff	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@7f7fffff
  00507	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  0050f	48 8d 8d e4 06
	00 00		 lea	 rcx, QWORD PTR $T29[rbp]
  00516	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@MMMM@Z	; ImRect::ImRect
  0051b	48 8b bd c8 02
	00 00		 mov	 rdi, QWORD PTR merge_group$15[rbp]
  00522	48 8b f0	 mov	 rsi, rax
  00525	b9 10 00 00 00	 mov	 ecx, 16
  0052a	f3 a4		 rep movsb
$LN32@TableMerge:

; 2426 :             ImBitArraySetBit(merge_group->ChannelsMask, channel_no);

  0052c	8b 95 44 02 00
	00		 mov	 edx, DWORD PTR channel_no$11[rbp]
  00532	48 8b 85 c8 02
	00 00		 mov	 rax, QWORD PTR merge_group$15[rbp]
  00539	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0053d	e8 00 00 00 00	 call	 ?ImBitArraySetBit@@YAXPEAIH@Z ; ImBitArraySetBit

; 2427 :             merge_group->ChannelsCount++;

  00542	48 8b 85 c8 02
	00 00		 mov	 rax, QWORD PTR merge_group$15[rbp]
  00549	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0054c	ff c0		 inc	 eax
  0054e	48 8b 8d c8 02
	00 00		 mov	 rcx, QWORD PTR merge_group$15[rbp]
  00555	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 2428 :             merge_group->ClipRect.Add(src_channel->_CmdBuffer[0].ClipRect);

  00558	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR src_channel$12[rbp]
  0055f	33 d2		 xor	 edx, edx
  00561	48 8b c8	 mov	 rcx, rax
  00564	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
  00569	48 8b d0	 mov	 rdx, rax
  0056c	48 8d 8d 14 07
	00 00		 lea	 rcx, QWORD PTR $T30[rbp]
  00573	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@AEBUImVec4@@@Z ; ImRect::ImRect
  00578	48 8b 85 c8 02
	00 00		 mov	 rax, QWORD PTR merge_group$15[rbp]
  0057f	48 8d 95 14 07
	00 00		 lea	 rdx, QWORD PTR $T30[rbp]
  00586	48 8b c8	 mov	 rcx, rax
  00589	e8 00 00 00 00	 call	 ?Add@ImRect@@QEAAXAEBU1@@Z ; ImRect::Add

; 2429 :             merge_group_mask |= (1 << merge_group_n);

  0058e	8b 85 a4 02 00
	00		 mov	 eax, DWORD PTR merge_group_n$14[rbp]
  00594	b9 01 00 00 00	 mov	 ecx, 1
  00599	89 8d 94 07 00
	00		 mov	 DWORD PTR tv645[rbp], ecx
  0059f	0f b6 c8	 movzx	 ecx, al
  005a2	8b 85 94 07 00
	00		 mov	 eax, DWORD PTR tv645[rbp]
  005a8	d3 e0		 shl	 eax, cl
  005aa	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR merge_group_mask$[rbp]
  005b0	0b c8		 or	 ecx, eax
  005b2	8b c1		 mov	 eax, ecx
  005b4	89 85 84 00 00
	00		 mov	 DWORD PTR merge_group_mask$[rbp], eax

; 2430 :         }

  005ba	e9 ef fc ff ff	 jmp	 $LN8@TableMerge
$LN9@TableMerge:

; 2431 : 
; 2432 :         // Invalidate current draw channel
; 2433 :         // (we don't clear DrawChannelFrozen/DrawChannelUnfrozen solely to facilitate debugging/later inspection of data)
; 2434 :         column->DrawChannelCurrent = (ImGuiTableDrawChannelIdx)-1;

  005bf	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  005c4	48 8b 8d e8 01
	00 00		 mov	 rcx, QWORD PTR column$8[rbp]
  005cb	66 89 41 5c	 mov	 WORD PTR [rcx+92], ax

; 2435 :     }

  005cf	e9 1a fc ff ff	 jmp	 $LN5@TableMerge
$LN6@TableMerge:

; 2436 : 
; 2437 :     // [DEBUG] Display merge groups
; 2438 : #if 0
; 2439 :     if (g.IO.KeyShift)
; 2440 :         for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)
; 2441 :         {
; 2442 :             MergeGroup* merge_group = &merge_groups[merge_group_n];
; 2443 :             if (merge_group->ChannelsCount == 0)
; 2444 :                 continue;
; 2445 :             char buf[32];
; 2446 :             ImFormatString(buf, 32, "MG%d:%d", merge_group_n, merge_group->ChannelsCount);
; 2447 :             ImVec2 text_pos = merge_group->ClipRect.Min + ImVec2(4, 4);
; 2448 :             ImVec2 text_size = CalcTextSize(buf, NULL);
; 2449 :             GetForegroundDrawList()->AddRectFilled(text_pos, text_pos + text_size, IM_COL32(0, 0, 0, 255));
; 2450 :             GetForegroundDrawList()->AddText(text_pos, IM_COL32(255, 255, 0, 255), buf, NULL);
; 2451 :             GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 255, 0, 255));
; 2452 :         }
; 2453 : #endif
; 2454 : 
; 2455 :     // 2. Rewrite channel list in our preferred order
; 2456 :     if (merge_group_mask != 0)

  005d4	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR merge_group_mask$[rbp], 0
  005db	0f 84 5e 06 00
	00		 je	 $LN33@TableMerge

; 2457 :     {
; 2458 :         // We skip channel 0 (Bg0/Bg1) and 1 (Bg2 frozen) from the shuffling since they won't move - see channels allocation in TableSetupDrawChannels().
; 2459 :         const int LEADING_DRAW_CHANNELS = 2;

  005e1	c7 85 e4 02 00
	00 02 00 00 00	 mov	 DWORD PTR LEADING_DRAW_CHANNELS$16[rbp], 2

; 2460 :         g.DrawChannelsTempMergeBuffer.resize(splitter->_Count - LEADING_DRAW_CHANNELS); // Use shared temporary storage so the allocation gets amortized

  005eb	48 8b 45 28	 mov	 rax, QWORD PTR splitter$[rbp]
  005ef	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  005f2	83 e8 02	 sub	 eax, 2
  005f5	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  005f9	48 81 c1 40 4b
	00 00		 add	 rcx, 19264		; 00004b40H
  00600	8b d0		 mov	 edx, eax
  00602	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ; ImVector<ImDrawChannel>::resize

; 2461 :         ImDrawChannel* dst_tmp = g.DrawChannelsTempMergeBuffer.Data;

  00607	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0060b	48 8b 80 48 4b
	00 00		 mov	 rax, QWORD PTR [rax+19272]
  00612	48 89 85 08 03
	00 00		 mov	 QWORD PTR dst_tmp$17[rbp], rax

; 2462 :         ImBitArraySetBitRange(remaining_mask, LEADING_DRAW_CHANNELS, splitter->_Count);

  00619	48 8b 45 28	 mov	 rax, QWORD PTR splitter$[rbp]
  0061d	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00621	ba 02 00 00 00	 mov	 edx, 2
  00626	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR remaining_mask$[rbp]
  0062d	e8 00 00 00 00	 call	 ?ImBitArraySetBitRange@@YAXPEAIHH@Z ; ImBitArraySetBitRange

; 2463 :         ImBitArrayClearBit(remaining_mask, table->Bg2DrawChannelUnfrozen);

  00632	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00639	0f b7 80 20 02
	00 00		 movzx	 eax, WORD PTR [rax+544]
  00640	8b d0		 mov	 edx, eax
  00642	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR remaining_mask$[rbp]
  00649	e8 00 00 00 00	 call	 ?ImBitArrayClearBit@@YAXPEAIH@Z ; ImBitArrayClearBit

; 2464 :         IM_ASSERT(has_freeze_v == false || table->Bg2DrawChannelUnfrozen != TABLE_DRAW_CHANNEL_BG2_FROZEN);

  0064e	0f b6 45 44	 movzx	 eax, BYTE PTR has_freeze_v$[rbp]
  00652	85 c0		 test	 eax, eax
  00654	74 35		 je	 SHORT $LN59@TableMerge
  00656	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0065d	0f b7 80 20 02
	00 00		 movzx	 eax, WORD PTR [rax+544]
  00664	83 f8 01	 cmp	 eax, 1
  00667	75 22		 jne	 SHORT $LN59@TableMerge
  00669	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  0066f	83 c0 67	 add	 eax, 103		; 00000067H
  00672	44 8b c0	 mov	 r8d, eax
  00675	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0067c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LA@JABKDEHA@?$AAh?$AAa?$AAs?$AA_?$AAf?$AAr?$AAe?$AAe?$AAz?$AAe?$AA_?$AAv?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO@
  00683	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00689	33 c0		 xor	 eax, eax
$LN59@TableMerge:

; 2465 :         int remaining_count = splitter->_Count - (has_freeze_v ? LEADING_DRAW_CHANNELS + 1 : LEADING_DRAW_CHANNELS);

  0068b	0f b6 45 44	 movzx	 eax, BYTE PTR has_freeze_v$[rbp]
  0068f	85 c0		 test	 eax, eax
  00691	74 0c		 je	 SHORT $LN60@TableMerge
  00693	c7 85 94 07 00
	00 03 00 00 00	 mov	 DWORD PTR tv301[rbp], 3
  0069d	eb 0a		 jmp	 SHORT $LN61@TableMerge
$LN60@TableMerge:
  0069f	c7 85 94 07 00
	00 02 00 00 00	 mov	 DWORD PTR tv301[rbp], 2
$LN61@TableMerge:
  006a9	48 8b 45 28	 mov	 rax, QWORD PTR splitter$[rbp]
  006ad	8b 8d 94 07 00
	00		 mov	 ecx, DWORD PTR tv301[rbp]
  006b3	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  006b6	2b c1		 sub	 eax, ecx
  006b8	89 85 24 03 00
	00		 mov	 DWORD PTR remaining_count$18[rbp], eax

; 2466 :         //ImRect host_rect = (table->InnerWindow == table->OuterWindow) ? table->InnerClipRect : table->HostClipRect;
; 2467 :         ImRect host_rect = table->HostClipRect;

  006be	48 8d 85 48 03
	00 00		 lea	 rax, QWORD PTR host_rect$19[rbp]
  006c5	48 8b 8d d0 07
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  006cc	48 8b f8	 mov	 rdi, rax
  006cf	48 8d b1 58 01
	00 00		 lea	 rsi, QWORD PTR [rcx+344]
  006d6	b9 10 00 00 00	 mov	 ecx, 16
  006db	f3 a4		 rep movsb

; 2468 :         for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)

  006dd	c7 85 74 03 00
	00 00 00 00 00	 mov	 DWORD PTR merge_group_n$20[rbp], 0
  006e7	eb 0e		 jmp	 SHORT $LN13@TableMerge
$LN11@TableMerge:
  006e9	8b 85 74 03 00
	00		 mov	 eax, DWORD PTR merge_group_n$20[rbp]
  006ef	ff c0		 inc	 eax
  006f1	89 85 74 03 00
	00		 mov	 DWORD PTR merge_group_n$20[rbp], eax
$LN13@TableMerge:
  006f7	83 bd 74 03 00
	00 04		 cmp	 DWORD PTR merge_group_n$20[rbp], 4
  006fe	0f 8d f3 03 00
	00		 jge	 $LN12@TableMerge

; 2469 :         {
; 2470 :             if (int merge_channels_count = merge_groups[merge_group_n].ChannelsCount)

  00704	48 63 85 74 03
	00 00		 movsxd	 rax, DWORD PTR merge_group_n$20[rbp]
  0070b	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0070f	8b 84 05 c0 00
	00 00		 mov	 eax, DWORD PTR merge_groups$[rbp+rax+16]
  00716	89 85 94 03 00
	00		 mov	 DWORD PTR merge_channels_count$21[rbp], eax
  0071c	83 bd 94 03 00
	00 00		 cmp	 DWORD PTR merge_channels_count$21[rbp], 0
  00723	0f 84 66 03 00
	00		 je	 $LN34@TableMerge

; 2471 :             {
; 2472 :                 MergeGroup* merge_group = &merge_groups[merge_group_n];

  00729	48 63 85 74 03
	00 00		 movsxd	 rax, DWORD PTR merge_group_n$20[rbp]
  00730	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00734	48 8d 84 05 b0
	00 00 00	 lea	 rax, QWORD PTR merge_groups$[rbp+rax]
  0073c	48 89 85 b8 03
	00 00		 mov	 QWORD PTR merge_group$22[rbp], rax

; 2473 :                 ImRect merge_clip_rect = merge_group->ClipRect;

  00743	48 8d 85 d8 03
	00 00		 lea	 rax, QWORD PTR merge_clip_rect$23[rbp]
  0074a	48 8b f8	 mov	 rdi, rax
  0074d	48 8b b5 b8 03
	00 00		 mov	 rsi, QWORD PTR merge_group$22[rbp]
  00754	b9 10 00 00 00	 mov	 ecx, 16
  00759	f3 a4		 rep movsb

; 2474 : 
; 2475 :                 // Extend outer-most clip limits to match those of host, so draw calls can be merged even if
; 2476 :                 // outer-most columns have some outer padding offsetting them from their parent ClipRect.
; 2477 :                 // The principal cases this is dealing with are:
; 2478 :                 // - On a same-window table (not scrolling = single group), all fitting columns ClipRect -> will extend and match host ClipRect -> will merge
; 2479 :                 // - Columns can use padding and have left-most ClipRect.Min.x and right-most ClipRect.Max.x != from host ClipRect -> will extend and match host ClipRect -> will merge
; 2480 :                 // FIXME-TABLE FIXME-WORKRECT: We are wasting a merge opportunity on tables without scrolling if column doesn't fit
; 2481 :                 // within host clip rect, solely because of the half-padding difference between window->WorkRect and window->InnerClipRect.
; 2482 :                 if ((merge_group_n & 1) == 0 || !has_freeze_h)

  0075b	8b 85 74 03 00
	00		 mov	 eax, DWORD PTR merge_group_n$20[rbp]
  00761	83 e0 01	 and	 eax, 1
  00764	85 c0		 test	 eax, eax
  00766	74 08		 je	 SHORT $LN36@TableMerge
  00768	0f b6 45 64	 movzx	 eax, BYTE PTR has_freeze_h$[rbp]
  0076c	85 c0		 test	 eax, eax
  0076e	75 1d		 jne	 SHORT $LN35@TableMerge
$LN36@TableMerge:

; 2483 :                     merge_clip_rect.Min.x = ImMin(merge_clip_rect.Min.x, host_rect.Min.x);

  00770	f3 0f 10 8d 48
	03 00 00	 movss	 xmm1, DWORD PTR host_rect$19[rbp]
  00778	f3 0f 10 85 d8
	03 00 00	 movss	 xmm0, DWORD PTR merge_clip_rect$23[rbp]
  00780	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00785	f3 0f 11 85 d8
	03 00 00	 movss	 DWORD PTR merge_clip_rect$23[rbp], xmm0
$LN35@TableMerge:

; 2484 :                 if ((merge_group_n & 2) == 0 || !has_freeze_v)

  0078d	8b 85 74 03 00
	00		 mov	 eax, DWORD PTR merge_group_n$20[rbp]
  00793	83 e0 02	 and	 eax, 2
  00796	85 c0		 test	 eax, eax
  00798	74 08		 je	 SHORT $LN38@TableMerge
  0079a	0f b6 45 44	 movzx	 eax, BYTE PTR has_freeze_v$[rbp]
  0079e	85 c0		 test	 eax, eax
  007a0	75 1d		 jne	 SHORT $LN37@TableMerge
$LN38@TableMerge:

; 2485 :                     merge_clip_rect.Min.y = ImMin(merge_clip_rect.Min.y, host_rect.Min.y);

  007a2	f3 0f 10 8d 4c
	03 00 00	 movss	 xmm1, DWORD PTR host_rect$19[rbp+4]
  007aa	f3 0f 10 85 dc
	03 00 00	 movss	 xmm0, DWORD PTR merge_clip_rect$23[rbp+4]
  007b2	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  007b7	f3 0f 11 85 dc
	03 00 00	 movss	 DWORD PTR merge_clip_rect$23[rbp+4], xmm0
$LN37@TableMerge:

; 2486 :                 if ((merge_group_n & 1) != 0)

  007bf	8b 85 74 03 00
	00		 mov	 eax, DWORD PTR merge_group_n$20[rbp]
  007c5	83 e0 01	 and	 eax, 1
  007c8	85 c0		 test	 eax, eax
  007ca	74 1d		 je	 SHORT $LN39@TableMerge

; 2487 :                     merge_clip_rect.Max.x = ImMax(merge_clip_rect.Max.x, host_rect.Max.x);

  007cc	f3 0f 10 8d 50
	03 00 00	 movss	 xmm1, DWORD PTR host_rect$19[rbp+8]
  007d4	f3 0f 10 85 e0
	03 00 00	 movss	 xmm0, DWORD PTR merge_clip_rect$23[rbp+8]
  007dc	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  007e1	f3 0f 11 85 e0
	03 00 00	 movss	 DWORD PTR merge_clip_rect$23[rbp+8], xmm0
$LN39@TableMerge:

; 2488 :                 if ((merge_group_n & 2) != 0 && (table->Flags & ImGuiTableFlags_NoHostExtendY) == 0)

  007e9	8b 85 74 03 00
	00		 mov	 eax, DWORD PTR merge_group_n$20[rbp]
  007ef	83 e0 02	 and	 eax, 2
  007f2	85 c0		 test	 eax, eax
  007f4	74 30		 je	 SHORT $LN40@TableMerge
  007f6	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  007fd	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00800	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00805	85 c0		 test	 eax, eax
  00807	75 1d		 jne	 SHORT $LN40@TableMerge

; 2489 :                     merge_clip_rect.Max.y = ImMax(merge_clip_rect.Max.y, host_rect.Max.y);

  00809	f3 0f 10 8d 54
	03 00 00	 movss	 xmm1, DWORD PTR host_rect$19[rbp+12]
  00811	f3 0f 10 85 e4
	03 00 00	 movss	 xmm0, DWORD PTR merge_clip_rect$23[rbp+12]
  00819	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0081e	f3 0f 11 85 e4
	03 00 00	 movss	 DWORD PTR merge_clip_rect$23[rbp+12], xmm0
$LN40@TableMerge:

; 2490 : #if 0
; 2491 :                 GetOverlayDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 0, 0, 200), 0.0f, 0, 1.0f);
; 2492 :                 GetOverlayDrawList()->AddLine(merge_group->ClipRect.Min, merge_clip_rect.Min, IM_COL32(255, 100, 0, 200));
; 2493 :                 GetOverlayDrawList()->AddLine(merge_group->ClipRect.Max, merge_clip_rect.Max, IM_COL32(255, 100, 0, 200));
; 2494 : #endif
; 2495 :                 remaining_count -= merge_group->ChannelsCount;

  00826	48 8b 85 b8 03
	00 00		 mov	 rax, QWORD PTR merge_group$22[rbp]
  0082d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00830	8b 8d 24 03 00
	00		 mov	 ecx, DWORD PTR remaining_count$18[rbp]
  00836	2b c8		 sub	 ecx, eax
  00838	8b c1		 mov	 eax, ecx
  0083a	89 85 24 03 00
	00		 mov	 DWORD PTR remaining_count$18[rbp], eax

; 2496 :                 for (int n = 0; n < (size_for_masks_bitarrays_one >> 2); n++)

  00840	c7 85 04 04 00
	00 00 00 00 00	 mov	 DWORD PTR n$24[rbp], 0
  0084a	eb 0e		 jmp	 SHORT $LN16@TableMerge
$LN14@TableMerge:
  0084c	8b 85 04 04 00
	00		 mov	 eax, DWORD PTR n$24[rbp]
  00852	ff c0		 inc	 eax
  00854	89 85 04 04 00
	00		 mov	 DWORD PTR n$24[rbp], eax
$LN16@TableMerge:
  0085a	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR size_for_masks_bitarrays_one$[rbp]
  00860	c1 f8 02	 sar	 eax, 2
  00863	39 85 04 04 00
	00		 cmp	 DWORD PTR n$24[rbp], eax
  00869	7d 3d		 jge	 SHORT $LN15@TableMerge

; 2497 :                     remaining_mask[n] &= ~merge_group->ChannelsMask[n];

  0086b	48 63 85 04 04
	00 00		 movsxd	 rax, DWORD PTR n$24[rbp]
  00872	48 63 8d 04 04
	00 00		 movsxd	 rcx, DWORD PTR n$24[rbp]
  00879	48 8b 95 b8 03
	00 00		 mov	 rdx, QWORD PTR merge_group$22[rbp]
  00880	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00884	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00887	f7 d1		 not	 ecx
  00889	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR remaining_mask$[rbp]
  00890	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00893	23 c1		 and	 eax, ecx
  00895	48 63 8d 04 04
	00 00		 movsxd	 rcx, DWORD PTR n$24[rbp]
  0089c	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR remaining_mask$[rbp]
  008a3	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  008a6	eb a4		 jmp	 SHORT $LN14@TableMerge
$LN15@TableMerge:

; 2498 :                 for (int n = 0; n < splitter->_Count && merge_channels_count != 0; n++)

  008a8	c7 85 24 04 00
	00 00 00 00 00	 mov	 DWORD PTR n$25[rbp], 0
  008b2	eb 0e		 jmp	 SHORT $LN19@TableMerge
$LN17@TableMerge:
  008b4	8b 85 24 04 00
	00		 mov	 eax, DWORD PTR n$25[rbp]
  008ba	ff c0		 inc	 eax
  008bc	89 85 24 04 00
	00		 mov	 DWORD PTR n$25[rbp], eax
$LN19@TableMerge:
  008c2	48 8b 45 28	 mov	 rax, QWORD PTR splitter$[rbp]
  008c6	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  008c9	39 85 24 04 00
	00		 cmp	 DWORD PTR n$25[rbp], eax
  008cf	0f 8d ba 01 00
	00		 jge	 $LN18@TableMerge
  008d5	83 bd 94 03 00
	00 00		 cmp	 DWORD PTR merge_channels_count$21[rbp], 0
  008dc	0f 84 ad 01 00
	00		 je	 $LN18@TableMerge

; 2499 :                 {
; 2500 :                     // Copy + overwrite new clip rect
; 2501 :                     if (!IM_BITARRAY_TESTBIT(merge_group->ChannelsMask, n))

  008e2	8b 85 24 04 00
	00		 mov	 eax, DWORD PTR n$25[rbp]
  008e8	c1 f8 05	 sar	 eax, 5
  008eb	48 98		 cdqe
  008ed	48 8b 8d b8 03
	00 00		 mov	 rcx, QWORD PTR merge_group$22[rbp]
  008f4	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  008f8	48 89 8d 98 07
	00 00		 mov	 QWORD PTR tv526[rbp], rcx
  008ff	8b 95 24 04 00
	00		 mov	 edx, DWORD PTR n$25[rbp]
  00905	83 e2 1f	 and	 edx, 31
  00908	bf 01 00 00 00	 mov	 edi, 1
  0090d	0f b6 ca	 movzx	 ecx, dl
  00910	8b d7		 mov	 edx, edi
  00912	d3 e2		 shl	 edx, cl
  00914	8b ca		 mov	 ecx, edx
  00916	48 8b 95 98 07
	00 00		 mov	 rdx, QWORD PTR tv526[rbp]
  0091d	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00920	23 c1		 and	 eax, ecx
  00922	85 c0		 test	 eax, eax
  00924	75 02		 jne	 SHORT $LN41@TableMerge

; 2502 :                         continue;

  00926	eb 8c		 jmp	 SHORT $LN17@TableMerge
$LN41@TableMerge:

; 2503 :                     IM_BITARRAY_CLEARBIT(merge_group->ChannelsMask, n);

  00928	8b 85 24 04 00
	00		 mov	 eax, DWORD PTR n$25[rbp]
  0092e	c1 f8 05	 sar	 eax, 5
  00931	48 98		 cdqe
  00933	48 8b 8d b8 03
	00 00		 mov	 rcx, QWORD PTR merge_group$22[rbp]
  0093a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0093e	48 89 8d 98 07
	00 00		 mov	 QWORD PTR tv525[rbp], rcx
  00945	8b 95 24 04 00
	00		 mov	 edx, DWORD PTR n$25[rbp]
  0094b	83 e2 1f	 and	 edx, 31
  0094e	bf 01 00 00 00	 mov	 edi, 1
  00953	0f b6 ca	 movzx	 ecx, dl
  00956	8b d7		 mov	 edx, edi
  00958	d3 e2		 shl	 edx, cl
  0095a	8b ca		 mov	 ecx, edx
  0095c	f7 d1		 not	 ecx
  0095e	48 8b 95 98 07
	00 00		 mov	 rdx, QWORD PTR tv525[rbp]
  00965	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00968	23 c1		 and	 eax, ecx
  0096a	8b 8d 24 04 00
	00		 mov	 ecx, DWORD PTR n$25[rbp]
  00970	c1 f9 05	 sar	 ecx, 5
  00973	48 63 c9	 movsxd	 rcx, ecx
  00976	48 8b 95 b8 03
	00 00		 mov	 rdx, QWORD PTR merge_group$22[rbp]
  0097d	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00981	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 2504 :                     merge_channels_count--;

  00984	8b 85 94 03 00
	00		 mov	 eax, DWORD PTR merge_channels_count$21[rbp]
  0098a	ff c8		 dec	 eax
  0098c	89 85 94 03 00
	00		 mov	 DWORD PTR merge_channels_count$21[rbp], eax

; 2505 : 
; 2506 :                     ImDrawChannel* channel = &splitter->_Channels[n];

  00992	48 8b 45 28	 mov	 rax, QWORD PTR splitter$[rbp]
  00996	48 83 c0 08	 add	 rax, 8
  0099a	8b 95 24 04 00
	00		 mov	 edx, DWORD PTR n$25[rbp]
  009a0	48 8b c8	 mov	 rcx, rax
  009a3	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  009a8	48 89 85 48 04
	00 00		 mov	 QWORD PTR channel$26[rbp], rax

; 2507 :                     IM_ASSERT(channel->_CmdBuffer.Size == 1 && merge_clip_rect.Contains(ImRect(channel->_CmdBuffer[0].ClipRect)));

  009af	48 8b 85 48 04
	00 00		 mov	 rax, QWORD PTR channel$26[rbp]
  009b6	83 38 01	 cmp	 DWORD PTR [rax], 1
  009b9	75 36		 jne	 SHORT $LN62@TableMerge
  009bb	48 8b 85 48 04
	00 00		 mov	 rax, QWORD PTR channel$26[rbp]
  009c2	33 d2		 xor	 edx, edx
  009c4	48 8b c8	 mov	 rcx, rax
  009c7	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
  009cc	48 8b d0	 mov	 rdx, rax
  009cf	48 8d 8d 44 07
	00 00		 lea	 rcx, QWORD PTR $T31[rbp]
  009d6	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@AEBUImVec4@@@Z ; ImRect::ImRect
  009db	48 8b d0	 mov	 rdx, rax
  009de	48 8d 8d d8 03
	00 00		 lea	 rcx, QWORD PTR merge_clip_rect$23[rbp]
  009e5	e8 00 00 00 00	 call	 ?Contains@ImRect@@QEBA_NAEBU1@@Z ; ImRect::Contains
  009ea	0f b6 c0	 movzx	 eax, al
  009ed	85 c0		 test	 eax, eax
  009ef	75 24		 jne	 SHORT $LN63@TableMerge
$LN62@TableMerge:
  009f1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  009f7	05 92 00 00 00	 add	 eax, 146		; 00000092H
  009fc	44 8b c0	 mov	 r8d, eax
  009ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00a06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1MG@IJOOMOFE@?$AAc?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?9?$AA?$DO?$AA_?$AAC?$AAm?$AAd?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@
  00a0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a13	33 c0		 xor	 eax, eax
$LN63@TableMerge:

; 2508 :                     channel->_CmdBuffer[0].ClipRect = merge_clip_rect.ToVec4();

  00a15	48 8d 95 74 07
	00 00		 lea	 rdx, QWORD PTR $T32[rbp]
  00a1c	48 8d 8d d8 03
	00 00		 lea	 rcx, QWORD PTR merge_clip_rect$23[rbp]
  00a23	e8 00 00 00 00	 call	 ?ToVec4@ImRect@@QEBA?AUImVec4@@XZ ; ImRect::ToVec4
  00a28	48 89 85 98 07
	00 00		 mov	 QWORD PTR tv452[rbp], rax
  00a2f	48 8b 8d 48 04
	00 00		 mov	 rcx, QWORD PTR channel$26[rbp]
  00a36	33 d2		 xor	 edx, edx
  00a38	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
  00a3d	48 8b f8	 mov	 rdi, rax
  00a40	48 8b 85 98 07
	00 00		 mov	 rax, QWORD PTR tv452[rbp]
  00a47	48 8b f0	 mov	 rsi, rax
  00a4a	b9 10 00 00 00	 mov	 ecx, 16
  00a4f	f3 a4		 rep movsb

; 2509 :                     memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));

  00a51	48 8b 85 08 03
	00 00		 mov	 rax, QWORD PTR dst_tmp$17[rbp]
  00a58	48 89 85 98 07
	00 00		 mov	 QWORD PTR tv459[rbp], rax
  00a5f	48 8b 85 08 03
	00 00		 mov	 rax, QWORD PTR dst_tmp$17[rbp]
  00a66	48 83 c0 20	 add	 rax, 32			; 00000020H
  00a6a	48 89 85 08 03
	00 00		 mov	 QWORD PTR dst_tmp$17[rbp], rax
  00a71	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00a77	48 8b 95 48 04
	00 00		 mov	 rdx, QWORD PTR channel$26[rbp]
  00a7e	48 8b 8d 98 07
	00 00		 mov	 rcx, QWORD PTR tv459[rbp]
  00a85	e8 00 00 00 00	 call	 memcpy

; 2510 :                 }

  00a8a	e9 25 fe ff ff	 jmp	 $LN17@TableMerge
$LN18@TableMerge:
$LN34@TableMerge:

; 2511 :             }
; 2512 : 
; 2513 :             // Make sure Bg2DrawChannelUnfrozen appears in the middle of our groups (whereas Bg0/Bg1 and Bg2 frozen are fixed to 0 and 1)
; 2514 :             if (merge_group_n == 1 && has_freeze_v)

  00a8f	83 bd 74 03 00
	00 01		 cmp	 DWORD PTR merge_group_n$20[rbp], 1
  00a96	75 5a		 jne	 SHORT $LN42@TableMerge
  00a98	0f b6 45 44	 movzx	 eax, BYTE PTR has_freeze_v$[rbp]
  00a9c	85 c0		 test	 eax, eax
  00a9e	74 52		 je	 SHORT $LN42@TableMerge

; 2515 :                 memcpy(dst_tmp++, &splitter->_Channels[table->Bg2DrawChannelUnfrozen], sizeof(ImDrawChannel));

  00aa0	48 8b 85 08 03
	00 00		 mov	 rax, QWORD PTR dst_tmp$17[rbp]
  00aa7	48 89 85 98 07
	00 00		 mov	 QWORD PTR tv473[rbp], rax
  00aae	48 8b 85 08 03
	00 00		 mov	 rax, QWORD PTR dst_tmp$17[rbp]
  00ab5	48 83 c0 20	 add	 rax, 32			; 00000020H
  00ab9	48 89 85 08 03
	00 00		 mov	 QWORD PTR dst_tmp$17[rbp], rax
  00ac0	48 8b 85 d0 07
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00ac7	0f b7 80 20 02
	00 00		 movzx	 eax, WORD PTR [rax+544]
  00ace	48 8b 4d 28	 mov	 rcx, QWORD PTR splitter$[rbp]
  00ad2	48 83 c1 08	 add	 rcx, 8
  00ad6	8b d0		 mov	 edx, eax
  00ad8	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  00add	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00ae3	48 8b d0	 mov	 rdx, rax
  00ae6	48 8b 8d 98 07
	00 00		 mov	 rcx, QWORD PTR tv473[rbp]
  00aed	e8 00 00 00 00	 call	 memcpy
$LN42@TableMerge:

; 2516 :         }

  00af2	e9 f2 fb ff ff	 jmp	 $LN11@TableMerge
$LN12@TableMerge:

; 2517 : 
; 2518 :         // Append unmergeable channels that we didn't reorder at the end of the list
; 2519 :         for (int n = 0; n < splitter->_Count && remaining_count != 0; n++)

  00af7	c7 85 64 04 00
	00 00 00 00 00	 mov	 DWORD PTR n$27[rbp], 0
  00b01	eb 0e		 jmp	 SHORT $LN22@TableMerge
$LN20@TableMerge:
  00b03	8b 85 64 04 00
	00		 mov	 eax, DWORD PTR n$27[rbp]
  00b09	ff c0		 inc	 eax
  00b0b	89 85 64 04 00
	00		 mov	 DWORD PTR n$27[rbp], eax
$LN22@TableMerge:
  00b11	48 8b 45 28	 mov	 rax, QWORD PTR splitter$[rbp]
  00b15	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00b18	39 85 64 04 00
	00		 cmp	 DWORD PTR n$27[rbp], eax
  00b1e	0f 8d a5 00 00
	00		 jge	 $LN21@TableMerge
  00b24	83 bd 24 03 00
	00 00		 cmp	 DWORD PTR remaining_count$18[rbp], 0
  00b2b	0f 84 98 00 00
	00		 je	 $LN21@TableMerge

; 2520 :         {
; 2521 :             if (!IM_BITARRAY_TESTBIT(remaining_mask, n))

  00b31	8b 85 64 04 00
	00		 mov	 eax, DWORD PTR n$27[rbp]
  00b37	c1 f8 05	 sar	 eax, 5
  00b3a	48 98		 cdqe
  00b3c	8b 8d 64 04 00
	00		 mov	 ecx, DWORD PTR n$27[rbp]
  00b42	83 e1 1f	 and	 ecx, 31
  00b45	ba 01 00 00 00	 mov	 edx, 1
  00b4a	d3 e2		 shl	 edx, cl
  00b4c	8b ca		 mov	 ecx, edx
  00b4e	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR remaining_mask$[rbp]
  00b55	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00b58	23 c1		 and	 eax, ecx
  00b5a	85 c0		 test	 eax, eax
  00b5c	75 02		 jne	 SHORT $LN43@TableMerge

; 2522 :                 continue;

  00b5e	eb a3		 jmp	 SHORT $LN20@TableMerge
$LN43@TableMerge:

; 2523 :             ImDrawChannel* channel = &splitter->_Channels[n];

  00b60	48 8b 45 28	 mov	 rax, QWORD PTR splitter$[rbp]
  00b64	48 83 c0 08	 add	 rax, 8
  00b68	8b 95 64 04 00
	00		 mov	 edx, DWORD PTR n$27[rbp]
  00b6e	48 8b c8	 mov	 rcx, rax
  00b71	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  00b76	48 89 85 88 04
	00 00		 mov	 QWORD PTR channel$28[rbp], rax

; 2524 :             memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));

  00b7d	48 8b 85 08 03
	00 00		 mov	 rax, QWORD PTR dst_tmp$17[rbp]
  00b84	48 89 85 98 07
	00 00		 mov	 QWORD PTR tv494[rbp], rax
  00b8b	48 8b 85 08 03
	00 00		 mov	 rax, QWORD PTR dst_tmp$17[rbp]
  00b92	48 83 c0 20	 add	 rax, 32			; 00000020H
  00b96	48 89 85 08 03
	00 00		 mov	 QWORD PTR dst_tmp$17[rbp], rax
  00b9d	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00ba3	48 8b 95 88 04
	00 00		 mov	 rdx, QWORD PTR channel$28[rbp]
  00baa	48 8b 8d 98 07
	00 00		 mov	 rcx, QWORD PTR tv494[rbp]
  00bb1	e8 00 00 00 00	 call	 memcpy

; 2525 :             remaining_count--;

  00bb6	8b 85 24 03 00
	00		 mov	 eax, DWORD PTR remaining_count$18[rbp]
  00bbc	ff c8		 dec	 eax
  00bbe	89 85 24 03 00
	00		 mov	 DWORD PTR remaining_count$18[rbp], eax

; 2526 :         }

  00bc4	e9 3a ff ff ff	 jmp	 $LN20@TableMerge
$LN21@TableMerge:

; 2527 :         IM_ASSERT(dst_tmp == g.DrawChannelsTempMergeBuffer.Data + g.DrawChannelsTempMergeBuffer.Size);

  00bc9	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00bcd	48 63 80 40 4b
	00 00		 movsxd	 rax, DWORD PTR [rax+19264]
  00bd4	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00bd8	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00bdc	48 03 81 48 4b
	00 00		 add	 rax, QWORD PTR [rcx+19272]
  00be3	48 39 85 08 03
	00 00		 cmp	 QWORD PTR dst_tmp$17[rbp], rax
  00bea	74 24		 je	 SHORT $LN64@TableMerge
  00bec	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00bf2	05 a6 00 00 00	 add	 eax, 166		; 000000a6H
  00bf7	44 8b c0	 mov	 r8d, eax
  00bfa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00c01	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KG@FHCGPPO@?$AAd?$AAs?$AAt?$AA_?$AAt?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAg?$AA?4?$AAD?$AAr?$AAa?$AAw?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AAs?$AAT?$AAe?$AAm?$AAp?$AAM?$AAe?$AAr@
  00c08	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00c0e	33 c0		 xor	 eax, eax
$LN64@TableMerge:

; 2528 :         memcpy(splitter->_Channels.Data + LEADING_DRAW_CHANNELS, g.DrawChannelsTempMergeBuffer.Data, (splitter->_Count - LEADING_DRAW_CHANNELS) * sizeof(ImDrawChannel));

  00c10	48 8b 45 28	 mov	 rax, QWORD PTR splitter$[rbp]
  00c14	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00c17	83 e8 02	 sub	 eax, 2
  00c1a	48 98		 cdqe
  00c1c	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00c20	48 8b 4d 28	 mov	 rcx, QWORD PTR splitter$[rbp]
  00c24	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00c28	48 83 c1 40	 add	 rcx, 64			; 00000040H
  00c2c	4c 8b c0	 mov	 r8, rax
  00c2f	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00c33	48 8b 90 48 4b
	00 00		 mov	 rdx, QWORD PTR [rax+19272]
  00c3a	e8 00 00 00 00	 call	 memcpy
$LN33@TableMerge:

; 2529 :     }
; 2530 : }

  00c3f	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  00c43	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData
  00c4a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00c4f	48 8b 8d a0 07
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00c56	48 33 cd	 xor	 rcx, rbp
  00c59	e8 00 00 00 00	 call	 __security_check_cookie
  00c5e	48 8d a5 b0 07
	00 00		 lea	 rsp, QWORD PTR [rbp+1968]
  00c65	5f		 pop	 rdi
  00c66	5e		 pop	 rsi
  00c67	5d		 pop	 rbp
  00c68	c3		 ret	 0
?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z ENDP ; ImGui::TableMergeDrawChannels
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableBeginContextMenuPopup@ImGui@@YA_NPEAUImGuiTable@@@Z
_TEXT	SEGMENT
context_menu_id$ = 4
table$ = 256
?TableBeginContextMenuPopup@ImGui@@YA_NPEAUImGuiTable@@@Z PROC ; ImGui::TableBeginContextMenuPopup, COMDAT

; 3066 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]

; 3067 :     if (!table->IsContextPopupOpen || table->InstanceCurrent != table->InstanceInteracted)

  0002a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00031	0f b6 80 27 02
	00 00		 movzx	 eax, BYTE PTR [rax+551]
  00038	85 c0		 test	 eax, eax
  0003a	74 1a		 je	 SHORT $LN3@TableBegin
  0003c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00043	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  00047	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0004e	0f bf 49 7a	 movsx	 ecx, WORD PTR [rcx+122]
  00052	3b c1		 cmp	 eax, ecx
  00054	74 04		 je	 SHORT $LN2@TableBegin
$LN3@TableBegin:

; 3068 :         return false;

  00056	32 c0		 xor	 al, al
  00058	eb 43		 jmp	 SHORT $LN1@TableBegin
$LN2@TableBegin:

; 3069 :     const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);

  0005a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00061	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00064	33 d2		 xor	 edx, edx
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@BMOANCPA@?$CD?$CDContextMenu?$AA@
  0006d	e8 00 00 00 00	 call	 ?ImHashStr@@YAIPEBD_KI@Z ; ImHashStr
  00072	89 45 04	 mov	 DWORD PTR context_menu_id$[rbp], eax

; 3070 :     if (BeginPopupEx(context_menu_id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings))

  00075	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  0007a	8b 4d 04	 mov	 ecx, DWORD PTR context_menu_id$[rbp]
  0007d	e8 00 00 00 00	 call	 ?BeginPopupEx@ImGui@@YA_NIH@Z ; ImGui::BeginPopupEx
  00082	0f b6 c0	 movzx	 eax, al
  00085	85 c0		 test	 eax, eax
  00087	74 04		 je	 SHORT $LN4@TableBegin

; 3071 :         return true;

  00089	b0 01		 mov	 al, 1
  0008b	eb 10		 jmp	 SHORT $LN1@TableBegin
$LN4@TableBegin:

; 3072 :     table->IsContextPopupOpen = false;

  0008d	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00094	c6 80 27 02 00
	00 00		 mov	 BYTE PTR [rax+551], 0

; 3073 :     return false;

  0009b	32 c0		 xor	 al, al
$LN1@TableBegin:

; 3074 : }

  0009d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000a4	5f		 pop	 rdi
  000a5	5d		 pop	 rbp
  000a6	c3		 ret	 0
?TableBeginContextMenuPopup@ImGui@@YA_NPEAUImGuiTable@@@Z ENDP ; ImGui::TableBeginContextMenuPopup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableDrawContextMenu@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
g$ = 8
window$ = 40
want_separator$ = 68
column_n$ = 100
column$ = 136
can_resize$1 = 164
size_all_desc$2 = 200
other_column_n$3 = 228
other_column$4 = 264
name$5 = 296
menu_item_active$6 = 324
tv222 = 532
tv203 = 532
tv165 = 532
tv94 = 532
tv77 = 532
tv83 = 536
table$ = 576
?TableDrawContextMenu@ImGui@@YAXPEAUImGuiTable@@@Z PROC	; ImGui::TableDrawContextMenu, COMDAT

; 3079 : {

$LN34:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 92 00 00 00	 mov	 ecx, 146		; 00000092H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR [rsp+616]

; 3080 :     ImGuiContext& g = *GImGui;

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00031	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3081 :     ImGuiWindow* window = g.CurrentWindow;

  00035	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00039	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  00040	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 3082 :     if (window->SkipItems)

  00044	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00048	0f b6 80 b3 00
	00 00		 movzx	 eax, BYTE PTR [rax+179]
  0004f	85 c0		 test	 eax, eax
  00051	74 05		 je	 SHORT $LN5@TableDrawC

; 3083 :         return;

  00053	e9 b2 03 00 00	 jmp	 $LN1@TableDrawC
$LN5@TableDrawC:

; 3084 : 
; 3085 :     bool want_separator = false;

  00058	c6 45 44 00	 mov	 BYTE PTR want_separator$[rbp], 0

; 3086 :     const int column_n = (table->ContextPopupColumn >= 0 && table->ContextPopupColumn < table->ColumnsCount) ? table->ContextPopupColumn : -1;

  0005c	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00063	0f bf 80 10 02
	00 00		 movsx	 eax, WORD PTR [rax+528]
  0006a	85 c0		 test	 eax, eax
  0006c	7c 30		 jl	 SHORT $LN22@TableDrawC
  0006e	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00075	0f bf 80 10 02
	00 00		 movsx	 eax, WORD PTR [rax+528]
  0007c	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00083	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  00086	7d 16		 jge	 SHORT $LN22@TableDrawC
  00088	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0008f	0f bf 80 10 02
	00 00		 movsx	 eax, WORD PTR [rax+528]
  00096	89 85 14 02 00
	00		 mov	 DWORD PTR tv77[rbp], eax
  0009c	eb 0a		 jmp	 SHORT $LN23@TableDrawC
$LN22@TableDrawC:
  0009e	c7 85 14 02 00
	00 ff ff ff ff	 mov	 DWORD PTR tv77[rbp], -1
$LN23@TableDrawC:
  000a8	8b 85 14 02 00
	00		 mov	 eax, DWORD PTR tv77[rbp]
  000ae	89 45 64	 mov	 DWORD PTR column_n$[rbp], eax

; 3087 :     ImGuiTableColumn* column = (column_n != -1) ? &table->Columns[column_n] : NULL;

  000b1	83 7d 64 ff	 cmp	 DWORD PTR column_n$[rbp], -1
  000b5	74 1f		 je	 SHORT $LN24@TableDrawC
  000b7	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000be	48 83 c0 18	 add	 rax, 24
  000c2	8b 55 64	 mov	 edx, DWORD PTR column_n$[rbp]
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  000cd	48 89 85 18 02
	00 00		 mov	 QWORD PTR tv83[rbp], rax
  000d4	eb 0b		 jmp	 SHORT $LN25@TableDrawC
$LN24@TableDrawC:
  000d6	48 c7 85 18 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv83[rbp], 0
$LN25@TableDrawC:
  000e1	48 8b 85 18 02
	00 00		 mov	 rax, QWORD PTR tv83[rbp]
  000e8	48 89 85 88 00
	00 00		 mov	 QWORD PTR column$[rbp], rax

; 3088 : 
; 3089 :     // Sizing
; 3090 :     if (table->Flags & ImGuiTableFlags_Resizable)

  000ef	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000f6	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000f9	83 e0 01	 and	 eax, 1
  000fc	85 c0		 test	 eax, eax
  000fe	0f 84 fd 00 00
	00		 je	 $LN6@TableDrawC

; 3091 :     {
; 3092 :         if (column != NULL)

  00104	48 83 bd 88 00
	00 00 00	 cmp	 QWORD PTR column$[rbp], 0
  0010c	74 6e		 je	 SHORT $LN7@TableDrawC

; 3093 :         {
; 3094 :             const bool can_resize = !(column->Flags & ImGuiTableColumnFlags_NoResize) && column->IsEnabled;

  0010e	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00115	8b 00		 mov	 eax, DWORD PTR [rax]
  00117	83 e0 20	 and	 eax, 32			; 00000020H
  0011a	85 c0		 test	 eax, eax
  0011c	75 18		 jne	 SHORT $LN26@TableDrawC
  0011e	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00125	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  00129	85 c0		 test	 eax, eax
  0012b	74 09		 je	 SHORT $LN26@TableDrawC
  0012d	c6 85 14 02 00
	00 01		 mov	 BYTE PTR tv94[rbp], 1
  00134	eb 07		 jmp	 SHORT $LN27@TableDrawC
$LN26@TableDrawC:
  00136	c6 85 14 02 00
	00 00		 mov	 BYTE PTR tv94[rbp], 0
$LN27@TableDrawC:
  0013d	0f b6 85 14 02
	00 00		 movzx	 eax, BYTE PTR tv94[rbp]
  00144	88 85 a4 00 00
	00		 mov	 BYTE PTR can_resize$1[rbp], al

; 3095 :             if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableSizeOne), NULL, false, can_resize)) // "###SizeOne"

  0014a	33 c9		 xor	 ecx, ecx
  0014c	e8 00 00 00 00	 call	 ?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z ; ImGui::LocalizeGetMsg
  00151	44 0f b6 8d a4
	00 00 00	 movzx	 r9d, BYTE PTR can_resize$1[rbp]
  00159	45 33 c0	 xor	 r8d, r8d
  0015c	33 d2		 xor	 edx, edx
  0015e	48 8b c8	 mov	 rcx, rax
  00161	e8 00 00 00 00	 call	 ?MenuItem@ImGui@@YA_NPEBD0_N1@Z ; ImGui::MenuItem
  00166	0f b6 c0	 movzx	 eax, al
  00169	85 c0		 test	 eax, eax
  0016b	74 0f		 je	 SHORT $LN8@TableDrawC

; 3096 :                 TableSetColumnWidthAutoSingle(table, column_n);

  0016d	8b 55 64	 mov	 edx, DWORD PTR column_n$[rbp]
  00170	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00177	e8 00 00 00 00	 call	 ?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z ; ImGui::TableSetColumnWidthAutoSingle
$LN8@TableDrawC:
$LN7@TableDrawC:

; 3097 :         }
; 3098 : 
; 3099 :         const char* size_all_desc;
; 3100 :         if (table->ColumnsEnabledFixedCount == table->ColumnsEnabledCount && (table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame)

  0017c	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00183	0f bf 80 f4 01
	00 00		 movsx	 eax, WORD PTR [rax+500]
  0018a	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00191	0f bf 89 f2 01
	00 00		 movsx	 ecx, WORD PTR [rcx+498]
  00198	3b c1		 cmp	 eax, ecx
  0019a	75 29		 jne	 SHORT $LN9@TableDrawC
  0019c	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001a6	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  001ab	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  001b0	74 13		 je	 SHORT $LN9@TableDrawC

; 3101 :             size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllFit);        // "###SizeAll" All fixed

  001b2	b9 01 00 00 00	 mov	 ecx, 1
  001b7	e8 00 00 00 00	 call	 ?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z ; ImGui::LocalizeGetMsg
  001bc	48 89 85 c8 00
	00 00		 mov	 QWORD PTR size_all_desc$2[rbp], rax

; 3102 :         else

  001c3	eb 11		 jmp	 SHORT $LN10@TableDrawC
$LN9@TableDrawC:

; 3103 :             size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllDefault);    // "###SizeAll" All stretch or mixed

  001c5	b9 02 00 00 00	 mov	 ecx, 2
  001ca	e8 00 00 00 00	 call	 ?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z ; ImGui::LocalizeGetMsg
  001cf	48 89 85 c8 00
	00 00		 mov	 QWORD PTR size_all_desc$2[rbp], rax
$LN10@TableDrawC:

; 3104 :         if (MenuItem(size_all_desc, NULL))

  001d6	41 b1 01	 mov	 r9b, 1
  001d9	45 33 c0	 xor	 r8d, r8d
  001dc	33 d2		 xor	 edx, edx
  001de	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR size_all_desc$2[rbp]
  001e5	e8 00 00 00 00	 call	 ?MenuItem@ImGui@@YA_NPEBD0_N1@Z ; ImGui::MenuItem
  001ea	0f b6 c0	 movzx	 eax, al
  001ed	85 c0		 test	 eax, eax
  001ef	74 0c		 je	 SHORT $LN11@TableDrawC

; 3105 :             TableSetColumnWidthAutoAll(table);

  001f1	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  001f8	e8 00 00 00 00	 call	 ?TableSetColumnWidthAutoAll@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableSetColumnWidthAutoAll
$LN11@TableDrawC:

; 3106 :         want_separator = true;

  001fd	c6 45 44 01	 mov	 BYTE PTR want_separator$[rbp], 1
$LN6@TableDrawC:

; 3107 :     }
; 3108 : 
; 3109 :     // Ordering
; 3110 :     if (table->Flags & ImGuiTableFlags_Reorderable)

  00201	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00208	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0020b	83 e0 02	 and	 eax, 2
  0020e	85 c0		 test	 eax, eax
  00210	74 5a		 je	 SHORT $LN12@TableDrawC

; 3111 :     {
; 3112 :         if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableResetOrder), NULL, false, !table->IsDefaultDisplayOrder))

  00212	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00219	0f b6 80 2a 02
	00 00		 movzx	 eax, BYTE PTR [rax+554]
  00220	85 c0		 test	 eax, eax
  00222	75 09		 jne	 SHORT $LN28@TableDrawC
  00224	c6 85 14 02 00
	00 01		 mov	 BYTE PTR tv165[rbp], 1
  0022b	eb 07		 jmp	 SHORT $LN29@TableDrawC
$LN28@TableDrawC:
  0022d	c6 85 14 02 00
	00 00		 mov	 BYTE PTR tv165[rbp], 0
$LN29@TableDrawC:
  00234	b9 03 00 00 00	 mov	 ecx, 3
  00239	e8 00 00 00 00	 call	 ?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z ; ImGui::LocalizeGetMsg
  0023e	44 0f b6 8d 14
	02 00 00	 movzx	 r9d, BYTE PTR tv165[rbp]
  00246	45 33 c0	 xor	 r8d, r8d
  00249	33 d2		 xor	 edx, edx
  0024b	48 8b c8	 mov	 rcx, rax
  0024e	e8 00 00 00 00	 call	 ?MenuItem@ImGui@@YA_NPEBD0_N1@Z ; ImGui::MenuItem
  00253	0f b6 c0	 movzx	 eax, al
  00256	85 c0		 test	 eax, eax
  00258	74 0e		 je	 SHORT $LN13@TableDrawC

; 3113 :             table->IsResetDisplayOrderRequest = true;

  0025a	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00261	c6 80 2c 02 00
	00 01		 mov	 BYTE PTR [rax+556], 1
$LN13@TableDrawC:

; 3114 :         want_separator = true;

  00268	c6 45 44 01	 mov	 BYTE PTR want_separator$[rbp], 1
$LN12@TableDrawC:

; 3115 :     }
; 3116 : 
; 3117 :     // Reset all (should work but seems unnecessary/noisy to expose?)
; 3118 :     //if (MenuItem("Reset all"))
; 3119 :     //    table->IsResetAllRequest = true;
; 3120 : 
; 3121 :     // Sorting
; 3122 :     // (modify TableOpenContextMenu() to add _Sortable flag if enabling this)
; 3123 : #if 0
; 3124 :     if ((table->Flags & ImGuiTableFlags_Sortable) && column != NULL && (column->Flags & ImGuiTableColumnFlags_NoSort) == 0)
; 3125 :     {
; 3126 :         if (want_separator)
; 3127 :             Separator();
; 3128 :         want_separator = true;
; 3129 : 
; 3130 :         bool append_to_sort_specs = g.IO.KeyShift;
; 3131 :         if (MenuItem("Sort in Ascending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Ascending, (column->Flags & ImGuiTableColumnFlags_NoSortAscending) == 0))
; 3132 :             TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Ascending, append_to_sort_specs);
; 3133 :         if (MenuItem("Sort in Descending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Descending, (column->Flags & ImGuiTableColumnFlags_NoSortDescending) == 0))
; 3134 :             TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Descending, append_to_sort_specs);
; 3135 :     }
; 3136 : #endif
; 3137 : 
; 3138 :     // Hiding / Visibility
; 3139 :     if (table->Flags & ImGuiTableFlags_Hideable)

  0026c	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00273	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00276	83 e0 04	 and	 eax, 4
  00279	85 c0		 test	 eax, eax
  0027b	0f 84 89 01 00
	00		 je	 $LN14@TableDrawC

; 3140 :     {
; 3141 :         if (want_separator)

  00281	0f b6 45 44	 movzx	 eax, BYTE PTR want_separator$[rbp]
  00285	85 c0		 test	 eax, eax
  00287	74 05		 je	 SHORT $LN15@TableDrawC

; 3142 :             Separator();

  00289	e8 00 00 00 00	 call	 ?Separator@ImGui@@YAXXZ	; ImGui::Separator
$LN15@TableDrawC:

; 3143 :         want_separator = true;

  0028e	c6 45 44 01	 mov	 BYTE PTR want_separator$[rbp], 1

; 3144 : 
; 3145 :         PushItemFlag(ImGuiItemFlags_SelectableDontClosePopup, true);

  00292	b2 01		 mov	 dl, 1
  00294	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00299	e8 00 00 00 00	 call	 ?PushItemFlag@ImGui@@YAXH_N@Z ; ImGui::PushItemFlag

; 3146 :         for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)

  0029e	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR other_column_n$3[rbp], 0
  002a8	eb 0e		 jmp	 SHORT $LN4@TableDrawC
$LN2@TableDrawC:
  002aa	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR other_column_n$3[rbp]
  002b0	ff c0		 inc	 eax
  002b2	89 85 e4 00 00
	00		 mov	 DWORD PTR other_column_n$3[rbp], eax
$LN4@TableDrawC:
  002b8	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002bf	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  002c2	39 85 e4 00 00
	00		 cmp	 DWORD PTR other_column_n$3[rbp], eax
  002c8	0f 8d 37 01 00
	00		 jge	 $LN3@TableDrawC

; 3147 :         {
; 3148 :             ImGuiTableColumn* other_column = &table->Columns[other_column_n];

  002ce	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002d5	48 83 c0 18	 add	 rax, 24
  002d9	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR other_column_n$3[rbp]
  002df	48 8b c8	 mov	 rcx, rax
  002e2	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  002e7	48 89 85 08 01
	00 00		 mov	 QWORD PTR other_column$4[rbp], rax

; 3149 :             if (other_column->Flags & ImGuiTableColumnFlags_Disabled)

  002ee	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR other_column$4[rbp]
  002f5	8b 00		 mov	 eax, DWORD PTR [rax]
  002f7	83 e0 01	 and	 eax, 1
  002fa	85 c0		 test	 eax, eax
  002fc	74 02		 je	 SHORT $LN16@TableDrawC

; 3150 :                 continue;

  002fe	eb aa		 jmp	 SHORT $LN2@TableDrawC
$LN16@TableDrawC:

; 3151 : 
; 3152 :             const char* name = TableGetColumnName(table, other_column_n);

  00300	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR other_column_n$3[rbp]
  00306	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0030d	e8 00 00 00 00	 call	 ?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z ; ImGui::TableGetColumnName
  00312	48 89 85 28 01
	00 00		 mov	 QWORD PTR name$5[rbp], rax

; 3153 :             if (name == NULL || name[0] == 0)

  00319	48 83 bd 28 01
	00 00 00	 cmp	 QWORD PTR name$5[rbp], 0
  00321	74 18		 je	 SHORT $LN18@TableDrawC
  00323	b8 01 00 00 00	 mov	 eax, 1
  00328	48 6b c0 00	 imul	 rax, rax, 0
  0032c	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR name$5[rbp]
  00333	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00337	85 c0		 test	 eax, eax
  00339	75 0e		 jne	 SHORT $LN17@TableDrawC
$LN18@TableDrawC:

; 3154 :                 name = "<Unknown>";

  0033b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09MGFHLAFE@?$DMUnknown?$DO?$AA@
  00342	48 89 85 28 01
	00 00		 mov	 QWORD PTR name$5[rbp], rax
$LN17@TableDrawC:

; 3155 : 
; 3156 :             // Make sure we can't hide the last active column
; 3157 :             bool menu_item_active = (other_column->Flags & ImGuiTableColumnFlags_NoHide) ? false : true;

  00349	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR other_column$4[rbp]
  00350	8b 00		 mov	 eax, DWORD PTR [rax]
  00352	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00357	85 c0		 test	 eax, eax
  00359	74 09		 je	 SHORT $LN30@TableDrawC
  0035b	c6 85 14 02 00
	00 00		 mov	 BYTE PTR tv203[rbp], 0
  00362	eb 07		 jmp	 SHORT $LN31@TableDrawC
$LN30@TableDrawC:
  00364	c6 85 14 02 00
	00 01		 mov	 BYTE PTR tv203[rbp], 1
$LN31@TableDrawC:
  0036b	0f b6 85 14 02
	00 00		 movzx	 eax, BYTE PTR tv203[rbp]
  00372	88 85 44 01 00
	00		 mov	 BYTE PTR menu_item_active$6[rbp], al

; 3158 :             if (other_column->IsUserEnabled && table->ColumnsEnabledCount <= 1)

  00378	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR other_column$4[rbp]
  0037f	0f b6 40 63	 movzx	 eax, BYTE PTR [rax+99]
  00383	85 c0		 test	 eax, eax
  00385	74 1a		 je	 SHORT $LN19@TableDrawC
  00387	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0038e	0f bf 80 f2 01
	00 00		 movsx	 eax, WORD PTR [rax+498]
  00395	83 f8 01	 cmp	 eax, 1
  00398	7f 07		 jg	 SHORT $LN19@TableDrawC

; 3159 :                 menu_item_active = false;

  0039a	c6 85 44 01 00
	00 00		 mov	 BYTE PTR menu_item_active$6[rbp], 0
$LN19@TableDrawC:

; 3160 :             if (MenuItem(name, NULL, other_column->IsUserEnabled, menu_item_active))

  003a1	44 0f b6 8d 44
	01 00 00	 movzx	 r9d, BYTE PTR menu_item_active$6[rbp]
  003a9	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR other_column$4[rbp]
  003b0	44 0f b6 40 63	 movzx	 r8d, BYTE PTR [rax+99]
  003b5	33 d2		 xor	 edx, edx
  003b7	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR name$5[rbp]
  003be	e8 00 00 00 00	 call	 ?MenuItem@ImGui@@YA_NPEBD0_N1@Z ; ImGui::MenuItem
  003c3	0f b6 c0	 movzx	 eax, al
  003c6	85 c0		 test	 eax, eax
  003c8	74 36		 je	 SHORT $LN20@TableDrawC

; 3161 :                 other_column->IsUserEnabledNextFrame = !other_column->IsUserEnabled;

  003ca	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR other_column$4[rbp]
  003d1	0f b6 40 63	 movzx	 eax, BYTE PTR [rax+99]
  003d5	85 c0		 test	 eax, eax
  003d7	75 0c		 jne	 SHORT $LN32@TableDrawC
  003d9	c7 85 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR tv222[rbp], 1
  003e3	eb 0a		 jmp	 SHORT $LN33@TableDrawC
$LN32@TableDrawC:
  003e5	c7 85 14 02 00
	00 00 00 00 00	 mov	 DWORD PTR tv222[rbp], 0
$LN33@TableDrawC:
  003ef	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR other_column$4[rbp]
  003f6	0f b6 8d 14 02
	00 00		 movzx	 ecx, BYTE PTR tv222[rbp]
  003fd	88 48 64	 mov	 BYTE PTR [rax+100], cl
$LN20@TableDrawC:

; 3162 :         }

  00400	e9 a5 fe ff ff	 jmp	 $LN2@TableDrawC
$LN3@TableDrawC:

; 3163 :         PopItemFlag();

  00405	e8 00 00 00 00	 call	 ?PopItemFlag@ImGui@@YAXXZ ; ImGui::PopItemFlag
$LN14@TableDrawC:
$LN1@TableDrawC:

; 3164 :     }
; 3165 : }

  0040a	48 8d a5 28 02
	00 00		 lea	 rsp, QWORD PTR [rbp+552]
  00411	5f		 pop	 rdi
  00412	5d		 pop	 rbp
  00413	c3		 ret	 0
?TableDrawContextMenu@ImGui@@YAXPEAUImGuiTable@@@Z ENDP	; ImGui::TableDrawContextMenu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
inner_window$ = 8
inner_drawlist$ = 40
table_instance$ = 72
border_size$ = 100
draw_y1$ = 132
draw_y2_body$ = 164
draw_y2_head$ = 196
order_n$4 = 228
column_n$5 = 260
column$6 = 296
is_hovered$7 = 324
is_resized$8 = 356
is_resizable$9 = 388
is_frozen_separator$10 = 420
col$11 = 452
draw_y2$12 = 484
outer_border$13 = 520
outer_col$14 = 564
border_y$15 = 596
$T16 = 1012
$T17 = 1044
$T18 = 1076
$T19 = 1108
$T20 = 1140
$T21 = 1172
$T22 = 1204
$T23 = 1236
tv248 = 1252
tv242 = 1252
tv238 = 1252
tv196 = 1252
tv191 = 1252
tv187 = 1252
tv178 = 1252
tv140 = 1252
tv389 = 1256
tv377 = 1256
tv254 = 1256
tv235 = 1256
tv150 = 1256
__$ArrayPad$ = 1264
table$ = 1312
?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z PROC	; ImGui::TableDrawBorders, COMDAT

; 2534 : {

$LN46:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 81 ec 40 05
	00 00		 sub	 rsp, 1344		; 00000540H
  0000f	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 50 01 00 00	 mov	 ecx, 336		; 00000150H
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 68
	05 00 00	 mov	 rcx, QWORD PTR [rsp+1384]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c5	 xor	 rax, rbp
  00035	48 89 85 f0 04
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 2535 :     ImGuiWindow* inner_window = table->InnerWindow;

  0003c	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00043	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  0004a	48 89 45 08	 mov	 QWORD PTR inner_window$[rbp], rax

; 2536 :     if (!table->OuterWindow->ClipRect.Overlaps(table->OuterRect))

  0004e	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00055	48 05 e8 00 00
	00		 add	 rax, 232		; 000000e8H
  0005b	48 8b 8d 20 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00062	48 8b 89 78 01
	00 00		 mov	 rcx, QWORD PTR [rcx+376]
  00069	48 81 c1 30 02
	00 00		 add	 rcx, 560		; 00000230H
  00070	48 8b d0	 mov	 rdx, rax
  00073	e8 00 00 00 00	 call	 ?Overlaps@ImRect@@QEBA_NAEBU1@@Z ; ImRect::Overlaps
  00078	0f b6 c0	 movzx	 eax, al
  0007b	85 c0		 test	 eax, eax
  0007d	75 05		 jne	 SHORT $LN5@TableDrawB

; 2537 :         return;

  0007f	e9 53 08 00 00	 jmp	 $LN1@TableDrawB
$LN5@TableDrawB:

; 2538 : 
; 2539 :     ImDrawList* inner_drawlist = inner_window->DrawList;

  00084	48 8b 45 08	 mov	 rax, QWORD PTR inner_window$[rbp]
  00088	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0008f	48 89 45 28	 mov	 QWORD PTR inner_drawlist$[rbp], rax

; 2540 :     table->DrawSplitter->SetCurrentChannel(inner_drawlist, TABLE_DRAW_CHANNEL_BG0);

  00093	45 33 c0	 xor	 r8d, r8d
  00096	48 8b 55 28	 mov	 rdx, QWORD PTR inner_drawlist$[rbp]
  0009a	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000a1	48 8b 88 98 01
	00 00		 mov	 rcx, QWORD PTR [rax+408]
  000a8	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 2541 :     inner_drawlist->PushClipRect(table->Bg0ClipRectForDrawCmd.Min, table->Bg0ClipRectForDrawCmd.Max, false);

  000ad	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000b4	48 05 40 01 00
	00		 add	 rax, 320		; 00000140H
  000ba	48 8b 8d 20 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000c1	48 81 c1 38 01
	00 00		 add	 rcx, 312		; 00000138H
  000c8	45 33 c9	 xor	 r9d, r9d
  000cb	4c 8b c0	 mov	 r8, rax
  000ce	48 8b d1	 mov	 rdx, rcx
  000d1	48 8b 4d 28	 mov	 rcx, QWORD PTR inner_drawlist$[rbp]
  000d5	e8 00 00 00 00	 call	 ?PushClipRect@ImDrawList@@QEAAXAEBUImVec2@@0_N@Z ; ImDrawList::PushClipRect

; 2542 : 
; 2543 :     // Draw inner border and resizing feedback
; 2544 :     ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);

  000da	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000e1	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  000e5	8b d0		 mov	 edx, eax
  000e7	48 8b 8d 20 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000ee	e8 00 00 00 00	 call	 ?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z ; ImGui::TableGetInstanceData
  000f3	48 89 45 48	 mov	 QWORD PTR table_instance$[rbp], rax

; 2545 :     const float border_size = TABLE_BORDER_SIZE;

  000f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000ff	f3 0f 11 45 64	 movss	 DWORD PTR border_size$[rbp], xmm0

; 2546 :     const float draw_y1 = table->InnerRect.Min.y;

  00104	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0010b	f3 0f 10 80 fc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+252]
  00113	f3 0f 11 85 84
	00 00 00	 movss	 DWORD PTR draw_y1$[rbp], xmm0

; 2547 :     const float draw_y2_body = table->InnerRect.Max.y;

  0011b	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00122	f3 0f 10 80 04
	01 00 00	 movss	 xmm0, DWORD PTR [rax+260]
  0012a	f3 0f 11 85 a4
	00 00 00	 movss	 DWORD PTR draw_y2_body$[rbp], xmm0

; 2548 :     const float draw_y2_head = table->IsUsingHeaders ? ImMin(table->InnerRect.Max.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table_instance->LastFirstRowHeight) : draw_y1;

  00132	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00139	0f b6 80 26 02
	00 00		 movzx	 eax, BYTE PTR [rax+550]
  00140	85 c0		 test	 eax, eax
  00142	74 75		 je	 SHORT $LN28@TableDrawB
  00144	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0014b	0f bf 80 14 02
	00 00		 movsx	 eax, WORD PTR [rax+532]
  00152	83 f8 01	 cmp	 eax, 1
  00155	7c 19		 jl	 SHORT $LN26@TableDrawB
  00157	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0015e	f3 0f 10 80 fc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+252]
  00166	f3 0f 11 85 e4
	04 00 00	 movss	 DWORD PTR tv140[rbp], xmm0
  0016e	eb 17		 jmp	 SHORT $LN27@TableDrawB
$LN26@TableDrawB:
  00170	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00177	f3 0f 10 80 0c
	01 00 00	 movss	 xmm0, DWORD PTR [rax+268]
  0017f	f3 0f 11 85 e4
	04 00 00	 movss	 DWORD PTR tv140[rbp], xmm0
$LN27@TableDrawB:
  00187	48 8b 45 48	 mov	 rax, QWORD PTR table_instance$[rbp]
  0018b	f3 0f 10 85 e4
	04 00 00	 movss	 xmm0, DWORD PTR tv140[rbp]
  00193	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [rax+4]
  00198	0f 28 c8	 movaps	 xmm1, xmm0
  0019b	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001a2	f3 0f 10 80 04
	01 00 00	 movss	 xmm0, DWORD PTR [rax+260]
  001aa	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  001af	f3 0f 11 85 e8
	04 00 00	 movss	 DWORD PTR tv150[rbp], xmm0
  001b7	eb 10		 jmp	 SHORT $LN29@TableDrawB
$LN28@TableDrawB:
  001b9	f3 0f 10 85 84
	00 00 00	 movss	 xmm0, DWORD PTR draw_y1$[rbp]
  001c1	f3 0f 11 85 e8
	04 00 00	 movss	 DWORD PTR tv150[rbp], xmm0
$LN29@TableDrawB:
  001c9	f3 0f 10 85 e8
	04 00 00	 movss	 xmm0, DWORD PTR tv150[rbp]
  001d1	f3 0f 11 85 c4
	00 00 00	 movss	 DWORD PTR draw_y2_head$[rbp], xmm0

; 2549 :     if (table->Flags & ImGuiTableFlags_BordersInnerV)

  001d9	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001e0	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001e3	25 00 02 00 00	 and	 eax, 512		; 00000200H
  001e8	85 c0		 test	 eax, eax
  001ea	0f 84 f6 03 00
	00		 je	 $LN6@TableDrawB

; 2550 :     {
; 2551 :         for (int order_n = 0; order_n < table->ColumnsCount; order_n++)

  001f0	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR order_n$4[rbp], 0
  001fa	eb 0e		 jmp	 SHORT $LN4@TableDrawB
$LN2@TableDrawB:
  001fc	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR order_n$4[rbp]
  00202	ff c0		 inc	 eax
  00204	89 85 e4 00 00
	00		 mov	 DWORD PTR order_n$4[rbp], eax
$LN4@TableDrawB:
  0020a	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00211	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00214	39 85 e4 00 00
	00		 cmp	 DWORD PTR order_n$4[rbp], eax
  0021a	0f 8d c6 03 00
	00		 jge	 $LN3@TableDrawB

; 2552 :         {
; 2553 :             if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))

  00220	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR order_n$4[rbp]
  00226	c1 f8 05	 sar	 eax, 5
  00229	48 98		 cdqe
  0022b	48 8b 8d 20 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00232	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00236	48 89 8d e8 04
	00 00		 mov	 QWORD PTR tv389[rbp], rcx
  0023d	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR order_n$4[rbp]
  00243	83 e2 1f	 and	 edx, 31
  00246	41 b8 01 00 00
	00		 mov	 r8d, 1
  0024c	0f b6 ca	 movzx	 ecx, dl
  0024f	41 8b d0	 mov	 edx, r8d
  00252	d3 e2		 shl	 edx, cl
  00254	8b ca		 mov	 ecx, edx
  00256	48 8b 95 e8 04
	00 00		 mov	 rdx, QWORD PTR tv389[rbp]
  0025d	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00260	23 c1		 and	 eax, ecx
  00262	85 c0		 test	 eax, eax
  00264	75 02		 jne	 SHORT $LN7@TableDrawB

; 2554 :                 continue;

  00266	eb 94		 jmp	 SHORT $LN2@TableDrawB
$LN7@TableDrawB:

; 2555 : 
; 2556 :             const int column_n = table->DisplayOrderToIndex[order_n];

  00268	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0026f	48 83 c0 28	 add	 rax, 40			; 00000028H
  00273	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR order_n$4[rbp]
  00279	48 8b c8	 mov	 rcx, rax
  0027c	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  00281	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00284	89 85 04 01 00
	00		 mov	 DWORD PTR column_n$5[rbp], eax

; 2557 :             ImGuiTableColumn* column = &table->Columns[column_n];

  0028a	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00291	48 83 c0 18	 add	 rax, 24
  00295	8b 95 04 01 00
	00		 mov	 edx, DWORD PTR column_n$5[rbp]
  0029b	48 8b c8	 mov	 rcx, rax
  0029e	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  002a3	48 89 85 28 01
	00 00		 mov	 QWORD PTR column$6[rbp], rax

; 2558 :             const bool is_hovered = (table->HoveredColumnBorder == column_n);

  002aa	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002b1	0f bf 80 fa 01
	00 00		 movsx	 eax, WORD PTR [rax+506]
  002b8	3b 85 04 01 00
	00		 cmp	 eax, DWORD PTR column_n$5[rbp]
  002be	75 09		 jne	 SHORT $LN30@TableDrawB
  002c0	c6 85 e4 04 00
	00 01		 mov	 BYTE PTR tv178[rbp], 1
  002c7	eb 07		 jmp	 SHORT $LN31@TableDrawB
$LN30@TableDrawB:
  002c9	c6 85 e4 04 00
	00 00		 mov	 BYTE PTR tv178[rbp], 0
$LN31@TableDrawB:
  002d0	0f b6 85 e4 04
	00 00		 movzx	 eax, BYTE PTR tv178[rbp]
  002d7	88 85 44 01 00
	00		 mov	 BYTE PTR is_hovered$7[rbp], al

; 2559 :             const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);

  002dd	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002e4	0f bf 80 fe 01
	00 00		 movsx	 eax, WORD PTR [rax+510]
  002eb	3b 85 04 01 00
	00		 cmp	 eax, DWORD PTR column_n$5[rbp]
  002f1	75 23		 jne	 SHORT $LN32@TableDrawB
  002f3	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002fa	0f bf 40 7a	 movsx	 eax, WORD PTR [rax+122]
  002fe	48 8b 8d 20 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00305	0f bf 49 78	 movsx	 ecx, WORD PTR [rcx+120]
  00309	3b c1		 cmp	 eax, ecx
  0030b	75 09		 jne	 SHORT $LN32@TableDrawB
  0030d	c6 85 e4 04 00
	00 01		 mov	 BYTE PTR tv187[rbp], 1
  00314	eb 07		 jmp	 SHORT $LN33@TableDrawB
$LN32@TableDrawB:
  00316	c6 85 e4 04 00
	00 00		 mov	 BYTE PTR tv187[rbp], 0
$LN33@TableDrawB:
  0031d	0f b6 85 e4 04
	00 00		 movzx	 eax, BYTE PTR tv187[rbp]
  00324	88 85 64 01 00
	00		 mov	 BYTE PTR is_resized$8[rbp], al

; 2560 :             const bool is_resizable = (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_)) == 0;

  0032a	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  00331	8b 00		 mov	 eax, DWORD PTR [rax]
  00333	25 20 00 00 40	 and	 eax, 1073741856		; 40000020H
  00338	85 c0		 test	 eax, eax
  0033a	75 09		 jne	 SHORT $LN34@TableDrawB
  0033c	c6 85 e4 04 00
	00 01		 mov	 BYTE PTR tv191[rbp], 1
  00343	eb 07		 jmp	 SHORT $LN35@TableDrawB
$LN34@TableDrawB:
  00345	c6 85 e4 04 00
	00 00		 mov	 BYTE PTR tv191[rbp], 0
$LN35@TableDrawB:
  0034c	0f b6 85 e4 04
	00 00		 movzx	 eax, BYTE PTR tv191[rbp]
  00353	88 85 84 01 00
	00		 mov	 BYTE PTR is_resizable$9[rbp], al

; 2561 :             const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);

  00359	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00360	0f bf 80 18 02
	00 00		 movsx	 eax, WORD PTR [rax+536]
  00367	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR order_n$4[rbp]
  0036d	ff c1		 inc	 ecx
  0036f	3b c1		 cmp	 eax, ecx
  00371	75 09		 jne	 SHORT $LN36@TableDrawB
  00373	c6 85 e4 04 00
	00 01		 mov	 BYTE PTR tv196[rbp], 1
  0037a	eb 07		 jmp	 SHORT $LN37@TableDrawB
$LN36@TableDrawB:
  0037c	c6 85 e4 04 00
	00 00		 mov	 BYTE PTR tv196[rbp], 0
$LN37@TableDrawB:
  00383	0f b6 85 e4 04
	00 00		 movzx	 eax, BYTE PTR tv196[rbp]
  0038a	88 85 a4 01 00
	00		 mov	 BYTE PTR is_frozen_separator$10[rbp], al

; 2562 :             if (column->MaxX > table->InnerClipRect.Max.x && !is_resized)

  00390	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  00397	48 8b 8d 20 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0039e	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  003a3	0f 2f 81 20 01
	00 00		 comiss	 xmm0, DWORD PTR [rcx+288]
  003aa	76 10		 jbe	 SHORT $LN8@TableDrawB
  003ac	0f b6 85 64 01
	00 00		 movzx	 eax, BYTE PTR is_resized$8[rbp]
  003b3	85 c0		 test	 eax, eax
  003b5	75 05		 jne	 SHORT $LN8@TableDrawB

; 2563 :                 continue;

  003b7	e9 40 fe ff ff	 jmp	 $LN2@TableDrawB
$LN8@TableDrawB:

; 2564 : 
; 2565 :             // Decide whether right-most column is visible
; 2566 :             if (column->NextEnabledColumn == -1 && !is_resizable)

  003bc	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  003c3	0f bf 40 58	 movsx	 eax, WORD PTR [rax+88]
  003c7	83 f8 ff	 cmp	 eax, -1
  003ca	75 39		 jne	 SHORT $LN9@TableDrawB
  003cc	0f b6 85 84 01
	00 00		 movzx	 eax, BYTE PTR is_resizable$9[rbp]
  003d3	85 c0		 test	 eax, eax
  003d5	75 2e		 jne	 SHORT $LN9@TableDrawB

; 2567 :                 if ((table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame || (table->Flags & ImGuiTableFlags_NoHostExtendX))

  003d7	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003de	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  003e1	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  003e6	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  003eb	75 13		 jne	 SHORT $LN11@TableDrawB
  003ed	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003f4	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  003f7	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  003fc	85 c0		 test	 eax, eax
  003fe	74 05		 je	 SHORT $LN10@TableDrawB
$LN11@TableDrawB:

; 2568 :                     continue;

  00400	e9 f7 fd ff ff	 jmp	 $LN2@TableDrawB
$LN10@TableDrawB:
$LN9@TableDrawB:

; 2569 :             if (column->MaxX <= column->ClipRect.Min.x) // FIXME-TABLE FIXME-STYLE: Assume BorderSize==1, this is problematic if we want to increase the border size..

  00405	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  0040c	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR column$6[rbp]
  00413	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [rax+32]
  00418	0f 2f 41 0c	 comiss	 xmm0, DWORD PTR [rcx+12]
  0041c	72 05		 jb	 SHORT $LN12@TableDrawB

; 2570 :                 continue;

  0041e	e9 d9 fd ff ff	 jmp	 $LN2@TableDrawB
$LN12@TableDrawB:

; 2571 : 
; 2572 :             // Draw in outer window so right-most column won't be clipped
; 2573 :             // Always draw full height border when being resized/hovered, or on the delimitation of frozen column scrolling.
; 2574 :             ImU32 col;
; 2575 :             float draw_y2;
; 2576 :             if (is_hovered || is_resized || is_frozen_separator)

  00423	0f b6 85 44 01
	00 00		 movzx	 eax, BYTE PTR is_hovered$7[rbp]
  0042a	85 c0		 test	 eax, eax
  0042c	75 1a		 jne	 SHORT $LN15@TableDrawB
  0042e	0f b6 85 64 01
	00 00		 movzx	 eax, BYTE PTR is_resized$8[rbp]
  00435	85 c0		 test	 eax, eax
  00437	75 0f		 jne	 SHORT $LN15@TableDrawB
  00439	0f b6 85 a4 01
	00 00		 movzx	 eax, BYTE PTR is_frozen_separator$10[rbp]
  00440	85 c0		 test	 eax, eax
  00442	0f 84 8a 00 00
	00		 je	 $LN13@TableDrawB
$LN15@TableDrawB:

; 2577 :             {
; 2578 :                 draw_y2 = draw_y2_body;

  00448	f3 0f 10 85 a4
	00 00 00	 movss	 xmm0, DWORD PTR draw_y2_body$[rbp]
  00450	f3 0f 11 85 e4
	01 00 00	 movss	 DWORD PTR draw_y2$12[rbp], xmm0

; 2579 :                 col = is_resized ? GetColorU32(ImGuiCol_SeparatorActive) : is_hovered ? GetColorU32(ImGuiCol_SeparatorHovered) : table->BorderColorStrong;

  00458	0f b6 85 64 01
	00 00		 movzx	 eax, BYTE PTR is_resized$8[rbp]
  0045f	85 c0		 test	 eax, eax
  00461	74 1a		 je	 SHORT $LN40@TableDrawB
  00463	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0046b	b9 1d 00 00 00	 mov	 ecx, 29
  00470	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00475	89 85 e4 04 00
	00		 mov	 DWORD PTR tv238[rbp], eax
  0047b	eb 44		 jmp	 SHORT $LN41@TableDrawB
$LN40@TableDrawB:
  0047d	0f b6 85 44 01
	00 00		 movzx	 eax, BYTE PTR is_hovered$7[rbp]
  00484	85 c0		 test	 eax, eax
  00486	74 1a		 je	 SHORT $LN38@TableDrawB
  00488	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00490	b9 1c 00 00 00	 mov	 ecx, 28
  00495	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0049a	89 85 e8 04 00
	00		 mov	 DWORD PTR tv235[rbp], eax
  004a0	eb 13		 jmp	 SHORT $LN39@TableDrawB
$LN38@TableDrawB:
  004a2	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004a9	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  004af	89 85 e8 04 00
	00		 mov	 DWORD PTR tv235[rbp], eax
$LN39@TableDrawB:
  004b5	8b 85 e8 04 00
	00		 mov	 eax, DWORD PTR tv235[rbp]
  004bb	89 85 e4 04 00
	00		 mov	 DWORD PTR tv238[rbp], eax
$LN41@TableDrawB:
  004c1	8b 85 e4 04 00
	00		 mov	 eax, DWORD PTR tv238[rbp]
  004c7	89 85 c4 01 00
	00		 mov	 DWORD PTR col$11[rbp], eax

; 2580 :             }
; 2581 :             else

  004cd	e9 8c 00 00 00	 jmp	 $LN14@TableDrawB
$LN13@TableDrawB:

; 2582 :             {
; 2583 :                 draw_y2 = (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)) ? draw_y2_head : draw_y2_body;

  004d2	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004d9	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  004dc	25 00 18 00 00	 and	 eax, 6144		; 00001800H
  004e1	85 c0		 test	 eax, eax
  004e3	74 12		 je	 SHORT $LN42@TableDrawB
  004e5	f3 0f 10 85 c4
	00 00 00	 movss	 xmm0, DWORD PTR draw_y2_head$[rbp]
  004ed	f3 0f 11 85 e4
	04 00 00	 movss	 DWORD PTR tv242[rbp], xmm0
  004f5	eb 10		 jmp	 SHORT $LN43@TableDrawB
$LN42@TableDrawB:
  004f7	f3 0f 10 85 a4
	00 00 00	 movss	 xmm0, DWORD PTR draw_y2_body$[rbp]
  004ff	f3 0f 11 85 e4
	04 00 00	 movss	 DWORD PTR tv242[rbp], xmm0
$LN43@TableDrawB:
  00507	f3 0f 10 85 e4
	04 00 00	 movss	 xmm0, DWORD PTR tv242[rbp]
  0050f	f3 0f 11 85 e4
	01 00 00	 movss	 DWORD PTR draw_y2$12[rbp], xmm0

; 2584 :                 col = (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)) ? table->BorderColorStrong : table->BorderColorLight;

  00517	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0051e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00521	25 00 18 00 00	 and	 eax, 6144		; 00001800H
  00526	85 c0		 test	 eax, eax
  00528	74 15		 je	 SHORT $LN44@TableDrawB
  0052a	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00531	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  00537	89 85 e4 04 00
	00		 mov	 DWORD PTR tv248[rbp], eax
  0053d	eb 13		 jmp	 SHORT $LN45@TableDrawB
$LN44@TableDrawB:
  0053f	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00546	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [rax+164]
  0054c	89 85 e4 04 00
	00		 mov	 DWORD PTR tv248[rbp], eax
$LN45@TableDrawB:
  00552	8b 85 e4 04 00
	00		 mov	 eax, DWORD PTR tv248[rbp]
  00558	89 85 c4 01 00
	00		 mov	 DWORD PTR col$11[rbp], eax
$LN14@TableDrawB:

; 2585 :             }
; 2586 : 
; 2587 :             if (draw_y2 > draw_y1)

  0055e	f3 0f 10 85 e4
	01 00 00	 movss	 xmm0, DWORD PTR draw_y2$12[rbp]
  00566	0f 2f 85 84 00
	00 00		 comiss	 xmm0, DWORD PTR draw_y1$[rbp]
  0056d	76 72		 jbe	 SHORT $LN16@TableDrawB

; 2588 :                 inner_drawlist->AddLine(ImVec2(column->MaxX, draw_y1), ImVec2(column->MaxX, draw_y2), col, border_size);

  0056f	f3 0f 10 95 e4
	01 00 00	 movss	 xmm2, DWORD PTR draw_y2$12[rbp]
  00577	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR column$6[rbp]
  0057e	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [rax+12]
  00583	48 8d 8d f4 03
	00 00		 lea	 rcx, QWORD PTR $T16[rbp]
  0058a	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  0058f	48 89 85 e8 04
	00 00		 mov	 QWORD PTR tv254[rbp], rax
  00596	f3 0f 10 95 84
	00 00 00	 movss	 xmm2, DWORD PTR draw_y1$[rbp]
  0059e	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR column$6[rbp]
  005a5	f3 0f 10 49 0c	 movss	 xmm1, DWORD PTR [rcx+12]
  005aa	48 8d 8d 14 04
	00 00		 lea	 rcx, QWORD PTR $T17[rbp]
  005b1	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  005b6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005be	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  005c4	44 8b 8d c4 01
	00 00		 mov	 r9d, DWORD PTR col$11[rbp]
  005cb	48 8b 8d e8 04
	00 00		 mov	 rcx, QWORD PTR tv254[rbp]
  005d2	4c 8b c1	 mov	 r8, rcx
  005d5	48 8b d0	 mov	 rdx, rax
  005d8	48 8b 4d 28	 mov	 rcx, QWORD PTR inner_drawlist$[rbp]
  005dc	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN16@TableDrawB:

; 2589 :         }

  005e1	e9 16 fc ff ff	 jmp	 $LN2@TableDrawB
$LN3@TableDrawB:
$LN6@TableDrawB:

; 2590 :     }
; 2591 : 
; 2592 :     // Draw outer border
; 2593 :     // FIXME: could use AddRect or explicit VLine/HLine helper?
; 2594 :     if (table->Flags & ImGuiTableFlags_BordersOuter)

  005e6	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  005ed	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  005f0	25 00 05 00 00	 and	 eax, 1280		; 00000500H
  005f5	85 c0		 test	 eax, eax
  005f7	0f 84 cd 01 00
	00		 je	 $LN17@TableDrawB

; 2595 :     {
; 2596 :         // Display outer border offset by 1 which is a simple way to display it without adding an extra draw call
; 2597 :         // (Without the offset, in outer_window it would be rendered behind cells, because child windows are above their
; 2598 :         // parent. In inner_window, it won't reach out over scrollbars. Another weird solution would be to display part
; 2599 :         // of it in inner window, and the part that's over scrollbars in the outer window..)
; 2600 :         // Either solution currently won't allow us to use a larger border size: the border would clipped.
; 2601 :         const ImRect outer_border = table->OuterRect;

  005fd	48 8d 85 08 02
	00 00		 lea	 rax, QWORD PTR outer_border$13[rbp]
  00604	48 8b 8d 20 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0060b	48 8b f8	 mov	 rdi, rax
  0060e	48 8d b1 e8 00
	00 00		 lea	 rsi, QWORD PTR [rcx+232]
  00615	b9 10 00 00 00	 mov	 ecx, 16
  0061a	f3 a4		 rep movsb

; 2602 :         const ImU32 outer_col = table->BorderColorStrong;

  0061c	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00623	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  00629	89 85 34 02 00
	00		 mov	 DWORD PTR outer_col$14[rbp], eax

; 2603 :         if ((table->Flags & ImGuiTableFlags_BordersOuter) == ImGuiTableFlags_BordersOuter)

  0062f	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00636	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00639	25 00 05 00 00	 and	 eax, 1280		; 00000500H
  0063e	3d 00 05 00 00	 cmp	 eax, 1280		; 00000500H
  00643	75 42		 jne	 SHORT $LN18@TableDrawB

; 2604 :         {
; 2605 :             inner_drawlist->AddRect(outer_border.Min, outer_border.Max, outer_col, 0.0f, 0, border_size);

  00645	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0064d	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00653	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0065b	0f 57 c0	 xorps	 xmm0, xmm0
  0065e	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00664	44 8b 8d 34 02
	00 00		 mov	 r9d, DWORD PTR outer_col$14[rbp]
  0066b	4c 8d 85 10 02
	00 00		 lea	 r8, QWORD PTR outer_border$13[rbp+8]
  00672	48 8d 95 08 02
	00 00		 lea	 rdx, QWORD PTR outer_border$13[rbp]
  00679	48 8b 4d 28	 mov	 rcx, QWORD PTR inner_drawlist$[rbp]
  0067d	e8 00 00 00 00	 call	 ?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
  00682	e9 43 01 00 00	 jmp	 $LN19@TableDrawB
$LN18@TableDrawB:

; 2606 :         }
; 2607 :         else if (table->Flags & ImGuiTableFlags_BordersOuterV)

  00687	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0068e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00691	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00696	85 c0		 test	 eax, eax
  00698	0f 84 8d 00 00
	00		 je	 $LN20@TableDrawB

; 2608 :         {
; 2609 :             inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Min.x, outer_border.Max.y), outer_col, border_size);

  0069e	f3 0f 10 95 14
	02 00 00	 movss	 xmm2, DWORD PTR outer_border$13[rbp+12]
  006a6	f3 0f 10 8d 08
	02 00 00	 movss	 xmm1, DWORD PTR outer_border$13[rbp]
  006ae	48 8d 8d 34 04
	00 00		 lea	 rcx, QWORD PTR $T18[rbp]
  006b5	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  006ba	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006c2	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  006c8	44 8b 8d 34 02
	00 00		 mov	 r9d, DWORD PTR outer_col$14[rbp]
  006cf	4c 8b c0	 mov	 r8, rax
  006d2	48 8d 95 08 02
	00 00		 lea	 rdx, QWORD PTR outer_border$13[rbp]
  006d9	48 8b 4d 28	 mov	 rcx, QWORD PTR inner_drawlist$[rbp]
  006dd	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine

; 2610 :             inner_drawlist->AddLine(ImVec2(outer_border.Max.x, outer_border.Min.y), outer_border.Max, outer_col, border_size);

  006e2	f3 0f 10 95 0c
	02 00 00	 movss	 xmm2, DWORD PTR outer_border$13[rbp+4]
  006ea	f3 0f 10 8d 10
	02 00 00	 movss	 xmm1, DWORD PTR outer_border$13[rbp+8]
  006f2	48 8d 8d 54 04
	00 00		 lea	 rcx, QWORD PTR $T19[rbp]
  006f9	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  006fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00706	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0070c	44 8b 8d 34 02
	00 00		 mov	 r9d, DWORD PTR outer_col$14[rbp]
  00713	4c 8d 85 10 02
	00 00		 lea	 r8, QWORD PTR outer_border$13[rbp+8]
  0071a	48 8b d0	 mov	 rdx, rax
  0071d	48 8b 4d 28	 mov	 rcx, QWORD PTR inner_drawlist$[rbp]
  00721	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
  00726	e9 9f 00 00 00	 jmp	 $LN21@TableDrawB
$LN20@TableDrawB:

; 2611 :         }
; 2612 :         else if (table->Flags & ImGuiTableFlags_BordersOuterH)

  0072b	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00732	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00735	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0073a	85 c0		 test	 eax, eax
  0073c	0f 84 88 00 00
	00		 je	 $LN22@TableDrawB

; 2613 :         {
; 2614 :             inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Max.x, outer_border.Min.y), outer_col, border_size);

  00742	f3 0f 10 95 0c
	02 00 00	 movss	 xmm2, DWORD PTR outer_border$13[rbp+4]
  0074a	f3 0f 10 8d 10
	02 00 00	 movss	 xmm1, DWORD PTR outer_border$13[rbp+8]
  00752	48 8d 8d 74 04
	00 00		 lea	 rcx, QWORD PTR $T20[rbp]
  00759	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  0075e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00766	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0076c	44 8b 8d 34 02
	00 00		 mov	 r9d, DWORD PTR outer_col$14[rbp]
  00773	4c 8b c0	 mov	 r8, rax
  00776	48 8d 95 08 02
	00 00		 lea	 rdx, QWORD PTR outer_border$13[rbp]
  0077d	48 8b 4d 28	 mov	 rcx, QWORD PTR inner_drawlist$[rbp]
  00781	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine

; 2615 :             inner_drawlist->AddLine(ImVec2(outer_border.Min.x, outer_border.Max.y), outer_border.Max, outer_col, border_size);

  00786	f3 0f 10 95 14
	02 00 00	 movss	 xmm2, DWORD PTR outer_border$13[rbp+12]
  0078e	f3 0f 10 8d 08
	02 00 00	 movss	 xmm1, DWORD PTR outer_border$13[rbp]
  00796	48 8d 8d 94 04
	00 00		 lea	 rcx, QWORD PTR $T21[rbp]
  0079d	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  007a2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  007aa	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  007b0	44 8b 8d 34 02
	00 00		 mov	 r9d, DWORD PTR outer_col$14[rbp]
  007b7	4c 8d 85 10 02
	00 00		 lea	 r8, QWORD PTR outer_border$13[rbp+8]
  007be	48 8b d0	 mov	 rdx, rax
  007c1	48 8b 4d 28	 mov	 rcx, QWORD PTR inner_drawlist$[rbp]
  007c5	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN22@TableDrawB:
$LN21@TableDrawB:
$LN19@TableDrawB:
$LN17@TableDrawB:

; 2616 :         }
; 2617 :     }
; 2618 :     if ((table->Flags & ImGuiTableFlags_BordersInnerH) && table->RowPosY2 < table->OuterRect.Max.y)

  007ca	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  007d1	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  007d4	25 80 00 00 00	 and	 eax, 128		; 00000080H
  007d9	85 c0		 test	 eax, eax
  007db	0f 84 ed 00 00
	00		 je	 $LN23@TableDrawB
  007e1	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  007e8	48 8b 8d 20 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  007ef	f3 0f 10 80 f4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+244]
  007f7	0f 2f 81 80 00
	00 00		 comiss	 xmm0, DWORD PTR [rcx+128]
  007fe	0f 86 ca 00 00
	00		 jbe	 $LN23@TableDrawB

; 2619 :     {
; 2620 :         // Draw bottom-most row border
; 2621 :         const float border_y = table->RowPosY2;

  00804	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0080b	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  00813	f3 0f 11 85 54
	02 00 00	 movss	 DWORD PTR border_y$15[rbp], xmm0

; 2622 :         if (border_y >= table->BgClipRect.Min.y && border_y < table->BgClipRect.Max.y)

  0081b	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00822	f3 0f 10 85 54
	02 00 00	 movss	 xmm0, DWORD PTR border_y$15[rbp]
  0082a	0f 2f 80 2c 01
	00 00		 comiss	 xmm0, DWORD PTR [rax+300]
  00831	0f 82 97 00 00
	00		 jb	 $LN24@TableDrawB
  00837	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0083e	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [rax+308]
  00846	0f 2f 85 54 02
	00 00		 comiss	 xmm0, DWORD PTR border_y$15[rbp]
  0084d	76 7f		 jbe	 SHORT $LN24@TableDrawB

; 2623 :             inner_drawlist->AddLine(ImVec2(table->BorderX1, border_y), ImVec2(table->BorderX2, border_y), table->BorderColorLight, border_size);

  0084f	f3 0f 10 95 54
	02 00 00	 movss	 xmm2, DWORD PTR border_y$15[rbp]
  00857	48 8b 85 20 05
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0085e	f3 0f 10 88 ac
	00 00 00	 movss	 xmm1, DWORD PTR [rax+172]
  00866	48 8d 8d b4 04
	00 00		 lea	 rcx, QWORD PTR $T22[rbp]
  0086d	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00872	48 89 85 e8 04
	00 00		 mov	 QWORD PTR tv377[rbp], rax
  00879	f3 0f 10 95 54
	02 00 00	 movss	 xmm2, DWORD PTR border_y$15[rbp]
  00881	48 8b 8d 20 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00888	f3 0f 10 89 a8
	00 00 00	 movss	 xmm1, DWORD PTR [rcx+168]
  00890	48 8d 8d d4 04
	00 00		 lea	 rcx, QWORD PTR $T23[rbp]
  00897	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  0089c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  008a4	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  008aa	48 8b 8d 20 05
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  008b1	44 8b 89 a4 00
	00 00		 mov	 r9d, DWORD PTR [rcx+164]
  008b8	48 8b 8d e8 04
	00 00		 mov	 rcx, QWORD PTR tv377[rbp]
  008bf	4c 8b c1	 mov	 r8, rcx
  008c2	48 8b d0	 mov	 rdx, rax
  008c5	48 8b 4d 28	 mov	 rcx, QWORD PTR inner_drawlist$[rbp]
  008c9	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN24@TableDrawB:
$LN23@TableDrawB:

; 2624 :     }
; 2625 : 
; 2626 :     inner_drawlist->PopClipRect();

  008ce	48 8b 4d 28	 mov	 rcx, QWORD PTR inner_drawlist$[rbp]
  008d2	e8 00 00 00 00	 call	 ?PopClipRect@ImDrawList@@QEAAXXZ ; ImDrawList::PopClipRect
$LN1@TableDrawB:

; 2627 : }

  008d7	48 8d 4d c0	 lea	 rcx, QWORD PTR [rbp-64]
  008db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData
  008e2	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  008e7	48 8b 8d f0 04
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  008ee	48 33 cd	 xor	 rcx, rbp
  008f1	e8 00 00 00 00	 call	 __security_check_cookie
  008f6	48 8d a5 00 05
	00 00		 lea	 rsp, QWORD PTR [rbp+1280]
  008fd	5f		 pop	 rdi
  008fe	5e		 pop	 rsi
  008ff	5d		 pop	 rbp
  00900	c3		 ret	 0
?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z ENDP	; ImGui::TableDrawBorders
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
visible_weight$ = 4
visible_width$ = 36
column_n$1 = 68
column$2 = 104
column_n$3 = 132
column$4 = 168
table$ = 416
?TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z PROC ; ImGui::TableUpdateColumnsWeightFromWidth, COMDAT

; 2212 : {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+456]

; 2213 :     IM_ASSERT(table->LeftMostStretchedColumn != -1 && table->RightMostStretchedColumn != -1);

  0002a	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00031	0f bf 80 0c 02
	00 00		 movsx	 eax, WORD PTR [rax+524]
  00038	83 f8 ff	 cmp	 eax, -1
  0003b	74 13		 je	 SHORT $LN13@TableUpdat
  0003d	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00044	0f bf 80 0e 02
	00 00		 movsx	 eax, WORD PTR [rax+526]
  0004b	83 f8 ff	 cmp	 eax, -1
  0004e	75 21		 jne	 SHORT $LN14@TableUpdat
$LN13@TableUpdat:
  00050	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00056	ff c0		 inc	 eax
  00058	44 8b c0	 mov	 r8d, eax
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JM@ELMLJHLO@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAL?$AAe?$AAf?$AAt?$AAM?$AAo?$AAs?$AAt?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$CB@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN14@TableUpdat:

; 2214 : 
; 2215 :     // Measure existing quantity
; 2216 :     float visible_weight = 0.0f;

  00071	0f 57 c0	 xorps	 xmm0, xmm0
  00074	f3 0f 11 45 04	 movss	 DWORD PTR visible_weight$[rbp], xmm0

; 2217 :     float visible_width = 0.0f;

  00079	0f 57 c0	 xorps	 xmm0, xmm0
  0007c	f3 0f 11 45 24	 movss	 DWORD PTR visible_width$[rbp], xmm0

; 2218 :     for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  00081	c7 45 44 00 00
	00 00		 mov	 DWORD PTR column_n$1[rbp], 0
  00088	eb 08		 jmp	 SHORT $LN4@TableUpdat
$LN2@TableUpdat:
  0008a	8b 45 44	 mov	 eax, DWORD PTR column_n$1[rbp]
  0008d	ff c0		 inc	 eax
  0008f	89 45 44	 mov	 DWORD PTR column_n$1[rbp], eax
$LN4@TableUpdat:
  00092	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00099	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0009c	39 45 44	 cmp	 DWORD PTR column_n$1[rbp], eax
  0009f	0f 8d 94 00 00
	00		 jge	 $LN3@TableUpdat

; 2219 :     {
; 2220 :         ImGuiTableColumn* column = &table->Columns[column_n];

  000a5	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000ac	48 83 c0 18	 add	 rax, 24
  000b0	8b 55 44	 mov	 edx, DWORD PTR column_n$1[rbp]
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  000bb	48 89 45 68	 mov	 QWORD PTR column$2[rbp], rax

; 2221 :         if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))

  000bf	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  000c3	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0d		 je	 SHORT $LN9@TableUpdat
  000cb	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  000cf	8b 00		 mov	 eax, DWORD PTR [rax]
  000d1	83 e0 08	 and	 eax, 8
  000d4	85 c0		 test	 eax, eax
  000d6	75 02		 jne	 SHORT $LN8@TableUpdat
$LN9@TableUpdat:

; 2222 :             continue;

  000d8	eb b0		 jmp	 SHORT $LN2@TableUpdat
$LN8@TableUpdat:

; 2223 :         IM_ASSERT(column->StretchWeight > 0.0f);

  000da	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  000de	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  000e3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000ea	77 22		 ja	 SHORT $LN15@TableUpdat
  000ec	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  000f2	83 c0 0b	 add	 eax, 11
  000f5	44 8b c0	 mov	 r8d, eax
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@MOAONJGL@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAW?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0010c	33 c0		 xor	 eax, eax
$LN15@TableUpdat:

; 2224 :         visible_weight += column->StretchWeight;

  0010e	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  00112	f3 0f 10 45 04	 movss	 xmm0, DWORD PTR visible_weight$[rbp]
  00117	f3 0f 58 40 18	 addss	 xmm0, DWORD PTR [rax+24]
  0011c	f3 0f 11 45 04	 movss	 DWORD PTR visible_weight$[rbp], xmm0

; 2225 :         visible_width += column->WidthRequest;

  00121	48 8b 45 68	 mov	 rax, QWORD PTR column$2[rbp]
  00125	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR visible_width$[rbp]
  0012a	f3 0f 58 40 10	 addss	 xmm0, DWORD PTR [rax+16]
  0012f	f3 0f 11 45 24	 movss	 DWORD PTR visible_width$[rbp], xmm0

; 2226 :     }

  00134	e9 51 ff ff ff	 jmp	 $LN2@TableUpdat
$LN3@TableUpdat:

; 2227 :     IM_ASSERT(visible_weight > 0.0f && visible_width > 0.0f);

  00139	f3 0f 10 45 04	 movss	 xmm0, DWORD PTR visible_weight$[rbp]
  0013e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00145	76 0e		 jbe	 SHORT $LN16@TableUpdat
  00147	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR visible_width$[rbp]
  0014c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00153	77 22		 ja	 SHORT $LN17@TableUpdat
$LN16@TableUpdat:
  00155	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  0015b	83 c0 0f	 add	 eax, 15
  0015e	44 8b c0	 mov	 r8d, eax
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@OBNODAI@?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe?$AA_?$AAw?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe@
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00175	33 c0		 xor	 eax, eax
$LN17@TableUpdat:

; 2228 : 
; 2229 :     // Apply new weights
; 2230 :     for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  00177	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$3[rbp], 0
  00181	eb 0e		 jmp	 SHORT $LN7@TableUpdat
$LN5@TableUpdat:
  00183	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR column_n$3[rbp]
  00189	ff c0		 inc	 eax
  0018b	89 85 84 00 00
	00		 mov	 DWORD PTR column_n$3[rbp], eax
$LN7@TableUpdat:
  00191	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00198	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0019b	39 85 84 00 00
	00		 cmp	 DWORD PTR column_n$3[rbp], eax
  001a1	0f 8d 9f 00 00
	00		 jge	 $LN6@TableUpdat

; 2231 :     {
; 2232 :         ImGuiTableColumn* column = &table->Columns[column_n];

  001a7	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001ae	48 83 c0 18	 add	 rax, 24
  001b2	8b 95 84 00 00
	00		 mov	 edx, DWORD PTR column_n$3[rbp]
  001b8	48 8b c8	 mov	 rcx, rax
  001bb	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  001c0	48 89 85 a8 00
	00 00		 mov	 QWORD PTR column$4[rbp], rax

; 2233 :         if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))

  001c7	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR column$4[rbp]
  001ce	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  001d2	85 c0		 test	 eax, eax
  001d4	74 10		 je	 SHORT $LN11@TableUpdat
  001d6	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR column$4[rbp]
  001dd	8b 00		 mov	 eax, DWORD PTR [rax]
  001df	83 e0 08	 and	 eax, 8
  001e2	85 c0		 test	 eax, eax
  001e4	75 02		 jne	 SHORT $LN10@TableUpdat
$LN11@TableUpdat:

; 2234 :             continue;

  001e6	eb 9b		 jmp	 SHORT $LN5@TableUpdat
$LN10@TableUpdat:

; 2235 :         column->StretchWeight = (column->WidthRequest / visible_width) * visible_weight;

  001e8	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR column$4[rbp]
  001ef	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  001f4	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR visible_width$[rbp]
  001f9	f3 0f 59 45 04	 mulss	 xmm0, DWORD PTR visible_weight$[rbp]
  001fe	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR column$4[rbp]
  00205	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0

; 2236 :         IM_ASSERT(column->StretchWeight > 0.0f);

  0020a	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR column$4[rbp]
  00211	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  00216	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0021d	77 22		 ja	 SHORT $LN18@TableUpdat
  0021f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00225	83 c0 18	 add	 eax, 24
  00228	44 8b c0	 mov	 r8d, eax
  0022b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@MOAONJGL@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAW?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0023f	33 c0		 xor	 eax, eax
$LN18@TableUpdat:

; 2237 :     }

  00241	e9 3d ff ff ff	 jmp	 $LN5@TableUpdat
$LN6@TableUpdat:

; 2238 : }

  00246	48 8d a5 88 01
	00 00		 lea	 rsp, QWORD PTR [rbp+392]
  0024d	5f		 pop	 rdi
  0024e	5d		 pop	 rbp
  0024f	c3		 ret	 0
?TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z ENDP ; ImGui::TableUpdateColumnsWeightFromWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
g$ = 8
table_instance$ = 40
hit_half_width$ = 68
hit_y1$ = 100
hit_y2_body$ = 132
hit_y2_head$ = 164
order_n$6 = 196
column_n$7 = 228
column$8 = 264
border_y2_hit$9 = 292
column_id$10 = 324
hit_rect$11 = 360
hovered$12 = 404
held$13 = 436
pressed$14 = 468
tv211 = 676
tv149 = 676
tv223 = 680
__$ArrayPad$ = 688
table$ = 736
?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z PROC	; ImGui::TableUpdateBorders, COMDAT

; 1159 : {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 02
	00 00		 sub	 rsp, 760		; 000002f8H
  0000e	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 be 00 00 00	 mov	 ecx, 190		; 000000beH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR [rsp+792]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c5	 xor	 rax, rbp
  00034	48 89 85 b0 02
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 1160 :     ImGuiContext& g = *GImGui;

  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00042	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1161 :     IM_ASSERT(table->Flags & ImGuiTableFlags_Resizable);

  00046	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0004d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00050	83 e0 01	 and	 eax, 1
  00053	85 c0		 test	 eax, eax
  00055	75 22		 jne	 SHORT $LN16@TableUpdat
  00057	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  0005d	83 c0 02	 add	 eax, 2
  00060	44 8b c0	 mov	 r8d, eax
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@BMHMHKON@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAR@
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00077	33 c0		 xor	 eax, eax
$LN16@TableUpdat:

; 1162 : 
; 1163 :     // At this point OuterRect height may be zero or under actual final height, so we rely on temporal coherency and
; 1164 :     // use the final height from last frame. Because this is only affecting _interaction_ with columns, it is not
; 1165 :     // really problematic (whereas the actual visual will be displayed in EndTable() and using the current frame height).
; 1166 :     // Actual columns highlight/render will be performed in EndTable() and not be affected.
; 1167 :     ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);

  00079	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00080	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  00084	8b d0		 mov	 edx, eax
  00086	48 8b 8d e0 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0008d	e8 00 00 00 00	 call	 ?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z ; ImGui::TableGetInstanceData
  00092	48 89 45 28	 mov	 QWORD PTR table_instance$[rbp], rax

; 1168 :     const float hit_half_width = TABLE_RESIZE_SEPARATOR_HALF_THICKNESS;

  00096	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  0009e	f3 0f 11 45 44	 movss	 DWORD PTR hit_half_width$[rbp], xmm0

; 1169 :     const float hit_y1 = table->OuterRect.Min.y;

  000a3	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000aa	f3 0f 10 80 ec
	00 00 00	 movss	 xmm0, DWORD PTR [rax+236]
  000b2	f3 0f 11 45 64	 movss	 DWORD PTR hit_y1$[rbp], xmm0

; 1170 :     const float hit_y2_body = ImMax(table->OuterRect.Max.y, hit_y1 + table_instance->LastOuterHeight);

  000b7	48 8b 45 28	 mov	 rax, QWORD PTR table_instance$[rbp]
  000bb	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR hit_y1$[rbp]
  000c0	f3 0f 58 00	 addss	 xmm0, DWORD PTR [rax]
  000c4	0f 28 c8	 movaps	 xmm1, xmm0
  000c7	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000ce	f3 0f 10 80 f4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+244]
  000d6	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000db	f3 0f 11 85 84
	00 00 00	 movss	 DWORD PTR hit_y2_body$[rbp], xmm0

; 1171 :     const float hit_y2_head = hit_y1 + table_instance->LastFirstRowHeight;

  000e3	48 8b 45 28	 mov	 rax, QWORD PTR table_instance$[rbp]
  000e7	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR hit_y1$[rbp]
  000ec	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [rax+4]
  000f1	f3 0f 11 85 a4
	00 00 00	 movss	 DWORD PTR hit_y2_head$[rbp], xmm0

; 1172 : 
; 1173 :     for (int order_n = 0; order_n < table->ColumnsCount; order_n++)

  000f9	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR order_n$6[rbp], 0
  00103	eb 0e		 jmp	 SHORT $LN4@TableUpdat
$LN2@TableUpdat:
  00105	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR order_n$6[rbp]
  0010b	ff c0		 inc	 eax
  0010d	89 85 c4 00 00
	00		 mov	 DWORD PTR order_n$6[rbp], eax
$LN4@TableUpdat:
  00113	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0011a	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0011d	39 85 c4 00 00
	00		 cmp	 DWORD PTR order_n$6[rbp], eax
  00123	0f 8d 4a 03 00
	00		 jge	 $LN3@TableUpdat

; 1174 :     {
; 1175 :         if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))

  00129	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR order_n$6[rbp]
  0012f	c1 f8 05	 sar	 eax, 5
  00132	48 98		 cdqe
  00134	48 8b 8d e0 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0013b	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0013f	48 89 8d a8 02
	00 00		 mov	 QWORD PTR tv223[rbp], rcx
  00146	8b 95 c4 00 00
	00		 mov	 edx, DWORD PTR order_n$6[rbp]
  0014c	83 e2 1f	 and	 edx, 31
  0014f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00155	0f b6 ca	 movzx	 ecx, dl
  00158	41 8b d0	 mov	 edx, r8d
  0015b	d3 e2		 shl	 edx, cl
  0015d	8b ca		 mov	 ecx, edx
  0015f	48 8b 95 a8 02
	00 00		 mov	 rdx, QWORD PTR tv223[rbp]
  00166	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00169	23 c1		 and	 eax, ecx
  0016b	85 c0		 test	 eax, eax
  0016d	75 02		 jne	 SHORT $LN5@TableUpdat

; 1176 :             continue;

  0016f	eb 94		 jmp	 SHORT $LN2@TableUpdat
$LN5@TableUpdat:

; 1177 : 
; 1178 :         const int column_n = table->DisplayOrderToIndex[order_n];

  00171	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00178	48 83 c0 28	 add	 rax, 40			; 00000028H
  0017c	8b 95 c4 00 00
	00		 mov	 edx, DWORD PTR order_n$6[rbp]
  00182	48 8b c8	 mov	 rcx, rax
  00185	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  0018a	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0018d	89 85 e4 00 00
	00		 mov	 DWORD PTR column_n$7[rbp], eax

; 1179 :         ImGuiTableColumn* column = &table->Columns[column_n];

  00193	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0019a	48 83 c0 18	 add	 rax, 24
  0019e	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR column_n$7[rbp]
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  001ac	48 89 85 08 01
	00 00		 mov	 QWORD PTR column$8[rbp], rax

; 1180 :         if (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_))

  001b3	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  001ba	8b 00		 mov	 eax, DWORD PTR [rax]
  001bc	25 20 00 00 40	 and	 eax, 1073741856		; 40000020H
  001c1	85 c0		 test	 eax, eax
  001c3	74 05		 je	 SHORT $LN6@TableUpdat

; 1181 :             continue;

  001c5	e9 3b ff ff ff	 jmp	 $LN2@TableUpdat
$LN6@TableUpdat:

; 1182 : 
; 1183 :         // ImGuiTableFlags_NoBordersInBodyUntilResize will be honored in TableDrawBorders()
; 1184 :         const float border_y2_hit = (table->Flags & ImGuiTableFlags_NoBordersInBody) ? hit_y2_head : hit_y2_body;

  001ca	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001d4	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  001d9	85 c0		 test	 eax, eax
  001db	74 12		 je	 SHORT $LN17@TableUpdat
  001dd	f3 0f 10 85 a4
	00 00 00	 movss	 xmm0, DWORD PTR hit_y2_head$[rbp]
  001e5	f3 0f 11 85 a4
	02 00 00	 movss	 DWORD PTR tv149[rbp], xmm0
  001ed	eb 10		 jmp	 SHORT $LN18@TableUpdat
$LN17@TableUpdat:
  001ef	f3 0f 10 85 84
	00 00 00	 movss	 xmm0, DWORD PTR hit_y2_body$[rbp]
  001f7	f3 0f 11 85 a4
	02 00 00	 movss	 DWORD PTR tv149[rbp], xmm0
$LN18@TableUpdat:
  001ff	f3 0f 10 85 a4
	02 00 00	 movss	 xmm0, DWORD PTR tv149[rbp]
  00207	f3 0f 11 85 24
	01 00 00	 movss	 DWORD PTR border_y2_hit$9[rbp], xmm0

; 1185 :         if ((table->Flags & ImGuiTableFlags_NoBordersInBody) && table->IsUsingHeaders == false)

  0020f	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00216	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00219	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0021e	85 c0		 test	 eax, eax
  00220	74 17		 je	 SHORT $LN7@TableUpdat
  00222	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00229	0f b6 80 26 02
	00 00		 movzx	 eax, BYTE PTR [rax+550]
  00230	85 c0		 test	 eax, eax
  00232	75 05		 jne	 SHORT $LN7@TableUpdat

; 1186 :             continue;

  00234	e9 cc fe ff ff	 jmp	 $LN2@TableUpdat
$LN7@TableUpdat:

; 1187 : 
; 1188 :         if (!column->IsVisibleX && table->LastResizedColumn != column_n)

  00239	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00240	0f b6 40 65	 movzx	 eax, BYTE PTR [rax+101]
  00244	85 c0		 test	 eax, eax
  00246	75 1b		 jne	 SHORT $LN8@TableUpdat
  00248	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0024f	0f bf 80 00 02
	00 00		 movsx	 eax, WORD PTR [rax+512]
  00256	3b 85 e4 00 00
	00		 cmp	 eax, DWORD PTR column_n$7[rbp]
  0025c	74 05		 je	 SHORT $LN8@TableUpdat

; 1189 :             continue;

  0025e	e9 a2 fe ff ff	 jmp	 $LN2@TableUpdat
$LN8@TableUpdat:

; 1190 : 
; 1191 :         ImGuiID column_id = TableGetColumnResizeID(table, column_n, table->InstanceCurrent);

  00263	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0026a	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  0026e	44 8b c0	 mov	 r8d, eax
  00271	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR column_n$7[rbp]
  00277	48 8b 8d e0 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0027e	e8 00 00 00 00	 call	 ?TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z ; ImGui::TableGetColumnResizeID
  00283	89 85 44 01 00
	00		 mov	 DWORD PTR column_id$10[rbp], eax

; 1192 :         ImRect hit_rect(column->MaxX - hit_half_width, hit_y1, column->MaxX + hit_half_width, border_y2_hit);

  00289	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00290	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  00295	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40800000
  0029d	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  002a4	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [rax+12]
  002a9	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@40800000
  002b1	f3 0f 10 95 24
	01 00 00	 movss	 xmm2, DWORD PTR border_y2_hit$9[rbp]
  002b9	f3 0f 11 54 24
	20		 movss	 DWORD PTR [rsp+32], xmm2
  002bf	0f 28 d8	 movaps	 xmm3, xmm0
  002c2	f3 0f 10 55 64	 movss	 xmm2, DWORD PTR hit_y1$[rbp]
  002c7	48 8d 8d 68 01
	00 00		 lea	 rcx, QWORD PTR hit_rect$11[rbp]
  002ce	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@MMMM@Z	; ImRect::ImRect

; 1193 :         ItemAdd(hit_rect, column_id, NULL, ImGuiItemFlags_NoNav);

  002d3	41 b9 08 00 00
	00		 mov	 r9d, 8
  002d9	45 33 c0	 xor	 r8d, r8d
  002dc	8b 95 44 01 00
	00		 mov	 edx, DWORD PTR column_id$10[rbp]
  002e2	48 8d 8d 68 01
	00 00		 lea	 rcx, QWORD PTR hit_rect$11[rbp]
  002e9	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd

; 1194 :         //GetForegroundDrawList()->AddRect(hit_rect.Min, hit_rect.Max, IM_COL32(255, 0, 0, 100));
; 1195 : 
; 1196 :         bool hovered = false, held = false;

  002ee	c6 85 94 01 00
	00 00		 mov	 BYTE PTR hovered$12[rbp], 0
  002f5	c6 85 b4 01 00
	00 00		 mov	 BYTE PTR held$13[rbp], 0

; 1197 :         bool pressed = ButtonBehavior(hit_rect, column_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_NoNavFocus);

  002fc	c7 44 24 20 10
	19 04 00	 mov	 DWORD PTR [rsp+32], 268560 ; 00041910H
  00304	4c 8d 8d b4 01
	00 00		 lea	 r9, QWORD PTR held$13[rbp]
  0030b	4c 8d 85 94 01
	00 00		 lea	 r8, QWORD PTR hovered$12[rbp]
  00312	8b 95 44 01 00
	00		 mov	 edx, DWORD PTR column_id$10[rbp]
  00318	48 8d 8d 68 01
	00 00		 lea	 rcx, QWORD PTR hit_rect$11[rbp]
  0031f	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
  00324	88 85 d4 01 00
	00		 mov	 BYTE PTR pressed$14[rbp], al

; 1198 :         if (pressed && IsMouseDoubleClicked(0))

  0032a	0f b6 85 d4 01
	00 00		 movzx	 eax, BYTE PTR pressed$14[rbp]
  00331	85 c0		 test	 eax, eax
  00333	74 39		 je	 SHORT $LN9@TableUpdat
  00335	33 c9		 xor	 ecx, ecx
  00337	e8 00 00 00 00	 call	 ?IsMouseDoubleClicked@ImGui@@YA_NH@Z ; ImGui::IsMouseDoubleClicked
  0033c	0f b6 c0	 movzx	 eax, al
  0033f	85 c0		 test	 eax, eax
  00341	74 2b		 je	 SHORT $LN9@TableUpdat

; 1199 :         {
; 1200 :             TableSetColumnWidthAutoSingle(table, column_n);

  00343	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR column_n$7[rbp]
  00349	48 8b 8d e0 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00350	e8 00 00 00 00	 call	 ?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z ; ImGui::TableSetColumnWidthAutoSingle

; 1201 :             ClearActiveID();

  00355	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 1202 :             held = hovered = false;

  0035a	c6 85 94 01 00
	00 00		 mov	 BYTE PTR hovered$12[rbp], 0
  00361	0f b6 85 94 01
	00 00		 movzx	 eax, BYTE PTR hovered$12[rbp]
  00368	88 85 b4 01 00
	00		 mov	 BYTE PTR held$13[rbp], al
$LN9@TableUpdat:

; 1203 :         }
; 1204 :         if (held)

  0036e	0f b6 85 b4 01
	00 00		 movzx	 eax, BYTE PTR held$13[rbp]
  00375	85 c0		 test	 eax, eax
  00377	0f 84 a7 00 00
	00		 je	 $LN10@TableUpdat

; 1205 :         {
; 1206 :             if (table->LastResizedColumn == -1)

  0037d	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00384	0f bf 80 00 02
	00 00		 movsx	 eax, WORD PTR [rax+512]
  0038b	83 f8 ff	 cmp	 eax, -1
  0038e	75 69		 jne	 SHORT $LN11@TableUpdat

; 1207 :                 table->ResizeLockMinContentsX2 = table->RightMostEnabledColumn != -1 ? table->Columns[table->RightMostEnabledColumn].MaxX : -FLT_MAX;

  00390	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00397	0f bf 80 0a 02
	00 00		 movsx	 eax, WORD PTR [rax+522]
  0039e	83 f8 ff	 cmp	 eax, -1
  003a1	74 2f		 je	 SHORT $LN19@TableUpdat
  003a3	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003aa	0f bf 80 0a 02
	00 00		 movsx	 eax, WORD PTR [rax+522]
  003b1	48 8b 8d e0 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  003b8	48 83 c1 18	 add	 rcx, 24
  003bc	8b d0		 mov	 edx, eax
  003be	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  003c3	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  003c8	f3 0f 11 85 a4
	02 00 00	 movss	 DWORD PTR tv211[rbp], xmm0
  003d0	eb 10		 jmp	 SHORT $LN20@TableUpdat
$LN19@TableUpdat:
  003d2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ff7fffff
  003da	f3 0f 11 85 a4
	02 00 00	 movss	 DWORD PTR tv211[rbp], xmm0
$LN20@TableUpdat:
  003e2	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003e9	f3 0f 10 85 a4
	02 00 00	 movss	 xmm0, DWORD PTR tv211[rbp]
  003f1	f3 0f 11 80 e0
	00 00 00	 movss	 DWORD PTR [rax+224], xmm0
$LN11@TableUpdat:

; 1208 :             table->ResizedColumn = (ImGuiTableColumnIdx)column_n;

  003f9	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00400	0f b7 8d e4 00
	00 00		 movzx	 ecx, WORD PTR column_n$7[rbp]
  00407	66 89 88 fe 01
	00 00		 mov	 WORD PTR [rax+510], cx

; 1209 :             table->InstanceInteracted = table->InstanceCurrent;

  0040e	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00415	48 8b 8d e0 02
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0041c	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  00420	66 89 48 7a	 mov	 WORD PTR [rax+122], cx
$LN10@TableUpdat:

; 1210 :         }
; 1211 :         if ((hovered && g.HoveredIdTimer > TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER) || held)

  00424	0f b6 85 94 01
	00 00		 movzx	 eax, BYTE PTR hovered$12[rbp]
  0042b	85 c0		 test	 eax, eax
  0042d	74 15		 je	 SHORT $LN14@TableUpdat
  0042f	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00433	f3 0f 10 80 f8
	3e 00 00	 movss	 xmm0, DWORD PTR [rax+16120]
  0043b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3d75c28f
  00442	77 0b		 ja	 SHORT $LN13@TableUpdat
$LN14@TableUpdat:
  00444	0f b6 85 b4 01
	00 00		 movzx	 eax, BYTE PTR held$13[rbp]
  0044b	85 c0		 test	 eax, eax
  0044d	74 1f		 je	 SHORT $LN12@TableUpdat
$LN13@TableUpdat:

; 1212 :         {
; 1213 :             table->HoveredColumnBorder = (ImGuiTableColumnIdx)column_n;

  0044f	48 8b 85 e0 02
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00456	0f b7 8d e4 00
	00 00		 movzx	 ecx, WORD PTR column_n$7[rbp]
  0045d	66 89 88 fa 01
	00 00		 mov	 WORD PTR [rax+506], cx

; 1214 :             SetMouseCursor(ImGuiMouseCursor_ResizeEW);

  00464	b9 04 00 00 00	 mov	 ecx, 4
  00469	e8 00 00 00 00	 call	 ?SetMouseCursor@ImGui@@YAXH@Z ; ImGui::SetMouseCursor
$LN12@TableUpdat:

; 1215 :         }
; 1216 :     }

  0046e	e9 92 fc ff ff	 jmp	 $LN2@TableUpdat
$LN3@TableUpdat:

; 1217 : }

  00473	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  00477	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData
  0047e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00483	48 8b 8d b0 02
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0048a	48 33 cd	 xor	 rcx, rbp
  0048d	e8 00 00 00 00	 call	 __security_check_cookie
  00492	48 8d a5 c8 02
	00 00		 lea	 rsp, QWORD PTR [rbp+712]
  00499	5f		 pop	 rdi
  0049a	5d		 pop	 rbp
  0049b	c3		 ret	 0
?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z ENDP	; ImGui::TableUpdateBorders
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
g$ = 8
table_sizing_policy$ = 36
count_fixed$ = 68
count_stretch$ = 100
prev_visible_column_idx$ = 132
has_auto_fit_request$ = 164
has_resizable$ = 196
stretch_sum_width_auto$ = 228
fixed_max_width_auto$ = 260
order_n$6 = 292
column_n$7 = 324
column$8 = 360
start_auto_fit$9 = 388
column_is_resizable$10 = 420
sum_width_requests$ = 452
stretch_sum_weights$ = 484
column_n$11 = 516
column$12 = 552
column_is_resizable$13 = 580
width_auto$14 = 612
work_rect$ = 648
width_spacings$ = 692
width_removed$ = 724
width_avail$ = 756
width_avail_for_stretched_columns$ = 788
width_remaining_for_stretched_columns$ = 820
column_n$15 = 852
column$16 = 888
weight_ratio$17 = 916
order_n$18 = 948
column$19 = 984
table_instance$ = 1016
mouse_hit_rect$ = 1048
backup_active_id$ = 1092
is_hovering_table$ = 1124
visible_n$ = 1156
offset_x_frozen$ = 1188
offset_x$ = 1220
host_clip_rect$ = 1256
order_n$20 = 1300
column_n$21 = 1332
column$22 = 1368
max_width$23 = 1396
is_visible$24 = 1428
unused_x1$ = 1460
inner_window$ = 1496
tv835 = 2084
tv826 = 2084
tv808 = 2084
tv672 = 2084
tv645 = 2084
tv637 = 2084
tv458 = 2084
tv446 = 2084
tv326 = 2084
tv247 = 2084
tv193 = 2084
tv170 = 2084
tv1048 = 2088
tv1046 = 2088
tv1044 = 2088
tv1043 = 2088
tv195 = 2088
tv192 = 2092
__$ArrayPad$ = 2096
table$ = 2144
?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z PROC	; ImGui::TableUpdateLayout, COMDAT

; 731  : {

$LN118:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 81 ec 70 08
	00 00		 sub	 rsp, 2160		; 00000870H
  0000f	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 1c 02 00 00	 mov	 ecx, 540		; 0000021cH
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 98
	08 00 00	 mov	 rcx, QWORD PTR [rsp+2200]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c5	 xor	 rax, rbp
  00035	48 89 85 30 08
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 732  :     ImGuiContext& g = *GImGui;

  0003c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00043	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 733  :     IM_ASSERT(table->IsLayoutLocked == false);

  00047	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0004e	0f b6 80 22 02
	00 00		 movzx	 eax, BYTE PTR [rax+546]
  00055	85 c0		 test	 eax, eax
  00057	74 22		 je	 SHORT $LN85@TableUpdat
  00059	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  0005f	83 c0 02	 add	 eax, 2
  00062	44 8b c0	 mov	 r8d, eax
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@DEAGPPGG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00079	33 c0		 xor	 eax, eax
$LN85@TableUpdat:

; 734  : 
; 735  :     const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);

  0007b	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00082	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00085	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  0008a	89 45 24	 mov	 DWORD PTR table_sizing_policy$[rbp], eax

; 736  :     table->IsDefaultDisplayOrder = true;

  0008d	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00094	c6 80 2a 02 00
	00 01		 mov	 BYTE PTR [rax+554], 1

; 737  :     table->ColumnsEnabledCount = 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000a4	66 89 81 f2 01
	00 00		 mov	 WORD PTR [rcx+498], ax

; 738  :     ImBitArrayClearAllBits(table->EnabledMaskByIndex, table->ColumnsCount);

  000ab	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000b2	8b 50 6c	 mov	 edx, DWORD PTR [rax+108]
  000b5	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000bc	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  000c0	e8 00 00 00 00	 call	 ?ImBitArrayClearAllBits@@YAXPEAIH@Z ; ImBitArrayClearAllBits

; 739  :     ImBitArrayClearAllBits(table->EnabledMaskByDisplayOrder, table->ColumnsCount);

  000c5	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000cc	8b 50 6c	 mov	 edx, DWORD PTR [rax+108]
  000cf	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000d6	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  000da	e8 00 00 00 00	 call	 ?ImBitArrayClearAllBits@@YAXPEAIH@Z ; ImBitArrayClearAllBits

; 740  :     table->LeftMostEnabledColumn = -1;

  000df	b8 ff ff ff ff	 mov	 eax, -1
  000e4	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000eb	66 89 81 08 02
	00 00		 mov	 WORD PTR [rcx+520], ax

; 741  :     table->MinColumnWidth = ImMax(1.0f, g.Style.FramePadding.x * 1.0f); // g.Style.ColumnsMinSpacing; // FIXME-TABLE

  000f2	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  000f6	f3 0f 10 80 1c
	38 00 00	 movss	 xmm0, DWORD PTR [rax+14364]
  000fe	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  00106	0f 28 c8	 movaps	 xmm1, xmm0
  00109	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00111	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00116	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0011d	f3 0f 11 80 b4
	00 00 00	 movss	 DWORD PTR [rax+180], xmm0

; 742  : 
; 743  :     // [Part 1] Apply/lock Enabled and Order states. Calculate auto/ideal width for columns. Count fixed/stretch columns.
; 744  :     // Process columns in their visible orders as we are building the Prev/Next indices.
; 745  :     int count_fixed = 0;                // Number of columns that have fixed sizing policies

  00125	c7 45 44 00 00
	00 00		 mov	 DWORD PTR count_fixed$[rbp], 0

; 746  :     int count_stretch = 0;              // Number of columns that have stretch sizing policies

  0012c	c7 45 64 00 00
	00 00		 mov	 DWORD PTR count_stretch$[rbp], 0

; 747  :     int prev_visible_column_idx = -1;

  00133	c7 85 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR prev_visible_column_idx$[rbp], -1

; 748  :     bool has_auto_fit_request = false;

  0013d	c6 85 a4 00 00
	00 00		 mov	 BYTE PTR has_auto_fit_request$[rbp], 0

; 749  :     bool has_resizable = false;

  00144	c6 85 c4 00 00
	00 00		 mov	 BYTE PTR has_resizable$[rbp], 0

; 750  :     float stretch_sum_width_auto = 0.0f;

  0014b	0f 57 c0	 xorps	 xmm0, xmm0
  0014e	f3 0f 11 85 e4
	00 00 00	 movss	 DWORD PTR stretch_sum_width_auto$[rbp], xmm0

; 751  :     float fixed_max_width_auto = 0.0f;

  00156	0f 57 c0	 xorps	 xmm0, xmm0
  00159	f3 0f 11 85 04
	01 00 00	 movss	 DWORD PTR fixed_max_width_auto$[rbp], xmm0

; 752  :     for (int order_n = 0; order_n < table->ColumnsCount; order_n++)

  00161	c7 85 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR order_n$6[rbp], 0
  0016b	eb 0e		 jmp	 SHORT $LN4@TableUpdat
$LN2@TableUpdat:
  0016d	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR order_n$6[rbp]
  00173	ff c0		 inc	 eax
  00175	89 85 24 01 00
	00		 mov	 DWORD PTR order_n$6[rbp], eax
$LN4@TableUpdat:
  0017b	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00182	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00185	39 85 24 01 00
	00		 cmp	 DWORD PTR order_n$6[rbp], eax
  0018b	0f 8d da 04 00
	00		 jge	 $LN3@TableUpdat

; 753  :     {
; 754  :         const int column_n = table->DisplayOrderToIndex[order_n];

  00191	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00198	48 83 c0 28	 add	 rax, 40			; 00000028H
  0019c	8b 95 24 01 00
	00		 mov	 edx, DWORD PTR order_n$6[rbp]
  001a2	48 8b c8	 mov	 rcx, rax
  001a5	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  001aa	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001ad	89 85 44 01 00
	00		 mov	 DWORD PTR column_n$7[rbp], eax

; 755  :         if (column_n != order_n)

  001b3	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR order_n$6[rbp]
  001b9	39 85 44 01 00
	00		 cmp	 DWORD PTR column_n$7[rbp], eax
  001bf	74 0e		 je	 SHORT $LN17@TableUpdat

; 756  :             table->IsDefaultDisplayOrder = false;

  001c1	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001c8	c6 80 2a 02 00
	00 00		 mov	 BYTE PTR [rax+554], 0
$LN17@TableUpdat:

; 757  :         ImGuiTableColumn* column = &table->Columns[column_n];

  001cf	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001d6	48 83 c0 18	 add	 rax, 24
  001da	8b 95 44 01 00
	00		 mov	 edx, DWORD PTR column_n$7[rbp]
  001e0	48 8b c8	 mov	 rcx, rax
  001e3	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  001e8	48 89 85 68 01
	00 00		 mov	 QWORD PTR column$8[rbp], rax

; 758  : 
; 759  :         // Clear column setup if not submitted by user. Currently we make it mandatory to call TableSetupColumn() every frame.
; 760  :         // It would easily work without but we're not ready to guarantee it since e.g. names need resubmission anyway.
; 761  :         // We take a slight shortcut but in theory we could be calling TableSetupColumn() here with dummy values, it should yield the same effect.
; 762  :         if (table->DeclColumnsCount <= column_n)

  001ef	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001f6	0f bf 80 f6 01
	00 00		 movsx	 eax, WORD PTR [rax+502]
  001fd	3b 85 44 01 00
	00		 cmp	 eax, DWORD PTR column_n$7[rbp]
  00203	7f 48		 jg	 SHORT $LN18@TableUpdat

; 763  :         {
; 764  :             TableSetupColumnFlags(table, column, ImGuiTableColumnFlags_None);

  00205	45 33 c0	 xor	 r8d, r8d
  00208	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR column$8[rbp]
  0020f	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00216	e8 00 00 00 00	 call	 ?TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z ; TableSetupColumnFlags

; 765  :             column->NameOffset = -1;

  0021b	b8 ff ff ff ff	 mov	 eax, -1
  00220	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR column$8[rbp]
  00227	66 89 41 50	 mov	 WORD PTR [rcx+80], ax

; 766  :             column->UserID = 0;

  0022b	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00232	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 767  :             column->InitStretchWeightOrWidth = -1.0f;

  00239	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00240	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00248	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0
$LN18@TableUpdat:

; 768  :         }
; 769  : 
; 770  :         // Update Enabled state, mark settings and sort specs dirty
; 771  :         if (!(table->Flags & ImGuiTableFlags_Hideable) || (column->Flags & ImGuiTableColumnFlags_NoHide))

  0024d	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00254	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00257	83 e0 04	 and	 eax, 4
  0025a	85 c0		 test	 eax, eax
  0025c	74 12		 je	 SHORT $LN20@TableUpdat
  0025e	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00265	8b 00		 mov	 eax, DWORD PTR [rax]
  00267	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0026c	85 c0		 test	 eax, eax
  0026e	74 0b		 je	 SHORT $LN19@TableUpdat
$LN20@TableUpdat:

; 772  :             column->IsUserEnabledNextFrame = true;

  00270	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00277	c6 40 64 01	 mov	 BYTE PTR [rax+100], 1
$LN19@TableUpdat:

; 773  :         if (column->IsUserEnabled != column->IsUserEnabledNextFrame)

  0027b	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00282	0f b6 40 63	 movzx	 eax, BYTE PTR [rax+99]
  00286	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR column$8[rbp]
  0028d	0f b6 49 64	 movzx	 ecx, BYTE PTR [rcx+100]
  00291	3b c1		 cmp	 eax, ecx
  00293	74 23		 je	 SHORT $LN21@TableUpdat

; 774  :         {
; 775  :             column->IsUserEnabled = column->IsUserEnabledNextFrame;

  00295	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  0029c	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR column$8[rbp]
  002a3	0f b6 49 64	 movzx	 ecx, BYTE PTR [rcx+100]
  002a7	88 48 63	 mov	 BYTE PTR [rax+99], cl

; 776  :             table->IsSettingsDirty = true;

  002aa	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002b1	c6 80 29 02 00
	00 01		 mov	 BYTE PTR [rax+553], 1
$LN21@TableUpdat:

; 777  :         }
; 778  :         column->IsEnabled = column->IsUserEnabled && (column->Flags & ImGuiTableColumnFlags_Disabled) == 0;

  002b8	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  002bf	0f b6 40 63	 movzx	 eax, BYTE PTR [rax+99]
  002c3	85 c0		 test	 eax, eax
  002c5	74 1c		 je	 SHORT $LN86@TableUpdat
  002c7	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  002ce	8b 00		 mov	 eax, DWORD PTR [rax]
  002d0	83 e0 01	 and	 eax, 1
  002d3	85 c0		 test	 eax, eax
  002d5	75 0c		 jne	 SHORT $LN86@TableUpdat
  002d7	c7 85 24 08 00
	00 01 00 00 00	 mov	 DWORD PTR tv170[rbp], 1
  002e1	eb 0a		 jmp	 SHORT $LN87@TableUpdat
$LN86@TableUpdat:
  002e3	c7 85 24 08 00
	00 00 00 00 00	 mov	 DWORD PTR tv170[rbp], 0
$LN87@TableUpdat:
  002ed	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  002f4	0f b6 8d 24 08
	00 00		 movzx	 ecx, BYTE PTR tv170[rbp]
  002fb	88 48 62	 mov	 BYTE PTR [rax+98], cl

; 779  : 
; 780  :         if (column->SortOrder != -1 && !column->IsEnabled)

  002fe	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00305	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  00309	83 f8 ff	 cmp	 eax, -1
  0030c	74 1d		 je	 SHORT $LN22@TableUpdat
  0030e	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00315	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  00319	85 c0		 test	 eax, eax
  0031b	75 0e		 jne	 SHORT $LN22@TableUpdat

; 781  :             table->IsSortSpecsDirty = true;

  0031d	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00324	c6 80 25 02 00
	00 01		 mov	 BYTE PTR [rax+549], 1
$LN22@TableUpdat:

; 782  :         if (column->SortOrder > 0 && !(table->Flags & ImGuiTableFlags_SortMulti))

  0032b	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00332	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  00336	85 c0		 test	 eax, eax
  00338	7e 21		 jle	 SHORT $LN23@TableUpdat
  0033a	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00341	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00344	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00349	85 c0		 test	 eax, eax
  0034b	75 0e		 jne	 SHORT $LN23@TableUpdat

; 783  :             table->IsSortSpecsDirty = true;

  0034d	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00354	c6 80 25 02 00
	00 01		 mov	 BYTE PTR [rax+549], 1
$LN23@TableUpdat:

; 784  : 
; 785  :         // Auto-fit unsized columns
; 786  :         const bool start_auto_fit = (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? (column->WidthRequest < 0.0f) : (column->StretchWeight < 0.0f);

  0035b	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00362	8b 00		 mov	 eax, DWORD PTR [rax]
  00364	83 e0 10	 and	 eax, 16
  00367	85 c0		 test	 eax, eax
  00369	74 34		 je	 SHORT $LN92@TableUpdat
  0036b	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00372	0f 57 c0	 xorps	 xmm0, xmm0
  00375	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [rax+16]
  00379	76 0c		 jbe	 SHORT $LN90@TableUpdat
  0037b	c7 85 24 08 00
	00 01 00 00 00	 mov	 DWORD PTR tv193[rbp], 1
  00385	eb 0a		 jmp	 SHORT $LN91@TableUpdat
$LN90@TableUpdat:
  00387	c7 85 24 08 00
	00 00 00 00 00	 mov	 DWORD PTR tv193[rbp], 0
$LN91@TableUpdat:
  00391	8b 85 24 08 00
	00		 mov	 eax, DWORD PTR tv193[rbp]
  00397	89 85 28 08 00
	00		 mov	 DWORD PTR tv195[rbp], eax
  0039d	eb 32		 jmp	 SHORT $LN93@TableUpdat
$LN92@TableUpdat:
  0039f	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  003a6	0f 57 c0	 xorps	 xmm0, xmm0
  003a9	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [rax+24]
  003ad	76 0c		 jbe	 SHORT $LN88@TableUpdat
  003af	c7 85 2c 08 00
	00 01 00 00 00	 mov	 DWORD PTR tv192[rbp], 1
  003b9	eb 0a		 jmp	 SHORT $LN89@TableUpdat
$LN88@TableUpdat:
  003bb	c7 85 2c 08 00
	00 00 00 00 00	 mov	 DWORD PTR tv192[rbp], 0
$LN89@TableUpdat:
  003c5	8b 85 2c 08 00
	00		 mov	 eax, DWORD PTR tv192[rbp]
  003cb	89 85 28 08 00
	00		 mov	 DWORD PTR tv195[rbp], eax
$LN93@TableUpdat:
  003d1	0f b6 85 28 08
	00 00		 movzx	 eax, BYTE PTR tv195[rbp]
  003d8	88 85 84 01 00
	00		 mov	 BYTE PTR start_auto_fit$9[rbp], al

; 787  :         if (start_auto_fit)

  003de	0f b6 85 84 01
	00 00		 movzx	 eax, BYTE PTR start_auto_fit$9[rbp]
  003e5	85 c0		 test	 eax, eax
  003e7	74 16		 je	 SHORT $LN24@TableUpdat

; 788  :             column->AutoFitQueue = column->CannotSkipItemsQueue = (1 << 3) - 1; // Fit for three frames

  003e9	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  003f0	c6 40 6c 07	 mov	 BYTE PTR [rax+108], 7
  003f4	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  003fb	c6 40 6b 07	 mov	 BYTE PTR [rax+107], 7
$LN24@TableUpdat:

; 789  : 
; 790  :         if (!column->IsEnabled)

  003ff	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00406	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  0040a	85 c0		 test	 eax, eax
  0040c	75 15		 jne	 SHORT $LN25@TableUpdat

; 791  :         {
; 792  :             column->IndexWithinEnabledSet = -1;

  0040e	b8 ff ff ff ff	 mov	 eax, -1
  00413	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR column$8[rbp]
  0041a	66 89 41 54	 mov	 WORD PTR [rcx+84], ax

; 793  :             continue;

  0041e	e9 4a fd ff ff	 jmp	 $LN2@TableUpdat
$LN25@TableUpdat:

; 794  :         }
; 795  : 
; 796  :         // Mark as enabled and link to previous/next enabled column
; 797  :         column->PrevEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;

  00423	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  0042a	0f b7 8d 84 00
	00 00		 movzx	 ecx, WORD PTR prev_visible_column_idx$[rbp]
  00431	66 89 48 56	 mov	 WORD PTR [rax+86], cx

; 798  :         column->NextEnabledColumn = -1;

  00435	b8 ff ff ff ff	 mov	 eax, -1
  0043a	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR column$8[rbp]
  00441	66 89 41 58	 mov	 WORD PTR [rcx+88], ax

; 799  :         if (prev_visible_column_idx != -1)

  00445	83 bd 84 00 00
	00 ff		 cmp	 DWORD PTR prev_visible_column_idx$[rbp], -1
  0044c	74 26		 je	 SHORT $LN26@TableUpdat

; 800  :             table->Columns[prev_visible_column_idx].NextEnabledColumn = (ImGuiTableColumnIdx)column_n;

  0044e	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00455	48 83 c0 18	 add	 rax, 24
  00459	8b 95 84 00 00
	00		 mov	 edx, DWORD PTR prev_visible_column_idx$[rbp]
  0045f	48 8b c8	 mov	 rcx, rax
  00462	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00467	0f b7 8d 44 01
	00 00		 movzx	 ecx, WORD PTR column_n$7[rbp]
  0046e	66 89 48 58	 mov	 WORD PTR [rax+88], cx

; 801  :         else

  00472	eb 15		 jmp	 SHORT $LN27@TableUpdat
$LN26@TableUpdat:

; 802  :             table->LeftMostEnabledColumn = (ImGuiTableColumnIdx)column_n;

  00474	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0047b	0f b7 8d 44 01
	00 00		 movzx	 ecx, WORD PTR column_n$7[rbp]
  00482	66 89 88 08 02
	00 00		 mov	 WORD PTR [rax+520], cx
$LN27@TableUpdat:

; 803  :         column->IndexWithinEnabledSet = table->ColumnsEnabledCount++;

  00489	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00490	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00497	0f b7 89 f2 01
	00 00		 movzx	 ecx, WORD PTR [rcx+498]
  0049e	66 89 48 54	 mov	 WORD PTR [rax+84], cx
  004a2	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004a9	0f b7 80 f2 01
	00 00		 movzx	 eax, WORD PTR [rax+498]
  004b0	66 ff c0	 inc	 ax
  004b3	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  004ba	66 89 81 f2 01
	00 00		 mov	 WORD PTR [rcx+498], ax

; 804  :         ImBitArraySetBit(table->EnabledMaskByIndex, column_n);

  004c1	8b 95 44 01 00
	00		 mov	 edx, DWORD PTR column_n$7[rbp]
  004c7	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004ce	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  004d2	e8 00 00 00 00	 call	 ?ImBitArraySetBit@@YAXPEAIH@Z ; ImBitArraySetBit

; 805  :         ImBitArraySetBit(table->EnabledMaskByDisplayOrder, column->DisplayOrder);

  004d7	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  004de	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  004e2	8b d0		 mov	 edx, eax
  004e4	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004eb	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  004ef	e8 00 00 00 00	 call	 ?ImBitArraySetBit@@YAXPEAIH@Z ; ImBitArraySetBit

; 806  :         prev_visible_column_idx = column_n;

  004f4	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR column_n$7[rbp]
  004fa	89 85 84 00 00
	00		 mov	 DWORD PTR prev_visible_column_idx$[rbp], eax

; 807  :         IM_ASSERT(column->IndexWithinEnabledSet <= column->DisplayOrder);

  00500	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00507	0f bf 40 54	 movsx	 eax, WORD PTR [rax+84]
  0050b	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR column$8[rbp]
  00512	0f bf 49 52	 movsx	 ecx, WORD PTR [rcx+82]
  00516	3b c1		 cmp	 eax, ecx
  00518	7e 22		 jle	 SHORT $LN94@TableUpdat
  0051a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00520	83 c0 4c	 add	 eax, 76			; 0000004cH
  00523	44 8b c0	 mov	 r8d, eax
  00526	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0052d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GM@PGNFGMB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAI?$AAn?$AAd?$AAe?$AAx?$AAW?$AAi?$AAt?$AAh?$AAi?$AAn?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAS?$AAe?$AAt?$AA?5?$AA?$DM?$AA?$DN@
  00534	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0053a	33 c0		 xor	 eax, eax
$LN94@TableUpdat:

; 808  : 
; 809  :         // Calculate ideal/auto column width (that's the width required for all contents to be visible without clipping)
; 810  :         // Combine width from regular rows + width from headers unless requested not to.
; 811  :         if (!column->IsPreserveWidthAuto)

  0053c	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00543	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00547	85 c0		 test	 eax, eax
  00549	75 1f		 jne	 SHORT $LN28@TableUpdat

; 812  :             column->WidthAuto = TableGetColumnWidthAuto(table, column);

  0054b	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR column$8[rbp]
  00552	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00559	e8 00 00 00 00	 call	 ?TableGetColumnWidthAuto@ImGui@@YAMPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z ; ImGui::TableGetColumnWidthAuto
  0055e	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00565	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0
$LN28@TableUpdat:

; 813  : 
; 814  :         // Non-resizable columns keep their requested width (apply user value regardless of IsPreserveWidthAuto)
; 815  :         const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;

  0056a	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00571	8b 00		 mov	 eax, DWORD PTR [rax]
  00573	83 e0 20	 and	 eax, 32			; 00000020H
  00576	85 c0		 test	 eax, eax
  00578	75 09		 jne	 SHORT $LN95@TableUpdat
  0057a	c6 85 24 08 00
	00 01		 mov	 BYTE PTR tv247[rbp], 1
  00581	eb 07		 jmp	 SHORT $LN96@TableUpdat
$LN95@TableUpdat:
  00583	c6 85 24 08 00
	00 00		 mov	 BYTE PTR tv247[rbp], 0
$LN96@TableUpdat:
  0058a	0f b6 85 24 08
	00 00		 movzx	 eax, BYTE PTR tv247[rbp]
  00591	88 85 a4 01 00
	00		 mov	 BYTE PTR column_is_resizable$10[rbp], al

; 816  :         if (column_is_resizable)

  00597	0f b6 85 a4 01
	00 00		 movzx	 eax, BYTE PTR column_is_resizable$10[rbp]
  0059e	85 c0		 test	 eax, eax
  005a0	74 07		 je	 SHORT $LN29@TableUpdat

; 817  :             has_resizable = true;

  005a2	c6 85 c4 00 00
	00 01		 mov	 BYTE PTR has_resizable$[rbp], 1
$LN29@TableUpdat:

; 818  :         if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f && !column_is_resizable)

  005a9	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  005b0	8b 00		 mov	 eax, DWORD PTR [rax]
  005b2	83 e0 10	 and	 eax, 16
  005b5	85 c0		 test	 eax, eax
  005b7	74 38		 je	 SHORT $LN30@TableUpdat
  005b9	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  005c0	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  005c5	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  005cc	76 23		 jbe	 SHORT $LN30@TableUpdat
  005ce	0f b6 85 a4 01
	00 00		 movzx	 eax, BYTE PTR column_is_resizable$10[rbp]
  005d5	85 c0		 test	 eax, eax
  005d7	75 18		 jne	 SHORT $LN30@TableUpdat

; 819  :             column->WidthAuto = column->InitStretchWeightOrWidth;

  005d9	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  005e0	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR column$8[rbp]
  005e7	f3 0f 10 41 1c	 movss	 xmm0, DWORD PTR [rcx+28]
  005ec	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0
$LN30@TableUpdat:

; 820  : 
; 821  :         if (column->AutoFitQueue != 0x00)

  005f1	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  005f8	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  005fc	85 c0		 test	 eax, eax
  005fe	74 07		 je	 SHORT $LN31@TableUpdat

; 822  :             has_auto_fit_request = true;

  00600	c6 85 a4 00 00
	00 01		 mov	 BYTE PTR has_auto_fit_request$[rbp], 1
$LN31@TableUpdat:

; 823  :         if (column->Flags & ImGuiTableColumnFlags_WidthStretch)

  00607	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  0060e	8b 00		 mov	 eax, DWORD PTR [rax]
  00610	83 e0 08	 and	 eax, 8
  00613	85 c0		 test	 eax, eax
  00615	74 26		 je	 SHORT $LN32@TableUpdat

; 824  :         {
; 825  :             stretch_sum_width_auto += column->WidthAuto;

  00617	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  0061e	f3 0f 10 85 e4
	00 00 00	 movss	 xmm0, DWORD PTR stretch_sum_width_auto$[rbp]
  00626	f3 0f 58 40 14	 addss	 xmm0, DWORD PTR [rax+20]
  0062b	f3 0f 11 85 e4
	00 00 00	 movss	 DWORD PTR stretch_sum_width_auto$[rbp], xmm0

; 826  :             count_stretch++;

  00633	8b 45 64	 mov	 eax, DWORD PTR count_stretch$[rbp]
  00636	ff c0		 inc	 eax
  00638	89 45 64	 mov	 DWORD PTR count_stretch$[rbp], eax

; 827  :         }
; 828  :         else

  0063b	eb 29		 jmp	 SHORT $LN33@TableUpdat
$LN32@TableUpdat:

; 829  :         {
; 830  :             fixed_max_width_auto = ImMax(fixed_max_width_auto, column->WidthAuto);

  0063d	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR column$8[rbp]
  00644	f3 0f 10 48 14	 movss	 xmm1, DWORD PTR [rax+20]
  00649	f3 0f 10 85 04
	01 00 00	 movss	 xmm0, DWORD PTR fixed_max_width_auto$[rbp]
  00651	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00656	f3 0f 11 85 04
	01 00 00	 movss	 DWORD PTR fixed_max_width_auto$[rbp], xmm0

; 831  :             count_fixed++;

  0065e	8b 45 44	 mov	 eax, DWORD PTR count_fixed$[rbp]
  00661	ff c0		 inc	 eax
  00663	89 45 44	 mov	 DWORD PTR count_fixed$[rbp], eax
$LN33@TableUpdat:

; 832  :         }
; 833  :     }

  00666	e9 02 fb ff ff	 jmp	 $LN2@TableUpdat
$LN3@TableUpdat:

; 834  :     if ((table->Flags & ImGuiTableFlags_Sortable) && table->SortSpecsCount == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))

  0066b	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00672	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00675	83 e0 08	 and	 eax, 8
  00678	85 c0		 test	 eax, eax
  0067a	74 33		 je	 SHORT $LN34@TableUpdat
  0067c	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00683	0f bf 80 f0 01
	00 00		 movsx	 eax, WORD PTR [rax+496]
  0068a	85 c0		 test	 eax, eax
  0068c	75 21		 jne	 SHORT $LN34@TableUpdat
  0068e	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00695	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00698	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0069d	85 c0		 test	 eax, eax
  0069f	75 0e		 jne	 SHORT $LN34@TableUpdat

; 835  :         table->IsSortSpecsDirty = true;

  006a1	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  006a8	c6 80 25 02 00
	00 01		 mov	 BYTE PTR [rax+549], 1
$LN34@TableUpdat:

; 836  :     table->RightMostEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;

  006af	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  006b6	0f b7 8d 84 00
	00 00		 movzx	 ecx, WORD PTR prev_visible_column_idx$[rbp]
  006bd	66 89 88 0a 02
	00 00		 mov	 WORD PTR [rax+522], cx

; 837  :     IM_ASSERT(table->LeftMostEnabledColumn >= 0 && table->RightMostEnabledColumn >= 0);

  006c4	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  006cb	0f bf 80 08 02
	00 00		 movsx	 eax, WORD PTR [rax+520]
  006d2	85 c0		 test	 eax, eax
  006d4	7c 12		 jl	 SHORT $LN97@TableUpdat
  006d6	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  006dd	0f bf 80 0a 02
	00 00		 movsx	 eax, WORD PTR [rax+522]
  006e4	85 c0		 test	 eax, eax
  006e6	7d 22		 jge	 SHORT $LN98@TableUpdat
$LN97@TableUpdat:
  006e8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  006ee	83 c0 6a	 add	 eax, 106		; 0000006aH
  006f1	44 8b c0	 mov	 r8d, eax
  006f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  006fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JA@JKJMNFJF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAL?$AAe?$AAf?$AAt?$AAM?$AAo?$AAs?$AAt?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAd?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5@
  00702	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00708	33 c0		 xor	 eax, eax
$LN98@TableUpdat:

; 838  : 
; 839  :     // [Part 2] Disable child window clipping while fitting columns. This is not strictly necessary but makes it possible
; 840  :     // to avoid the column fitting having to wait until the first visible frame of the child container (may or not be a good thing).
; 841  :     // FIXME-TABLE: for always auto-resizing columns may not want to do that all the time.
; 842  :     if (has_auto_fit_request && table->OuterWindow != table->InnerWindow)

  0070a	0f b6 85 a4 00
	00 00		 movzx	 eax, BYTE PTR has_auto_fit_request$[rbp]
  00711	85 c0		 test	 eax, eax
  00713	74 33		 je	 SHORT $LN35@TableUpdat
  00715	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0071c	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00723	48 8b 89 80 01
	00 00		 mov	 rcx, QWORD PTR [rcx+384]
  0072a	48 39 88 78 01
	00 00		 cmp	 QWORD PTR [rax+376], rcx
  00731	74 15		 je	 SHORT $LN35@TableUpdat

; 843  :         table->InnerWindow->SkipItems = false;

  00733	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0073a	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00741	c6 80 b3 00 00
	00 00		 mov	 BYTE PTR [rax+179], 0
$LN35@TableUpdat:

; 844  :     if (has_auto_fit_request)

  00748	0f b6 85 a4 00
	00 00		 movzx	 eax, BYTE PTR has_auto_fit_request$[rbp]
  0074f	85 c0		 test	 eax, eax
  00751	74 0e		 je	 SHORT $LN36@TableUpdat

; 845  :         table->IsSettingsDirty = true;

  00753	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0075a	c6 80 29 02 00
	00 01		 mov	 BYTE PTR [rax+553], 1
$LN36@TableUpdat:

; 846  : 
; 847  :     // [Part 3] Fix column flags and record a few extra information.
; 848  :     float sum_width_requests = 0.0f;        // Sum of all width for fixed and auto-resize columns, excluding width contributed by Stretch columns but including spacing/padding.

  00761	0f 57 c0	 xorps	 xmm0, xmm0
  00764	f3 0f 11 85 c4
	01 00 00	 movss	 DWORD PTR sum_width_requests$[rbp], xmm0

; 849  :     float stretch_sum_weights = 0.0f;       // Sum of all weights for stretch columns.

  0076c	0f 57 c0	 xorps	 xmm0, xmm0
  0076f	f3 0f 11 85 e4
	01 00 00	 movss	 DWORD PTR stretch_sum_weights$[rbp], xmm0

; 850  :     table->LeftMostStretchedColumn = table->RightMostStretchedColumn = -1;

  00777	b8 ff ff ff ff	 mov	 eax, -1
  0077c	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00783	66 89 81 0e 02
	00 00		 mov	 WORD PTR [rcx+526], ax
  0078a	b8 ff ff ff ff	 mov	 eax, -1
  0078f	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00796	66 89 81 0c 02
	00 00		 mov	 WORD PTR [rcx+524], ax

; 851  :     for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  0079d	c7 85 04 02 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$11[rbp], 0
  007a7	eb 0e		 jmp	 SHORT $LN7@TableUpdat
$LN5@TableUpdat:
  007a9	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR column_n$11[rbp]
  007af	ff c0		 inc	 eax
  007b1	89 85 04 02 00
	00		 mov	 DWORD PTR column_n$11[rbp], eax
$LN7@TableUpdat:
  007b7	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  007be	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  007c1	39 85 04 02 00
	00		 cmp	 DWORD PTR column_n$11[rbp], eax
  007c7	0f 8d 8d 03 00
	00		 jge	 $LN6@TableUpdat

; 852  :     {
; 853  :         if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))

  007cd	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR column_n$11[rbp]
  007d3	c1 f8 05	 sar	 eax, 5
  007d6	48 98		 cdqe
  007d8	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  007df	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  007e3	48 89 8d 28 08
	00 00		 mov	 QWORD PTR tv1048[rbp], rcx
  007ea	8b 95 04 02 00
	00		 mov	 edx, DWORD PTR column_n$11[rbp]
  007f0	83 e2 1f	 and	 edx, 31
  007f3	41 b8 01 00 00
	00		 mov	 r8d, 1
  007f9	0f b6 ca	 movzx	 ecx, dl
  007fc	41 8b d0	 mov	 edx, r8d
  007ff	d3 e2		 shl	 edx, cl
  00801	8b ca		 mov	 ecx, edx
  00803	48 8b 95 28 08
	00 00		 mov	 rdx, QWORD PTR tv1048[rbp]
  0080a	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  0080d	23 c1		 and	 eax, ecx
  0080f	85 c0		 test	 eax, eax
  00811	75 02		 jne	 SHORT $LN37@TableUpdat

; 854  :             continue;

  00813	eb 94		 jmp	 SHORT $LN5@TableUpdat
$LN37@TableUpdat:

; 855  :         ImGuiTableColumn* column = &table->Columns[column_n];

  00815	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0081c	48 83 c0 18	 add	 rax, 24
  00820	8b 95 04 02 00
	00		 mov	 edx, DWORD PTR column_n$11[rbp]
  00826	48 8b c8	 mov	 rcx, rax
  00829	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  0082e	48 89 85 28 02
	00 00		 mov	 QWORD PTR column$12[rbp], rax

; 856  : 
; 857  :         const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;

  00835	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  0083c	8b 00		 mov	 eax, DWORD PTR [rax]
  0083e	83 e0 20	 and	 eax, 32			; 00000020H
  00841	85 c0		 test	 eax, eax
  00843	75 09		 jne	 SHORT $LN99@TableUpdat
  00845	c6 85 24 08 00
	00 01		 mov	 BYTE PTR tv326[rbp], 1
  0084c	eb 07		 jmp	 SHORT $LN100@TableUpdat
$LN99@TableUpdat:
  0084e	c6 85 24 08 00
	00 00		 mov	 BYTE PTR tv326[rbp], 0
$LN100@TableUpdat:
  00855	0f b6 85 24 08
	00 00		 movzx	 eax, BYTE PTR tv326[rbp]
  0085c	88 85 44 02 00
	00		 mov	 BYTE PTR column_is_resizable$13[rbp], al

; 858  :         if (column->Flags & ImGuiTableColumnFlags_WidthFixed)

  00862	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00869	8b 00		 mov	 eax, DWORD PTR [rax]
  0086b	83 e0 10	 and	 eax, 16
  0086e	85 c0		 test	 eax, eax
  00870	0f 84 33 01 00
	00		 je	 $LN38@TableUpdat

; 859  :         {
; 860  :             // Apply same widths policy
; 861  :             float width_auto = column->WidthAuto;

  00876	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  0087d	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  00882	f3 0f 11 85 64
	02 00 00	 movss	 DWORD PTR width_auto$14[rbp], xmm0

; 862  :             if (table_sizing_policy == ImGuiTableFlags_SizingFixedSame && (column->AutoFitQueue != 0x00 || !column_is_resizable))

  0088a	81 7d 24 00 40
	00 00		 cmp	 DWORD PTR table_sizing_policy$[rbp], 16384 ; 00004000H
  00891	75 2a		 jne	 SHORT $LN40@TableUpdat
  00893	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  0089a	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  0089e	85 c0		 test	 eax, eax
  008a0	75 0b		 jne	 SHORT $LN41@TableUpdat
  008a2	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR column_is_resizable$13[rbp]
  008a9	85 c0		 test	 eax, eax
  008ab	75 10		 jne	 SHORT $LN40@TableUpdat
$LN41@TableUpdat:

; 863  :                 width_auto = fixed_max_width_auto;

  008ad	f3 0f 10 85 04
	01 00 00	 movss	 xmm0, DWORD PTR fixed_max_width_auto$[rbp]
  008b5	f3 0f 11 85 64
	02 00 00	 movss	 DWORD PTR width_auto$14[rbp], xmm0
$LN40@TableUpdat:

; 864  : 
; 865  :             // Apply automatic width
; 866  :             // Latch initial size for fixed columns and update it constantly for auto-resizing column (unless clipped!)
; 867  :             if (column->AutoFitQueue != 0x00)

  008bd	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  008c4	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  008c8	85 c0		 test	 eax, eax
  008ca	74 16		 je	 SHORT $LN42@TableUpdat

; 868  :                 column->WidthRequest = width_auto;

  008cc	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  008d3	f3 0f 10 85 64
	02 00 00	 movss	 xmm0, DWORD PTR width_auto$14[rbp]
  008db	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
  008e0	eb 3e		 jmp	 SHORT $LN43@TableUpdat
$LN42@TableUpdat:

; 869  :             else if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !column_is_resizable && column->IsRequestOutput)

  008e2	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  008e9	8b 00		 mov	 eax, DWORD PTR [rax]
  008eb	83 e0 10	 and	 eax, 16
  008ee	85 c0		 test	 eax, eax
  008f0	74 2e		 je	 SHORT $LN44@TableUpdat
  008f2	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR column_is_resizable$13[rbp]
  008f9	85 c0		 test	 eax, eax
  008fb	75 23		 jne	 SHORT $LN44@TableUpdat
  008fd	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00904	0f b6 40 67	 movzx	 eax, BYTE PTR [rax+103]
  00908	85 c0		 test	 eax, eax
  0090a	74 14		 je	 SHORT $LN44@TableUpdat

; 870  :                 column->WidthRequest = width_auto;

  0090c	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00913	f3 0f 10 85 64
	02 00 00	 movss	 xmm0, DWORD PTR width_auto$14[rbp]
  0091b	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
$LN44@TableUpdat:
$LN43@TableUpdat:

; 871  : 
; 872  :             // FIXME-TABLE: Increase minimum size during init frame to avoid biasing auto-fitting widgets
; 873  :             // (e.g. TextWrapped) too much. Otherwise what tends to happen is that TextWrapped would output a very
; 874  :             // large height (= first frame scrollbar display very off + clipper would skip lots of items).
; 875  :             // This is merely making the side-effect less extreme, but doesn't properly fixes it.
; 876  :             // FIXME: Move this to ->WidthGiven to avoid temporary lossyless?
; 877  :             // FIXME: This break IsPreserveWidthAuto from not flickering if the stored WidthAuto was smaller.
; 878  :             if (column->AutoFitQueue > 0x01 && table->IsInitializing && !column->IsPreserveWidthAuto)

  00920	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00927	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  0092b	83 f8 01	 cmp	 eax, 1
  0092e	7e 58		 jle	 SHORT $LN45@TableUpdat
  00930	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00937	0f b6 80 24 02
	00 00		 movzx	 eax, BYTE PTR [rax+548]
  0093e	85 c0		 test	 eax, eax
  00940	74 46		 je	 SHORT $LN45@TableUpdat
  00942	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00949	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  0094d	85 c0		 test	 eax, eax
  0094f	75 37		 jne	 SHORT $LN45@TableUpdat

; 879  :                 column->WidthRequest = ImMax(column->WidthRequest, table->MinColumnWidth * 4.0f); // FIXME-TABLE: Another constant/scale?

  00951	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00958	f3 0f 10 80 b4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+180]
  00960	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40800000
  00968	0f 28 c8	 movaps	 xmm1, xmm0
  0096b	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00972	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  00977	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0097c	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00983	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
$LN45@TableUpdat:

; 880  :             sum_width_requests += column->WidthRequest;

  00988	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  0098f	f3 0f 10 85 c4
	01 00 00	 movss	 xmm0, DWORD PTR sum_width_requests$[rbp]
  00997	f3 0f 58 40 10	 addss	 xmm0, DWORD PTR [rax+16]
  0099c	f3 0f 11 85 c4
	01 00 00	 movss	 DWORD PTR sum_width_requests$[rbp], xmm0

; 881  :         }
; 882  :         else

  009a4	e9 73 01 00 00	 jmp	 $LN39@TableUpdat
$LN38@TableUpdat:

; 883  :         {
; 884  :             // Initialize stretch weight
; 885  :             if (column->AutoFitQueue != 0x00 || column->StretchWeight < 0.0f || !column_is_resizable)

  009a9	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  009b0	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  009b4	85 c0		 test	 eax, eax
  009b6	75 1b		 jne	 SHORT $LN47@TableUpdat
  009b8	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  009bf	0f 57 c0	 xorps	 xmm0, xmm0
  009c2	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [rax+24]
  009c6	77 0b		 ja	 SHORT $LN47@TableUpdat
  009c8	0f b6 85 44 02
	00 00		 movzx	 eax, BYTE PTR column_is_resizable$13[rbp]
  009cf	85 c0		 test	 eax, eax
  009d1	75 77		 jne	 SHORT $LN46@TableUpdat
$LN47@TableUpdat:

; 886  :             {
; 887  :                 if (column->InitStretchWeightOrWidth > 0.0f)

  009d3	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  009da	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  009df	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  009e6	76 1a		 jbe	 SHORT $LN48@TableUpdat

; 888  :                     column->StretchWeight = column->InitStretchWeightOrWidth;

  009e8	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  009ef	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR column$12[rbp]
  009f6	f3 0f 10 41 1c	 movss	 xmm0, DWORD PTR [rcx+28]
  009fb	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0
  00a00	eb 48		 jmp	 SHORT $LN49@TableUpdat
$LN48@TableUpdat:

; 889  :                 else if (table_sizing_policy == ImGuiTableFlags_SizingStretchProp)

  00a02	81 7d 24 00 60
	00 00		 cmp	 DWORD PTR table_sizing_policy$[rbp], 24576 ; 00006000H
  00a09	75 2b		 jne	 SHORT $LN50@TableUpdat

; 890  :                     column->StretchWeight = (column->WidthAuto / stretch_sum_width_auto) * count_stretch;

  00a0b	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00a12	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  00a17	f3 0f 5e 85 e4
	00 00 00	 divss	 xmm0, DWORD PTR stretch_sum_width_auto$[rbp]
  00a1f	f3 0f 2a 4d 64	 cvtsi2ss xmm1, DWORD PTR count_stretch$[rbp]
  00a24	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00a28	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00a2f	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0

; 891  :                 else

  00a34	eb 14		 jmp	 SHORT $LN51@TableUpdat
$LN50@TableUpdat:

; 892  :                     column->StretchWeight = 1.0f;

  00a36	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00a3d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a45	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0
$LN51@TableUpdat:
$LN49@TableUpdat:
$LN46@TableUpdat:

; 893  :             }
; 894  : 
; 895  :             stretch_sum_weights += column->StretchWeight;

  00a4a	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00a51	f3 0f 10 85 e4
	01 00 00	 movss	 xmm0, DWORD PTR stretch_sum_weights$[rbp]
  00a59	f3 0f 58 40 18	 addss	 xmm0, DWORD PTR [rax+24]
  00a5e	f3 0f 11 85 e4
	01 00 00	 movss	 DWORD PTR stretch_sum_weights$[rbp], xmm0

; 896  :             if (table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder > column->DisplayOrder)

  00a66	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00a6d	0f bf 80 0c 02
	00 00		 movsx	 eax, WORD PTR [rax+524]
  00a74	83 f8 ff	 cmp	 eax, -1
  00a77	74 33		 je	 SHORT $LN53@TableUpdat
  00a79	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00a80	0f bf 80 0c 02
	00 00		 movsx	 eax, WORD PTR [rax+524]
  00a87	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00a8e	48 83 c1 18	 add	 rcx, 24
  00a92	8b d0		 mov	 edx, eax
  00a94	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00a99	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  00a9d	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR column$12[rbp]
  00aa4	0f bf 49 52	 movsx	 ecx, WORD PTR [rcx+82]
  00aa8	3b c1		 cmp	 eax, ecx
  00aaa	7e 15		 jle	 SHORT $LN52@TableUpdat
$LN53@TableUpdat:

; 897  :                 table->LeftMostStretchedColumn = (ImGuiTableColumnIdx)column_n;

  00aac	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00ab3	0f b7 8d 04 02
	00 00		 movzx	 ecx, WORD PTR column_n$11[rbp]
  00aba	66 89 88 0c 02
	00 00		 mov	 WORD PTR [rax+524], cx
$LN52@TableUpdat:

; 898  :             if (table->RightMostStretchedColumn == -1 || table->Columns[table->RightMostStretchedColumn].DisplayOrder < column->DisplayOrder)

  00ac1	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00ac8	0f bf 80 0e 02
	00 00		 movsx	 eax, WORD PTR [rax+526]
  00acf	83 f8 ff	 cmp	 eax, -1
  00ad2	74 33		 je	 SHORT $LN55@TableUpdat
  00ad4	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00adb	0f bf 80 0e 02
	00 00		 movsx	 eax, WORD PTR [rax+526]
  00ae2	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00ae9	48 83 c1 18	 add	 rcx, 24
  00aed	8b d0		 mov	 edx, eax
  00aef	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00af4	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  00af8	48 8b 8d 28 02
	00 00		 mov	 rcx, QWORD PTR column$12[rbp]
  00aff	0f bf 49 52	 movsx	 ecx, WORD PTR [rcx+82]
  00b03	3b c1		 cmp	 eax, ecx
  00b05	7d 15		 jge	 SHORT $LN54@TableUpdat
$LN55@TableUpdat:

; 899  :                 table->RightMostStretchedColumn = (ImGuiTableColumnIdx)column_n;

  00b07	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00b0e	0f b7 8d 04 02
	00 00		 movzx	 ecx, WORD PTR column_n$11[rbp]
  00b15	66 89 88 0e 02
	00 00		 mov	 WORD PTR [rax+526], cx
$LN54@TableUpdat:
$LN39@TableUpdat:

; 900  :         }
; 901  :         column->IsPreserveWidthAuto = false;

  00b1c	48 8b 85 28 02
	00 00		 mov	 rax, QWORD PTR column$12[rbp]
  00b23	c6 40 69 00	 mov	 BYTE PTR [rax+105], 0

; 902  :         sum_width_requests += table->CellPaddingX * 2.0f;

  00b27	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00b2e	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+188]
  00b36	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00b3e	f3 0f 10 8d c4
	01 00 00	 movss	 xmm1, DWORD PTR sum_width_requests$[rbp]
  00b46	f3 0f 58 c8	 addss	 xmm1, xmm0
  00b4a	0f 28 c1	 movaps	 xmm0, xmm1
  00b4d	f3 0f 11 85 c4
	01 00 00	 movss	 DWORD PTR sum_width_requests$[rbp], xmm0

; 903  :     }

  00b55	e9 4f fc ff ff	 jmp	 $LN5@TableUpdat
$LN6@TableUpdat:

; 904  :     table->ColumnsEnabledFixedCount = (ImGuiTableColumnIdx)count_fixed;

  00b5a	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00b61	0f b7 4d 44	 movzx	 ecx, WORD PTR count_fixed$[rbp]
  00b65	66 89 88 f4 01
	00 00		 mov	 WORD PTR [rax+500], cx

; 905  :     table->ColumnsStretchSumWeights = stretch_sum_weights;

  00b6c	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00b73	f3 0f 10 85 e4
	01 00 00	 movss	 xmm0, DWORD PTR stretch_sum_weights$[rbp]
  00b7b	f3 0f 11 80 d8
	00 00 00	 movss	 DWORD PTR [rax+216], xmm0

; 906  : 
; 907  :     // [Part 4] Apply final widths based on requested widths
; 908  :     const ImRect work_rect = table->WorkRect;

  00b83	48 8d 85 88 02
	00 00		 lea	 rax, QWORD PTR work_rect$[rbp]
  00b8a	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00b91	48 8b f8	 mov	 rdi, rax
  00b94	48 8d b1 08 01
	00 00		 lea	 rsi, QWORD PTR [rcx+264]
  00b9b	b9 10 00 00 00	 mov	 ecx, 16
  00ba0	f3 a4		 rep movsb

; 909  :     const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);

  00ba2	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00ba9	f3 0f 10 80 b8
	00 00 00	 movss	 xmm0, DWORD PTR [rax+184]
  00bb1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00bb9	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00bc0	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00bc7	f3 0f 10 88 c4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+196]
  00bcf	f3 0f 58 89 c8
	00 00 00	 addss	 xmm1, DWORD PTR [rcx+200]
  00bd7	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00bde	0f bf 80 f2 01
	00 00		 movsx	 eax, WORD PTR [rax+498]
  00be5	ff c8		 dec	 eax
  00be7	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  00beb	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00bef	f3 0f 58 c1	 addss	 xmm0, xmm1
  00bf3	f3 0f 11 85 b4
	02 00 00	 movss	 DWORD PTR width_spacings$[rbp], xmm0

; 910  :     const float width_removed = (table->HasScrollbarYPrev && !table->InnerWindow->ScrollbarY) ? g.Style.ScrollbarSize : 0.0f; // To synchronize decoration width of synched tables with mismatching scrollbar state (#5920)

  00bfb	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c02	0f b6 80 30 02
	00 00		 movzx	 eax, BYTE PTR [rax+560]
  00c09	85 c0		 test	 eax, eax
  00c0b	74 2f		 je	 SHORT $LN101@TableUpdat
  00c0d	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c14	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00c1b	0f b6 80 ad 00
	00 00		 movzx	 eax, BYTE PTR [rax+173]
  00c22	85 c0		 test	 eax, eax
  00c24	75 16		 jne	 SHORT $LN101@TableUpdat
  00c26	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00c2a	f3 0f 10 80 54
	38 00 00	 movss	 xmm0, DWORD PTR [rax+14420]
  00c32	f3 0f 11 85 24
	08 00 00	 movss	 DWORD PTR tv446[rbp], xmm0
  00c3a	eb 0b		 jmp	 SHORT $LN102@TableUpdat
$LN101@TableUpdat:
  00c3c	0f 57 c0	 xorps	 xmm0, xmm0
  00c3f	f3 0f 11 85 24
	08 00 00	 movss	 DWORD PTR tv446[rbp], xmm0
$LN102@TableUpdat:
  00c47	f3 0f 10 85 24
	08 00 00	 movss	 xmm0, DWORD PTR tv446[rbp]
  00c4f	f3 0f 11 85 d4
	02 00 00	 movss	 DWORD PTR width_removed$[rbp], xmm0

; 911  :     const float width_avail = ImMax(1.0f, (((table->Flags & ImGuiTableFlags_ScrollX) && table->InnerWidth == 0.0f) ? table->InnerClipRect.GetWidth() : work_rect.GetWidth()) - width_removed);

  00c57	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c5e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00c61	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00c66	85 c0		 test	 eax, eax
  00c68	74 39		 je	 SHORT $LN103@TableUpdat
  00c6a	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c71	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+204]
  00c79	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00c80	7a 21		 jp	 SHORT $LN103@TableUpdat
  00c82	75 1f		 jne	 SHORT $LN103@TableUpdat
  00c84	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c8b	48 05 18 01 00
	00		 add	 rax, 280		; 00000118H
  00c91	48 8b c8	 mov	 rcx, rax
  00c94	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QEBAMXZ ; ImRect::GetWidth
  00c99	f3 0f 11 85 24
	08 00 00	 movss	 DWORD PTR tv458[rbp], xmm0
  00ca1	eb 14		 jmp	 SHORT $LN104@TableUpdat
$LN103@TableUpdat:
  00ca3	48 8d 8d 88 02
	00 00		 lea	 rcx, QWORD PTR work_rect$[rbp]
  00caa	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QEBAMXZ ; ImRect::GetWidth
  00caf	f3 0f 11 85 24
	08 00 00	 movss	 DWORD PTR tv458[rbp], xmm0
$LN104@TableUpdat:
  00cb7	f3 0f 10 85 24
	08 00 00	 movss	 xmm0, DWORD PTR tv458[rbp]
  00cbf	f3 0f 5c 85 d4
	02 00 00	 subss	 xmm0, DWORD PTR width_removed$[rbp]
  00cc7	0f 28 c8	 movaps	 xmm1, xmm0
  00cca	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00cd2	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00cd7	f3 0f 11 85 f4
	02 00 00	 movss	 DWORD PTR width_avail$[rbp], xmm0

; 912  :     const float width_avail_for_stretched_columns = width_avail - width_spacings - sum_width_requests;

  00cdf	f3 0f 10 85 f4
	02 00 00	 movss	 xmm0, DWORD PTR width_avail$[rbp]
  00ce7	f3 0f 5c 85 b4
	02 00 00	 subss	 xmm0, DWORD PTR width_spacings$[rbp]
  00cef	f3 0f 5c 85 c4
	01 00 00	 subss	 xmm0, DWORD PTR sum_width_requests$[rbp]
  00cf7	f3 0f 11 85 14
	03 00 00	 movss	 DWORD PTR width_avail_for_stretched_columns$[rbp], xmm0

; 913  :     float width_remaining_for_stretched_columns = width_avail_for_stretched_columns;

  00cff	f3 0f 10 85 14
	03 00 00	 movss	 xmm0, DWORD PTR width_avail_for_stretched_columns$[rbp]
  00d07	f3 0f 11 85 34
	03 00 00	 movss	 DWORD PTR width_remaining_for_stretched_columns$[rbp], xmm0

; 914  :     table->ColumnsGivenWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount;

  00d0f	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d16	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+188]
  00d1e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00d26	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d2d	0f bf 80 f2 01
	00 00		 movsx	 eax, WORD PTR [rax+498]
  00d34	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00d38	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00d3c	f3 0f 10 8d b4
	02 00 00	 movss	 xmm1, DWORD PTR width_spacings$[rbp]
  00d44	f3 0f 58 c8	 addss	 xmm1, xmm0
  00d48	0f 28 c1	 movaps	 xmm0, xmm1
  00d4b	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d52	f3 0f 11 80 d0
	00 00 00	 movss	 DWORD PTR [rax+208], xmm0

; 915  :     for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  00d5a	c7 85 54 03 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$15[rbp], 0
  00d64	eb 0e		 jmp	 SHORT $LN10@TableUpdat
$LN8@TableUpdat:
  00d66	8b 85 54 03 00
	00		 mov	 eax, DWORD PTR column_n$15[rbp]
  00d6c	ff c0		 inc	 eax
  00d6e	89 85 54 03 00
	00		 mov	 DWORD PTR column_n$15[rbp], eax
$LN10@TableUpdat:
  00d74	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d7b	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00d7e	39 85 54 03 00
	00		 cmp	 DWORD PTR column_n$15[rbp], eax
  00d84	0f 8d 87 01 00
	00		 jge	 $LN9@TableUpdat

; 916  :     {
; 917  :         if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))

  00d8a	8b 85 54 03 00
	00		 mov	 eax, DWORD PTR column_n$15[rbp]
  00d90	c1 f8 05	 sar	 eax, 5
  00d93	48 98		 cdqe
  00d95	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00d9c	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00da0	48 89 8d 28 08
	00 00		 mov	 QWORD PTR tv1046[rbp], rcx
  00da7	8b 95 54 03 00
	00		 mov	 edx, DWORD PTR column_n$15[rbp]
  00dad	83 e2 1f	 and	 edx, 31
  00db0	bf 01 00 00 00	 mov	 edi, 1
  00db5	0f b6 ca	 movzx	 ecx, dl
  00db8	8b d7		 mov	 edx, edi
  00dba	d3 e2		 shl	 edx, cl
  00dbc	8b ca		 mov	 ecx, edx
  00dbe	48 8b 95 28 08
	00 00		 mov	 rdx, QWORD PTR tv1046[rbp]
  00dc5	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00dc8	23 c1		 and	 eax, ecx
  00dca	85 c0		 test	 eax, eax
  00dcc	75 02		 jne	 SHORT $LN56@TableUpdat

; 918  :             continue;

  00dce	eb 96		 jmp	 SHORT $LN8@TableUpdat
$LN56@TableUpdat:

; 919  :         ImGuiTableColumn* column = &table->Columns[column_n];

  00dd0	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00dd7	48 83 c0 18	 add	 rax, 24
  00ddb	8b 95 54 03 00
	00		 mov	 edx, DWORD PTR column_n$15[rbp]
  00de1	48 8b c8	 mov	 rcx, rax
  00de4	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00de9	48 89 85 78 03
	00 00		 mov	 QWORD PTR column$16[rbp], rax

; 920  : 
; 921  :         // Allocate width for stretched/weighted columns (StretchWeight gets converted into WidthRequest)
; 922  :         if (column->Flags & ImGuiTableColumnFlags_WidthStretch)

  00df0	48 8b 85 78 03
	00 00		 mov	 rax, QWORD PTR column$16[rbp]
  00df7	8b 00		 mov	 eax, DWORD PTR [rax]
  00df9	83 e0 08	 and	 eax, 8
  00dfc	85 c0		 test	 eax, eax
  00dfe	74 78		 je	 SHORT $LN57@TableUpdat

; 923  :         {
; 924  :             float weight_ratio = column->StretchWeight / stretch_sum_weights;

  00e00	48 8b 85 78 03
	00 00		 mov	 rax, QWORD PTR column$16[rbp]
  00e07	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  00e0c	f3 0f 5e 85 e4
	01 00 00	 divss	 xmm0, DWORD PTR stretch_sum_weights$[rbp]
  00e14	f3 0f 11 85 94
	03 00 00	 movss	 DWORD PTR weight_ratio$17[rbp], xmm0

; 925  :             column->WidthRequest = IM_FLOOR(ImMax(width_avail_for_stretched_columns * weight_ratio, table->MinColumnWidth) + 0.01f);

  00e1c	f3 0f 10 85 14
	03 00 00	 movss	 xmm0, DWORD PTR width_avail_for_stretched_columns$[rbp]
  00e24	f3 0f 59 85 94
	03 00 00	 mulss	 xmm0, DWORD PTR weight_ratio$17[rbp]
  00e2c	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00e33	f3 0f 10 88 b4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+180]
  00e3b	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00e40	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3c23d70a
  00e48	f3 0f 2c c0	 cvttss2si eax, xmm0
  00e4c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00e50	48 8b 85 78 03
	00 00		 mov	 rax, QWORD PTR column$16[rbp]
  00e57	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 926  :             width_remaining_for_stretched_columns -= column->WidthRequest;

  00e5c	48 8b 85 78 03
	00 00		 mov	 rax, QWORD PTR column$16[rbp]
  00e63	f3 0f 10 85 34
	03 00 00	 movss	 xmm0, DWORD PTR width_remaining_for_stretched_columns$[rbp]
  00e6b	f3 0f 5c 40 10	 subss	 xmm0, DWORD PTR [rax+16]
  00e70	f3 0f 11 85 34
	03 00 00	 movss	 DWORD PTR width_remaining_for_stretched_columns$[rbp], xmm0
$LN57@TableUpdat:

; 927  :         }
; 928  : 
; 929  :         // [Resize Rule 1] The right-most Visible column is not resizable if there is at least one Stretch column
; 930  :         // See additional comments in TableSetColumnWidth().
; 931  :         if (column->NextEnabledColumn == -1 && table->LeftMostStretchedColumn != -1)

  00e78	48 8b 85 78 03
	00 00		 mov	 rax, QWORD PTR column$16[rbp]
  00e7f	0f bf 40 58	 movsx	 eax, WORD PTR [rax+88]
  00e83	83 f8 ff	 cmp	 eax, -1
  00e86	75 29		 jne	 SHORT $LN58@TableUpdat
  00e88	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00e8f	0f bf 80 0c 02
	00 00		 movsx	 eax, WORD PTR [rax+524]
  00e96	83 f8 ff	 cmp	 eax, -1
  00e99	74 16		 je	 SHORT $LN58@TableUpdat

; 932  :             column->Flags |= ImGuiTableColumnFlags_NoDirectResize_;

  00e9b	48 8b 85 78 03
	00 00		 mov	 rax, QWORD PTR column$16[rbp]
  00ea2	8b 00		 mov	 eax, DWORD PTR [rax]
  00ea4	0f ba e8 1e	 bts	 eax, 30
  00ea8	48 8b 8d 78 03
	00 00		 mov	 rcx, QWORD PTR column$16[rbp]
  00eaf	89 01		 mov	 DWORD PTR [rcx], eax
$LN58@TableUpdat:

; 933  : 
; 934  :         // Assign final width, record width in case we will need to shrink
; 935  :         column->WidthGiven = ImFloor(ImMax(column->WidthRequest, table->MinColumnWidth));

  00eb1	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00eb8	f3 0f 10 88 b4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+180]
  00ec0	48 8b 85 78 03
	00 00		 mov	 rax, QWORD PTR column$16[rbp]
  00ec7	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  00ecc	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00ed1	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  00ed6	48 8b 85 78 03
	00 00		 mov	 rax, QWORD PTR column$16[rbp]
  00edd	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 936  :         table->ColumnsGivenWidth += column->WidthGiven;

  00ee2	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00ee9	48 8b 8d 78 03
	00 00		 mov	 rcx, QWORD PTR column$16[rbp]
  00ef0	f3 0f 10 80 d0
	00 00 00	 movss	 xmm0, DWORD PTR [rax+208]
  00ef8	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [rcx+4]
  00efd	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00f04	f3 0f 11 80 d0
	00 00 00	 movss	 DWORD PTR [rax+208], xmm0

; 937  :     }

  00f0c	e9 55 fe ff ff	 jmp	 $LN8@TableUpdat
$LN9@TableUpdat:

; 938  : 
; 939  :     // [Part 5] Redistribute stretch remainder width due to rounding (remainder width is < 1.0f * number of Stretch column).
; 940  :     // Using right-to-left distribution (more likely to match resizing cursor).
; 941  :     if (width_remaining_for_stretched_columns >= 1.0f && !(table->Flags & ImGuiTableFlags_PreciseWidths))

  00f11	f3 0f 10 85 34
	03 00 00	 movss	 xmm0, DWORD PTR width_remaining_for_stretched_columns$[rbp]
  00f19	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00f20	0f 82 60 01 00
	00		 jb	 $LN59@TableUpdat
  00f26	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00f2d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00f30	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00f35	85 c0		 test	 eax, eax
  00f37	0f 85 49 01 00
	00		 jne	 $LN59@TableUpdat

; 942  :         for (int order_n = table->ColumnsCount - 1; stretch_sum_weights > 0.0f && width_remaining_for_stretched_columns >= 1.0f && order_n >= 0; order_n--)

  00f3d	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00f44	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00f47	ff c8		 dec	 eax
  00f49	89 85 b4 03 00
	00		 mov	 DWORD PTR order_n$18[rbp], eax
  00f4f	eb 0e		 jmp	 SHORT $LN13@TableUpdat
$LN11@TableUpdat:
  00f51	8b 85 b4 03 00
	00		 mov	 eax, DWORD PTR order_n$18[rbp]
  00f57	ff c8		 dec	 eax
  00f59	89 85 b4 03 00
	00		 mov	 DWORD PTR order_n$18[rbp], eax
$LN13@TableUpdat:
  00f5f	f3 0f 10 85 e4
	01 00 00	 movss	 xmm0, DWORD PTR stretch_sum_weights$[rbp]
  00f67	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00f6e	0f 86 12 01 00
	00		 jbe	 $LN12@TableUpdat
  00f74	f3 0f 10 85 34
	03 00 00	 movss	 xmm0, DWORD PTR width_remaining_for_stretched_columns$[rbp]
  00f7c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00f83	0f 82 fd 00 00
	00		 jb	 $LN12@TableUpdat
  00f89	83 bd b4 03 00
	00 00		 cmp	 DWORD PTR order_n$18[rbp], 0
  00f90	0f 8c f0 00 00
	00		 jl	 $LN12@TableUpdat

; 943  :         {
; 944  :             if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))

  00f96	8b 85 b4 03 00
	00		 mov	 eax, DWORD PTR order_n$18[rbp]
  00f9c	c1 f8 05	 sar	 eax, 5
  00f9f	48 98		 cdqe
  00fa1	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00fa8	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00fac	48 89 8d 28 08
	00 00		 mov	 QWORD PTR tv1044[rbp], rcx
  00fb3	8b 95 b4 03 00
	00		 mov	 edx, DWORD PTR order_n$18[rbp]
  00fb9	83 e2 1f	 and	 edx, 31
  00fbc	bf 01 00 00 00	 mov	 edi, 1
  00fc1	0f b6 ca	 movzx	 ecx, dl
  00fc4	8b d7		 mov	 edx, edi
  00fc6	d3 e2		 shl	 edx, cl
  00fc8	8b ca		 mov	 ecx, edx
  00fca	48 8b 95 28 08
	00 00		 mov	 rdx, QWORD PTR tv1044[rbp]
  00fd1	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00fd4	23 c1		 and	 eax, ecx
  00fd6	85 c0		 test	 eax, eax
  00fd8	75 05		 jne	 SHORT $LN60@TableUpdat

; 945  :                 continue;

  00fda	e9 72 ff ff ff	 jmp	 $LN11@TableUpdat
$LN60@TableUpdat:

; 946  :             ImGuiTableColumn* column = &table->Columns[table->DisplayOrderToIndex[order_n]];

  00fdf	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00fe6	48 83 c0 28	 add	 rax, 40			; 00000028H
  00fea	8b 95 b4 03 00
	00		 mov	 edx, DWORD PTR order_n$18[rbp]
  00ff0	48 8b c8	 mov	 rcx, rax
  00ff3	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  00ff8	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00ffb	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01002	48 83 c1 18	 add	 rcx, 24
  01006	8b d0		 mov	 edx, eax
  01008	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  0100d	48 89 85 d8 03
	00 00		 mov	 QWORD PTR column$19[rbp], rax

; 947  :             if (!(column->Flags & ImGuiTableColumnFlags_WidthStretch))

  01014	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR column$19[rbp]
  0101b	8b 00		 mov	 eax, DWORD PTR [rax]
  0101d	83 e0 08	 and	 eax, 8
  01020	85 c0		 test	 eax, eax
  01022	75 05		 jne	 SHORT $LN61@TableUpdat

; 948  :                 continue;

  01024	e9 28 ff ff ff	 jmp	 $LN11@TableUpdat
$LN61@TableUpdat:

; 949  :             column->WidthRequest += 1.0f;

  01029	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR column$19[rbp]
  01030	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  01035	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0103d	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR column$19[rbp]
  01044	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 950  :             column->WidthGiven += 1.0f;

  01049	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR column$19[rbp]
  01050	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  01055	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0105d	48 8b 85 d8 03
	00 00		 mov	 rax, QWORD PTR column$19[rbp]
  01064	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 951  :             width_remaining_for_stretched_columns -= 1.0f;

  01069	f3 0f 10 85 34
	03 00 00	 movss	 xmm0, DWORD PTR width_remaining_for_stretched_columns$[rbp]
  01071	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  01079	f3 0f 11 85 34
	03 00 00	 movss	 DWORD PTR width_remaining_for_stretched_columns$[rbp], xmm0

; 952  :         }

  01081	e9 cb fe ff ff	 jmp	 $LN11@TableUpdat
$LN12@TableUpdat:
$LN59@TableUpdat:

; 953  : 
; 954  :     // Determine if table is hovered which will be used to flag columns as hovered.
; 955  :     // - In principle we'd like to use the equivalent of IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
; 956  :     //   but because our item is partially submitted at this point we use ItemHoverable() and a workaround (temporarily
; 957  :     //   clear ActiveId, which is equivalent to the change provided by _AllowWhenBLockedByActiveItem).
; 958  :     // - This allows columns to be marked as hovered when e.g. clicking a button inside the column, or using drag and drop.
; 959  :     ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);

  01086	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0108d	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  01091	8b d0		 mov	 edx, eax
  01093	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0109a	e8 00 00 00 00	 call	 ?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z ; ImGui::TableGetInstanceData
  0109f	48 89 85 f8 03
	00 00		 mov	 QWORD PTR table_instance$[rbp], rax

; 960  :     table->HoveredColumnBody = -1;

  010a6	b8 ff ff ff ff	 mov	 eax, -1
  010ab	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  010b2	66 89 81 f8 01
	00 00		 mov	 WORD PTR [rcx+504], ax

; 961  :     table->HoveredColumnBorder = -1;

  010b9	b8 ff ff ff ff	 mov	 eax, -1
  010be	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  010c5	66 89 81 fa 01
	00 00		 mov	 WORD PTR [rcx+506], ax

; 962  :     const ImRect mouse_hit_rect(table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.Max.x, ImMax(table->OuterRect.Max.y, table->OuterRect.Min.y + table_instance->LastOuterHeight));

  010cc	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  010d3	48 8b 8d f8 03
	00 00		 mov	 rcx, QWORD PTR table_instance$[rbp]
  010da	f3 0f 10 80 ec
	00 00 00	 movss	 xmm0, DWORD PTR [rax+236]
  010e2	f3 0f 58 01	 addss	 xmm0, DWORD PTR [rcx]
  010e6	0f 28 c8	 movaps	 xmm1, xmm0
  010e9	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  010f0	f3 0f 10 80 f4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+244]
  010f8	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  010fd	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  01103	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0110a	f3 0f 10 98 f0
	00 00 00	 movss	 xmm3, DWORD PTR [rax+240]
  01112	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01119	f3 0f 10 90 ec
	00 00 00	 movss	 xmm2, DWORD PTR [rax+236]
  01121	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01128	f3 0f 10 88 e8
	00 00 00	 movss	 xmm1, DWORD PTR [rax+232]
  01130	48 8d 8d 18 04
	00 00		 lea	 rcx, QWORD PTR mouse_hit_rect$[rbp]
  01137	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@MMMM@Z	; ImRect::ImRect

; 963  :     const ImGuiID backup_active_id = g.ActiveId;

  0113c	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  01140	8b 80 00 3f 00
	00		 mov	 eax, DWORD PTR [rax+16128]
  01146	89 85 44 04 00
	00		 mov	 DWORD PTR backup_active_id$[rbp], eax

; 964  :     g.ActiveId = 0;

  0114c	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  01150	c7 80 00 3f 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+16128], 0

; 965  :     const bool is_hovering_table = ItemHoverable(mouse_hit_rect, 0);

  0115a	33 d2		 xor	 edx, edx
  0115c	48 8d 8d 18 04
	00 00		 lea	 rcx, QWORD PTR mouse_hit_rect$[rbp]
  01163	e8 00 00 00 00	 call	 ?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z ; ImGui::ItemHoverable
  01168	88 85 64 04 00
	00		 mov	 BYTE PTR is_hovering_table$[rbp], al

; 966  :     g.ActiveId = backup_active_id;

  0116e	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  01172	8b 8d 44 04 00
	00		 mov	 ecx, DWORD PTR backup_active_id$[rbp]
  01178	89 88 00 3f 00
	00		 mov	 DWORD PTR [rax+16128], ecx

; 967  : 
; 968  :     // [Part 6] Setup final position, offset, skip/clip states and clipping rectangles, detect hovered column
; 969  :     // Process columns in their visible orders as we are comparing the visible order and adjusting host_clip_rect while looping.
; 970  :     int visible_n = 0;

  0117e	c7 85 84 04 00
	00 00 00 00 00	 mov	 DWORD PTR visible_n$[rbp], 0

; 971  :     bool offset_x_frozen = (table->FreezeColumnsCount > 0);

  01188	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0118f	0f bf 80 18 02
	00 00		 movsx	 eax, WORD PTR [rax+536]
  01196	85 c0		 test	 eax, eax
  01198	7e 0c		 jle	 SHORT $LN105@TableUpdat
  0119a	c7 85 24 08 00
	00 01 00 00 00	 mov	 DWORD PTR tv637[rbp], 1
  011a4	eb 0a		 jmp	 SHORT $LN106@TableUpdat
$LN105@TableUpdat:
  011a6	c7 85 24 08 00
	00 00 00 00 00	 mov	 DWORD PTR tv637[rbp], 0
$LN106@TableUpdat:
  011b0	0f b6 85 24 08
	00 00		 movzx	 eax, BYTE PTR tv637[rbp]
  011b7	88 85 a4 04 00
	00		 mov	 BYTE PTR offset_x_frozen$[rbp], al

; 972  :     float offset_x = ((table->FreezeColumnsCount > 0) ? table->OuterRect.Min.x : work_rect.Min.x) + table->OuterPaddingX - table->CellSpacingX1;

  011bd	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  011c4	0f bf 80 18 02
	00 00		 movsx	 eax, WORD PTR [rax+536]
  011cb	85 c0		 test	 eax, eax
  011cd	7e 19		 jle	 SHORT $LN107@TableUpdat
  011cf	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  011d6	f3 0f 10 80 e8
	00 00 00	 movss	 xmm0, DWORD PTR [rax+232]
  011de	f3 0f 11 85 24
	08 00 00	 movss	 DWORD PTR tv645[rbp], xmm0
  011e6	eb 10		 jmp	 SHORT $LN108@TableUpdat
$LN107@TableUpdat:
  011e8	f3 0f 10 85 88
	02 00 00	 movss	 xmm0, DWORD PTR work_rect$[rbp]
  011f0	f3 0f 11 85 24
	08 00 00	 movss	 DWORD PTR tv645[rbp], xmm0
$LN108@TableUpdat:
  011f8	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  011ff	f3 0f 10 85 24
	08 00 00	 movss	 xmm0, DWORD PTR tv645[rbp]
  01207	f3 0f 58 80 b8
	00 00 00	 addss	 xmm0, DWORD PTR [rax+184]
  0120f	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01216	f3 0f 5c 80 c4
	00 00 00	 subss	 xmm0, DWORD PTR [rax+196]
  0121e	f3 0f 11 85 c4
	04 00 00	 movss	 DWORD PTR offset_x$[rbp], xmm0

; 973  :     ImRect host_clip_rect = table->InnerClipRect;

  01226	48 8d 85 e8 04
	00 00		 lea	 rax, QWORD PTR host_clip_rect$[rbp]
  0122d	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01234	48 8b f8	 mov	 rdi, rax
  01237	48 8d b1 18 01
	00 00		 lea	 rsi, QWORD PTR [rcx+280]
  0123e	b9 10 00 00 00	 mov	 ecx, 16
  01243	f3 a4		 rep movsb

; 974  :     //host_clip_rect.Max.x += table->CellPaddingX + table->CellSpacingX2;
; 975  :     ImBitArrayClearAllBits(table->VisibleMaskByIndex, table->ColumnsCount);

  01245	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0124c	8b 50 6c	 mov	 edx, DWORD PTR [rax+108]
  0124f	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01256	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0125a	e8 00 00 00 00	 call	 ?ImBitArrayClearAllBits@@YAXPEAIH@Z ; ImBitArrayClearAllBits

; 976  :     for (int order_n = 0; order_n < table->ColumnsCount; order_n++)

  0125f	c7 85 14 05 00
	00 00 00 00 00	 mov	 DWORD PTR order_n$20[rbp], 0
  01269	eb 0e		 jmp	 SHORT $LN16@TableUpdat
$LN14@TableUpdat:
  0126b	8b 85 14 05 00
	00		 mov	 eax, DWORD PTR order_n$20[rbp]
  01271	ff c0		 inc	 eax
  01273	89 85 14 05 00
	00		 mov	 DWORD PTR order_n$20[rbp], eax
$LN16@TableUpdat:
  01279	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01280	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  01283	39 85 14 05 00
	00		 cmp	 DWORD PTR order_n$20[rbp], eax
  01289	0f 8d 9d 07 00
	00		 jge	 $LN15@TableUpdat

; 977  :     {
; 978  :         const int column_n = table->DisplayOrderToIndex[order_n];

  0128f	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01296	48 83 c0 28	 add	 rax, 40			; 00000028H
  0129a	8b 95 14 05 00
	00		 mov	 edx, DWORD PTR order_n$20[rbp]
  012a0	48 8b c8	 mov	 rcx, rax
  012a3	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  012a8	0f bf 00	 movsx	 eax, WORD PTR [rax]
  012ab	89 85 34 05 00
	00		 mov	 DWORD PTR column_n$21[rbp], eax

; 979  :         ImGuiTableColumn* column = &table->Columns[column_n];

  012b1	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  012b8	48 83 c0 18	 add	 rax, 24
  012bc	8b 95 34 05 00
	00		 mov	 edx, DWORD PTR column_n$21[rbp]
  012c2	48 8b c8	 mov	 rcx, rax
  012c5	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  012ca	48 89 85 58 05
	00 00		 mov	 QWORD PTR column$22[rbp], rax

; 980  : 
; 981  :         column->NavLayerCurrent = (ImS8)(table->FreezeRowsCount > 0 ? ImGuiNavLayer_Menu : ImGuiNavLayer_Main); // Use Count NOT request so Header line changes layer when frozen

  012d1	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  012d8	0f bf 80 14 02
	00 00		 movsx	 eax, WORD PTR [rax+532]
  012df	85 c0		 test	 eax, eax
  012e1	7e 0c		 jle	 SHORT $LN109@TableUpdat
  012e3	c7 85 24 08 00
	00 01 00 00 00	 mov	 DWORD PTR tv672[rbp], 1
  012ed	eb 0a		 jmp	 SHORT $LN110@TableUpdat
$LN109@TableUpdat:
  012ef	c7 85 24 08 00
	00 00 00 00 00	 mov	 DWORD PTR tv672[rbp], 0
$LN110@TableUpdat:
  012f9	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01300	0f b6 8d 24 08
	00 00		 movzx	 ecx, BYTE PTR tv672[rbp]
  01307	88 48 6a	 mov	 BYTE PTR [rax+106], cl

; 982  : 
; 983  :         if (offset_x_frozen && table->FreezeColumnsCount == visible_n)

  0130a	0f b6 85 a4 04
	00 00		 movzx	 eax, BYTE PTR offset_x_frozen$[rbp]
  01311	85 c0		 test	 eax, eax
  01313	74 4b		 je	 SHORT $LN62@TableUpdat
  01315	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0131c	0f bf 80 18 02
	00 00		 movsx	 eax, WORD PTR [rax+536]
  01323	3b 85 84 04 00
	00		 cmp	 eax, DWORD PTR visible_n$[rbp]
  01329	75 35		 jne	 SHORT $LN62@TableUpdat

; 984  :         {
; 985  :             offset_x += work_rect.Min.x - table->OuterRect.Min.x;

  0132b	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01332	f3 0f 10 85 88
	02 00 00	 movss	 xmm0, DWORD PTR work_rect$[rbp]
  0133a	f3 0f 5c 80 e8
	00 00 00	 subss	 xmm0, DWORD PTR [rax+232]
  01342	f3 0f 10 8d c4
	04 00 00	 movss	 xmm1, DWORD PTR offset_x$[rbp]
  0134a	f3 0f 58 c8	 addss	 xmm1, xmm0
  0134e	0f 28 c1	 movaps	 xmm0, xmm1
  01351	f3 0f 11 85 c4
	04 00 00	 movss	 DWORD PTR offset_x$[rbp], xmm0

; 986  :             offset_x_frozen = false;

  01359	c6 85 a4 04 00
	00 00		 mov	 BYTE PTR offset_x_frozen$[rbp], 0
$LN62@TableUpdat:

; 987  :         }
; 988  : 
; 989  :         // Clear status flags
; 990  :         column->Flags &= ~ImGuiTableColumnFlags_StatusMask_;

  01360	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01367	8b 00		 mov	 eax, DWORD PTR [rax]
  01369	25 ff ff ff f0	 and	 eax, -251658241		; fffffffff0ffffffH
  0136e	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  01375	89 01		 mov	 DWORD PTR [rcx], eax

; 991  : 
; 992  :         if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))

  01377	8b 85 14 05 00
	00		 mov	 eax, DWORD PTR order_n$20[rbp]
  0137d	c1 f8 05	 sar	 eax, 5
  01380	48 98		 cdqe
  01382	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01389	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0138d	48 89 8d 28 08
	00 00		 mov	 QWORD PTR tv1043[rbp], rcx
  01394	8b 95 14 05 00
	00		 mov	 edx, DWORD PTR order_n$20[rbp]
  0139a	83 e2 1f	 and	 edx, 31
  0139d	bf 01 00 00 00	 mov	 edi, 1
  013a2	0f b6 ca	 movzx	 ecx, dl
  013a5	8b d7		 mov	 edx, edi
  013a7	d3 e2		 shl	 edx, cl
  013a9	8b ca		 mov	 ecx, edx
  013ab	48 8b 95 28 08
	00 00		 mov	 rdx, QWORD PTR tv1043[rbp]
  013b2	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  013b5	23 c1		 and	 eax, ecx
  013b7	85 c0		 test	 eax, eax
  013b9	0f 85 fa 00 00
	00		 jne	 $LN63@TableUpdat

; 993  :         {
; 994  :             // Hidden column: clear a few fields and we are done with it for the remainder of the function.
; 995  :             // We set a zero-width clip rect but set Min.y/Max.y properly to not interfere with the clipper.
; 996  :             column->MinX = column->MaxX = column->WorkMinX = column->ClipRect.Min.x = column->ClipRect.Max.x = offset_x;

  013bf	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  013c6	f3 0f 10 85 c4
	04 00 00	 movss	 xmm0, DWORD PTR offset_x$[rbp]
  013ce	f3 0f 11 40 28	 movss	 DWORD PTR [rax+40], xmm0
  013d3	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  013da	f3 0f 10 85 c4
	04 00 00	 movss	 xmm0, DWORD PTR offset_x$[rbp]
  013e2	f3 0f 11 40 20	 movss	 DWORD PTR [rax+32], xmm0
  013e7	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  013ee	f3 0f 10 85 c4
	04 00 00	 movss	 xmm0, DWORD PTR offset_x$[rbp]
  013f6	f3 0f 11 40 34	 movss	 DWORD PTR [rax+52], xmm0
  013fb	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01402	f3 0f 10 85 c4
	04 00 00	 movss	 xmm0, DWORD PTR offset_x$[rbp]
  0140a	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0
  0140f	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01416	f3 0f 10 85 c4
	04 00 00	 movss	 xmm0, DWORD PTR offset_x$[rbp]
  0141e	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 997  :             column->WidthGiven = 0.0f;

  01423	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0142a	0f 57 c0	 xorps	 xmm0, xmm0
  0142d	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 998  :             column->ClipRect.Min.y = work_rect.Min.y;

  01432	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01439	f3 0f 10 85 8c
	02 00 00	 movss	 xmm0, DWORD PTR work_rect$[rbp+4]
  01441	f3 0f 11 40 24	 movss	 DWORD PTR [rax+36], xmm0

; 999  :             column->ClipRect.Max.y = FLT_MAX;

  01446	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0144d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  01455	f3 0f 11 40 2c	 movss	 DWORD PTR [rax+44], xmm0

; 1000 :             column->ClipRect.ClipWithFull(host_clip_rect);

  0145a	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01461	48 83 c0 20	 add	 rax, 32			; 00000020H
  01465	48 8d 95 e8 04
	00 00		 lea	 rdx, QWORD PTR host_clip_rect$[rbp]
  0146c	48 8b c8	 mov	 rcx, rax
  0146f	e8 00 00 00 00	 call	 ?ClipWithFull@ImRect@@QEAAXAEBU1@@Z ; ImRect::ClipWithFull

; 1001 :             column->IsVisibleX = column->IsVisibleY = column->IsRequestOutput = false;

  01474	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0147b	c6 40 67 00	 mov	 BYTE PTR [rax+103], 0
  0147f	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01486	c6 40 66 00	 mov	 BYTE PTR [rax+102], 0
  0148a	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01491	c6 40 65 00	 mov	 BYTE PTR [rax+101], 0

; 1002 :             column->IsSkipItems = true;

  01495	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0149c	c6 40 68 01	 mov	 BYTE PTR [rax+104], 1

; 1003 :             column->ItemWidth = 1.0f;

  014a0	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  014a7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  014af	f3 0f 11 40 3c	 movss	 DWORD PTR [rax+60], xmm0

; 1004 :             continue;

  014b4	e9 b2 fd ff ff	 jmp	 $LN14@TableUpdat
$LN63@TableUpdat:

; 1005 :         }
; 1006 : 
; 1007 :         // Detect hovered column
; 1008 :         if (is_hovering_table && g.IO.MousePos.x >= column->ClipRect.Min.x && g.IO.MousePos.x < column->ClipRect.Max.x)

  014b9	0f b6 85 64 04
	00 00		 movzx	 eax, BYTE PTR is_hovering_table$[rbp]
  014c0	85 c0		 test	 eax, eax
  014c2	74 47		 je	 SHORT $LN64@TableUpdat
  014c4	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  014c8	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  014cf	f3 0f 10 80 fc
	0d 00 00	 movss	 xmm0, DWORD PTR [rax+3580]
  014d7	0f 2f 41 20	 comiss	 xmm0, DWORD PTR [rcx+32]
  014db	72 2e		 jb	 SHORT $LN64@TableUpdat
  014dd	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  014e4	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  014e8	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [rax+40]
  014ed	0f 2f 81 fc 0d
	00 00		 comiss	 xmm0, DWORD PTR [rcx+3580]
  014f4	76 15		 jbe	 SHORT $LN64@TableUpdat

; 1009 :             table->HoveredColumnBody = (ImGuiTableColumnIdx)column_n;

  014f6	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  014fd	0f b7 8d 34 05
	00 00		 movzx	 ecx, WORD PTR column_n$21[rbp]
  01504	66 89 88 f8 01
	00 00		 mov	 WORD PTR [rax+504], cx
$LN64@TableUpdat:

; 1010 : 
; 1011 :         // Lock start position
; 1012 :         column->MinX = offset_x;

  0150b	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01512	f3 0f 10 85 c4
	04 00 00	 movss	 xmm0, DWORD PTR offset_x$[rbp]
  0151a	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 1013 : 
; 1014 :         // Lock width based on start position and minimum/maximum width for this position
; 1015 :         float max_width = TableGetMaxColumnWidth(table, column_n);

  0151f	8b 95 34 05 00
	00		 mov	 edx, DWORD PTR column_n$21[rbp]
  01525	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0152c	e8 00 00 00 00	 call	 ?TableGetMaxColumnWidth@ImGui@@YAMPEBUImGuiTable@@H@Z ; ImGui::TableGetMaxColumnWidth
  01531	f3 0f 11 85 74
	05 00 00	 movss	 DWORD PTR max_width$23[rbp], xmm0

; 1016 :         column->WidthGiven = ImMin(column->WidthGiven, max_width);

  01539	f3 0f 10 8d 74
	05 00 00	 movss	 xmm1, DWORD PTR max_width$23[rbp]
  01541	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01548	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0154d	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  01552	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01559	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 1017 :         column->WidthGiven = ImMax(column->WidthGiven, ImMin(column->WidthRequest, table->MinColumnWidth));

  0155e	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01565	f3 0f 10 88 b4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+180]
  0156d	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01574	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  01579	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  0157e	0f 28 c8	 movaps	 xmm1, xmm0
  01581	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01588	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0158d	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  01592	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01599	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 1018 :         column->MaxX = offset_x + column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;

  0159e	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  015a5	f3 0f 10 85 c4
	04 00 00	 movss	 xmm0, DWORD PTR offset_x$[rbp]
  015ad	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [rax+4]
  015b2	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  015b9	f3 0f 58 80 c4
	00 00 00	 addss	 xmm0, DWORD PTR [rax+196]
  015c1	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  015c8	f3 0f 58 80 c8
	00 00 00	 addss	 xmm0, DWORD PTR [rax+200]
  015d0	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  015d7	f3 0f 10 88 bc
	00 00 00	 movss	 xmm1, DWORD PTR [rax+188]
  015df	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  015e7	f3 0f 58 c1	 addss	 xmm0, xmm1
  015eb	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  015f2	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0

; 1019 : 
; 1020 :         // Lock other positions
; 1021 :         // - ClipRect.Min.x: Because merging draw commands doesn't compare min boundaries, we make ClipRect.Min.x match left bounds to be consistent regardless of merging.
; 1022 :         // - ClipRect.Max.x: using WorkMaxX instead of MaxX (aka including padding) makes things more consistent when resizing down, tho slightly detrimental to visibility in very-small column.
; 1023 :         // - ClipRect.Max.x: using MaxX makes it easier for header to receive hover highlight with no discontinuity and display sorting arrow.
; 1024 :         // - FIXME-TABLE: We want equal width columns to have equal (ClipRect.Max.x - WorkMinX) width, which means ClipRect.max.x cannot stray off host_clip_rect.Max.x else right-most column may appear shorter.
; 1025 :         column->WorkMinX = column->MinX + table->CellPaddingX + table->CellSpacingX1;

  015f7	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  015fe	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01605	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  0160a	f3 0f 58 81 bc
	00 00 00	 addss	 xmm0, DWORD PTR [rcx+188]
  01612	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01619	f3 0f 58 80 c4
	00 00 00	 addss	 xmm0, DWORD PTR [rax+196]
  01621	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01628	f3 0f 11 40 34	 movss	 DWORD PTR [rax+52], xmm0

; 1026 :         column->WorkMaxX = column->MaxX - table->CellPaddingX - table->CellSpacingX2; // Expected max

  0162d	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01634	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0163b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  01640	f3 0f 5c 81 bc
	00 00 00	 subss	 xmm0, DWORD PTR [rcx+188]
  01648	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0164f	f3 0f 5c 80 c8
	00 00 00	 subss	 xmm0, DWORD PTR [rax+200]
  01657	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0165e	f3 0f 11 40 38	 movss	 DWORD PTR [rax+56], xmm0

; 1027 :         column->ItemWidth = ImFloor(column->WidthGiven * 0.65f);

  01663	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0166a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0166f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f266666
  01677	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  0167c	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01683	f3 0f 11 40 3c	 movss	 DWORD PTR [rax+60], xmm0

; 1028 :         column->ClipRect.Min.x = column->MinX;

  01688	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0168f	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  01696	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [rcx+8]
  0169b	f3 0f 11 40 20	 movss	 DWORD PTR [rax+32], xmm0

; 1029 :         column->ClipRect.Min.y = work_rect.Min.y;

  016a0	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  016a7	f3 0f 10 85 8c
	02 00 00	 movss	 xmm0, DWORD PTR work_rect$[rbp+4]
  016af	f3 0f 11 40 24	 movss	 DWORD PTR [rax+36], xmm0

; 1030 :         column->ClipRect.Max.x = column->MaxX; //column->WorkMaxX;

  016b4	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  016bb	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  016c2	f3 0f 10 41 0c	 movss	 xmm0, DWORD PTR [rcx+12]
  016c7	f3 0f 11 40 28	 movss	 DWORD PTR [rax+40], xmm0

; 1031 :         column->ClipRect.Max.y = FLT_MAX;

  016cc	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  016d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  016db	f3 0f 11 40 2c	 movss	 DWORD PTR [rax+44], xmm0

; 1032 :         column->ClipRect.ClipWithFull(host_clip_rect);

  016e0	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  016e7	48 83 c0 20	 add	 rax, 32			; 00000020H
  016eb	48 8d 95 e8 04
	00 00		 lea	 rdx, QWORD PTR host_clip_rect$[rbp]
  016f2	48 8b c8	 mov	 rcx, rax
  016f5	e8 00 00 00 00	 call	 ?ClipWithFull@ImRect@@QEAAXAEBU1@@Z ; ImRect::ClipWithFull

; 1033 : 
; 1034 :         // Mark column as Clipped (not in sight)
; 1035 :         // Note that scrolling tables (where inner_window != outer_window) handle Y clipped earlier in BeginTable() so IsVisibleY really only applies to non-scrolling tables.
; 1036 :         // FIXME-TABLE: Because InnerClipRect.Max.y is conservatively ==outer_window->ClipRect.Max.y, we never can mark columns _Above_ the scroll line as not IsVisibleY.
; 1037 :         // Taking advantage of LastOuterHeight would yield good results there...
; 1038 :         // FIXME-TABLE: Y clipping is disabled because it effectively means not submitting will reduce contents width which is fed to outer_window->DC.CursorMaxPos.x,
; 1039 :         // and this may be used (e.g. typically by outer_window using AlwaysAutoResize or outer_window's horizontal scrollbar, but could be something else).
; 1040 :         // Possible solution to preserve last known content width for clipped column. Test 'table_reported_size' fails when enabling Y clipping and window is resized small.
; 1041 :         column->IsVisibleX = (column->ClipRect.Max.x > column->ClipRect.Min.x);

  016fa	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01701	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  01708	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [rax+40]
  0170d	0f 2f 41 20	 comiss	 xmm0, DWORD PTR [rcx+32]
  01711	76 0c		 jbe	 SHORT $LN111@TableUpdat
  01713	c7 85 24 08 00
	00 01 00 00 00	 mov	 DWORD PTR tv808[rbp], 1
  0171d	eb 0a		 jmp	 SHORT $LN112@TableUpdat
$LN111@TableUpdat:
  0171f	c7 85 24 08 00
	00 00 00 00 00	 mov	 DWORD PTR tv808[rbp], 0
$LN112@TableUpdat:
  01729	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01730	0f b6 8d 24 08
	00 00		 movzx	 ecx, BYTE PTR tv808[rbp]
  01737	88 48 65	 mov	 BYTE PTR [rax+101], cl

; 1042 :         column->IsVisibleY = true; // (column->ClipRect.Max.y > column->ClipRect.Min.y);

  0173a	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01741	c6 40 66 01	 mov	 BYTE PTR [rax+102], 1

; 1043 :         const bool is_visible = column->IsVisibleX; //&& column->IsVisibleY;

  01745	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0174c	0f b6 40 65	 movzx	 eax, BYTE PTR [rax+101]
  01750	88 85 94 05 00
	00		 mov	 BYTE PTR is_visible$24[rbp], al

; 1044 :         if (is_visible)

  01756	0f b6 85 94 05
	00 00		 movzx	 eax, BYTE PTR is_visible$24[rbp]
  0175d	85 c0		 test	 eax, eax
  0175f	74 16		 je	 SHORT $LN65@TableUpdat

; 1045 :             ImBitArraySetBit(table->VisibleMaskByIndex, column_n);

  01761	8b 95 34 05 00
	00		 mov	 edx, DWORD PTR column_n$21[rbp]
  01767	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0176e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  01772	e8 00 00 00 00	 call	 ?ImBitArraySetBit@@YAXPEAIH@Z ; ImBitArraySetBit
$LN65@TableUpdat:

; 1046 : 
; 1047 :         // Mark column as requesting output from user. Note that fixed + non-resizable sets are auto-fitting at all times and therefore always request output.
; 1048 :         column->IsRequestOutput = is_visible || column->AutoFitQueue != 0 || column->CannotSkipItemsQueue != 0;

  01777	0f b6 85 94 05
	00 00		 movzx	 eax, BYTE PTR is_visible$24[rbp]
  0177e	85 c0		 test	 eax, eax
  01780	75 2a		 jne	 SHORT $LN113@TableUpdat
  01782	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01789	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  0178d	85 c0		 test	 eax, eax
  0178f	75 1b		 jne	 SHORT $LN113@TableUpdat
  01791	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01798	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  0179c	85 c0		 test	 eax, eax
  0179e	75 0c		 jne	 SHORT $LN113@TableUpdat
  017a0	c7 85 24 08 00
	00 00 00 00 00	 mov	 DWORD PTR tv826[rbp], 0
  017aa	eb 0a		 jmp	 SHORT $LN114@TableUpdat
$LN113@TableUpdat:
  017ac	c7 85 24 08 00
	00 01 00 00 00	 mov	 DWORD PTR tv826[rbp], 1
$LN114@TableUpdat:
  017b6	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  017bd	0f b6 8d 24 08
	00 00		 movzx	 ecx, BYTE PTR tv826[rbp]
  017c4	88 48 67	 mov	 BYTE PTR [rax+103], cl

; 1049 : 
; 1050 :         // Mark column as SkipItems (ignoring all items/layout)
; 1051 :         column->IsSkipItems = !column->IsEnabled || table->HostSkipItems;

  017c7	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  017ce	0f b6 40 62	 movzx	 eax, BYTE PTR [rax+98]
  017d2	85 c0		 test	 eax, eax
  017d4	74 1e		 je	 SHORT $LN115@TableUpdat
  017d6	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  017dd	0f b6 80 32 02
	00 00		 movzx	 eax, BYTE PTR [rax+562]
  017e4	85 c0		 test	 eax, eax
  017e6	75 0c		 jne	 SHORT $LN115@TableUpdat
  017e8	c7 85 24 08 00
	00 00 00 00 00	 mov	 DWORD PTR tv835[rbp], 0
  017f2	eb 0a		 jmp	 SHORT $LN116@TableUpdat
$LN115@TableUpdat:
  017f4	c7 85 24 08 00
	00 01 00 00 00	 mov	 DWORD PTR tv835[rbp], 1
$LN116@TableUpdat:
  017fe	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01805	0f b6 8d 24 08
	00 00		 movzx	 ecx, BYTE PTR tv835[rbp]
  0180c	88 48 68	 mov	 BYTE PTR [rax+104], cl

; 1052 :         if (column->IsSkipItems)

  0180f	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01816	0f b6 40 68	 movzx	 eax, BYTE PTR [rax+104]
  0181a	85 c0		 test	 eax, eax
  0181c	74 2f		 je	 SHORT $LN66@TableUpdat

; 1053 :             IM_ASSERT(!is_visible);

  0181e	0f b6 85 94 05
	00 00		 movzx	 eax, BYTE PTR is_visible$24[rbp]
  01825	85 c0		 test	 eax, eax
  01827	74 24		 je	 SHORT $LN117@TableUpdat
  01829	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  0182f	05 42 01 00 00	 add	 eax, 322		; 00000142H
  01834	44 8b c0	 mov	 r8d, eax
  01837	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0183e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@PMBHHKFI@?$AA?$CB?$AAi?$AAs?$AA_?$AAv?$AAi?$AAs?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
  01845	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0184b	33 c0		 xor	 eax, eax
$LN117@TableUpdat:
$LN66@TableUpdat:

; 1054 : 
; 1055 :         // Update status flags
; 1056 :         column->Flags |= ImGuiTableColumnFlags_IsEnabled;

  0184d	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01854	8b 00		 mov	 eax, DWORD PTR [rax]
  01856	0f ba e8 18	 bts	 eax, 24
  0185a	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  01861	89 01		 mov	 DWORD PTR [rcx], eax

; 1057 :         if (is_visible)

  01863	0f b6 85 94 05
	00 00		 movzx	 eax, BYTE PTR is_visible$24[rbp]
  0186a	85 c0		 test	 eax, eax
  0186c	74 16		 je	 SHORT $LN67@TableUpdat

; 1058 :             column->Flags |= ImGuiTableColumnFlags_IsVisible;

  0186e	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01875	8b 00		 mov	 eax, DWORD PTR [rax]
  01877	0f ba e8 19	 bts	 eax, 25
  0187b	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  01882	89 01		 mov	 DWORD PTR [rcx], eax
$LN67@TableUpdat:

; 1059 :         if (column->SortOrder != -1)

  01884	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0188b	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  0188f	83 f8 ff	 cmp	 eax, -1
  01892	74 16		 je	 SHORT $LN68@TableUpdat

; 1060 :             column->Flags |= ImGuiTableColumnFlags_IsSorted;

  01894	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0189b	8b 00		 mov	 eax, DWORD PTR [rax]
  0189d	0f ba e8 1a	 bts	 eax, 26
  018a1	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  018a8	89 01		 mov	 DWORD PTR [rcx], eax
$LN68@TableUpdat:

; 1061 :         if (table->HoveredColumnBody == column_n)

  018aa	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  018b1	0f bf 80 f8 01
	00 00		 movsx	 eax, WORD PTR [rax+504]
  018b8	3b 85 34 05 00
	00		 cmp	 eax, DWORD PTR column_n$21[rbp]
  018be	75 16		 jne	 SHORT $LN69@TableUpdat

; 1062 :             column->Flags |= ImGuiTableColumnFlags_IsHovered;

  018c0	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  018c7	8b 00		 mov	 eax, DWORD PTR [rax]
  018c9	0f ba e8 1b	 bts	 eax, 27
  018cd	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  018d4	89 01		 mov	 DWORD PTR [rcx], eax
$LN69@TableUpdat:

; 1063 : 
; 1064 :         // Alignment
; 1065 :         // FIXME-TABLE: This align based on the whole column width, not per-cell, and therefore isn't useful in
; 1066 :         // many cases (to be able to honor this we might be able to store a log of cells width, per row, for
; 1067 :         // visible rows, but nav/programmatic scroll would have visible artifacts.)
; 1068 :         //if (column->Flags & ImGuiTableColumnFlags_AlignRight)
; 1069 :         //    column->WorkMinX = ImMax(column->WorkMinX, column->MaxX - column->ContentWidthRowsUnfrozen);
; 1070 :         //else if (column->Flags & ImGuiTableColumnFlags_AlignCenter)
; 1071 :         //    column->WorkMinX = ImLerp(column->WorkMinX, ImMax(column->StartX, column->MaxX - column->ContentWidthRowsUnfrozen), 0.5f);
; 1072 : 
; 1073 :         // Reset content width variables
; 1074 :         column->ContentMaxXFrozen = column->ContentMaxXUnfrozen = column->WorkMinX;

  018d6	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  018dd	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  018e4	f3 0f 10 41 34	 movss	 xmm0, DWORD PTR [rcx+52]
  018e9	f3 0f 11 40 44	 movss	 DWORD PTR [rax+68], xmm0
  018ee	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  018f5	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  018fc	f3 0f 10 41 44	 movss	 xmm0, DWORD PTR [rcx+68]
  01901	f3 0f 11 40 40	 movss	 DWORD PTR [rax+64], xmm0

; 1075 :         column->ContentMaxXHeadersUsed = column->ContentMaxXHeadersIdeal = column->WorkMinX;

  01906	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0190d	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  01914	f3 0f 10 41 34	 movss	 xmm0, DWORD PTR [rcx+52]
  01919	f3 0f 11 40 4c	 movss	 DWORD PTR [rax+76], xmm0
  0191e	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01925	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  0192c	f3 0f 10 41 4c	 movss	 xmm0, DWORD PTR [rcx+76]
  01931	f3 0f 11 40 48	 movss	 DWORD PTR [rax+72], xmm0

; 1076 : 
; 1077 :         // Don't decrement auto-fit counters until container window got a chance to submit its items
; 1078 :         if (table->HostSkipItems == false)

  01936	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0193d	0f b6 80 32 02
	00 00		 movzx	 eax, BYTE PTR [rax+562]
  01944	85 c0		 test	 eax, eax
  01946	75 2e		 jne	 SHORT $LN70@TableUpdat

; 1079 :         {
; 1080 :             column->AutoFitQueue >>= 1;

  01948	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  0194f	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  01953	d0 e8		 shr	 al, 1
  01955	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  0195c	88 41 6b	 mov	 BYTE PTR [rcx+107], al

; 1081 :             column->CannotSkipItemsQueue >>= 1;

  0195f	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01966	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  0196a	d0 e8		 shr	 al, 1
  0196c	48 8b 8d 58 05
	00 00		 mov	 rcx, QWORD PTR column$22[rbp]
  01973	88 41 6c	 mov	 BYTE PTR [rcx+108], al
$LN70@TableUpdat:

; 1082 :         }
; 1083 : 
; 1084 :         if (visible_n < table->FreezeColumnsCount)

  01976	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0197d	0f bf 80 18 02
	00 00		 movsx	 eax, WORD PTR [rax+536]
  01984	39 85 84 04 00
	00		 cmp	 DWORD PTR visible_n$[rbp], eax
  0198a	7d 31		 jge	 SHORT $LN71@TableUpdat

; 1085 :             host_clip_rect.Min.x = ImClamp(column->MaxX + TABLE_BORDER_SIZE, host_clip_rect.Min.x, host_clip_rect.Max.x);

  0198c	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  01993	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  01998	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  019a0	f3 0f 10 95 f0
	04 00 00	 movss	 xmm2, DWORD PTR host_clip_rect$[rbp+8]
  019a8	f3 0f 10 8d e8
	04 00 00	 movss	 xmm1, DWORD PTR host_clip_rect$[rbp]
  019b0	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  019b5	f3 0f 11 85 e8
	04 00 00	 movss	 DWORD PTR host_clip_rect$[rbp], xmm0
$LN71@TableUpdat:

; 1086 : 
; 1087 :         offset_x += column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;

  019bd	48 8b 85 58 05
	00 00		 mov	 rax, QWORD PTR column$22[rbp]
  019c4	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  019cb	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  019d0	f3 0f 58 81 c4
	00 00 00	 addss	 xmm0, DWORD PTR [rcx+196]
  019d8	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  019df	f3 0f 58 80 c8
	00 00 00	 addss	 xmm0, DWORD PTR [rax+200]
  019e7	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  019ee	f3 0f 10 88 bc
	00 00 00	 movss	 xmm1, DWORD PTR [rax+188]
  019f6	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  019fe	f3 0f 58 c1	 addss	 xmm0, xmm1
  01a02	f3 0f 10 8d c4
	04 00 00	 movss	 xmm1, DWORD PTR offset_x$[rbp]
  01a0a	f3 0f 58 c8	 addss	 xmm1, xmm0
  01a0e	0f 28 c1	 movaps	 xmm0, xmm1
  01a11	f3 0f 11 85 c4
	04 00 00	 movss	 DWORD PTR offset_x$[rbp], xmm0

; 1088 :         visible_n++;

  01a19	8b 85 84 04 00
	00		 mov	 eax, DWORD PTR visible_n$[rbp]
  01a1f	ff c0		 inc	 eax
  01a21	89 85 84 04 00
	00		 mov	 DWORD PTR visible_n$[rbp], eax

; 1089 :     }

  01a27	e9 3f f8 ff ff	 jmp	 $LN14@TableUpdat
$LN15@TableUpdat:

; 1090 : 
; 1091 :     // [Part 7] Detect/store when we are hovering the unused space after the right-most column (so e.g. context menus can react on it)
; 1092 :     // Clear Resizable flag if none of our column are actually resizable (either via an explicit _NoResize flag, either
; 1093 :     // because of using _WidthAuto/_WidthStretch). This will hide the resizing option from the context menu.
; 1094 :     const float unused_x1 = ImMax(table->WorkRect.Min.x, table->Columns[table->RightMostEnabledColumn].ClipRect.Max.x);

  01a2c	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01a33	0f bf 80 0a 02
	00 00		 movsx	 eax, WORD PTR [rax+522]
  01a3a	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01a41	48 83 c1 18	 add	 rcx, 24
  01a45	8b d0		 mov	 edx, eax
  01a47	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  01a4c	f3 0f 10 48 28	 movss	 xmm1, DWORD PTR [rax+40]
  01a51	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01a58	f3 0f 10 80 08
	01 00 00	 movss	 xmm0, DWORD PTR [rax+264]
  01a60	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  01a65	f3 0f 11 85 b4
	05 00 00	 movss	 DWORD PTR unused_x1$[rbp], xmm0

; 1095 :     if (is_hovering_table && table->HoveredColumnBody == -1)

  01a6d	0f b6 85 64 04
	00 00		 movzx	 eax, BYTE PTR is_hovering_table$[rbp]
  01a74	85 c0		 test	 eax, eax
  01a76	74 41		 je	 SHORT $LN72@TableUpdat
  01a78	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01a7f	0f bf 80 f8 01
	00 00		 movsx	 eax, WORD PTR [rax+504]
  01a86	83 f8 ff	 cmp	 eax, -1
  01a89	75 2e		 jne	 SHORT $LN72@TableUpdat

; 1096 :     {
; 1097 :         if (g.IO.MousePos.x >= unused_x1)

  01a8b	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  01a8f	f3 0f 10 80 fc
	0d 00 00	 movss	 xmm0, DWORD PTR [rax+3580]
  01a97	0f 2f 85 b4 05
	00 00		 comiss	 xmm0, DWORD PTR unused_x1$[rbp]
  01a9e	72 19		 jb	 SHORT $LN73@TableUpdat

; 1098 :             table->HoveredColumnBody = (ImGuiTableColumnIdx)table->ColumnsCount;

  01aa0	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01aa7	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01aae	0f b7 49 6c	 movzx	 ecx, WORD PTR [rcx+108]
  01ab2	66 89 88 f8 01
	00 00		 mov	 WORD PTR [rax+504], cx
$LN73@TableUpdat:
$LN72@TableUpdat:

; 1099 :     }
; 1100 :     if (has_resizable == false && (table->Flags & ImGuiTableFlags_Resizable))

  01ab9	0f b6 85 c4 00
	00 00		 movzx	 eax, BYTE PTR has_resizable$[rbp]
  01ac0	85 c0		 test	 eax, eax
  01ac2	75 28		 jne	 SHORT $LN74@TableUpdat
  01ac4	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01acb	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01ace	83 e0 01	 and	 eax, 1
  01ad1	85 c0		 test	 eax, eax
  01ad3	74 17		 je	 SHORT $LN74@TableUpdat

; 1101 :         table->Flags &= ~ImGuiTableFlags_Resizable;

  01ad5	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01adc	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01adf	83 e0 fe	 and	 eax, -2
  01ae2	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01ae9	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN74@TableUpdat:

; 1102 : 
; 1103 :     // [Part 8] Lock actual OuterRect/WorkRect right-most position.
; 1104 :     // This is done late to handle the case of fixed-columns tables not claiming more widths that they need.
; 1105 :     // Because of this we are careful with uses of WorkRect and InnerClipRect before this point.
; 1106 :     if (table->RightMostStretchedColumn != -1)

  01aec	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01af3	0f bf 80 0e 02
	00 00		 movsx	 eax, WORD PTR [rax+526]
  01afa	83 f8 ff	 cmp	 eax, -1
  01afd	74 18		 je	 SHORT $LN75@TableUpdat

; 1107 :         table->Flags &= ~ImGuiTableFlags_NoHostExtendX;

  01aff	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01b06	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01b09	0f ba f0 10	 btr	 eax, 16
  01b0d	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01b14	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN75@TableUpdat:

; 1108 :     if (table->Flags & ImGuiTableFlags_NoHostExtendX)

  01b17	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01b1e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01b21	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  01b26	85 c0		 test	 eax, eax
  01b28	74 59		 je	 SHORT $LN76@TableUpdat

; 1109 :     {
; 1110 :         table->OuterRect.Max.x = table->WorkRect.Max.x = unused_x1;

  01b2a	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01b31	f3 0f 10 85 b4
	05 00 00	 movss	 xmm0, DWORD PTR unused_x1$[rbp]
  01b39	f3 0f 11 80 10
	01 00 00	 movss	 DWORD PTR [rax+272], xmm0
  01b41	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01b48	f3 0f 10 85 b4
	05 00 00	 movss	 xmm0, DWORD PTR unused_x1$[rbp]
  01b50	f3 0f 11 80 f0
	00 00 00	 movss	 DWORD PTR [rax+240], xmm0

; 1111 :         table->InnerClipRect.Max.x = ImMin(table->InnerClipRect.Max.x, unused_x1);

  01b58	f3 0f 10 8d b4
	05 00 00	 movss	 xmm1, DWORD PTR unused_x1$[rbp]
  01b60	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01b67	f3 0f 10 80 20
	01 00 00	 movss	 xmm0, DWORD PTR [rax+288]
  01b6f	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  01b74	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01b7b	f3 0f 11 80 20
	01 00 00	 movss	 DWORD PTR [rax+288], xmm0
$LN76@TableUpdat:

; 1112 :     }
; 1113 :     table->InnerWindow->ParentWorkRect = table->WorkRect;

  01b83	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01b8a	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  01b91	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01b98	48 8d b8 20 02
	00 00		 lea	 rdi, QWORD PTR [rax+544]
  01b9f	48 8d b1 08 01
	00 00		 lea	 rsi, QWORD PTR [rcx+264]
  01ba6	b9 10 00 00 00	 mov	 ecx, 16
  01bab	f3 a4		 rep movsb

; 1114 :     table->BorderX1 = table->InnerClipRect.Min.x;// +((table->Flags & ImGuiTableFlags_BordersOuter) ? 0.0f : -1.0f);

  01bad	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01bb4	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01bbb	f3 0f 10 81 18
	01 00 00	 movss	 xmm0, DWORD PTR [rcx+280]
  01bc3	f3 0f 11 80 a8
	00 00 00	 movss	 DWORD PTR [rax+168], xmm0

; 1115 :     table->BorderX2 = table->InnerClipRect.Max.x;// +((table->Flags & ImGuiTableFlags_BordersOuter) ? 0.0f : +1.0f);

  01bcb	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01bd2	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01bd9	f3 0f 10 81 20
	01 00 00	 movss	 xmm0, DWORD PTR [rcx+288]
  01be1	f3 0f 11 80 ac
	00 00 00	 movss	 DWORD PTR [rax+172], xmm0

; 1116 : 
; 1117 :     // [Part 9] Allocate draw channels and setup background cliprect
; 1118 :     TableSetupDrawChannels(table);

  01be9	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01bf0	e8 00 00 00 00	 call	 ?TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableSetupDrawChannels

; 1119 : 
; 1120 :     // [Part 10] Hit testing on borders
; 1121 :     if (table->Flags & ImGuiTableFlags_Resizable)

  01bf5	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01bfc	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01bff	83 e0 01	 and	 eax, 1
  01c02	85 c0		 test	 eax, eax
  01c04	74 0c		 je	 SHORT $LN77@TableUpdat

; 1122 :         TableUpdateBorders(table);

  01c06	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01c0d	e8 00 00 00 00	 call	 ?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableUpdateBorders
$LN77@TableUpdat:

; 1123 :     table_instance->LastFirstRowHeight = 0.0f;

  01c12	48 8b 85 f8 03
	00 00		 mov	 rax, QWORD PTR table_instance$[rbp]
  01c19	0f 57 c0	 xorps	 xmm0, xmm0
  01c1c	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 1124 :     table->IsLayoutLocked = true;

  01c21	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01c28	c6 80 22 02 00
	00 01		 mov	 BYTE PTR [rax+546], 1

; 1125 :     table->IsUsingHeaders = false;

  01c2f	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01c36	c6 80 26 02 00
	00 00		 mov	 BYTE PTR [rax+550], 0

; 1126 : 
; 1127 :     // [Part 11] Context menu
; 1128 :     if (TableBeginContextMenuPopup(table))

  01c3d	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01c44	e8 00 00 00 00	 call	 ?TableBeginContextMenuPopup@ImGui@@YA_NPEAUImGuiTable@@@Z ; ImGui::TableBeginContextMenuPopup
  01c49	0f b6 c0	 movzx	 eax, al
  01c4c	85 c0		 test	 eax, eax
  01c4e	74 11		 je	 SHORT $LN78@TableUpdat

; 1129 :     {
; 1130 :         TableDrawContextMenu(table);

  01c50	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01c57	e8 00 00 00 00	 call	 ?TableDrawContextMenu@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableDrawContextMenu

; 1131 :         EndPopup();

  01c5c	e8 00 00 00 00	 call	 ?EndPopup@ImGui@@YAXXZ	; ImGui::EndPopup
$LN78@TableUpdat:

; 1132 :     }
; 1133 : 
; 1134 :     // [Part 13] Sanitize and build sort specs before we have a change to use them for display.
; 1135 :     // This path will only be exercised when sort specs are modified before header rows (e.g. init or visibility change)
; 1136 :     if (table->IsSortSpecsDirty && (table->Flags & ImGuiTableFlags_Sortable))

  01c61	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01c68	0f b6 80 25 02
	00 00		 movzx	 eax, BYTE PTR [rax+549]
  01c6f	85 c0		 test	 eax, eax
  01c71	74 1d		 je	 SHORT $LN79@TableUpdat
  01c73	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01c7a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01c7d	83 e0 08	 and	 eax, 8
  01c80	85 c0		 test	 eax, eax
  01c82	74 0c		 je	 SHORT $LN79@TableUpdat

; 1137 :         TableSortSpecsBuild(table);

  01c84	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01c8b	e8 00 00 00 00	 call	 ?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableSortSpecsBuild
$LN79@TableUpdat:

; 1138 : 
; 1139 :     // [Part 14] Setup inner window decoration size (for scrolling / nav tracking to properly take account of frozen rows/columns)
; 1140 :     if (table->FreezeColumnsRequest > 0)

  01c90	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01c97	0f bf 80 16 02
	00 00		 movsx	 eax, WORD PTR [rax+534]
  01c9e	85 c0		 test	 eax, eax
  01ca0	7e 5e		 jle	 SHORT $LN80@TableUpdat

; 1141 :         table->InnerWindow->DecoInnerSizeX1 = table->Columns[table->DisplayOrderToIndex[table->FreezeColumnsRequest - 1]].MaxX - table->OuterRect.Min.x;

  01ca2	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01ca9	0f bf 80 16 02
	00 00		 movsx	 eax, WORD PTR [rax+534]
  01cb0	ff c8		 dec	 eax
  01cb2	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01cb9	48 83 c1 28	 add	 rcx, 40			; 00000028H
  01cbd	8b d0		 mov	 edx, eax
  01cbf	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  01cc4	0f bf 00	 movsx	 eax, WORD PTR [rax]
  01cc7	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01cce	48 83 c1 18	 add	 rcx, 24
  01cd2	8b d0		 mov	 edx, eax
  01cd4	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  01cd9	48 8b 8d 60 08
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01ce0	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  01ce5	f3 0f 5c 81 e8
	00 00 00	 subss	 xmm0, DWORD PTR [rcx+232]
  01ced	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01cf4	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  01cfb	f3 0f 11 40 68	 movss	 DWORD PTR [rax+104], xmm0
$LN80@TableUpdat:

; 1142 :     if (table->FreezeRowsRequest > 0)

  01d00	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01d07	0f bf 80 12 02
	00 00		 movsx	 eax, WORD PTR [rax+530]
  01d0e	85 c0		 test	 eax, eax
  01d10	7e 1f		 jle	 SHORT $LN81@TableUpdat

; 1143 :         table->InnerWindow->DecoInnerSizeY1 = table_instance->LastFrozenHeight;

  01d12	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01d19	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  01d20	48 8b 8d f8 03
	00 00		 mov	 rcx, QWORD PTR table_instance$[rbp]
  01d27	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [rcx+8]
  01d2c	f3 0f 11 40 6c	 movss	 DWORD PTR [rax+108], xmm0
$LN81@TableUpdat:

; 1144 :     table_instance->LastFrozenHeight = 0.0f;

  01d31	48 8b 85 f8 03
	00 00		 mov	 rax, QWORD PTR table_instance$[rbp]
  01d38	0f 57 c0	 xorps	 xmm0, xmm0
  01d3b	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 1145 : 
; 1146 :     // Initial state
; 1147 :     ImGuiWindow* inner_window = table->InnerWindow;

  01d40	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01d47	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  01d4e	48 89 85 d8 05
	00 00		 mov	 QWORD PTR inner_window$[rbp], rax

; 1148 :     if (table->Flags & ImGuiTableFlags_NoClip)

  01d55	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01d5c	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01d5f	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  01d64	85 c0		 test	 eax, eax
  01d66	74 29		 je	 SHORT $LN82@TableUpdat

; 1149 :         table->DrawSplitter->SetCurrentChannel(inner_window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);

  01d68	41 b8 02 00 00
	00		 mov	 r8d, 2
  01d6e	48 8b 85 d8 05
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  01d75	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  01d7c	48 8b 85 60 08
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01d83	48 8b 88 98 01
	00 00		 mov	 rcx, QWORD PTR [rax+408]
  01d8a	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 1150 :     else

  01d8f	eb 37		 jmp	 SHORT $LN83@TableUpdat
$LN82@TableUpdat:

; 1151 :         inner_window->DrawList->PushClipRect(inner_window->ClipRect.Min, inner_window->ClipRect.Max, false);

  01d91	48 8b 85 d8 05
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  01d98	48 05 38 02 00
	00		 add	 rax, 568		; 00000238H
  01d9e	48 8b 8d d8 05
	00 00		 mov	 rcx, QWORD PTR inner_window$[rbp]
  01da5	48 81 c1 30 02
	00 00		 add	 rcx, 560		; 00000230H
  01dac	45 33 c9	 xor	 r9d, r9d
  01daf	4c 8b c0	 mov	 r8, rax
  01db2	48 8b d1	 mov	 rdx, rcx
  01db5	48 8b 85 d8 05
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  01dbc	48 8b 88 90 02
	00 00		 mov	 rcx, QWORD PTR [rax+656]
  01dc3	e8 00 00 00 00	 call	 ?PushClipRect@ImDrawList@@QEAAXAEBUImVec2@@0_N@Z ; ImDrawList::PushClipRect
$LN83@TableUpdat:

; 1152 : }

  01dc8	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  01dcc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z$rtcFrameData
  01dd3	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  01dd8	48 8b 8d 30 08
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  01ddf	48 33 cd	 xor	 rcx, rbp
  01de2	e8 00 00 00 00	 call	 __security_check_cookie
  01de7	48 8d a5 40 08
	00 00		 lea	 rsp, QWORD PTR [rbp+2112]
  01dee	5f		 pop	 rdi
  01def	5e		 pop	 rsi
  01df0	5d		 pop	 rbp
  01df1	c3		 ret	 0
?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z ENDP	; ImGui::TableUpdateLayout
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
freeze_row_multiplier$ = 4
channels_for_row$ = 36
channels_for_bg$ = 68
channels_for_dummy$ = 100
channels_total$ = 132
draw_channel_current$ = 164
column_n$1 = 196
column$2 = 232
tv163 = 436
tv142 = 436
tv134 = 436
tv89 = 436
tv73 = 436
tv67 = 436
table$ = 480
?TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z PROC ; ImGui::TableSetupDrawChannels, COMDAT

; 2293 : {

$LN22:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 81 ec e0 01
	00 00		 sub	 rsp, 480		; 000001e0H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR [rsp+520]

; 2294 :     const int freeze_row_multiplier = (table->FreezeRowsCount > 0) ? 2 : 1;

  0002b	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00032	0f bf 80 14 02
	00 00		 movsx	 eax, WORD PTR [rax+532]
  00039	85 c0		 test	 eax, eax
  0003b	7e 0c		 jle	 SHORT $LN9@TableSetup
  0003d	c7 85 b4 01 00
	00 02 00 00 00	 mov	 DWORD PTR tv67[rbp], 2
  00047	eb 0a		 jmp	 SHORT $LN10@TableSetup
$LN9@TableSetup:
  00049	c7 85 b4 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv67[rbp], 1
$LN10@TableSetup:
  00053	8b 85 b4 01 00
	00		 mov	 eax, DWORD PTR tv67[rbp]
  00059	89 45 04	 mov	 DWORD PTR freeze_row_multiplier$[rbp], eax

; 2295 :     const int channels_for_row = (table->Flags & ImGuiTableFlags_NoClip) ? 1 : table->ColumnsEnabledCount;

  0005c	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00063	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00066	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  0006b	85 c0		 test	 eax, eax
  0006d	74 0c		 je	 SHORT $LN11@TableSetup
  0006f	c7 85 b4 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv73[rbp], 1
  00079	eb 14		 jmp	 SHORT $LN12@TableSetup
$LN11@TableSetup:
  0007b	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00082	0f bf 80 f2 01
	00 00		 movsx	 eax, WORD PTR [rax+498]
  00089	89 85 b4 01 00
	00		 mov	 DWORD PTR tv73[rbp], eax
$LN12@TableSetup:
  0008f	8b 85 b4 01 00
	00		 mov	 eax, DWORD PTR tv73[rbp]
  00095	89 45 24	 mov	 DWORD PTR channels_for_row$[rbp], eax

; 2296 :     const int channels_for_bg = 1 + 1 * freeze_row_multiplier;

  00098	8b 45 04	 mov	 eax, DWORD PTR freeze_row_multiplier$[rbp]
  0009b	ff c0		 inc	 eax
  0009d	89 45 44	 mov	 DWORD PTR channels_for_bg$[rbp], eax

; 2297 :     const int channels_for_dummy = (table->ColumnsEnabledCount < table->ColumnsCount || (memcmp(table->VisibleMaskByIndex, table->EnabledMaskByIndex, ImBitArrayGetStorageSizeInBytes(table->ColumnsCount)) != 0)) ? +1 : 0;

  000a0	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000a7	0f bf 80 f2 01
	00 00		 movsx	 eax, WORD PTR [rax+498]
  000ae	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000b5	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  000b8	7c 3d		 jl	 SHORT $LN13@TableSetup
  000ba	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000c1	8b 48 6c	 mov	 ecx, DWORD PTR [rax+108]
  000c4	e8 00 00 00 00	 call	 ?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z ; ImBitArrayGetStorageSizeInBytes
  000c9	4c 8b c0	 mov	 r8, rax
  000cc	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000d3	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  000d7	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000de	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000e2	e8 00 00 00 00	 call	 memcmp
  000e7	85 c0		 test	 eax, eax
  000e9	75 0c		 jne	 SHORT $LN13@TableSetup
  000eb	c7 85 b4 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv89[rbp], 0
  000f5	eb 0a		 jmp	 SHORT $LN14@TableSetup
$LN13@TableSetup:
  000f7	c7 85 b4 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv89[rbp], 1
$LN14@TableSetup:
  00101	8b 85 b4 01 00
	00		 mov	 eax, DWORD PTR tv89[rbp]
  00107	89 45 64	 mov	 DWORD PTR channels_for_dummy$[rbp], eax

; 2298 :     const int channels_total = channels_for_bg + (channels_for_row * freeze_row_multiplier) + channels_for_dummy;

  0010a	8b 45 24	 mov	 eax, DWORD PTR channels_for_row$[rbp]
  0010d	0f af 45 04	 imul	 eax, DWORD PTR freeze_row_multiplier$[rbp]
  00111	8b 4d 44	 mov	 ecx, DWORD PTR channels_for_bg$[rbp]
  00114	03 c8		 add	 ecx, eax
  00116	8b c1		 mov	 eax, ecx
  00118	03 45 64	 add	 eax, DWORD PTR channels_for_dummy$[rbp]
  0011b	89 85 84 00 00
	00		 mov	 DWORD PTR channels_total$[rbp], eax

; 2299 :     table->DrawSplitter->Split(table->InnerWindow->DrawList, channels_total);

  00121	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00128	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  0012f	44 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR channels_total$[rbp]
  00136	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  0013d	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00144	48 8b 88 98 01
	00 00		 mov	 rcx, QWORD PTR [rax+408]
  0014b	e8 00 00 00 00	 call	 ?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::Split

; 2300 :     table->DummyDrawChannel = (ImGuiTableDrawChannelIdx)((channels_for_dummy > 0) ? channels_total - 1 : -1);

  00150	83 7d 64 00	 cmp	 DWORD PTR channels_for_dummy$[rbp], 0
  00154	7e 10		 jle	 SHORT $LN15@TableSetup
  00156	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR channels_total$[rbp]
  0015c	ff c8		 dec	 eax
  0015e	89 85 b4 01 00
	00		 mov	 DWORD PTR tv134[rbp], eax
  00164	eb 0a		 jmp	 SHORT $LN16@TableSetup
$LN15@TableSetup:
  00166	c7 85 b4 01 00
	00 ff ff ff ff	 mov	 DWORD PTR tv134[rbp], -1
$LN16@TableSetup:
  00170	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00177	0f b7 8d b4 01
	00 00		 movzx	 ecx, WORD PTR tv134[rbp]
  0017e	66 89 88 1c 02
	00 00		 mov	 WORD PTR [rax+540], cx

; 2301 :     table->Bg2DrawChannelCurrent = TABLE_DRAW_CHANNEL_BG2_FROZEN;

  00185	b8 01 00 00 00	 mov	 eax, 1
  0018a	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00191	66 89 81 1e 02
	00 00		 mov	 WORD PTR [rcx+542], ax

; 2302 :     table->Bg2DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)((table->FreezeRowsCount > 0) ? 2 + channels_for_row : TABLE_DRAW_CHANNEL_BG2_FROZEN);

  00198	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0019f	0f bf 80 14 02
	00 00		 movsx	 eax, WORD PTR [rax+532]
  001a6	85 c0		 test	 eax, eax
  001a8	7e 0e		 jle	 SHORT $LN17@TableSetup
  001aa	8b 45 24	 mov	 eax, DWORD PTR channels_for_row$[rbp]
  001ad	83 c0 02	 add	 eax, 2
  001b0	89 85 b4 01 00
	00		 mov	 DWORD PTR tv142[rbp], eax
  001b6	eb 0a		 jmp	 SHORT $LN18@TableSetup
$LN17@TableSetup:
  001b8	c7 85 b4 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv142[rbp], 1
$LN18@TableSetup:
  001c2	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001c9	0f b7 8d b4 01
	00 00		 movzx	 ecx, WORD PTR tv142[rbp]
  001d0	66 89 88 20 02
	00 00		 mov	 WORD PTR [rax+544], cx

; 2303 : 
; 2304 :     int draw_channel_current = 2;

  001d7	c7 85 a4 00 00
	00 02 00 00 00	 mov	 DWORD PTR draw_channel_current$[rbp], 2

; 2305 :     for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  001e1	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$1[rbp], 0
  001eb	eb 0e		 jmp	 SHORT $LN4@TableSetup
$LN2@TableSetup:
  001ed	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR column_n$1[rbp]
  001f3	ff c0		 inc	 eax
  001f5	89 85 c4 00 00
	00		 mov	 DWORD PTR column_n$1[rbp], eax
$LN4@TableSetup:
  001fb	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00202	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00205	39 85 c4 00 00
	00		 cmp	 DWORD PTR column_n$1[rbp], eax
  0020b	0f 8d 05 01 00
	00		 jge	 $LN3@TableSetup

; 2306 :     {
; 2307 :         ImGuiTableColumn* column = &table->Columns[column_n];

  00211	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00218	48 83 c0 18	 add	 rax, 24
  0021c	8b 95 c4 00 00
	00		 mov	 edx, DWORD PTR column_n$1[rbp]
  00222	48 8b c8	 mov	 rcx, rax
  00225	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  0022a	48 89 85 e8 00
	00 00		 mov	 QWORD PTR column$2[rbp], rax

; 2308 :         if (column->IsVisibleX && column->IsVisibleY)

  00231	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR column$2[rbp]
  00238	0f b6 40 65	 movzx	 eax, BYTE PTR [rax+101]
  0023c	85 c0		 test	 eax, eax
  0023e	0f 84 88 00 00
	00		 je	 $LN5@TableSetup
  00244	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR column$2[rbp]
  0024b	0f b6 40 66	 movzx	 eax, BYTE PTR [rax+102]
  0024f	85 c0		 test	 eax, eax
  00251	74 79		 je	 SHORT $LN5@TableSetup

; 2309 :         {
; 2310 :             column->DrawChannelFrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current);

  00253	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR column$2[rbp]
  0025a	0f b7 8d a4 00
	00 00		 movzx	 ecx, WORD PTR draw_channel_current$[rbp]
  00261	66 89 48 5e	 mov	 WORD PTR [rax+94], cx

; 2311 :             column->DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current + (table->FreezeRowsCount > 0 ? channels_for_row + 1 : 0));

  00265	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0026c	0f bf 80 14 02
	00 00		 movsx	 eax, WORD PTR [rax+532]
  00273	85 c0		 test	 eax, eax
  00275	7e 0d		 jle	 SHORT $LN19@TableSetup
  00277	8b 45 24	 mov	 eax, DWORD PTR channels_for_row$[rbp]
  0027a	ff c0		 inc	 eax
  0027c	89 85 b4 01 00
	00		 mov	 DWORD PTR tv163[rbp], eax
  00282	eb 0a		 jmp	 SHORT $LN20@TableSetup
$LN19@TableSetup:
  00284	c7 85 b4 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv163[rbp], 0
$LN20@TableSetup:
  0028e	8b 85 b4 01 00
	00		 mov	 eax, DWORD PTR tv163[rbp]
  00294	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR draw_channel_current$[rbp]
  0029a	03 c8		 add	 ecx, eax
  0029c	8b c1		 mov	 eax, ecx
  0029e	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR column$2[rbp]
  002a5	66 89 41 60	 mov	 WORD PTR [rcx+96], ax

; 2312 :             if (!(table->Flags & ImGuiTableFlags_NoClip))

  002a9	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  002b0	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002b3	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  002b8	85 c0		 test	 eax, eax
  002ba	75 0e		 jne	 SHORT $LN7@TableSetup

; 2313 :                 draw_channel_current++;

  002bc	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR draw_channel_current$[rbp]
  002c2	ff c0		 inc	 eax
  002c4	89 85 a4 00 00
	00		 mov	 DWORD PTR draw_channel_current$[rbp], eax
$LN7@TableSetup:

; 2314 :         }
; 2315 :         else

  002ca	eb 2f		 jmp	 SHORT $LN6@TableSetup
$LN5@TableSetup:

; 2316 :         {
; 2317 :             column->DrawChannelFrozen = column->DrawChannelUnfrozen = table->DummyDrawChannel;

  002cc	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR column$2[rbp]
  002d3	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  002da	0f b7 89 1c 02
	00 00		 movzx	 ecx, WORD PTR [rcx+540]
  002e1	66 89 48 60	 mov	 WORD PTR [rax+96], cx
  002e5	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR column$2[rbp]
  002ec	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR column$2[rbp]
  002f3	0f b7 49 60	 movzx	 ecx, WORD PTR [rcx+96]
  002f7	66 89 48 5e	 mov	 WORD PTR [rax+94], cx
$LN6@TableSetup:

; 2318 :         }
; 2319 :         column->DrawChannelCurrent = column->DrawChannelFrozen;

  002fb	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR column$2[rbp]
  00302	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR column$2[rbp]
  00309	0f b7 49 5e	 movzx	 ecx, WORD PTR [rcx+94]
  0030d	66 89 48 5c	 mov	 WORD PTR [rax+92], cx

; 2320 :     }

  00311	e9 d7 fe ff ff	 jmp	 $LN2@TableSetup
$LN3@TableSetup:

; 2321 : 
; 2322 :     // Initial draw cmd starts with a BgClipRect that matches the one of its host, to facilitate merge draw commands by default.
; 2323 :     // All our cell highlight are manually clipped with BgClipRect. When unfreezing it will be made smaller to fit scrolling rect.
; 2324 :     // (This technically isn't part of setting up draw channels, but is reasonably related to be done here)
; 2325 :     table->BgClipRect = table->InnerClipRect;

  00316	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0031d	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00324	48 8d b8 28 01
	00 00		 lea	 rdi, QWORD PTR [rax+296]
  0032b	48 8d b1 18 01
	00 00		 lea	 rsi, QWORD PTR [rcx+280]
  00332	b9 10 00 00 00	 mov	 ecx, 16
  00337	f3 a4		 rep movsb

; 2326 :     table->Bg0ClipRectForDrawCmd = table->OuterWindow->ClipRect;

  00339	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00340	48 8b 80 78 01
	00 00		 mov	 rax, QWORD PTR [rax+376]
  00347	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0034e	48 8d b9 38 01
	00 00		 lea	 rdi, QWORD PTR [rcx+312]
  00355	48 8d b0 30 02
	00 00		 lea	 rsi, QWORD PTR [rax+560]
  0035c	b9 10 00 00 00	 mov	 ecx, 16
  00361	f3 a4		 rep movsb

; 2327 :     table->Bg2ClipRectForDrawCmd = table->HostClipRect;

  00363	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0036a	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00371	48 8d b8 48 01
	00 00		 lea	 rdi, QWORD PTR [rax+328]
  00378	48 8d b1 58 01
	00 00		 lea	 rsi, QWORD PTR [rcx+344]
  0037f	b9 10 00 00 00	 mov	 ecx, 16
  00384	f3 a4		 rep movsb

; 2328 :     IM_ASSERT(table->BgClipRect.Min.y <= table->BgClipRect.Max.y);

  00386	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0038d	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00394	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [rax+308]
  0039c	0f 2f 81 2c 01
	00 00		 comiss	 xmm0, DWORD PTR [rcx+300]
  003a3	73 22		 jae	 SHORT $LN21@TableSetup
  003a5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  003ab	83 c0 23	 add	 eax, 35			; 00000023H
  003ae	44 8b c0	 mov	 r8d, eax
  003b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  003b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GG@NCDBECJP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAB?$AAg?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AA?4?$AAM?$AAi?$AAn?$AA?4?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe@
  003bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003c5	33 c0		 xor	 eax, eax
$LN21@TableSetup:

; 2329 : }

  003c7	48 8d a5 c0 01
	00 00		 lea	 rsp, QWORD PTR [rbp+448]
  003ce	5f		 pop	 rdi
  003cf	5e		 pop	 rsi
  003d0	5d		 pop	 rbp
  003d1	c3		 ret	 0
?TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z ENDP ; ImGui::TableSetupDrawChannels
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
reorder_dir$1 = 4
src_column$2 = 40
dst_column$3 = 72
src_order$4 = 100
dst_order$5 = 132
order_n$6 = 164
column_n$7 = 196
n$8 = 228
tv174 = 436
tv197 = 440
table$ = 480
?TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z PROC ; ImGui::TableBeginApplyRequests, COMDAT

; 604  : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 7a 00 00 00	 mov	 ecx, 122		; 0000007aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR [rsp+520]

; 605  :     // Handle resizing request
; 606  :     // (We process this at the first TableBegin of the frame)
; 607  :     // FIXME-TABLE: Contains columns if our work area doesn't allow for scrolling?
; 608  :     if (table->InstanceCurrent == 0)

  0002a	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00031	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  00035	85 c0		 test	 eax, eax
  00037	0f 85 f5 00 00
	00		 jne	 $LN11@TableBegin

; 609  :     {
; 610  :         if (table->ResizedColumn != -1 && table->ResizedColumnNextWidth != FLT_MAX)

  0003d	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00044	0f bf 80 fe 01
	00 00		 movsx	 eax, WORD PTR [rax+510]
  0004b	83 f8 ff	 cmp	 eax, -1
  0004e	74 3e		 je	 SHORT $LN12@TableBegin
  00050	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00057	f3 0f 10 80 dc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+220]
  0005f	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@7f7fffff
  00066	7a 02		 jp	 SHORT $LN24@TableBegin
  00068	74 24		 je	 SHORT $LN12@TableBegin
$LN24@TableBegin:

; 611  :             TableSetColumnWidth(table->ResizedColumn, table->ResizedColumnNextWidth);

  0006a	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00071	0f bf 80 fe 01
	00 00		 movsx	 eax, WORD PTR [rax+510]
  00078	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0007f	f3 0f 10 89 dc
	00 00 00	 movss	 xmm1, DWORD PTR [rcx+220]
  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 ?TableSetColumnWidth@ImGui@@YAXHM@Z ; ImGui::TableSetColumnWidth
$LN12@TableBegin:

; 612  :         table->LastResizedColumn = table->ResizedColumn;

  0008e	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00095	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0009c	0f b7 89 fe 01
	00 00		 movzx	 ecx, WORD PTR [rcx+510]
  000a3	66 89 88 00 02
	00 00		 mov	 WORD PTR [rax+512], cx

; 613  :         table->ResizedColumnNextWidth = FLT_MAX;

  000aa	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000b1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  000b9	f3 0f 11 80 dc
	00 00 00	 movss	 DWORD PTR [rax+220], xmm0

; 614  :         table->ResizedColumn = -1;

  000c1	b8 ff ff ff ff	 mov	 eax, -1
  000c6	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000cd	66 89 81 fe 01
	00 00		 mov	 WORD PTR [rcx+510], ax

; 615  : 
; 616  :         // Process auto-fit for single column, which is a special case for stretch columns and fixed columns with FixedSame policy.
; 617  :         // FIXME-TABLE: Would be nice to redistribute available stretch space accordingly to other weights, instead of giving it all to siblings.
; 618  :         if (table->AutoFitSingleColumn != -1)

  000d4	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000db	0f bf 80 fc 01
	00 00		 movsx	 eax, WORD PTR [rax+508]
  000e2	83 f8 ff	 cmp	 eax, -1
  000e5	74 4b		 je	 SHORT $LN13@TableBegin

; 619  :         {
; 620  :             TableSetColumnWidth(table->AutoFitSingleColumn, table->Columns[table->AutoFitSingleColumn].WidthAuto);

  000e7	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  000ee	0f bf 80 fc 01
	00 00		 movsx	 eax, WORD PTR [rax+508]
  000f5	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  000fc	48 83 c1 18	 add	 rcx, 24
  00100	8b d0		 mov	 edx, eax
  00102	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00107	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0010e	0f bf 89 fc 01
	00 00		 movsx	 ecx, WORD PTR [rcx+508]
  00115	f3 0f 10 48 14	 movss	 xmm1, DWORD PTR [rax+20]
  0011a	e8 00 00 00 00	 call	 ?TableSetColumnWidth@ImGui@@YAXHM@Z ; ImGui::TableSetColumnWidth

; 621  :             table->AutoFitSingleColumn = -1;

  0011f	b8 ff ff ff ff	 mov	 eax, -1
  00124	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0012b	66 89 81 fc 01
	00 00		 mov	 WORD PTR [rcx+508], ax
$LN13@TableBegin:
$LN11@TableBegin:

; 622  :         }
; 623  :     }
; 624  : 
; 625  :     // Handle reordering request
; 626  :     // Note: we don't clear ReorderColumn after handling the request.
; 627  :     if (table->InstanceCurrent == 0)

  00132	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00139	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  0013d	85 c0		 test	 eax, eax
  0013f	0f 85 cb 02 00
	00		 jne	 $LN14@TableBegin

; 628  :     {
; 629  :         if (table->HeldHeaderColumn == -1 && table->ReorderColumn != -1)

  00145	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0014c	0f bf 80 02 02
	00 00		 movsx	 eax, WORD PTR [rax+514]
  00153	83 f8 ff	 cmp	 eax, -1
  00156	75 26		 jne	 SHORT $LN15@TableBegin
  00158	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0015f	0f bf 80 04 02
	00 00		 movsx	 eax, WORD PTR [rax+516]
  00166	83 f8 ff	 cmp	 eax, -1
  00169	74 13		 je	 SHORT $LN15@TableBegin

; 630  :             table->ReorderColumn = -1;

  0016b	b8 ff ff ff ff	 mov	 eax, -1
  00170	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00177	66 89 81 04 02
	00 00		 mov	 WORD PTR [rcx+516], ax
$LN15@TableBegin:

; 631  :         table->HeldHeaderColumn = -1;

  0017e	b8 ff ff ff ff	 mov	 eax, -1
  00183	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0018a	66 89 81 02 02
	00 00		 mov	 WORD PTR [rcx+514], ax

; 632  :         if (table->ReorderColumn != -1 && table->ReorderColumnDir != 0)

  00191	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00198	0f bf 80 04 02
	00 00		 movsx	 eax, WORD PTR [rax+516]
  0019f	83 f8 ff	 cmp	 eax, -1
  001a2	0f 84 68 02 00
	00		 je	 $LN16@TableBegin
  001a8	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001af	0f bf 80 06 02
	00 00		 movsx	 eax, WORD PTR [rax+518]
  001b6	85 c0		 test	 eax, eax
  001b8	0f 84 52 02 00
	00		 je	 $LN16@TableBegin

; 633  :         {
; 634  :             // We need to handle reordering across hidden columns.
; 635  :             // In the configuration below, moving C to the right of E will lead to:
; 636  :             //    ... C [D] E  --->  ... [D] E  C   (Column name/index)
; 637  :             //    ... 2  3  4        ...  2  3  4   (Display order)
; 638  :             const int reorder_dir = table->ReorderColumnDir;

  001be	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  001c5	0f bf 80 06 02
	00 00		 movsx	 eax, WORD PTR [rax+518]
  001cc	89 45 04	 mov	 DWORD PTR reorder_dir$1[rbp], eax

; 639  :             IM_ASSERT(reorder_dir == -1 || reorder_dir == +1);

  001cf	83 7d 04 ff	 cmp	 DWORD PTR reorder_dir$1[rbp], -1
  001d3	74 28		 je	 SHORT $LN19@TableBegin
  001d5	83 7d 04 01	 cmp	 DWORD PTR reorder_dir$1[rbp], 1
  001d9	74 22		 je	 SHORT $LN19@TableBegin
  001db	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  001e1	83 c0 23	 add	 eax, 35			; 00000023H
  001e4	44 8b c0	 mov	 r8d, eax
  001e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  001ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@CLPKFPLH@?$AAr?$AAe?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAd?$AAi?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAr?$AAe?$AAo?$AAr?$AAd?$AAe?$AAr?$AA_?$AAd?$AAi?$AAr@
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001fb	33 c0		 xor	 eax, eax
$LN19@TableBegin:

; 640  :             IM_ASSERT(table->Flags & ImGuiTableFlags_Reorderable);

  001fd	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00204	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00207	83 e0 02	 and	 eax, 2
  0020a	85 c0		 test	 eax, eax
  0020c	75 22		 jne	 SHORT $LN20@TableBegin
  0020e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  00214	83 c0 24	 add	 eax, 36			; 00000024H
  00217	44 8b c0	 mov	 r8d, eax
  0021a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FG@FFJIEHAF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAR@
  00228	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0022e	33 c0		 xor	 eax, eax
$LN20@TableBegin:

; 641  :             ImGuiTableColumn* src_column = &table->Columns[table->ReorderColumn];

  00230	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00237	0f bf 80 04 02
	00 00		 movsx	 eax, WORD PTR [rax+516]
  0023e	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00245	48 83 c1 18	 add	 rcx, 24
  00249	8b d0		 mov	 edx, eax
  0024b	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00250	48 89 45 28	 mov	 QWORD PTR src_column$2[rbp], rax

; 642  :             ImGuiTableColumn* dst_column = &table->Columns[(reorder_dir == -1) ? src_column->PrevEnabledColumn : src_column->NextEnabledColumn];

  00254	83 7d 04 ff	 cmp	 DWORD PTR reorder_dir$1[rbp], -1
  00258	75 11		 jne	 SHORT $LN21@TableBegin
  0025a	48 8b 45 28	 mov	 rax, QWORD PTR src_column$2[rbp]
  0025e	0f b7 40 56	 movzx	 eax, WORD PTR [rax+86]
  00262	66 89 85 b4 01
	00 00		 mov	 WORD PTR tv174[rbp], ax
  00269	eb 0f		 jmp	 SHORT $LN22@TableBegin
$LN21@TableBegin:
  0026b	48 8b 45 28	 mov	 rax, QWORD PTR src_column$2[rbp]
  0026f	0f b7 40 58	 movzx	 eax, WORD PTR [rax+88]
  00273	66 89 85 b4 01
	00 00		 mov	 WORD PTR tv174[rbp], ax
$LN22@TableBegin:
  0027a	0f bf 85 b4 01
	00 00		 movsx	 eax, WORD PTR tv174[rbp]
  00281	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00288	48 83 c1 18	 add	 rcx, 24
  0028c	8b d0		 mov	 edx, eax
  0028e	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00293	48 89 45 48	 mov	 QWORD PTR dst_column$3[rbp], rax

; 643  :             IM_UNUSED(dst_column);
; 644  :             const int src_order = src_column->DisplayOrder;

  00297	48 8b 45 28	 mov	 rax, QWORD PTR src_column$2[rbp]
  0029b	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  0029f	89 45 64	 mov	 DWORD PTR src_order$4[rbp], eax

; 645  :             const int dst_order = dst_column->DisplayOrder;

  002a2	48 8b 45 48	 mov	 rax, QWORD PTR dst_column$3[rbp]
  002a6	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  002aa	89 85 84 00 00
	00		 mov	 DWORD PTR dst_order$5[rbp], eax

; 646  :             src_column->DisplayOrder = (ImGuiTableColumnIdx)dst_order;

  002b0	48 8b 45 28	 mov	 rax, QWORD PTR src_column$2[rbp]
  002b4	0f b7 8d 84 00
	00 00		 movzx	 ecx, WORD PTR dst_order$5[rbp]
  002bb	66 89 48 52	 mov	 WORD PTR [rax+82], cx

; 647  :             for (int order_n = src_order + reorder_dir; order_n != dst_order + reorder_dir; order_n += reorder_dir)

  002bf	8b 45 04	 mov	 eax, DWORD PTR reorder_dir$1[rbp]
  002c2	8b 4d 64	 mov	 ecx, DWORD PTR src_order$4[rbp]
  002c5	03 c8		 add	 ecx, eax
  002c7	8b c1		 mov	 eax, ecx
  002c9	89 85 a4 00 00
	00		 mov	 DWORD PTR order_n$6[rbp], eax
  002cf	eb 13		 jmp	 SHORT $LN4@TableBegin
$LN2@TableBegin:
  002d1	8b 45 04	 mov	 eax, DWORD PTR reorder_dir$1[rbp]
  002d4	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR order_n$6[rbp]
  002da	03 c8		 add	 ecx, eax
  002dc	8b c1		 mov	 eax, ecx
  002de	89 85 a4 00 00
	00		 mov	 DWORD PTR order_n$6[rbp], eax
$LN4@TableBegin:
  002e4	8b 45 04	 mov	 eax, DWORD PTR reorder_dir$1[rbp]
  002e7	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR dst_order$5[rbp]
  002ed	03 c8		 add	 ecx, eax
  002ef	8b c1		 mov	 eax, ecx
  002f1	39 85 a4 00 00
	00		 cmp	 DWORD PTR order_n$6[rbp], eax
  002f7	74 57		 je	 SHORT $LN3@TableBegin

; 648  :                 table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder -= (ImGuiTableColumnIdx)reorder_dir;

  002f9	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00300	48 83 c0 28	 add	 rax, 40			; 00000028H
  00304	8b 95 a4 00 00
	00		 mov	 edx, DWORD PTR order_n$6[rbp]
  0030a	48 8b c8	 mov	 rcx, rax
  0030d	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  00312	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00315	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0031c	48 83 c1 18	 add	 rcx, 24
  00320	8b d0		 mov	 edx, eax
  00322	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00327	48 83 c0 52	 add	 rax, 82			; 00000052H
  0032b	48 89 85 b8 01
	00 00		 mov	 QWORD PTR tv197[rbp], rax
  00332	0f bf 45 04	 movsx	 eax, WORD PTR reorder_dir$1[rbp]
  00336	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR tv197[rbp]
  0033d	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00340	2b c8		 sub	 ecx, eax
  00342	8b c1		 mov	 eax, ecx
  00344	48 8b 8d b8 01
	00 00		 mov	 rcx, QWORD PTR tv197[rbp]
  0034b	66 89 01	 mov	 WORD PTR [rcx], ax
  0034e	eb 81		 jmp	 SHORT $LN2@TableBegin
$LN3@TableBegin:

; 649  :             IM_ASSERT(dst_column->DisplayOrder == dst_order - reorder_dir);

  00350	48 8b 45 48	 mov	 rax, QWORD PTR dst_column$3[rbp]
  00354	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  00358	8b 4d 04	 mov	 ecx, DWORD PTR reorder_dir$1[rbp]
  0035b	8b 95 84 00 00
	00		 mov	 edx, DWORD PTR dst_order$5[rbp]
  00361	2b d1		 sub	 edx, ecx
  00363	8b ca		 mov	 ecx, edx
  00365	3b c1		 cmp	 eax, ecx
  00367	74 22		 je	 SHORT $LN23@TableBegin
  00369	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z@4JA
  0036f	83 c0 2d	 add	 eax, 45			; 0000002dH
  00372	44 8b c0	 mov	 r8d, eax
  00375	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0037c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GI@FDBBNGED@?$AAd?$AAs?$AAt?$AA_?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?9?$AA?$DO?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAO?$AAr?$AAd?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAs?$AAt?$AA_@
  00383	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00389	33 c0		 xor	 eax, eax
$LN23@TableBegin:

; 650  : 
; 651  :             // Display order is stored in both columns->IndexDisplayOrder and table->DisplayOrder[],
; 652  :             // rebuild the later from the former.
; 653  :             for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  0038b	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$7[rbp], 0
  00395	eb 0e		 jmp	 SHORT $LN7@TableBegin
$LN5@TableBegin:
  00397	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR column_n$7[rbp]
  0039d	ff c0		 inc	 eax
  0039f	89 85 c4 00 00
	00		 mov	 DWORD PTR column_n$7[rbp], eax
$LN7@TableBegin:
  003a5	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003ac	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  003af	39 85 c4 00 00
	00		 cmp	 DWORD PTR column_n$7[rbp], eax
  003b5	7d 3b		 jge	 SHORT $LN6@TableBegin

; 654  :                 table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;

  003b7	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003be	48 83 c0 18	 add	 rax, 24
  003c2	8b 95 c4 00 00
	00		 mov	 edx, DWORD PTR column_n$7[rbp]
  003c8	48 8b c8	 mov	 rcx, rax
  003cb	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  003d0	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  003d4	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  003db	48 83 c1 28	 add	 rcx, 40			; 00000028H
  003df	8b d0		 mov	 edx, eax
  003e1	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  003e6	0f b7 8d c4 00
	00 00		 movzx	 ecx, WORD PTR column_n$7[rbp]
  003ed	66 89 08	 mov	 WORD PTR [rax], cx
  003f0	eb a5		 jmp	 SHORT $LN5@TableBegin
$LN6@TableBegin:

; 655  :             table->ReorderColumnDir = 0;

  003f2	33 c0		 xor	 eax, eax
  003f4	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  003fb	66 89 81 06 02
	00 00		 mov	 WORD PTR [rcx+518], ax

; 656  :             table->IsSettingsDirty = true;

  00402	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00409	c6 80 29 02 00
	00 01		 mov	 BYTE PTR [rax+553], 1
$LN16@TableBegin:
$LN14@TableBegin:

; 657  :         }
; 658  :     }
; 659  : 
; 660  :     // Handle display order reset request
; 661  :     if (table->IsResetDisplayOrderRequest)

  00410	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00417	0f b6 80 2c 02
	00 00		 movzx	 eax, BYTE PTR [rax+556]
  0041e	85 c0		 test	 eax, eax
  00420	0f 84 91 00 00
	00		 je	 $LN17@TableBegin

; 662  :     {
; 663  :         for (int n = 0; n < table->ColumnsCount; n++)

  00426	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR n$8[rbp], 0
  00430	eb 0e		 jmp	 SHORT $LN10@TableBegin
$LN8@TableBegin:
  00432	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR n$8[rbp]
  00438	ff c0		 inc	 eax
  0043a	89 85 e4 00 00
	00		 mov	 DWORD PTR n$8[rbp], eax
$LN10@TableBegin:
  00440	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00447	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0044a	39 85 e4 00 00
	00		 cmp	 DWORD PTR n$8[rbp], eax
  00450	7d 49		 jge	 SHORT $LN9@TableBegin

; 664  :             table->DisplayOrderToIndex[n] = table->Columns[n].DisplayOrder = (ImGuiTableColumnIdx)n;

  00452	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00459	48 83 c0 18	 add	 rax, 24
  0045d	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR n$8[rbp]
  00463	48 8b c8	 mov	 rcx, rax
  00466	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  0046b	0f b7 8d e4 00
	00 00		 movzx	 ecx, WORD PTR n$8[rbp]
  00472	66 89 48 52	 mov	 WORD PTR [rax+82], cx
  00476	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0047d	48 83 c0 28	 add	 rax, 40			; 00000028H
  00481	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR n$8[rbp]
  00487	48 8b c8	 mov	 rcx, rax
  0048a	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  0048f	0f b7 8d e4 00
	00 00		 movzx	 ecx, WORD PTR n$8[rbp]
  00496	66 89 08	 mov	 WORD PTR [rax], cx
  00499	eb 97		 jmp	 SHORT $LN8@TableBegin
$LN9@TableBegin:

; 665  :         table->IsResetDisplayOrderRequest = false;

  0049b	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004a2	c6 80 2c 02 00
	00 00		 mov	 BYTE PTR [rax+556], 0

; 666  :         table->IsSettingsDirty = true;

  004a9	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004b0	c6 80 29 02 00
	00 01		 mov	 BYTE PTR [rax+553], 1
$LN17@TableBegin:

; 667  :     }
; 668  : }

  004b7	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  004be	5f		 pop	 rdi
  004bf	5d		 pop	 rbp
  004c0	c3		 ret	 0
?TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z ENDP ; ImGui::TableBeginApplyRequests
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z
_TEXT	SEGMENT
columns_bit_array_size$ = 4
span_allocator$ = 48
n$4 = 132
__$ArrayPad$ = 344
table$ = 384
columns_count$ = 392
?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z PROC ; ImGui::TableBeginInitMemory, COMDAT

; 582  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 62 00 00 00	 mov	 ecx, 98			; 00000062H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+424]
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c5	 xor	 rax, rbp
  00038	48 89 85 58 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 583  :     // Allocate single buffer for our arrays
; 584  :     const int columns_bit_array_size = (int)ImBitArrayGetStorageSizeInBytes(columns_count);

  0003f	8b 8d 88 01 00
	00		 mov	 ecx, DWORD PTR columns_count$[rbp]
  00045	e8 00 00 00 00	 call	 ?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z ; ImBitArrayGetStorageSizeInBytes
  0004a	89 45 04	 mov	 DWORD PTR columns_bit_array_size$[rbp], eax

; 585  :     ImSpanAllocator<6> span_allocator;

  0004d	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  00051	e8 00 00 00 00	 call	 ??0?$ImSpanAllocator@$05@@QEAA@XZ ; ImSpanAllocator<6>::ImSpanAllocator<6>

; 586  :     span_allocator.Reserve(0, columns_count * sizeof(ImGuiTableColumn));

  00056	48 63 85 88 01
	00 00		 movsxd	 rax, DWORD PTR columns_count$[rbp]
  0005d	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00061	41 b9 04 00 00
	00		 mov	 r9d, 4
  00067	4c 8b c0	 mov	 r8, rax
  0006a	33 d2		 xor	 edx, edx
  0006c	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  00070	e8 00 00 00 00	 call	 ?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z ; ImSpanAllocator<6>::Reserve

; 587  :     span_allocator.Reserve(1, columns_count * sizeof(ImGuiTableColumnIdx));

  00075	48 63 85 88 01
	00 00		 movsxd	 rax, DWORD PTR columns_count$[rbp]
  0007c	48 d1 e0	 shl	 rax, 1
  0007f	41 b9 04 00 00
	00		 mov	 r9d, 4
  00085	4c 8b c0	 mov	 r8, rax
  00088	ba 01 00 00 00	 mov	 edx, 1
  0008d	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  00091	e8 00 00 00 00	 call	 ?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z ; ImSpanAllocator<6>::Reserve

; 588  :     span_allocator.Reserve(2, columns_count * sizeof(ImGuiTableCellData), 4);

  00096	48 63 85 88 01
	00 00		 movsxd	 rax, DWORD PTR columns_count$[rbp]
  0009d	48 c1 e0 03	 shl	 rax, 3
  000a1	41 b9 04 00 00
	00		 mov	 r9d, 4
  000a7	4c 8b c0	 mov	 r8, rax
  000aa	ba 02 00 00 00	 mov	 edx, 2
  000af	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  000b3	e8 00 00 00 00	 call	 ?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z ; ImSpanAllocator<6>::Reserve

; 589  :     for (int n = 3; n < 6; n++)

  000b8	c7 85 84 00 00
	00 03 00 00 00	 mov	 DWORD PTR n$4[rbp], 3
  000c2	eb 0e		 jmp	 SHORT $LN4@TableBegin
$LN2@TableBegin:
  000c4	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR n$4[rbp]
  000ca	ff c0		 inc	 eax
  000cc	89 85 84 00 00
	00		 mov	 DWORD PTR n$4[rbp], eax
$LN4@TableBegin:
  000d2	83 bd 84 00 00
	00 06		 cmp	 DWORD PTR n$4[rbp], 6
  000d9	7d 1e		 jge	 SHORT $LN3@TableBegin

; 590  :         span_allocator.Reserve(n, columns_bit_array_size);

  000db	48 63 45 04	 movsxd	 rax, DWORD PTR columns_bit_array_size$[rbp]
  000df	41 b9 04 00 00
	00		 mov	 r9d, 4
  000e5	4c 8b c0	 mov	 r8, rax
  000e8	8b 95 84 00 00
	00		 mov	 edx, DWORD PTR n$4[rbp]
  000ee	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  000f2	e8 00 00 00 00	 call	 ?Reserve@?$ImSpanAllocator@$05@@QEAAXH_KH@Z ; ImSpanAllocator<6>::Reserve
  000f7	eb cb		 jmp	 SHORT $LN2@TableBegin
$LN3@TableBegin:

; 591  :     table->RawData = IM_ALLOC(span_allocator.GetArenaSizeInBytes());

  000f9	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  000fd	e8 00 00 00 00	 call	 ?GetArenaSizeInBytes@?$ImSpanAllocator@$05@@QEAAHXZ ; ImSpanAllocator<6>::GetArenaSizeInBytes
  00102	48 98		 cdqe
  00104	48 8b c8	 mov	 rcx, rax
  00107	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  0010c	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00113	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 592  :     memset(table->RawData, 0, span_allocator.GetArenaSizeInBytes());

  00117	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  0011b	e8 00 00 00 00	 call	 ?GetArenaSizeInBytes@?$ImSpanAllocator@$05@@QEAAHXZ ; ImSpanAllocator<6>::GetArenaSizeInBytes
  00120	48 98		 cdqe
  00122	4c 8b c0	 mov	 r8, rax
  00125	33 d2		 xor	 edx, edx
  00127	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0012e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00132	e8 00 00 00 00	 call	 memset

; 593  :     span_allocator.SetArenaBasePtr(table->RawData);

  00137	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0013e	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00142	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  00146	e8 00 00 00 00	 call	 ?SetArenaBasePtr@?$ImSpanAllocator@$05@@QEAAXPEAX@Z ; ImSpanAllocator<6>::SetArenaBasePtr

; 594  :     span_allocator.GetSpan(0, &table->Columns);

  0014b	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00152	48 83 c0 18	 add	 rax, 24
  00156	4c 8b c0	 mov	 r8, rax
  00159	33 d2		 xor	 edx, edx
  0015b	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  0015f	e8 00 00 00 00	 call	 ??$GetSpan@UImGuiTableColumn@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableColumn@@@@@Z ; ImSpanAllocator<6>::GetSpan<ImGuiTableColumn>

; 595  :     span_allocator.GetSpan(1, &table->DisplayOrderToIndex);

  00164	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0016b	48 83 c0 28	 add	 rax, 40			; 00000028H
  0016f	4c 8b c0	 mov	 r8, rax
  00172	ba 01 00 00 00	 mov	 edx, 1
  00177	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  0017b	e8 00 00 00 00	 call	 ??$GetSpan@F@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@F@@@Z ; ImSpanAllocator<6>::GetSpan<short>

; 596  :     span_allocator.GetSpan(2, &table->RowCellData);

  00180	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00187	48 83 c0 38	 add	 rax, 56			; 00000038H
  0018b	4c 8b c0	 mov	 r8, rax
  0018e	ba 02 00 00 00	 mov	 edx, 2
  00193	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  00197	e8 00 00 00 00	 call	 ??$GetSpan@UImGuiTableCellData@@@?$ImSpanAllocator@$05@@QEAAXHPEAU?$ImSpan@UImGuiTableCellData@@@@@Z ; ImSpanAllocator<6>::GetSpan<ImGuiTableCellData>

; 597  :     table->EnabledMaskByDisplayOrder = (ImU32*)span_allocator.GetSpanPtrBegin(3);

  0019c	ba 03 00 00 00	 mov	 edx, 3
  001a1	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  001a5	e8 00 00 00 00	 call	 ?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrBegin
  001aa	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  001b1	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax

; 598  :     table->EnabledMaskByIndex = (ImU32*)span_allocator.GetSpanPtrBegin(4);

  001b5	ba 04 00 00 00	 mov	 edx, 4
  001ba	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  001be	e8 00 00 00 00	 call	 ?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrBegin
  001c3	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  001ca	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 599  :     table->VisibleMaskByIndex = (ImU32*)span_allocator.GetSpanPtrBegin(5);

  001ce	ba 05 00 00 00	 mov	 edx, 5
  001d3	48 8d 4d 30	 lea	 rcx, QWORD PTR span_allocator$[rbp]
  001d7	e8 00 00 00 00	 call	 ?GetSpanPtrBegin@?$ImSpanAllocator@$05@@QEAAPEAXH@Z ; ImSpanAllocator<6>::GetSpanPtrBegin
  001dc	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  001e3	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 600  : }

  001e7	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  001eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z$rtcFrameData
  001f2	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001f7	48 8b 8d 58 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  001fe	48 33 cd	 xor	 rcx, rbp
  00201	e8 00 00 00 00	 call	 __security_check_cookie
  00206	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  0020d	5f		 pop	 rdi
  0020e	5d		 pop	 rbp
  0020f	c3		 ret	 0
?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z ENDP ; ImGui::TableBeginInitMemory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z
_TEXT	SEGMENT
g$ = 8
outer_window$ = 40
use_child_window$ = 68
avail_size$ = 104
actual_outer_size$ = 136
outer_rect$ = 168
table$ = 216
instance_no$ = 244
instance_id$ = 276
table_last_flags$ = 308
table_idx$ = 340
temp_data$ = 376
override_content_size$7 = 408
child_flags$8 = 436
inner_window$ = 472
pad_outer_x$ = 500
pad_inner_x$ = 532
inner_spacing_for_border$ = 564
inner_spacing_explicit$ = 596
inner_padding_explicit$ = 628
outer_padding_for_border$ = 660
outer_padding_explicit$ = 692
old_columns_to_preserve$ = 728
old_columns_raw_data$ = 760
old_columns_count$ = 788
n$9 = 820
column$10 = 856
width_auto$11 = 884
new_ref_scale_unit$ = 916
scale_factor$12 = 948
n$13 = 980
$T14 = 1780
$T15 = 1816
$T16 = 1956
$T17 = 1988
$T18 = 2020
$T19 = 2052
$T20 = 2084
$T21 = 2132
$T22 = 2168
$T23 = 2196
$T24 = 2228
$T25 = 2376
tv637 = 2388
tv549 = 2388
tv503 = 2388
tv461 = 2388
tv455 = 2388
tv444 = 2388
tv436 = 2388
tv428 = 2388
tv425 = 2388
tv421 = 2388
tv351 = 2388
tv267 = 2388
tv252 = 2388
tv209 = 2388
tv180 = 2388
tv162 = 2388
tv93 = 2388
tv85 = 2388
tv651 = 2392
tv476 = 2392
tv419 = 2392
tv255 = 2392
tv196 = 2392
tv417 = 2396
tv650 = 2400
__$ArrayPad$ = 2408
name$ = 2448
id$ = 2456
columns_count$ = 2464
flags$ = 2472
outer_size$ = 2480
inner_width$ = 2488
?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z PROC	; ImGui::BeginTableEx, COMDAT

; 311  : {

$LN88:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec a0 09
	00 00		 sub	 rsp, 2464		; 000009a0H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8b fc	 mov	 rdi, rsp
  00025	b9 68 02 00 00	 mov	 ecx, 616		; 00000268H
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	48 8b 8c 24 c8
	09 00 00	 mov	 rcx, QWORD PTR [rsp+2504]
  00039	48 c7 85 48 09
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T25[rbp], -2
  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0004b	48 33 c5	 xor	 rax, rbp
  0004e	48 89 85 68 09
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 312  :     ImGuiContext& g = *GImGui;

  00055	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0005c	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 313  :     ImGuiWindow* outer_window = GetCurrentWindow();

  00060	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00065	48 89 45 28	 mov	 QWORD PTR outer_window$[rbp], rax

; 314  :     if (outer_window->SkipItems) // Consistent with other tables + beneficial side effect that assert on miscalling EndTable() will be more visible.

  00069	48 8b 45 28	 mov	 rax, QWORD PTR outer_window$[rbp]
  0006d	0f b6 80 b3 00
	00 00		 movzx	 eax, BYTE PTR [rax+179]
  00074	85 c0		 test	 eax, eax
  00076	74 07		 je	 SHORT $LN8@BeginTable

; 315  :         return false;

  00078	32 c0		 xor	 al, al
  0007a	e9 32 14 00 00	 jmp	 $LN1@BeginTable
$LN8@BeginTable:

; 316  : 
; 317  :     // Sanity checks
; 318  :     IM_ASSERT(columns_count > 0 && columns_count < IMGUI_TABLE_MAX_COLUMNS);

  0007f	83 bd a0 09 00
	00 00		 cmp	 DWORD PTR columns_count$[rbp], 0
  00086	7e 0c		 jle	 SHORT $LN36@BeginTable
  00088	81 bd a0 09 00
	00 00 02 00 00	 cmp	 DWORD PTR columns_count$[rbp], 512 ; 00000200H
  00092	7c 22		 jl	 SHORT $LN37@BeginTable
$LN36@BeginTable:
  00094	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4JA
  0009a	83 c0 07	 add	 eax, 7
  0009d	44 8b c0	 mov	 r8d, eax
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@LLGOGPDA@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu@
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b4	33 c0		 xor	 eax, eax
$LN37@BeginTable:

; 319  :     if (flags & ImGuiTableFlags_ScrollX)

  000b6	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  000bc	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000c1	85 c0		 test	 eax, eax
  000c3	74 33		 je	 SHORT $LN9@BeginTable

; 320  :         IM_ASSERT(inner_width >= 0.0f);

  000c5	f3 0f 10 85 b8
	09 00 00	 movss	 xmm0, DWORD PTR inner_width$[rbp]
  000cd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000d4	73 22		 jae	 SHORT $LN9@BeginTable
  000d6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4JA
  000dc	83 c0 09	 add	 eax, 9
  000df	44 8b c0	 mov	 r8d, eax
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@NLGBMAGB@?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f6	33 c0		 xor	 eax, eax
$LN9@BeginTable:

; 321  : 
; 322  :     // If an outer size is specified ahead we will be able to early out when not visible. Exact clipping rules may evolve.
; 323  :     const bool use_child_window = (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) != 0;

  000f8	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  000fe	25 00 00 00 03	 and	 eax, 50331648		; 03000000H
  00103	85 c0		 test	 eax, eax
  00105	74 09		 je	 SHORT $LN39@BeginTable
  00107	c6 85 54 09 00
	00 01		 mov	 BYTE PTR tv85[rbp], 1
  0010e	eb 07		 jmp	 SHORT $LN40@BeginTable
$LN39@BeginTable:
  00110	c6 85 54 09 00
	00 00		 mov	 BYTE PTR tv85[rbp], 0
$LN40@BeginTable:
  00117	0f b6 85 54 09
	00 00		 movzx	 eax, BYTE PTR tv85[rbp]
  0011e	88 45 44	 mov	 BYTE PTR use_child_window$[rbp], al

; 324  :     const ImVec2 avail_size = GetContentRegionAvail();

  00121	48 8d 4d 68	 lea	 rcx, QWORD PTR avail_size$[rbp]
  00125	e8 00 00 00 00	 call	 ?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail

; 325  :     ImVec2 actual_outer_size = CalcItemSize(outer_size, ImMax(avail_size.x, 1.0f), use_child_window ? ImMax(avail_size.y, 1.0f) : 0.0f);

  0012a	0f b6 45 44	 movzx	 eax, BYTE PTR use_child_window$[rbp]
  0012e	85 c0		 test	 eax, eax
  00130	74 1c		 je	 SHORT $LN41@BeginTable
  00132	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0013a	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR avail_size$[rbp+4]
  0013f	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00144	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv93[rbp], xmm0
  0014c	eb 0b		 jmp	 SHORT $LN42@BeginTable
$LN41@BeginTable:
  0014e	0f 57 c0	 xorps	 xmm0, xmm0
  00151	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv93[rbp], xmm0
$LN42@BeginTable:
  00159	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00161	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR avail_size$[rbp]
  00166	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0016b	f3 0f 10 9d 54
	09 00 00	 movss	 xmm3, DWORD PTR tv93[rbp]
  00173	0f 28 d0	 movaps	 xmm2, xmm0
  00176	48 8b 85 b0 09
	00 00		 mov	 rax, QWORD PTR outer_size$[rbp]
  0017d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00180	48 8d 8d 88 00
	00 00		 lea	 rcx, QWORD PTR actual_outer_size$[rbp]
  00187	e8 00 00 00 00	 call	 ?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize

; 326  :     ImRect outer_rect(outer_window->DC.CursorPos, outer_window->DC.CursorPos + actual_outer_size);

  0018c	48 8b 45 28	 mov	 rax, QWORD PTR outer_window$[rbp]
  00190	48 05 f8 00 00
	00		 add	 rax, 248		; 000000f8H
  00196	4c 8d 85 88 00
	00 00		 lea	 r8, QWORD PTR actual_outer_size$[rbp]
  0019d	48 8b d0	 mov	 rdx, rax
  001a0	48 8d 8d f4 06
	00 00		 lea	 rcx, QWORD PTR $T14[rbp]
  001a7	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@AEBU0@0@Z ; operator+
  001ac	48 8b 4d 28	 mov	 rcx, QWORD PTR outer_window$[rbp]
  001b0	48 81 c1 f8 00
	00 00		 add	 rcx, 248		; 000000f8H
  001b7	4c 8b c0	 mov	 r8, rax
  001ba	48 8b d1	 mov	 rdx, rcx
  001bd	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR outer_rect$[rbp]
  001c4	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@AEBUImVec2@@0@Z ; ImRect::ImRect

; 327  :     if (use_child_window && IsClippedEx(outer_rect, 0))

  001c9	0f b6 45 44	 movzx	 eax, BYTE PTR use_child_window$[rbp]
  001cd	85 c0		 test	 eax, eax
  001cf	74 30		 je	 SHORT $LN10@BeginTable
  001d1	33 d2		 xor	 edx, edx
  001d3	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR outer_rect$[rbp]
  001da	e8 00 00 00 00	 call	 ?IsClippedEx@ImGui@@YA_NAEBUImRect@@I@Z ; ImGui::IsClippedEx
  001df	0f b6 c0	 movzx	 eax, al
  001e2	85 c0		 test	 eax, eax
  001e4	74 1b		 je	 SHORT $LN10@BeginTable

; 328  :     {
; 329  :         ItemSize(outer_rect);

  001e6	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  001ee	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR outer_rect$[rbp]
  001f5	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXAEBUImRect@@M@Z ; ImGui::ItemSize

; 330  :         return false;

  001fa	32 c0		 xor	 al, al
  001fc	e9 b0 12 00 00	 jmp	 $LN1@BeginTable
$LN10@BeginTable:

; 331  :     }
; 332  : 
; 333  :     // Acquire storage for the table
; 334  :     ImGuiTable* table = g.Tables.GetOrAddByKey(id);

  00201	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00205	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  0020b	8b 95 98 09 00
	00		 mov	 edx, DWORD PTR id$[rbp]
  00211	48 8b c8	 mov	 rcx, rax
  00214	e8 00 00 00 00	 call	 ?GetOrAddByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z ; ImPool<ImGuiTable>::GetOrAddByKey
  00219	48 89 85 d8 00
	00 00		 mov	 QWORD PTR table$[rbp], rax

; 335  :     const int instance_no = (table->LastFrameActive != g.FrameCount) ? 0 : table->InstanceCurrent + 1;

  00220	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00227	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  0022b	8b 89 20 3e 00
	00		 mov	 ecx, DWORD PTR [rcx+15904]
  00231	39 48 68	 cmp	 DWORD PTR [rax+104], ecx
  00234	74 0c		 je	 SHORT $LN43@BeginTable
  00236	c7 85 54 09 00
	00 00 00 00 00	 mov	 DWORD PTR tv162[rbp], 0
  00240	eb 13		 jmp	 SHORT $LN44@BeginTable
$LN43@BeginTable:
  00242	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00249	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  0024d	ff c0		 inc	 eax
  0024f	89 85 54 09 00
	00		 mov	 DWORD PTR tv162[rbp], eax
$LN44@BeginTable:
  00255	8b 85 54 09 00
	00		 mov	 eax, DWORD PTR tv162[rbp]
  0025b	89 85 f4 00 00
	00		 mov	 DWORD PTR instance_no$[rbp], eax

; 336  :     const ImGuiID instance_id = id + instance_no;

  00261	8b 85 f4 00 00
	00		 mov	 eax, DWORD PTR instance_no$[rbp]
  00267	8b 8d 98 09 00
	00		 mov	 ecx, DWORD PTR id$[rbp]
  0026d	03 c8		 add	 ecx, eax
  0026f	8b c1		 mov	 eax, ecx
  00271	89 85 14 01 00
	00		 mov	 DWORD PTR instance_id$[rbp], eax

; 337  :     const ImGuiTableFlags table_last_flags = table->Flags;

  00277	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0027e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00281	89 85 34 01 00
	00		 mov	 DWORD PTR table_last_flags$[rbp], eax

; 338  :     if (instance_no > 0)

  00287	83 bd f4 00 00
	00 00		 cmp	 DWORD PTR instance_no$[rbp], 0
  0028e	7e 40		 jle	 SHORT $LN11@BeginTable

; 339  :         IM_ASSERT(table->ColumnsCount == columns_count && "BeginTable(): Cannot change columns count mid-frame while preserving same ID");

  00290	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00297	8b 8d a0 09 00
	00		 mov	 ecx, DWORD PTR columns_count$[rbp]
  0029d	39 48 6c	 cmp	 DWORD PTR [rax+108], ecx
  002a0	75 0c		 jne	 SHORT $LN45@BeginTable
  002a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0EN@HCDJLOKE@BeginTable?$CI?$CJ?3?5Cannot?5change?5colu@
  002a9	48 85 c0	 test	 rax, rax
  002ac	75 22		 jne	 SHORT $LN11@BeginTable
$LN45@BeginTable:
  002ae	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4JA
  002b4	83 c0 1c	 add	 eax, 28
  002b7	44 8b c0	 mov	 r8d, eax
  002ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  002c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1OO@LHJMPKOL@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc@
  002c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ce	33 c0		 xor	 eax, eax
$LN11@BeginTable:

; 340  : 
; 341  :     // Acquire temporary buffers
; 342  :     const int table_idx = g.Tables.GetIndex(table);

  002d0	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  002d4	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  002da	48 8b 95 d8 00
	00 00		 mov	 rdx, QWORD PTR table$[rbp]
  002e1	48 8b c8	 mov	 rcx, rax
  002e4	e8 00 00 00 00	 call	 ?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z ; ImPool<ImGuiTable>::GetIndex
  002e9	89 85 54 01 00
	00		 mov	 DWORD PTR table_idx$[rbp], eax

; 343  :     if (++g.TablesTempDataStacked > g.TablesTempData.Size)

  002ef	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  002f3	8b 80 f0 4a 00
	00		 mov	 eax, DWORD PTR [rax+19184]
  002f9	ff c0		 inc	 eax
  002fb	89 85 54 09 00
	00		 mov	 DWORD PTR tv180[rbp], eax
  00301	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00305	8b 8d 54 09 00
	00		 mov	 ecx, DWORD PTR tv180[rbp]
  0030b	89 88 f0 4a 00
	00		 mov	 DWORD PTR [rax+19184], ecx
  00311	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00315	8b 80 f8 4a 00
	00		 mov	 eax, DWORD PTR [rax+19192]
  0031b	39 85 54 09 00
	00		 cmp	 DWORD PTR tv180[rbp], eax
  00321	7e 51		 jle	 SHORT $LN12@BeginTable

; 344  :         g.TablesTempData.resize(g.TablesTempDataStacked, ImGuiTableTempData());

  00323	48 8d 8d 18 07
	00 00		 lea	 rcx, QWORD PTR $T15[rbp]
  0032a	e8 00 00 00 00	 call	 ??0ImGuiTableTempData@@QEAA@XZ ; ImGuiTableTempData::ImGuiTableTempData
  0032f	48 89 85 58 09
	00 00		 mov	 QWORD PTR tv651[rbp], rax
  00336	48 8b 85 58 09
	00 00		 mov	 rax, QWORD PTR tv651[rbp]
  0033d	48 89 85 60 09
	00 00		 mov	 QWORD PTR tv650[rbp], rax
  00344	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00348	48 05 f8 4a 00
	00		 add	 rax, 19192		; 00004af8H
  0034e	4c 8b 85 60 09
	00 00		 mov	 r8, QWORD PTR tv650[rbp]
  00355	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00359	8b 91 f0 4a 00
	00		 mov	 edx, DWORD PTR [rcx+19184]
  0035f	48 8b c8	 mov	 rcx, rax
  00362	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImGuiTableTempData@@@@QEAAXHAEBUImGuiTableTempData@@@Z ; ImVector<ImGuiTableTempData>::resize
  00367	90		 npad	 1
  00368	48 8d 8d 18 07
	00 00		 lea	 rcx, QWORD PTR $T15[rbp]
  0036f	e8 00 00 00 00	 call	 ??1ImGuiTableTempData@@QEAA@XZ
$LN12@BeginTable:

; 345  :     ImGuiTableTempData* temp_data = table->TempData = &g.TablesTempData[g.TablesTempDataStacked - 1];

  00374	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00378	8b 80 f0 4a 00
	00		 mov	 eax, DWORD PTR [rax+19184]
  0037e	ff c8		 dec	 eax
  00380	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00384	48 81 c1 f8 4a
	00 00		 add	 rcx, 19192		; 00004af8H
  0038b	8b d0		 mov	 edx, eax
  0038d	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTableTempData@@@@QEAAAEAUImGuiTableTempData@@H@Z ; ImVector<ImGuiTableTempData>::operator[]
  00392	48 89 85 58 09
	00 00		 mov	 QWORD PTR tv196[rbp], rax
  00399	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003a0	48 8b 8d 58 09
	00 00		 mov	 rcx, QWORD PTR tv196[rbp]
  003a7	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  003ab	48 8b 85 58 09
	00 00		 mov	 rax, QWORD PTR tv196[rbp]
  003b2	48 89 85 78 01
	00 00		 mov	 QWORD PTR temp_data$[rbp], rax

; 346  :     temp_data->TableIndex = table_idx;

  003b9	48 8b 85 78 01
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  003c0	8b 8d 54 01 00
	00		 mov	 ecx, DWORD PTR table_idx$[rbp]
  003c6	89 08		 mov	 DWORD PTR [rax], ecx

; 347  :     table->DrawSplitter = &table->TempData->DrawSplitter;

  003c8	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003cf	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  003d3	48 83 c0 10	 add	 rax, 16
  003d7	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  003de	48 89 81 98 01
	00 00		 mov	 QWORD PTR [rcx+408], rax

; 348  :     table->DrawSplitter->Clear();

  003e5	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  003ec	48 8b 88 98 01
	00 00		 mov	 rcx, QWORD PTR [rax+408]
  003f3	e8 00 00 00 00	 call	 ?Clear@ImDrawListSplitter@@QEAAXXZ ; ImDrawListSplitter::Clear

; 349  : 
; 350  :     // Fix flags
; 351  :     table->IsDefaultSizingPolicy = (flags & ImGuiTableFlags_SizingMask_) == 0;

  003f8	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  003fe	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  00403	85 c0		 test	 eax, eax
  00405	75 0c		 jne	 SHORT $LN47@BeginTable
  00407	c7 85 54 09 00
	00 01 00 00 00	 mov	 DWORD PTR tv209[rbp], 1
  00411	eb 0a		 jmp	 SHORT $LN48@BeginTable
$LN47@BeginTable:
  00413	c7 85 54 09 00
	00 00 00 00 00	 mov	 DWORD PTR tv209[rbp], 0
$LN48@BeginTable:
  0041d	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00424	0f b6 8d 54 09
	00 00		 movzx	 ecx, BYTE PTR tv209[rbp]
  0042b	88 88 2e 02 00
	00		 mov	 BYTE PTR [rax+558], cl

; 352  :     flags = TableFixFlags(flags, outer_window);

  00431	48 8b 55 28	 mov	 rdx, QWORD PTR outer_window$[rbp]
  00435	8b 8d a8 09 00
	00		 mov	 ecx, DWORD PTR flags$[rbp]
  0043b	e8 00 00 00 00	 call	 ?TableFixFlags@@YAHHPEAUImGuiWindow@@@Z ; TableFixFlags
  00440	89 85 a8 09 00
	00		 mov	 DWORD PTR flags$[rbp], eax

; 353  : 
; 354  :     // Initialize
; 355  :     table->ID = id;

  00446	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0044d	8b 8d 98 09 00
	00		 mov	 ecx, DWORD PTR id$[rbp]
  00453	89 08		 mov	 DWORD PTR [rax], ecx

; 356  :     table->Flags = flags;

  00455	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0045c	8b 8d a8 09 00
	00		 mov	 ecx, DWORD PTR flags$[rbp]
  00462	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 357  :     table->InstanceCurrent = (ImS16)instance_no;

  00465	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0046c	0f b7 8d f4 00
	00 00		 movzx	 ecx, WORD PTR instance_no$[rbp]
  00473	66 89 48 78	 mov	 WORD PTR [rax+120], cx

; 358  :     table->LastFrameActive = g.FrameCount;

  00477	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0047e	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00482	8b 89 20 3e 00
	00		 mov	 ecx, DWORD PTR [rcx+15904]
  00488	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 359  :     table->OuterWindow = table->InnerWindow = outer_window;

  0048b	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00492	48 8b 4d 28	 mov	 rcx, QWORD PTR outer_window$[rbp]
  00496	48 89 88 80 01
	00 00		 mov	 QWORD PTR [rax+384], rcx
  0049d	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004a4	48 8b 4d 28	 mov	 rcx, QWORD PTR outer_window$[rbp]
  004a8	48 89 88 78 01
	00 00		 mov	 QWORD PTR [rax+376], rcx

; 360  :     table->ColumnsCount = columns_count;

  004af	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004b6	8b 8d a0 09 00
	00		 mov	 ecx, DWORD PTR columns_count$[rbp]
  004bc	89 48 6c	 mov	 DWORD PTR [rax+108], ecx

; 361  :     table->IsLayoutLocked = false;

  004bf	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004c6	c6 80 22 02 00
	00 00		 mov	 BYTE PTR [rax+546], 0

; 362  :     table->InnerWidth = inner_width;

  004cd	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  004d4	f3 0f 10 85 b8
	09 00 00	 movss	 xmm0, DWORD PTR inner_width$[rbp]
  004dc	f3 0f 11 80 cc
	00 00 00	 movss	 DWORD PTR [rax+204], xmm0

; 363  :     temp_data->UserOuterSize = outer_size;

  004e4	48 8b 85 b0 09
	00 00		 mov	 rax, QWORD PTR outer_size$[rbp]
  004eb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004ee	48 8b 8d 78 01
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  004f5	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 364  :     if (instance_no > 0 && table->InstanceDataExtra.Size < instance_no)

  004f9	83 bd f4 00 00
	00 00		 cmp	 DWORD PTR instance_no$[rbp], 0
  00500	7e 37		 jle	 SHORT $LN13@BeginTable
  00502	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00509	8b 8d f4 00 00
	00		 mov	 ecx, DWORD PTR instance_no$[rbp]
  0050f	39 88 b0 01 00
	00		 cmp	 DWORD PTR [rax+432], ecx
  00515	7d 22		 jge	 SHORT $LN13@BeginTable

; 365  :         table->InstanceDataExtra.push_back(ImGuiTableInstanceData());

  00517	48 8d 8d a4 07
	00 00		 lea	 rcx, QWORD PTR $T16[rbp]
  0051e	e8 00 00 00 00	 call	 ??0ImGuiTableInstanceData@@QEAA@XZ ; ImGuiTableInstanceData::ImGuiTableInstanceData
  00523	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0052a	48 81 c1 b0 01
	00 00		 add	 rcx, 432		; 000001b0H
  00531	48 8b d0	 mov	 rdx, rax
  00534	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImGuiTableInstanceData@@@@QEAAXAEBUImGuiTableInstanceData@@@Z ; ImVector<ImGuiTableInstanceData>::push_back
$LN13@BeginTable:

; 366  : 
; 367  :     // When not using a child window, WorkRect.Max will grow as we append contents.
; 368  :     if (use_child_window)

  00539	0f b6 45 44	 movzx	 eax, BYTE PTR use_child_window$[rbp]
  0053d	85 c0		 test	 eax, eax
  0053f	0f 84 5c 03 00
	00		 je	 $LN14@BeginTable

; 369  :     {
; 370  :         // Ensure no vertical scrollbar appears if we only want horizontal one, to make flag consistent
; 371  :         // (we have no other way to disable vertical scrollbar of a window while keeping the horizontal one showing)
; 372  :         ImVec2 override_content_size(FLT_MAX, FLT_MAX);

  00545	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@7f7fffff
  0054d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  00555	48 8d 8d 98 01
	00 00		 lea	 rcx, QWORD PTR override_content_size$7[rbp]
  0055c	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2

; 373  :         if ((flags & ImGuiTableFlags_ScrollX) && !(flags & ImGuiTableFlags_ScrollY))

  00561	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00567	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0056c	85 c0		 test	 eax, eax
  0056e	74 1f		 je	 SHORT $LN16@BeginTable
  00570	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00576	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0057b	85 c0		 test	 eax, eax
  0057d	75 10		 jne	 SHORT $LN16@BeginTable

; 374  :             override_content_size.y = FLT_MIN;

  0057f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00800000
  00587	f3 0f 11 85 9c
	01 00 00	 movss	 DWORD PTR override_content_size$7[rbp+4], xmm0
$LN16@BeginTable:

; 375  : 
; 376  :         // Ensure specified width (when not specified, Stretched columns will act as if the width == OuterWidth and
; 377  :         // never lead to any scrolling). We don't handle inner_width < 0.0f, we could potentially use it to right-align
; 378  :         // based on the right side of the child window work rect, which would require knowing ahead if we are going to
; 379  :         // have decoration taking horizontal spaces (typically a vertical scrollbar).
; 380  :         if ((flags & ImGuiTableFlags_ScrollX) && inner_width > 0.0f)

  0058f	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00595	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0059a	85 c0		 test	 eax, eax
  0059c	74 21		 je	 SHORT $LN17@BeginTable
  0059e	f3 0f 10 85 b8
	09 00 00	 movss	 xmm0, DWORD PTR inner_width$[rbp]
  005a6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  005ad	76 10		 jbe	 SHORT $LN17@BeginTable

; 381  :             override_content_size.x = inner_width;

  005af	f3 0f 10 85 b8
	09 00 00	 movss	 xmm0, DWORD PTR inner_width$[rbp]
  005b7	f3 0f 11 85 98
	01 00 00	 movss	 DWORD PTR override_content_size$7[rbp], xmm0
$LN17@BeginTable:

; 382  : 
; 383  :         if (override_content_size.x != FLT_MAX || override_content_size.y != FLT_MAX)

  005bf	f3 0f 10 85 98
	01 00 00	 movss	 xmm0, DWORD PTR override_content_size$7[rbp]
  005c7	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@7f7fffff
  005ce	7a 19		 jp	 SHORT $LN19@BeginTable
  005d0	75 17		 jne	 SHORT $LN19@BeginTable
  005d2	f3 0f 10 85 9c
	01 00 00	 movss	 xmm0, DWORD PTR override_content_size$7[rbp+4]
  005da	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@7f7fffff
  005e1	7a 06		 jp	 SHORT $LN19@BeginTable
  005e3	0f 84 84 00 00
	00		 je	 $LN18@BeginTable
$LN19@BeginTable:

; 384  :             SetNextWindowContentSize(ImVec2(override_content_size.x != FLT_MAX ? override_content_size.x : 0.0f, override_content_size.y != FLT_MAX ? override_content_size.y : 0.0f));

  005e9	f3 0f 10 85 9c
	01 00 00	 movss	 xmm0, DWORD PTR override_content_size$7[rbp+4]
  005f1	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@7f7fffff
  005f8	7a 02		 jp	 SHORT $LN86@BeginTable
  005fa	74 12		 je	 SHORT $LN49@BeginTable
$LN86@BeginTable:
  005fc	f3 0f 10 85 9c
	01 00 00	 movss	 xmm0, DWORD PTR override_content_size$7[rbp+4]
  00604	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv252[rbp], xmm0
  0060c	eb 0b		 jmp	 SHORT $LN50@BeginTable
$LN49@BeginTable:
  0060e	0f 57 c0	 xorps	 xmm0, xmm0
  00611	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv252[rbp], xmm0
$LN50@BeginTable:
  00619	f3 0f 10 85 98
	01 00 00	 movss	 xmm0, DWORD PTR override_content_size$7[rbp]
  00621	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@7f7fffff
  00628	7a 02		 jp	 SHORT $LN85@BeginTable
  0062a	74 12		 je	 SHORT $LN51@BeginTable
$LN85@BeginTable:
  0062c	f3 0f 10 85 98
	01 00 00	 movss	 xmm0, DWORD PTR override_content_size$7[rbp]
  00634	f3 0f 11 85 58
	09 00 00	 movss	 DWORD PTR tv255[rbp], xmm0
  0063c	eb 0b		 jmp	 SHORT $LN52@BeginTable
$LN51@BeginTable:
  0063e	0f 57 c0	 xorps	 xmm0, xmm0
  00641	f3 0f 11 85 58
	09 00 00	 movss	 DWORD PTR tv255[rbp], xmm0
$LN52@BeginTable:
  00649	f3 0f 10 95 54
	09 00 00	 movss	 xmm2, DWORD PTR tv252[rbp]
  00651	f3 0f 10 8d 58
	09 00 00	 movss	 xmm1, DWORD PTR tv255[rbp]
  00659	48 8d 8d c4 07
	00 00		 lea	 rcx, QWORD PTR $T17[rbp]
  00660	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00665	48 8b c8	 mov	 rcx, rax
  00668	e8 00 00 00 00	 call	 ?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z ; ImGui::SetNextWindowContentSize
$LN18@BeginTable:

; 385  : 
; 386  :         // Reset scroll if we are reactivating it
; 387  :         if ((table_last_flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) == 0)

  0066d	8b 85 34 01 00
	00		 mov	 eax, DWORD PTR table_last_flags$[rbp]
  00673	25 00 00 00 03	 and	 eax, 50331648		; 03000000H
  00678	85 c0		 test	 eax, eax
  0067a	75 1a		 jne	 SHORT $LN20@BeginTable

; 388  :             SetNextWindowScroll(ImVec2(0.0f, 0.0f));

  0067c	0f 57 d2	 xorps	 xmm2, xmm2
  0067f	0f 57 c9	 xorps	 xmm1, xmm1
  00682	48 8d 8d e4 07
	00 00		 lea	 rcx, QWORD PTR $T18[rbp]
  00689	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  0068e	48 8b c8	 mov	 rcx, rax
  00691	e8 00 00 00 00	 call	 ?SetNextWindowScroll@ImGui@@YAXAEBUImVec2@@@Z ; ImGui::SetNextWindowScroll
$LN20@BeginTable:

; 389  : 
; 390  :         // Create scrolling region (without border and zero window padding)
; 391  :         ImGuiWindowFlags child_flags = (flags & ImGuiTableFlags_ScrollX) ? ImGuiWindowFlags_HorizontalScrollbar : ImGuiWindowFlags_None;

  00696	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  0069c	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  006a1	85 c0		 test	 eax, eax
  006a3	74 0c		 je	 SHORT $LN53@BeginTable
  006a5	c7 85 54 09 00
	00 00 08 00 00	 mov	 DWORD PTR tv267[rbp], 2048 ; 00000800H
  006af	eb 0a		 jmp	 SHORT $LN54@BeginTable
$LN53@BeginTable:
  006b1	c7 85 54 09 00
	00 00 00 00 00	 mov	 DWORD PTR tv267[rbp], 0
$LN54@BeginTable:
  006bb	8b 85 54 09 00
	00		 mov	 eax, DWORD PTR tv267[rbp]
  006c1	89 85 b4 01 00
	00		 mov	 DWORD PTR child_flags$8[rbp], eax

; 392  :         BeginChildEx(name, instance_id, outer_rect.GetSize(), false, child_flags);

  006c7	48 8d 95 04 08
	00 00		 lea	 rdx, QWORD PTR $T19[rbp]
  006ce	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR outer_rect$[rbp]
  006d5	e8 00 00 00 00	 call	 ?GetSize@ImRect@@QEBA?AUImVec2@@XZ ; ImRect::GetSize
  006da	8b 8d b4 01 00
	00		 mov	 ecx, DWORD PTR child_flags$8[rbp]
  006e0	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  006e4	45 33 c9	 xor	 r9d, r9d
  006e7	4c 8b c0	 mov	 r8, rax
  006ea	8b 95 14 01 00
	00		 mov	 edx, DWORD PTR instance_id$[rbp]
  006f0	48 8b 8d 90 09
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  006f7	e8 00 00 00 00	 call	 ?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z ; ImGui::BeginChildEx

; 393  :         table->InnerWindow = g.CurrentWindow;

  006fc	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00703	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00707	48 8b 89 a0 3e
	00 00		 mov	 rcx, QWORD PTR [rcx+16032]
  0070e	48 89 88 80 01
	00 00		 mov	 QWORD PTR [rax+384], rcx

; 394  :         table->WorkRect = table->InnerWindow->WorkRect;

  00715	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0071c	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00723	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0072a	48 8d b9 08 01
	00 00		 lea	 rdi, QWORD PTR [rcx+264]
  00731	48 8d b0 10 02
	00 00		 lea	 rsi, QWORD PTR [rax+528]
  00738	b9 10 00 00 00	 mov	 ecx, 16
  0073d	f3 a4		 rep movsb

; 395  :         table->OuterRect = table->InnerWindow->Rect();

  0073f	48 8d 95 24 08
	00 00		 lea	 rdx, QWORD PTR $T20[rbp]
  00746	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0074d	48 8b 88 80 01
	00 00		 mov	 rcx, QWORD PTR [rax+384]
  00754	e8 00 00 00 00	 call	 ?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ ; ImGuiWindow::Rect
  00759	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00760	48 8d b9 e8 00
	00 00		 lea	 rdi, QWORD PTR [rcx+232]
  00767	48 8b f0	 mov	 rsi, rax
  0076a	b9 10 00 00 00	 mov	 ecx, 16
  0076f	f3 a4		 rep movsb

; 396  :         table->InnerRect = table->InnerWindow->InnerRect;

  00771	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00778	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  0077f	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00786	48 8d b9 f8 00
	00 00		 lea	 rdi, QWORD PTR [rcx+248]
  0078d	48 8d b0 f0 01
	00 00		 lea	 rsi, QWORD PTR [rax+496]
  00794	b9 10 00 00 00	 mov	 ecx, 16
  00799	f3 a4		 rep movsb

; 397  :         IM_ASSERT(table->InnerWindow->WindowPadding.x == 0.0f && table->InnerWindow->WindowPadding.y == 0.0f && table->InnerWindow->WindowBorderSize == 0.0f);

  0079b	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  007a2	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  007a9	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [rax+72]
  007ae	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  007b5	7a 3e		 jp	 SHORT $LN55@BeginTable
  007b7	75 3c		 jne	 SHORT $LN55@BeginTable
  007b9	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  007c0	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  007c7	f3 0f 10 40 4c	 movss	 xmm0, DWORD PTR [rax+76]
  007cc	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  007d3	7a 20		 jp	 SHORT $LN55@BeginTable
  007d5	75 1e		 jne	 SHORT $LN55@BeginTable
  007d7	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  007de	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  007e5	f3 0f 10 40 54	 movss	 xmm0, DWORD PTR [rax+84]
  007ea	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  007f1	7a 02		 jp	 SHORT $LN55@BeginTable
  007f3	74 22		 je	 SHORT $LN56@BeginTable
$LN55@BeginTable:
  007f5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4JA
  007fb	83 c0 56	 add	 eax, 86			; 00000056H
  007fe	44 8b c0	 mov	 r8d, eax
  00801	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00808	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BBG@HLLCHCOP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAn?$AAn?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAP?$AAa?$AAd?$AAd?$AAi?$AAn@
  0080f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00815	33 c0		 xor	 eax, eax
$LN56@BeginTable:

; 398  : 
; 399  :         // When using multiple instances, ensure they have the same amount of horizontal decorations (aka vertical scrollbar) so stretched columns can be aligned)
; 400  :         if (instance_no == 0)

  00817	83 bd f4 00 00
	00 00		 cmp	 DWORD PTR instance_no$[rbp], 0
  0081e	75 29		 jne	 SHORT $LN21@BeginTable

; 401  :         {
; 402  :             table->HasScrollbarYPrev = table->HasScrollbarYCurr;

  00820	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00827	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0082e	0f b6 89 2f 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+559]
  00835	88 88 30 02 00
	00		 mov	 BYTE PTR [rax+560], cl

; 403  :             table->HasScrollbarYCurr = false;

  0083b	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00842	c6 80 2f 02 00
	00 00		 mov	 BYTE PTR [rax+559], 0
$LN21@BeginTable:

; 404  :         }
; 405  :         table->HasScrollbarYCurr |= (table->InnerWindow->ScrollMax.y > 0.0f);

  00849	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00850	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00857	f3 0f 10 80 88
	00 00 00	 movss	 xmm0, DWORD PTR [rax+136]
  0085f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00866	76 0c		 jbe	 SHORT $LN57@BeginTable
  00868	c7 85 54 09 00
	00 01 00 00 00	 mov	 DWORD PTR tv351[rbp], 1
  00872	eb 0a		 jmp	 SHORT $LN58@BeginTable
$LN57@BeginTable:
  00874	c7 85 54 09 00
	00 00 00 00 00	 mov	 DWORD PTR tv351[rbp], 0
$LN58@BeginTable:
  0087e	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00885	0f b6 80 2f 02
	00 00		 movzx	 eax, BYTE PTR [rax+559]
  0088c	0b 85 54 09 00
	00		 or	 eax, DWORD PTR tv351[rbp]
  00892	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00899	88 81 2f 02 00
	00		 mov	 BYTE PTR [rcx+559], al

; 406  :     }
; 407  :     else

  0089f	eb 65		 jmp	 SHORT $LN15@BeginTable
$LN14@BeginTable:

; 408  :     {
; 409  :         // For non-scrolling tables, WorkRect == OuterRect == InnerRect.
; 410  :         // But at this point we do NOT have a correct value for .Max.y (unless a height has been explicitly passed in). It will only be updated in EndTable().
; 411  :         table->WorkRect = table->OuterRect = table->InnerRect = outer_rect;

  008a1	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  008a8	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR outer_rect$[rbp]
  008af	48 8d b8 f8 00
	00 00		 lea	 rdi, QWORD PTR [rax+248]
  008b6	48 8b f1	 mov	 rsi, rcx
  008b9	b9 10 00 00 00	 mov	 ecx, 16
  008be	f3 a4		 rep movsb
  008c0	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  008c7	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  008ce	48 8d b8 e8 00
	00 00		 lea	 rdi, QWORD PTR [rax+232]
  008d5	48 8d b1 f8 00
	00 00		 lea	 rsi, QWORD PTR [rcx+248]
  008dc	b9 10 00 00 00	 mov	 ecx, 16
  008e1	f3 a4		 rep movsb
  008e3	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  008ea	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  008f1	48 8d b8 08 01
	00 00		 lea	 rdi, QWORD PTR [rax+264]
  008f8	48 8d b1 e8 00
	00 00		 lea	 rsi, QWORD PTR [rcx+232]
  008ff	b9 10 00 00 00	 mov	 ecx, 16
  00904	f3 a4		 rep movsb
$LN15@BeginTable:

; 412  :     }
; 413  : 
; 414  :     // Push a standardized ID for both child-using and not-child-using tables
; 415  :     PushOverrideID(instance_id);

  00906	8b 8d 14 01 00
	00		 mov	 ecx, DWORD PTR instance_id$[rbp]
  0090c	e8 00 00 00 00	 call	 ?PushOverrideID@ImGui@@YAXI@Z ; ImGui::PushOverrideID

; 416  : 
; 417  :     // Backup a copy of host window members we will modify
; 418  :     ImGuiWindow* inner_window = table->InnerWindow;

  00911	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00918	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  0091f	48 89 85 d8 01
	00 00		 mov	 QWORD PTR inner_window$[rbp], rax

; 419  :     table->HostIndentX = inner_window->DC.Indent.x;

  00926	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0092d	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR inner_window$[rbp]
  00934	f3 0f 10 81 3c
	01 00 00	 movss	 xmm0, DWORD PTR [rcx+316]
  0093c	f3 0f 11 80 b0
	00 00 00	 movss	 DWORD PTR [rax+176], xmm0

; 420  :     table->HostClipRect = inner_window->ClipRect;

  00944	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0094b	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR inner_window$[rbp]
  00952	48 8d b8 58 01
	00 00		 lea	 rdi, QWORD PTR [rax+344]
  00959	48 8d b1 30 02
	00 00		 lea	 rsi, QWORD PTR [rcx+560]
  00960	b9 10 00 00 00	 mov	 ecx, 16
  00965	f3 a4		 rep movsb

; 421  :     table->HostSkipItems = inner_window->SkipItems;

  00967	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0096e	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR inner_window$[rbp]
  00975	0f b6 89 b3 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+179]
  0097c	88 88 32 02 00
	00		 mov	 BYTE PTR [rax+562], cl

; 422  :     temp_data->HostBackupWorkRect = inner_window->WorkRect;

  00982	48 8b 85 78 01
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00989	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR inner_window$[rbp]
  00990	48 8d 78 28	 lea	 rdi, QWORD PTR [rax+40]
  00994	48 8d b1 10 02
	00 00		 lea	 rsi, QWORD PTR [rcx+528]
  0099b	b9 10 00 00 00	 mov	 ecx, 16
  009a0	f3 a4		 rep movsb

; 423  :     temp_data->HostBackupParentWorkRect = inner_window->ParentWorkRect;

  009a2	48 8b 85 78 01
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  009a9	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR inner_window$[rbp]
  009b0	48 8d 78 38	 lea	 rdi, QWORD PTR [rax+56]
  009b4	48 8d b1 20 02
	00 00		 lea	 rsi, QWORD PTR [rcx+544]
  009bb	b9 10 00 00 00	 mov	 ecx, 16
  009c0	f3 a4		 rep movsb

; 424  :     temp_data->HostBackupColumnsOffset = outer_window->DC.ColumnsOffset;

  009c2	48 8b 45 28	 mov	 rax, QWORD PTR outer_window$[rbp]
  009c6	8b 80 40 01 00
	00		 mov	 eax, DWORD PTR [rax+320]
  009cc	48 8b 8d 78 01
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  009d3	89 41 60	 mov	 DWORD PTR [rcx+96], eax

; 425  :     temp_data->HostBackupPrevLineSize = inner_window->DC.PrevLineSize;

  009d6	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  009dd	48 8b 80 28 01
	00 00		 mov	 rax, QWORD PTR [rax+296]
  009e4	48 8b 8d 78 01
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  009eb	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax

; 426  :     temp_data->HostBackupCurrLineSize = inner_window->DC.CurrLineSize;

  009ef	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  009f6	48 8b 80 20 01
	00 00		 mov	 rax, QWORD PTR [rax+288]
  009fd	48 8b 8d 78 01
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  00a04	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 427  :     temp_data->HostBackupCursorMaxPos = inner_window->DC.CursorMaxPos;

  00a08	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  00a0f	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  00a16	48 8b 8d 78 01
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  00a1d	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 428  :     temp_data->HostBackupItemWidth = outer_window->DC.ItemWidth;

  00a21	48 8b 85 78 01
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00a28	48 8b 4d 28	 mov	 rcx, QWORD PTR outer_window$[rbp]
  00a2c	f3 0f 10 81 b4
	01 00 00	 movss	 xmm0, DWORD PTR [rcx+436]
  00a34	f3 0f 11 40 64	 movss	 DWORD PTR [rax+100], xmm0

; 429  :     temp_data->HostBackupItemWidthStackSize = outer_window->DC.ItemWidthStack.Size;

  00a39	48 8b 85 78 01
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00a40	48 8b 4d 28	 mov	 rcx, QWORD PTR outer_window$[rbp]
  00a44	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [rcx+448]
  00a4a	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 430  :     inner_window->DC.PrevLineSize = inner_window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);

  00a4d	0f 57 d2	 xorps	 xmm2, xmm2
  00a50	0f 57 c9	 xorps	 xmm1, xmm1
  00a53	48 8d 8d 54 08
	00 00		 lea	 rcx, QWORD PTR $T21[rbp]
  00a5a	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00a5f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a62	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR inner_window$[rbp]
  00a69	48 89 81 20 01
	00 00		 mov	 QWORD PTR [rcx+288], rax
  00a70	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  00a77	48 8b 80 20 01
	00 00		 mov	 rax, QWORD PTR [rax+288]
  00a7e	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR inner_window$[rbp]
  00a85	48 89 81 28 01
	00 00		 mov	 QWORD PTR [rcx+296], rax

; 431  : 
; 432  :     // Padding and Spacing
; 433  :     // - None               ........Content..... Pad .....Content........
; 434  :     // - PadOuter           | Pad ..Content..... Pad .....Content.. Pad |
; 435  :     // - PadInner           ........Content.. Pad | Pad ..Content........
; 436  :     // - PadOuter+PadInner  | Pad ..Content.. Pad | Pad ..Content.. Pad |
; 437  :     const bool pad_outer_x = (flags & ImGuiTableFlags_NoPadOuterX) ? false : (flags & ImGuiTableFlags_PadOuterX) ? true : (flags & ImGuiTableFlags_BordersOuterV) != 0;

  00a8c	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00a92	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00a97	85 c0		 test	 eax, eax
  00a99	74 0c		 je	 SHORT $LN63@BeginTable
  00a9b	c7 85 54 09 00
	00 00 00 00 00	 mov	 DWORD PTR tv421[rbp], 0
  00aa5	eb 58		 jmp	 SHORT $LN64@BeginTable
$LN63@BeginTable:
  00aa7	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00aad	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00ab2	85 c0		 test	 eax, eax
  00ab4	74 0c		 je	 SHORT $LN61@BeginTable
  00ab6	c7 85 58 09 00
	00 01 00 00 00	 mov	 DWORD PTR tv419[rbp], 1
  00ac0	eb 31		 jmp	 SHORT $LN62@BeginTable
$LN61@BeginTable:
  00ac2	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00ac8	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00acd	85 c0		 test	 eax, eax
  00acf	74 0c		 je	 SHORT $LN59@BeginTable
  00ad1	c7 85 5c 09 00
	00 01 00 00 00	 mov	 DWORD PTR tv417[rbp], 1
  00adb	eb 0a		 jmp	 SHORT $LN60@BeginTable
$LN59@BeginTable:
  00add	c7 85 5c 09 00
	00 00 00 00 00	 mov	 DWORD PTR tv417[rbp], 0
$LN60@BeginTable:
  00ae7	8b 85 5c 09 00
	00		 mov	 eax, DWORD PTR tv417[rbp]
  00aed	89 85 58 09 00
	00		 mov	 DWORD PTR tv419[rbp], eax
$LN62@BeginTable:
  00af3	8b 85 58 09 00
	00		 mov	 eax, DWORD PTR tv419[rbp]
  00af9	89 85 54 09 00
	00		 mov	 DWORD PTR tv421[rbp], eax
$LN64@BeginTable:
  00aff	0f b6 85 54 09
	00 00		 movzx	 eax, BYTE PTR tv421[rbp]
  00b06	88 85 f4 01 00
	00		 mov	 BYTE PTR pad_outer_x$[rbp], al

; 438  :     const bool pad_inner_x = (flags & ImGuiTableFlags_NoPadInnerX) ? false : true;

  00b0c	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00b12	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00b17	85 c0		 test	 eax, eax
  00b19	74 09		 je	 SHORT $LN65@BeginTable
  00b1b	c6 85 54 09 00
	00 00		 mov	 BYTE PTR tv425[rbp], 0
  00b22	eb 07		 jmp	 SHORT $LN66@BeginTable
$LN65@BeginTable:
  00b24	c6 85 54 09 00
	00 01		 mov	 BYTE PTR tv425[rbp], 1
$LN66@BeginTable:
  00b2b	0f b6 85 54 09
	00 00		 movzx	 eax, BYTE PTR tv425[rbp]
  00b32	88 85 14 02 00
	00		 mov	 BYTE PTR pad_inner_x$[rbp], al

; 439  :     const float inner_spacing_for_border = (flags & ImGuiTableFlags_BordersInnerV) ? TABLE_BORDER_SIZE : 0.0f;

  00b38	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00b3e	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00b43	85 c0		 test	 eax, eax
  00b45	74 12		 je	 SHORT $LN67@BeginTable
  00b47	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b4f	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv428[rbp], xmm0
  00b57	eb 0b		 jmp	 SHORT $LN68@BeginTable
$LN67@BeginTable:
  00b59	0f 57 c0	 xorps	 xmm0, xmm0
  00b5c	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv428[rbp], xmm0
$LN68@BeginTable:
  00b64	f3 0f 10 85 54
	09 00 00	 movss	 xmm0, DWORD PTR tv428[rbp]
  00b6c	f3 0f 11 85 34
	02 00 00	 movss	 DWORD PTR inner_spacing_for_border$[rbp], xmm0

; 440  :     const float inner_spacing_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) == 0) ? g.Style.CellPadding.x : 0.0f;

  00b74	0f b6 85 14 02
	00 00		 movzx	 eax, BYTE PTR pad_inner_x$[rbp]
  00b7b	85 c0		 test	 eax, eax
  00b7d	74 25		 je	 SHORT $LN69@BeginTable
  00b7f	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00b85	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00b8a	85 c0		 test	 eax, eax
  00b8c	75 16		 jne	 SHORT $LN69@BeginTable
  00b8e	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00b92	f3 0f 10 80 3c
	38 00 00	 movss	 xmm0, DWORD PTR [rax+14396]
  00b9a	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv436[rbp], xmm0
  00ba2	eb 0b		 jmp	 SHORT $LN70@BeginTable
$LN69@BeginTable:
  00ba4	0f 57 c0	 xorps	 xmm0, xmm0
  00ba7	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv436[rbp], xmm0
$LN70@BeginTable:
  00baf	f3 0f 10 85 54
	09 00 00	 movss	 xmm0, DWORD PTR tv436[rbp]
  00bb7	f3 0f 11 85 54
	02 00 00	 movss	 DWORD PTR inner_spacing_explicit$[rbp], xmm0

; 441  :     const float inner_padding_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) != 0) ? g.Style.CellPadding.x : 0.0f;

  00bbf	0f b6 85 14 02
	00 00		 movzx	 eax, BYTE PTR pad_inner_x$[rbp]
  00bc6	85 c0		 test	 eax, eax
  00bc8	74 25		 je	 SHORT $LN71@BeginTable
  00bca	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00bd0	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00bd5	85 c0		 test	 eax, eax
  00bd7	74 16		 je	 SHORT $LN71@BeginTable
  00bd9	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00bdd	f3 0f 10 80 3c
	38 00 00	 movss	 xmm0, DWORD PTR [rax+14396]
  00be5	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv444[rbp], xmm0
  00bed	eb 0b		 jmp	 SHORT $LN72@BeginTable
$LN71@BeginTable:
  00bef	0f 57 c0	 xorps	 xmm0, xmm0
  00bf2	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv444[rbp], xmm0
$LN72@BeginTable:
  00bfa	f3 0f 10 85 54
	09 00 00	 movss	 xmm0, DWORD PTR tv444[rbp]
  00c02	f3 0f 11 85 74
	02 00 00	 movss	 DWORD PTR inner_padding_explicit$[rbp], xmm0

; 442  :     table->CellSpacingX1 = inner_spacing_explicit + inner_spacing_for_border;

  00c0a	f3 0f 10 85 54
	02 00 00	 movss	 xmm0, DWORD PTR inner_spacing_explicit$[rbp]
  00c12	f3 0f 58 85 34
	02 00 00	 addss	 xmm0, DWORD PTR inner_spacing_for_border$[rbp]
  00c1a	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c21	f3 0f 11 80 c4
	00 00 00	 movss	 DWORD PTR [rax+196], xmm0

; 443  :     table->CellSpacingX2 = inner_spacing_explicit;

  00c29	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c30	f3 0f 10 85 54
	02 00 00	 movss	 xmm0, DWORD PTR inner_spacing_explicit$[rbp]
  00c38	f3 0f 11 80 c8
	00 00 00	 movss	 DWORD PTR [rax+200], xmm0

; 444  :     table->CellPaddingX = inner_padding_explicit;

  00c40	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c47	f3 0f 10 85 74
	02 00 00	 movss	 xmm0, DWORD PTR inner_padding_explicit$[rbp]
  00c4f	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [rax+188], xmm0

; 445  :     table->CellPaddingY = g.Style.CellPadding.y;

  00c57	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00c5e	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00c62	f3 0f 10 81 40
	38 00 00	 movss	 xmm0, DWORD PTR [rcx+14400]
  00c6a	f3 0f 11 80 c0
	00 00 00	 movss	 DWORD PTR [rax+192], xmm0

; 446  : 
; 447  :     const float outer_padding_for_border = (flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;

  00c72	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00c78	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00c7d	85 c0		 test	 eax, eax
  00c7f	74 12		 je	 SHORT $LN73@BeginTable
  00c81	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c89	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv455[rbp], xmm0
  00c91	eb 0b		 jmp	 SHORT $LN74@BeginTable
$LN73@BeginTable:
  00c93	0f 57 c0	 xorps	 xmm0, xmm0
  00c96	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv455[rbp], xmm0
$LN74@BeginTable:
  00c9e	f3 0f 10 85 54
	09 00 00	 movss	 xmm0, DWORD PTR tv455[rbp]
  00ca6	f3 0f 11 85 94
	02 00 00	 movss	 DWORD PTR outer_padding_for_border$[rbp], xmm0

; 448  :     const float outer_padding_explicit = pad_outer_x ? g.Style.CellPadding.x : 0.0f;

  00cae	0f b6 85 f4 01
	00 00		 movzx	 eax, BYTE PTR pad_outer_x$[rbp]
  00cb5	85 c0		 test	 eax, eax
  00cb7	74 16		 je	 SHORT $LN75@BeginTable
  00cb9	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00cbd	f3 0f 10 80 3c
	38 00 00	 movss	 xmm0, DWORD PTR [rax+14396]
  00cc5	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv461[rbp], xmm0
  00ccd	eb 0b		 jmp	 SHORT $LN76@BeginTable
$LN75@BeginTable:
  00ccf	0f 57 c0	 xorps	 xmm0, xmm0
  00cd2	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv461[rbp], xmm0
$LN76@BeginTable:
  00cda	f3 0f 10 85 54
	09 00 00	 movss	 xmm0, DWORD PTR tv461[rbp]
  00ce2	f3 0f 11 85 b4
	02 00 00	 movss	 DWORD PTR outer_padding_explicit$[rbp], xmm0

; 449  :     table->OuterPaddingX = (outer_padding_for_border + outer_padding_explicit) - table->CellPaddingX;

  00cea	f3 0f 10 85 94
	02 00 00	 movss	 xmm0, DWORD PTR outer_padding_for_border$[rbp]
  00cf2	f3 0f 58 85 b4
	02 00 00	 addss	 xmm0, DWORD PTR outer_padding_explicit$[rbp]
  00cfa	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d01	f3 0f 5c 80 bc
	00 00 00	 subss	 xmm0, DWORD PTR [rax+188]
  00d09	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d10	f3 0f 11 80 b8
	00 00 00	 movss	 DWORD PTR [rax+184], xmm0

; 450  : 
; 451  :     table->CurrentColumn = -1;

  00d18	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d1f	c7 40 74 ff ff
	ff ff		 mov	 DWORD PTR [rax+116], -1

; 452  :     table->CurrentRow = -1;

  00d26	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d2d	c7 40 70 ff ff
	ff ff		 mov	 DWORD PTR [rax+112], -1

; 453  :     table->RowBgColorCounter = 0;

  00d34	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d3b	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 454  :     table->LastRowFlags = ImGuiTableRowFlags_None;

  00d45	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d4c	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00d52	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00d57	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00d5e	89 81 90 00 00
	00		 mov	 DWORD PTR [rcx+144], eax

; 455  :     table->InnerClipRect = (inner_window == outer_window) ? table->WorkRect : inner_window->ClipRect;

  00d64	48 8b 45 28	 mov	 rax, QWORD PTR outer_window$[rbp]
  00d68	48 39 85 d8 01
	00 00		 cmp	 QWORD PTR inner_window$[rbp], rax
  00d6f	75 16		 jne	 SHORT $LN77@BeginTable
  00d71	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00d78	48 05 08 01 00
	00		 add	 rax, 264		; 00000108H
  00d7e	48 89 85 58 09
	00 00		 mov	 QWORD PTR tv476[rbp], rax
  00d85	eb 14		 jmp	 SHORT $LN78@BeginTable
$LN77@BeginTable:
  00d87	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  00d8e	48 05 30 02 00
	00		 add	 rax, 560		; 00000230H
  00d94	48 89 85 58 09
	00 00		 mov	 QWORD PTR tv476[rbp], rax
$LN78@BeginTable:
  00d9b	48 8b 85 58 09
	00 00		 mov	 rax, QWORD PTR tv476[rbp]
  00da2	48 89 85 78 08
	00 00		 mov	 QWORD PTR $T22[rbp], rax
  00da9	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00db0	48 8d b8 18 01
	00 00		 lea	 rdi, QWORD PTR [rax+280]
  00db7	48 8b b5 78 08
	00 00		 mov	 rsi, QWORD PTR $T22[rbp]
  00dbe	b9 10 00 00 00	 mov	 ecx, 16
  00dc3	f3 a4		 rep movsb

; 456  :     table->InnerClipRect.ClipWith(table->WorkRect);     // We need this to honor inner_width

  00dc5	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00dcc	48 05 08 01 00
	00		 add	 rax, 264		; 00000108H
  00dd2	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00dd9	48 81 c1 18 01
	00 00		 add	 rcx, 280		; 00000118H
  00de0	48 8b d0	 mov	 rdx, rax
  00de3	e8 00 00 00 00	 call	 ?ClipWith@ImRect@@QEAAXAEBU1@@Z ; ImRect::ClipWith

; 457  :     table->InnerClipRect.ClipWithFull(table->HostClipRect);

  00de8	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00def	48 05 58 01 00
	00		 add	 rax, 344		; 00000158H
  00df5	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00dfc	48 81 c1 18 01
	00 00		 add	 rcx, 280		; 00000118H
  00e03	48 8b d0	 mov	 rdx, rax
  00e06	e8 00 00 00 00	 call	 ?ClipWithFull@ImRect@@QEAAXAEBU1@@Z ; ImRect::ClipWithFull

; 458  :     table->InnerClipRect.Max.y = (flags & ImGuiTableFlags_NoHostExtendY) ? ImMin(table->InnerClipRect.Max.y, inner_window->WorkRect.Max.y) : inner_window->ClipRect.Max.y;

  00e0b	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00e11	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00e16	85 c0		 test	 eax, eax
  00e18	74 2d		 je	 SHORT $LN79@BeginTable
  00e1a	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  00e21	f3 0f 10 88 1c
	02 00 00	 movss	 xmm1, DWORD PTR [rax+540]
  00e29	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00e30	f3 0f 10 80 24
	01 00 00	 movss	 xmm0, DWORD PTR [rax+292]
  00e38	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00e3d	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv503[rbp], xmm0
  00e45	eb 17		 jmp	 SHORT $LN80@BeginTable
$LN79@BeginTable:
  00e47	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  00e4e	f3 0f 10 80 3c
	02 00 00	 movss	 xmm0, DWORD PTR [rax+572]
  00e56	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv503[rbp], xmm0
$LN80@BeginTable:
  00e5e	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00e65	f3 0f 10 85 54
	09 00 00	 movss	 xmm0, DWORD PTR tv503[rbp]
  00e6d	f3 0f 11 80 24
	01 00 00	 movss	 DWORD PTR [rax+292], xmm0

; 459  : 
; 460  :     table->RowPosY1 = table->RowPosY2 = table->WorkRect.Min.y; // This is needed somehow

  00e75	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00e7c	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00e83	f3 0f 10 81 0c
	01 00 00	 movss	 xmm0, DWORD PTR [rcx+268]
  00e8b	f3 0f 11 80 80
	00 00 00	 movss	 DWORD PTR [rax+128], xmm0
  00e93	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00e9a	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00ea1	f3 0f 10 81 80
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+128]
  00ea9	f3 0f 11 40 7c	 movss	 DWORD PTR [rax+124], xmm0

; 461  :     table->RowTextBaseline = 0.0f; // This will be cleared again by TableBeginRow()

  00eae	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00eb5	0f 57 c0	 xorps	 xmm0, xmm0
  00eb8	f3 0f 11 80 88
	00 00 00	 movss	 DWORD PTR [rax+136], xmm0

; 462  :     table->FreezeRowsRequest = table->FreezeRowsCount = 0; // This will be setup by TableSetupScrollFreeze(), if any

  00ec0	33 c0		 xor	 eax, eax
  00ec2	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00ec9	66 89 81 14 02
	00 00		 mov	 WORD PTR [rcx+532], ax
  00ed0	33 c0		 xor	 eax, eax
  00ed2	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00ed9	66 89 81 12 02
	00 00		 mov	 WORD PTR [rcx+530], ax

; 463  :     table->FreezeColumnsRequest = table->FreezeColumnsCount = 0;

  00ee0	33 c0		 xor	 eax, eax
  00ee2	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00ee9	66 89 81 18 02
	00 00		 mov	 WORD PTR [rcx+536], ax
  00ef0	33 c0		 xor	 eax, eax
  00ef2	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00ef9	66 89 81 16 02
	00 00		 mov	 WORD PTR [rcx+534], ax

; 464  :     table->IsUnfrozenRows = true;

  00f00	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00f07	c6 80 2d 02 00
	00 01		 mov	 BYTE PTR [rax+557], 1

; 465  :     table->DeclColumnsCount = 0;

  00f0e	33 c0		 xor	 eax, eax
  00f10	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00f17	66 89 81 f6 01
	00 00		 mov	 WORD PTR [rcx+502], ax

; 466  : 
; 467  :     // Using opaque colors facilitate overlapping elements of the grid
; 468  :     table->BorderColorStrong = GetColorU32(ImGuiCol_TableBorderStrong);

  00f1e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00f26	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00f2b	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00f30	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00f37	89 81 a0 00 00
	00		 mov	 DWORD PTR [rcx+160], eax

; 469  :     table->BorderColorLight = GetColorU32(ImGuiCol_TableBorderLight);

  00f3d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00f45	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00f4a	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00f4f	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00f56	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax

; 470  : 
; 471  :     // Make table current
; 472  :     g.CurrentTable = table;

  00f5c	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00f60	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  00f67	48 89 88 e8 4a
	00 00		 mov	 QWORD PTR [rax+19176], rcx

; 473  :     outer_window->DC.CurrentTableIdx = table_idx;

  00f6e	48 8b 45 28	 mov	 rax, QWORD PTR outer_window$[rbp]
  00f72	8b 8d 54 01 00
	00		 mov	 ecx, DWORD PTR table_idx$[rbp]
  00f78	89 88 a8 01 00
	00		 mov	 DWORD PTR [rax+424], ecx

; 474  :     if (inner_window != outer_window) // So EndChild() within the inner window can restore the table properly.

  00f7e	48 8b 45 28	 mov	 rax, QWORD PTR outer_window$[rbp]
  00f82	48 39 85 d8 01
	00 00		 cmp	 QWORD PTR inner_window$[rbp], rax
  00f89	74 13		 je	 SHORT $LN22@BeginTable

; 475  :         inner_window->DC.CurrentTableIdx = table_idx;

  00f8b	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  00f92	8b 8d 54 01 00
	00		 mov	 ecx, DWORD PTR table_idx$[rbp]
  00f98	89 88 a8 01 00
	00		 mov	 DWORD PTR [rax+424], ecx
$LN22@BeginTable:

; 476  : 
; 477  :     if ((table_last_flags & ImGuiTableFlags_Reorderable) && (flags & ImGuiTableFlags_Reorderable) == 0)

  00f9e	8b 85 34 01 00
	00		 mov	 eax, DWORD PTR table_last_flags$[rbp]
  00fa4	83 e0 02	 and	 eax, 2
  00fa7	85 c0		 test	 eax, eax
  00fa9	74 1b		 je	 SHORT $LN23@BeginTable
  00fab	8b 85 a8 09 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00fb1	83 e0 02	 and	 eax, 2
  00fb4	85 c0		 test	 eax, eax
  00fb6	75 0e		 jne	 SHORT $LN23@BeginTable

; 478  :         table->IsResetDisplayOrderRequest = true;

  00fb8	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  00fbf	c6 80 2c 02 00
	00 01		 mov	 BYTE PTR [rax+556], 1
$LN23@BeginTable:

; 479  : 
; 480  :     // Mark as used
; 481  :     if (table_idx >= g.TablesLastTimeActive.Size)

  00fc6	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00fca	8b 80 30 4b 00
	00		 mov	 eax, DWORD PTR [rax+19248]
  00fd0	39 85 54 01 00
	00		 cmp	 DWORD PTR table_idx$[rbp], eax
  00fd6	7c 31		 jl	 SHORT $LN24@BeginTable

; 482  :         g.TablesLastTimeActive.resize(table_idx + 1, -1.0f);

  00fd8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00fe0	f3 0f 11 85 94
	08 00 00	 movss	 DWORD PTR $T23[rbp], xmm0
  00fe8	8b 85 54 01 00
	00		 mov	 eax, DWORD PTR table_idx$[rbp]
  00fee	ff c0		 inc	 eax
  00ff0	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00ff4	48 81 c1 30 4b
	00 00		 add	 rcx, 19248		; 00004b30H
  00ffb	4c 8d 85 94 08
	00 00		 lea	 r8, QWORD PTR $T23[rbp]
  01002	8b d0		 mov	 edx, eax
  01004	e8 00 00 00 00	 call	 ?resize@?$ImVector@M@@QEAAXHAEBM@Z ; ImVector<float>::resize
$LN24@BeginTable:

; 483  :     g.TablesLastTimeActive[table_idx] = (float)g.Time;

  01009	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0100d	f2 0f 5a 80 18
	3e 00 00	 cvtsd2ss xmm0, QWORD PTR [rax+15896]
  01015	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv549[rbp], xmm0
  0101d	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  01021	48 05 30 4b 00
	00		 add	 rax, 19248		; 00004b30H
  01027	8b 95 54 01 00
	00		 mov	 edx, DWORD PTR table_idx$[rbp]
  0102d	48 8b c8	 mov	 rcx, rax
  01030	e8 00 00 00 00	 call	 ??A?$ImVector@M@@QEAAAEAMH@Z ; ImVector<float>::operator[]
  01035	f3 0f 10 85 54
	09 00 00	 movss	 xmm0, DWORD PTR tv549[rbp]
  0103d	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 484  :     temp_data->LastTimeActive = (float)g.Time;

  01041	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  01045	f2 0f 5a 80 18
	3e 00 00	 cvtsd2ss xmm0, QWORD PTR [rax+15896]
  0104d	48 8b 85 78 01
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  01054	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 485  :     table->MemoryCompacted = false;

  01059	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01060	c6 80 31 02 00
	00 00		 mov	 BYTE PTR [rax+561], 0

; 486  : 
; 487  :     // Setup memory buffer (clear data if columns count changed)
; 488  :     ImGuiTableColumn* old_columns_to_preserve = NULL;

  01067	48 c7 85 d8 02
	00 00 00 00 00
	00		 mov	 QWORD PTR old_columns_to_preserve$[rbp], 0

; 489  :     void* old_columns_raw_data = NULL;

  01072	48 c7 85 f8 02
	00 00 00 00 00
	00		 mov	 QWORD PTR old_columns_raw_data$[rbp], 0

; 490  :     const int old_columns_count = table->Columns.size();

  0107d	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01084	48 83 c0 18	 add	 rax, 24
  01088	48 8b c8	 mov	 rcx, rax
  0108b	e8 00 00 00 00	 call	 ?size@?$ImSpan@UImGuiTableColumn@@@@QEBAHXZ ; ImSpan<ImGuiTableColumn>::size
  01090	89 85 14 03 00
	00		 mov	 DWORD PTR old_columns_count$[rbp], eax

; 491  :     if (old_columns_count != 0 && old_columns_count != columns_count)

  01096	83 bd 14 03 00
	00 00		 cmp	 DWORD PTR old_columns_count$[rbp], 0
  0109d	74 41		 je	 SHORT $LN25@BeginTable
  0109f	8b 85 a0 09 00
	00		 mov	 eax, DWORD PTR columns_count$[rbp]
  010a5	39 85 14 03 00
	00		 cmp	 DWORD PTR old_columns_count$[rbp], eax
  010ab	74 33		 je	 SHORT $LN25@BeginTable

; 492  :     {
; 493  :         // Attempt to preserve width on column count change (#4046)
; 494  :         old_columns_to_preserve = table->Columns.Data;

  010ad	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  010b4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  010b8	48 89 85 d8 02
	00 00		 mov	 QWORD PTR old_columns_to_preserve$[rbp], rax

; 495  :         old_columns_raw_data = table->RawData;

  010bf	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  010c6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  010ca	48 89 85 f8 02
	00 00		 mov	 QWORD PTR old_columns_raw_data$[rbp], rax

; 496  :         table->RawData = NULL;

  010d1	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  010d8	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN25@BeginTable:

; 497  :     }
; 498  :     if (table->RawData == NULL)

  010e0	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  010e7	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  010ec	75 2e		 jne	 SHORT $LN26@BeginTable

; 499  :     {
; 500  :         TableBeginInitMemory(table, columns_count);

  010ee	8b 95 a0 09 00
	00		 mov	 edx, DWORD PTR columns_count$[rbp]
  010f4	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  010fb	e8 00 00 00 00	 call	 ?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z ; ImGui::TableBeginInitMemory

; 501  :         table->IsInitializing = table->IsSettingsRequestLoad = true;

  01100	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01107	c6 80 28 02 00
	00 01		 mov	 BYTE PTR [rax+552], 1
  0110e	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01115	c6 80 24 02 00
	00 01		 mov	 BYTE PTR [rax+548], 1
$LN26@BeginTable:

; 502  :     }
; 503  :     if (table->IsResetAllRequest)

  0111c	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01123	0f b6 80 2b 02
	00 00		 movzx	 eax, BYTE PTR [rax+555]
  0112a	85 c0		 test	 eax, eax
  0112c	74 0c		 je	 SHORT $LN27@BeginTable

; 504  :         TableResetSettings(table);

  0112e	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01135	e8 00 00 00 00	 call	 ?TableResetSettings@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableResetSettings
$LN27@BeginTable:

; 505  :     if (table->IsInitializing)

  0113a	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01141	0f b6 80 24 02
	00 00		 movzx	 eax, BYTE PTR [rax+548]
  01148	85 c0		 test	 eax, eax
  0114a	0f 84 e6 01 00
	00		 je	 $LN28@BeginTable

; 506  :     {
; 507  :         // Initialize
; 508  :         table->SettingsOffset = -1;

  01150	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01157	c7 40 64 ff ff
	ff ff		 mov	 DWORD PTR [rax+100], -1

; 509  :         table->IsSortSpecsDirty = true;

  0115e	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01165	c6 80 25 02 00
	00 01		 mov	 BYTE PTR [rax+549], 1

; 510  :         table->InstanceInteracted = -1;

  0116c	b8 ff ff ff ff	 mov	 eax, -1
  01171	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01178	66 89 41 7a	 mov	 WORD PTR [rcx+122], ax

; 511  :         table->ContextPopupColumn = -1;

  0117c	b8 ff ff ff ff	 mov	 eax, -1
  01181	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01188	66 89 81 10 02
	00 00		 mov	 WORD PTR [rcx+528], ax

; 512  :         table->ReorderColumn = table->ResizedColumn = table->LastResizedColumn = -1;

  0118f	b8 ff ff ff ff	 mov	 eax, -1
  01194	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  0119b	66 89 81 00 02
	00 00		 mov	 WORD PTR [rcx+512], ax
  011a2	b8 ff ff ff ff	 mov	 eax, -1
  011a7	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  011ae	66 89 81 fe 01
	00 00		 mov	 WORD PTR [rcx+510], ax
  011b5	b8 ff ff ff ff	 mov	 eax, -1
  011ba	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  011c1	66 89 81 04 02
	00 00		 mov	 WORD PTR [rcx+516], ax

; 513  :         table->AutoFitSingleColumn = -1;

  011c8	b8 ff ff ff ff	 mov	 eax, -1
  011cd	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  011d4	66 89 81 fc 01
	00 00		 mov	 WORD PTR [rcx+508], ax

; 514  :         table->HoveredColumnBody = table->HoveredColumnBorder = -1;

  011db	b8 ff ff ff ff	 mov	 eax, -1
  011e0	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  011e7	66 89 81 fa 01
	00 00		 mov	 WORD PTR [rcx+506], ax
  011ee	b8 ff ff ff ff	 mov	 eax, -1
  011f3	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  011fa	66 89 81 f8 01
	00 00		 mov	 WORD PTR [rcx+504], ax

; 515  :         for (int n = 0; n < columns_count; n++)

  01201	c7 85 34 03 00
	00 00 00 00 00	 mov	 DWORD PTR n$9[rbp], 0
  0120b	eb 0e		 jmp	 SHORT $LN4@BeginTable
$LN2@BeginTable:
  0120d	8b 85 34 03 00
	00		 mov	 eax, DWORD PTR n$9[rbp]
  01213	ff c0		 inc	 eax
  01215	89 85 34 03 00
	00		 mov	 DWORD PTR n$9[rbp], eax
$LN4@BeginTable:
  0121b	8b 85 a0 09 00
	00		 mov	 eax, DWORD PTR columns_count$[rbp]
  01221	39 85 34 03 00
	00		 cmp	 DWORD PTR n$9[rbp], eax
  01227	0f 8d 09 01 00
	00		 jge	 $LN28@BeginTable

; 516  :         {
; 517  :             ImGuiTableColumn* column = &table->Columns[n];

  0122d	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01234	48 83 c0 18	 add	 rax, 24
  01238	8b 95 34 03 00
	00		 mov	 edx, DWORD PTR n$9[rbp]
  0123e	48 8b c8	 mov	 rcx, rax
  01241	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  01246	48 89 85 58 03
	00 00		 mov	 QWORD PTR column$10[rbp], rax

; 518  :             if (old_columns_to_preserve && n < old_columns_count)

  0124d	48 83 bd d8 02
	00 00 00	 cmp	 QWORD PTR old_columns_to_preserve$[rbp], 0
  01255	74 34		 je	 SHORT $LN29@BeginTable
  01257	8b 85 14 03 00
	00		 mov	 eax, DWORD PTR old_columns_count$[rbp]
  0125d	39 85 34 03 00
	00		 cmp	 DWORD PTR n$9[rbp], eax
  01263	7d 26		 jge	 SHORT $LN29@BeginTable

; 519  :             {
; 520  :                 // FIXME: We don't attempt to preserve column order in this path.
; 521  :                 *column = old_columns_to_preserve[n];

  01265	48 63 85 34 03
	00 00		 movsxd	 rax, DWORD PTR n$9[rbp]
  0126c	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  01270	48 8b 8d d8 02
	00 00		 mov	 rcx, QWORD PTR old_columns_to_preserve$[rbp]
  01277	48 8b bd 58 03
	00 00		 mov	 rdi, QWORD PTR column$10[rbp]
  0127e	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  01282	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  01287	f3 a4		 rep movsb

; 522  :             }
; 523  :             else

  01289	eb 71		 jmp	 SHORT $LN30@BeginTable
$LN29@BeginTable:

; 524  :             {
; 525  :                 float width_auto = column->WidthAuto;

  0128b	48 8b 85 58 03
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  01292	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  01297	f3 0f 11 85 74
	03 00 00	 movss	 DWORD PTR width_auto$11[rbp], xmm0

; 526  :                 *column = ImGuiTableColumn();

  0129f	48 8d 8d b4 08
	00 00		 lea	 rcx, QWORD PTR $T24[rbp]
  012a6	e8 00 00 00 00	 call	 ??0ImGuiTableColumn@@QEAA@XZ ; ImGuiTableColumn::ImGuiTableColumn
  012ab	48 8b bd 58 03
	00 00		 mov	 rdi, QWORD PTR column$10[rbp]
  012b2	48 8b f0	 mov	 rsi, rax
  012b5	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  012ba	f3 a4		 rep movsb

; 527  :                 column->WidthAuto = width_auto;

  012bc	48 8b 85 58 03
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  012c3	f3 0f 10 85 74
	03 00 00	 movss	 xmm0, DWORD PTR width_auto$11[rbp]
  012cb	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0

; 528  :                 column->IsPreserveWidthAuto = true; // Preserve WidthAuto when reinitializing a live table: not technically necessary but remove a visible flicker

  012d0	48 8b 85 58 03
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  012d7	c6 40 69 01	 mov	 BYTE PTR [rax+105], 1

; 529  :                 column->IsEnabled = column->IsUserEnabled = column->IsUserEnabledNextFrame = true;

  012db	48 8b 85 58 03
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  012e2	c6 40 64 01	 mov	 BYTE PTR [rax+100], 1
  012e6	48 8b 85 58 03
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  012ed	c6 40 63 01	 mov	 BYTE PTR [rax+99], 1
  012f1	48 8b 85 58 03
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  012f8	c6 40 62 01	 mov	 BYTE PTR [rax+98], 1
$LN30@BeginTable:

; 530  :             }
; 531  :             column->DisplayOrder = table->DisplayOrderToIndex[n] = (ImGuiTableColumnIdx)n;

  012fc	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01303	48 83 c0 28	 add	 rax, 40			; 00000028H
  01307	8b 95 34 03 00
	00		 mov	 edx, DWORD PTR n$9[rbp]
  0130d	48 8b c8	 mov	 rcx, rax
  01310	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  01315	0f b7 8d 34 03
	00 00		 movzx	 ecx, WORD PTR n$9[rbp]
  0131c	66 89 08	 mov	 WORD PTR [rax], cx
  0131f	48 8b 85 58 03
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  01326	0f b7 8d 34 03
	00 00		 movzx	 ecx, WORD PTR n$9[rbp]
  0132d	66 89 48 52	 mov	 WORD PTR [rax+82], cx

; 532  :         }

  01331	e9 d7 fe ff ff	 jmp	 $LN2@BeginTable
$LN28@BeginTable:

; 533  :     }
; 534  :     if (old_columns_raw_data)

  01336	48 83 bd f8 02
	00 00 00	 cmp	 QWORD PTR old_columns_raw_data$[rbp], 0
  0133e	74 0c		 je	 SHORT $LN31@BeginTable

; 535  :         IM_FREE(old_columns_raw_data);

  01340	48 8b 8d f8 02
	00 00		 mov	 rcx, QWORD PTR old_columns_raw_data$[rbp]
  01347	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN31@BeginTable:

; 536  : 
; 537  :     // Load settings
; 538  :     if (table->IsSettingsRequestLoad)

  0134c	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01353	0f b6 80 28 02
	00 00		 movzx	 eax, BYTE PTR [rax+552]
  0135a	85 c0		 test	 eax, eax
  0135c	74 0c		 je	 SHORT $LN32@BeginTable

; 539  :         TableLoadSettings(table);

  0135e	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  01365	e8 00 00 00 00	 call	 ?TableLoadSettings@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableLoadSettings
$LN32@BeginTable:

; 540  : 
; 541  :     // Handle DPI/font resize
; 542  :     // This is designed to facilitate DPI changes with the assumption that e.g. style.CellPadding has been scaled as well.
; 543  :     // It will also react to changing fonts with mixed results. It doesn't need to be perfect but merely provide a decent transition.
; 544  :     // FIXME-DPI: Provide consistent standards for reference size. Perhaps using g.CurrentDpiScale would be more self explanatory.
; 545  :     // This is will lead us to non-rounded WidthRequest in columns, which should work but is a poorly tested path.
; 546  :     const float new_ref_scale_unit = g.FontSize; // g.Font->GetCharAdvance('A') ?

  0136a	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0136e	f3 0f 10 80 00
	3c 00 00	 movss	 xmm0, DWORD PTR [rax+15360]
  01376	f3 0f 11 85 94
	03 00 00	 movss	 DWORD PTR new_ref_scale_unit$[rbp], xmm0

; 547  :     if (table->RefScale != 0.0f && table->RefScale != new_ref_scale_unit)

  0137e	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01385	f3 0f 10 80 e4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+228]
  0138d	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  01394	7a 06		 jp	 SHORT $LN83@BeginTable
  01396	0f 84 bb 00 00
	00		 je	 $LN33@BeginTable
$LN83@BeginTable:
  0139c	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  013a3	f3 0f 10 80 e4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+228]
  013ab	0f 2e 85 94 03
	00 00		 ucomiss xmm0, DWORD PTR new_ref_scale_unit$[rbp]
  013b2	7a 06		 jp	 SHORT $LN82@BeginTable
  013b4	0f 84 9d 00 00
	00		 je	 $LN33@BeginTable
$LN82@BeginTable:

; 548  :     {
; 549  :         const float scale_factor = new_ref_scale_unit / table->RefScale;

  013ba	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  013c1	f3 0f 10 85 94
	03 00 00	 movss	 xmm0, DWORD PTR new_ref_scale_unit$[rbp]
  013c9	f3 0f 5e 80 e4
	00 00 00	 divss	 xmm0, DWORD PTR [rax+228]
  013d1	f3 0f 11 85 b4
	03 00 00	 movss	 DWORD PTR scale_factor$12[rbp], xmm0

; 550  :         //IMGUI_DEBUG_PRINT("[table] %08X RefScaleUnit %.3f -> %.3f, scaling width by %.3f\n", table->ID, table->RefScaleUnit, new_ref_scale_unit, scale_factor);
; 551  :         for (int n = 0; n < columns_count; n++)

  013d9	c7 85 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR n$13[rbp], 0
  013e3	eb 0e		 jmp	 SHORT $LN7@BeginTable
$LN5@BeginTable:
  013e5	8b 85 d4 03 00
	00		 mov	 eax, DWORD PTR n$13[rbp]
  013eb	ff c0		 inc	 eax
  013ed	89 85 d4 03 00
	00		 mov	 DWORD PTR n$13[rbp], eax
$LN7@BeginTable:
  013f3	8b 85 a0 09 00
	00		 mov	 eax, DWORD PTR columns_count$[rbp]
  013f9	39 85 d4 03 00
	00		 cmp	 DWORD PTR n$13[rbp], eax
  013ff	7d 56		 jge	 SHORT $LN33@BeginTable

; 552  :             table->Columns[n].WidthRequest = table->Columns[n].WidthRequest * scale_factor;

  01401	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01408	48 83 c0 18	 add	 rax, 24
  0140c	8b 95 d4 03 00
	00		 mov	 edx, DWORD PTR n$13[rbp]
  01412	48 8b c8	 mov	 rcx, rax
  01415	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  0141a	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  0141f	f3 0f 59 85 b4
	03 00 00	 mulss	 xmm0, DWORD PTR scale_factor$12[rbp]
  01427	f3 0f 11 85 54
	09 00 00	 movss	 DWORD PTR tv637[rbp], xmm0
  0142f	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01436	48 83 c0 18	 add	 rax, 24
  0143a	8b 95 d4 03 00
	00		 mov	 edx, DWORD PTR n$13[rbp]
  01440	48 8b c8	 mov	 rcx, rax
  01443	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  01448	f3 0f 10 85 54
	09 00 00	 movss	 xmm0, DWORD PTR tv637[rbp]
  01450	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
  01455	eb 8e		 jmp	 SHORT $LN5@BeginTable
$LN33@BeginTable:

; 553  :     }
; 554  :     table->RefScale = new_ref_scale_unit;

  01457	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  0145e	f3 0f 10 85 94
	03 00 00	 movss	 xmm0, DWORD PTR new_ref_scale_unit$[rbp]
  01466	f3 0f 11 80 e4
	00 00 00	 movss	 DWORD PTR [rax+228], xmm0

; 555  : 
; 556  :     // Disable output until user calls TableNextRow() or TableNextColumn() leading to the TableUpdateLayout() call..
; 557  :     // This is not strictly necessary but will reduce cases were "out of table" output will be misleading to the user.
; 558  :     // Because we cannot safely assert in EndTable() when no rows have been created, this seems like our best option.
; 559  :     inner_window->SkipItems = true;

  0146e	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR inner_window$[rbp]
  01475	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1

; 560  : 
; 561  :     // Clear names
; 562  :     // At this point the ->NameOffset field of each column will be invalid until TableUpdateLayout() or the first call to TableSetupColumn()
; 563  :     if (table->ColumnsNames.Buf.Size > 0)

  0147c	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01483	83 b8 88 01 00
	00 00		 cmp	 DWORD PTR [rax+392], 0
  0148a	7e 17		 jle	 SHORT $LN34@BeginTable

; 564  :         table->ColumnsNames.Buf.resize(0);

  0148c	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR table$[rbp]
  01493	48 05 88 01 00
	00		 add	 rax, 392		; 00000188H
  01499	33 d2		 xor	 edx, edx
  0149b	48 8b c8	 mov	 rcx, rax
  0149e	e8 00 00 00 00	 call	 ?resize@?$ImVector@D@@QEAAXH@Z ; ImVector<char>::resize
$LN34@BeginTable:

; 565  : 
; 566  :     // Apply queued resizing/reordering/hiding requests
; 567  :     TableBeginApplyRequests(table);

  014a3	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR table$[rbp]
  014aa	e8 00 00 00 00	 call	 ?TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableBeginApplyRequests

; 568  : 
; 569  :     return true;

  014af	b0 01		 mov	 al, 1
$LN1@BeginTable:

; 570  : }

  014b1	48 8b f8	 mov	 rdi, rax
  014b4	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  014b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z$rtcFrameData
  014bf	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  014c4	48 8b c7	 mov	 rax, rdi
  014c7	48 8b 8d 68 09
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  014ce	48 33 cd	 xor	 rcx, rbp
  014d1	e8 00 00 00 00	 call	 __security_check_cookie
  014d6	48 8d a5 70 09
	00 00		 lea	 rsp, QWORD PTR [rbp+2416]
  014dd	5f		 pop	 rdi
  014de	5e		 pop	 rsi
  014df	5d		 pop	 rbp
  014e0	c3		 ret	 0
?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z ENDP	; ImGui::BeginTableEx
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
g$ = 8
outer_window$ = 40
use_child_window$ = 68
avail_size$ = 104
actual_outer_size$ = 136
outer_rect$ = 168
table$ = 216
instance_no$ = 244
instance_id$ = 276
table_last_flags$ = 308
table_idx$ = 340
temp_data$ = 376
override_content_size$7 = 408
child_flags$8 = 436
inner_window$ = 472
pad_outer_x$ = 500
pad_inner_x$ = 532
inner_spacing_for_border$ = 564
inner_spacing_explicit$ = 596
inner_padding_explicit$ = 628
outer_padding_for_border$ = 660
outer_padding_explicit$ = 692
old_columns_to_preserve$ = 728
old_columns_raw_data$ = 760
old_columns_count$ = 788
n$9 = 820
column$10 = 856
width_auto$11 = 884
new_ref_scale_unit$ = 916
scale_factor$12 = 948
n$13 = 980
$T14 = 1780
$T15 = 1816
$T16 = 1956
$T17 = 1988
$T18 = 2020
$T19 = 2052
$T20 = 2084
$T21 = 2132
$T22 = 2168
$T23 = 2196
$T24 = 2228
$T25 = 2376
tv637 = 2388
tv549 = 2388
tv503 = 2388
tv461 = 2388
tv455 = 2388
tv444 = 2388
tv436 = 2388
tv428 = 2388
tv425 = 2388
tv421 = 2388
tv351 = 2388
tv267 = 2388
tv252 = 2388
tv209 = 2388
tv180 = 2388
tv162 = 2388
tv93 = 2388
tv85 = 2388
tv651 = 2392
tv476 = 2392
tv419 = 2392
tv255 = 2392
tv196 = 2392
tv417 = 2396
tv650 = 2400
__$ArrayPad$ = 2408
name$ = 2448
id$ = 2456
columns_count$ = 2464
flags$ = 2472
outer_size$ = 2480
inner_width$ = 2488
?dtor$0@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4HA PROC ; `ImGui::BeginTableEx'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  00014	48 8d 8d 18 07
	00 00		 lea	 rcx, QWORD PTR $T15[rbp]
  0001b	e8 00 00 00 00	 call	 ??1ImGuiTableTempData@@QEAA@XZ
  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	5f		 pop	 rdi
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
?dtor$0@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4HA ENDP ; `ImGui::BeginTableEx'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
g$ = 8
outer_window$ = 40
use_child_window$ = 68
avail_size$ = 104
actual_outer_size$ = 136
outer_rect$ = 168
table$ = 216
instance_no$ = 244
instance_id$ = 276
table_last_flags$ = 308
table_idx$ = 340
temp_data$ = 376
override_content_size$7 = 408
child_flags$8 = 436
inner_window$ = 472
pad_outer_x$ = 500
pad_inner_x$ = 532
inner_spacing_for_border$ = 564
inner_spacing_explicit$ = 596
inner_padding_explicit$ = 628
outer_padding_for_border$ = 660
outer_padding_explicit$ = 692
old_columns_to_preserve$ = 728
old_columns_raw_data$ = 760
old_columns_count$ = 788
n$9 = 820
column$10 = 856
width_auto$11 = 884
new_ref_scale_unit$ = 916
scale_factor$12 = 948
n$13 = 980
$T14 = 1780
$T15 = 1816
$T16 = 1956
$T17 = 1988
$T18 = 2020
$T19 = 2052
$T20 = 2084
$T21 = 2132
$T22 = 2168
$T23 = 2196
$T24 = 2228
$T25 = 2376
tv637 = 2388
tv549 = 2388
tv503 = 2388
tv461 = 2388
tv455 = 2388
tv444 = 2388
tv436 = 2388
tv428 = 2388
tv425 = 2388
tv421 = 2388
tv351 = 2388
tv267 = 2388
tv252 = 2388
tv209 = 2388
tv180 = 2388
tv162 = 2388
tv93 = 2388
tv85 = 2388
tv651 = 2392
tv476 = 2392
tv419 = 2392
tv255 = 2392
tv196 = 2392
tv417 = 2396
tv650 = 2400
__$ArrayPad$ = 2408
name$ = 2448
id$ = 2456
columns_count$ = 2464
flags$ = 2472
outer_size$ = 2480
inner_width$ = 2488
?dtor$0@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4HA PROC ; `ImGui::BeginTableEx'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 30	 lea	 rbp, QWORD PTR [rdx+48]
  00014	48 8d 8d 18 07
	00 00		 lea	 rcx, QWORD PTR $T15[rbp]
  0001b	e8 00 00 00 00	 call	 ??1ImGuiTableTempData@@QEAA@XZ
  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	5f		 pop	 rdi
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
?dtor$0@?0??BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z@4HA ENDP ; `ImGui::BeginTableEx'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableFindByID@ImGui@@YAPEAUImGuiTable@@I@Z
_TEXT	SEGMENT
g$ = 8
id$ = 256
?TableFindByID@ImGui@@YAPEAUImGuiTable@@I@Z PROC	; ImGui::TableFindByID, COMDAT

; 298  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR [rsp+296]

; 299  :     ImGuiContext& g = *GImGui;

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0002f	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 300  :     return g.Tables.GetByKey(id);

  00033	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00037	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  0003d	8b 95 00 01 00
	00		 mov	 edx, DWORD PTR id$[rbp]
  00043	48 8b c8	 mov	 rcx, rax
  00046	e8 00 00 00 00	 call	 ?GetByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z ; ImPool<ImGuiTable>::GetByKey

; 301  : }

  0004b	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00052	5f		 pop	 rdi
  00053	5d		 pop	 rbp
  00054	c3		 ret	 0
?TableFindByID@ImGui@@YAPEAUImGuiTable@@I@Z ENDP	; ImGui::TableFindByID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TablePopBackgroundChannel@ImGui@@YAXXZ
_TEXT	SEGMENT
g$ = 8
window$ = 40
table$ = 72
column$ = 104
?TablePopBackgroundChannel@ImGui@@YAXXZ PROC		; ImGui::TablePopBackgroundChannel, COMDAT

; 2265 : {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2266 :     ImGuiContext& g = *GImGui;

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00025	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 2267 :     ImGuiWindow* window = g.CurrentWindow;

  00029	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0002d	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  00034	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 2268 :     ImGuiTable* table = g.CurrentTable;

  00038	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003c	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00043	48 89 45 48	 mov	 QWORD PTR table$[rbp], rax

; 2269 :     ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];

  00047	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  0004b	48 83 c0 18	 add	 rax, 24
  0004f	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  00053	8b 51 74	 mov	 edx, DWORD PTR [rcx+116]
  00056	48 8b c8	 mov	 rcx, rax
  00059	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  0005e	48 89 45 68	 mov	 QWORD PTR column$[rbp], rax

; 2270 : 
; 2271 :     // Optimization: avoid PopClipRect() + SetCurrentChannel()
; 2272 :     SetWindowClipRectBeforeSetChannel(window, table->HostBackupInnerClipRect);

  00062	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00066	48 05 68 01 00
	00		 add	 rax, 360		; 00000168H
  0006c	48 8b d0	 mov	 rdx, rax
  0006f	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00073	e8 00 00 00 00	 call	 ?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; ImGui::SetWindowClipRectBeforeSetChannel

; 2273 :     table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);

  00078	48 8b 45 68	 mov	 rax, QWORD PTR column$[rbp]
  0007c	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  00080	44 8b c0	 mov	 r8d, eax
  00083	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00087	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  0008e	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00092	48 8b 88 98 01
	00 00		 mov	 rcx, QWORD PTR [rax+408]
  00099	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 2274 : }

  0009e	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  000a5	5f		 pop	 rdi
  000a6	5d		 pop	 rbp
  000a7	c3		 ret	 0
?TablePopBackgroundChannel@ImGui@@YAXXZ ENDP		; ImGui::TablePopBackgroundChannel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TablePushBackgroundChannel@ImGui@@YAXXZ
_TEXT	SEGMENT
g$ = 8
window$ = 40
table$ = 72
?TablePushBackgroundChannel@ImGui@@YAXXZ PROC		; ImGui::TablePushBackgroundChannel, COMDAT

; 2253 : {

$LN3:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0000b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00010	48 8b fc	 mov	 rdi, rsp
  00013	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd

; 2254 :     ImGuiContext& g = *GImGui;

  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00026	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 2255 :     ImGuiWindow* window = g.CurrentWindow;

  0002a	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0002e	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  00035	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 2256 :     ImGuiTable* table = g.CurrentTable;

  00039	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003d	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00044	48 89 45 48	 mov	 QWORD PTR table$[rbp], rax

; 2257 : 
; 2258 :     // Optimization: avoid SetCurrentChannel() + PushClipRect()
; 2259 :     table->HostBackupInnerClipRect = window->ClipRect;

  00048	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  0004c	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00050	48 8d b8 68 01
	00 00		 lea	 rdi, QWORD PTR [rax+360]
  00057	48 8d b1 30 02
	00 00		 lea	 rsi, QWORD PTR [rcx+560]
  0005e	b9 10 00 00 00	 mov	 ecx, 16
  00063	f3 a4		 rep movsb

; 2260 :     SetWindowClipRectBeforeSetChannel(window, table->Bg2ClipRectForDrawCmd);

  00065	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00069	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  0006f	48 8b d0	 mov	 rdx, rax
  00072	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00076	e8 00 00 00 00	 call	 ?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; ImGui::SetWindowClipRectBeforeSetChannel

; 2261 :     table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Bg2DrawChannelCurrent);

  0007b	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  0007f	0f b7 80 1e 02
	00 00		 movzx	 eax, WORD PTR [rax+542]
  00086	44 8b c0	 mov	 r8d, eax
  00089	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0008d	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  00094	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00098	48 8b 88 98 01
	00 00		 mov	 rcx, QWORD PTR [rax+408]
  0009f	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 2262 : }

  000a4	48 8d a5 20 01
	00 00		 lea	 rsp, QWORD PTR [rbp+288]
  000ab	5f		 pop	 rdi
  000ac	5e		 pop	 rsi
  000ad	5d		 pop	 rbp
  000ae	c3		 ret	 0
?TablePushBackgroundChannel@ImGui@@YAXXZ ENDP		; ImGui::TablePushBackgroundChannel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetHeaderRowHeight@ImGui@@YAMXZ
_TEXT	SEGMENT
row_height$ = 4
columns_count$ = 36
column_n$1 = 68
flags$2 = 100
$T3 = 324
?TableGetHeaderRowHeight@ImGui@@YAMXZ PROC		; ImGui::TableGetHeaderRowHeight, COMDAT

; 2834 : {

$LN7:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  0000a	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2835 :     // Caring for a minor edge case:
; 2836 :     // Calculate row height, for the unlikely case that some labels may be taller than others.
; 2837 :     // If we didn't do that, uneven header height would highlight but smaller one before the tallest wouldn't catch input for all height.
; 2838 :     // In your custom header row you may omit this all together and just call TableNextRow() without a height...
; 2839 :     float row_height = GetTextLineHeight();

  0001e	e8 00 00 00 00	 call	 ?GetTextLineHeight@ImGui@@YAMXZ ; ImGui::GetTextLineHeight
  00023	f3 0f 11 45 04	 movss	 DWORD PTR row_height$[rbp], xmm0

; 2840 :     int columns_count = TableGetColumnCount();

  00028	e8 00 00 00 00	 call	 ?TableGetColumnCount@ImGui@@YAHXZ ; ImGui::TableGetColumnCount
  0002d	89 45 24	 mov	 DWORD PTR columns_count$[rbp], eax

; 2841 :     for (int column_n = 0; column_n < columns_count; column_n++)

  00030	c7 45 44 00 00
	00 00		 mov	 DWORD PTR column_n$1[rbp], 0
  00037	eb 08		 jmp	 SHORT $LN4@TableGetHe
$LN2@TableGetHe:
  00039	8b 45 44	 mov	 eax, DWORD PTR column_n$1[rbp]
  0003c	ff c0		 inc	 eax
  0003e	89 45 44	 mov	 DWORD PTR column_n$1[rbp], eax
$LN4@TableGetHe:
  00041	8b 45 24	 mov	 eax, DWORD PTR columns_count$[rbp]
  00044	39 45 44	 cmp	 DWORD PTR column_n$1[rbp], eax
  00047	7d 64		 jge	 SHORT $LN3@TableGetHe

; 2842 :     {
; 2843 :         ImGuiTableColumnFlags flags = TableGetColumnFlags(column_n);

  00049	8b 4d 44	 mov	 ecx, DWORD PTR column_n$1[rbp]
  0004c	e8 00 00 00 00	 call	 ?TableGetColumnFlags@ImGui@@YAHH@Z ; ImGui::TableGetColumnFlags
  00051	89 45 64	 mov	 DWORD PTR flags$2[rbp], eax

; 2844 :         if ((flags & ImGuiTableColumnFlags_IsEnabled) && !(flags & ImGuiTableColumnFlags_NoHeaderLabel))

  00054	8b 45 64	 mov	 eax, DWORD PTR flags$2[rbp]
  00057	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 4b		 je	 SHORT $LN5@TableGetHe
  00060	8b 45 64	 mov	 eax, DWORD PTR flags$2[rbp]
  00063	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00068	85 c0		 test	 eax, eax
  0006a	75 3f		 jne	 SHORT $LN5@TableGetHe

; 2845 :             row_height = ImMax(row_height, CalcTextSize(TableGetColumnName(column_n)).y);

  0006c	8b 4d 44	 mov	 ecx, DWORD PTR column_n$1[rbp]
  0006f	e8 00 00 00 00	 call	 ?TableGetColumnName@ImGui@@YAPEBDH@Z ; ImGui::TableGetColumnName
  00074	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0007c	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00082	45 33 c9	 xor	 r9d, r9d
  00085	45 33 c0	 xor	 r8d, r8d
  00088	48 8b d0	 mov	 rdx, rax
  0008b	48 8d 8d 44 01
	00 00		 lea	 rcx, QWORD PTR $T3[rbp]
  00092	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
  00097	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [rax+4]
  0009c	f3 0f 10 45 04	 movss	 xmm0, DWORD PTR row_height$[rbp]
  000a1	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000a6	f3 0f 11 45 04	 movss	 DWORD PTR row_height$[rbp], xmm0
$LN5@TableGetHe:

; 2846 :     }

  000ab	eb 8c		 jmp	 SHORT $LN2@TableGetHe
$LN3@TableGetHe:

; 2847 :     row_height += GetStyle().CellPadding.y * 2.0f;

  000ad	e8 00 00 00 00	 call	 ?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ ; ImGui::GetStyle
  000b2	f3 0f 10 40 60	 movss	 xmm0, DWORD PTR [rax+96]
  000b7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  000bf	f3 0f 10 4d 04	 movss	 xmm1, DWORD PTR row_height$[rbp]
  000c4	f3 0f 58 c8	 addss	 xmm1, xmm0
  000c8	0f 28 c1	 movaps	 xmm0, xmm1
  000cb	f3 0f 11 45 04	 movss	 DWORD PTR row_height$[rbp], xmm0

; 2848 :     return row_height;

  000d0	f3 0f 10 45 04	 movss	 xmm0, DWORD PTR row_height$[rbp]

; 2849 : }

  000d5	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  000dc	5f		 pop	 rdi
  000dd	5d		 pop	 rbp
  000de	c3		 ret	 0
?TableGetHeaderRowHeight@ImGui@@YAMXZ ENDP		; ImGui::TableGetHeaderRowHeight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetHoveredColumn@ImGui@@YAHXZ
_TEXT	SEGMENT
g$ = 8
table$ = 40
?TableGetHoveredColumn@ImGui@@YAHXZ PROC		; ImGui::TableGetHoveredColumn, COMDAT

; 1631 : {

$LN4:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd

; 1632 :     ImGuiContext& g = *GImGui;

  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00023	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1633 :     ImGuiTable* table = g.CurrentTable;

  00027	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0002b	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00032	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1634 :     if (!table)

  00036	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0003b	75 07		 jne	 SHORT $LN2@TableGetHo

; 1635 :         return -1;

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	eb 0b		 jmp	 SHORT $LN1@TableGetHo
$LN2@TableGetHo:

; 1636 :     return (int)table->HoveredColumnBody;

  00044	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00048	0f bf 80 f8 01
	00 00		 movsx	 eax, WORD PTR [rax+504]
$LN1@TableGetHo:

; 1637 : }

  0004f	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00056	5f		 pop	 rdi
  00057	5d		 pop	 rbp
  00058	c3		 ret	 0
?TableGetHoveredColumn@ImGui@@YAHXZ ENDP		; ImGui::TableGetHoveredColumn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetColumnSortDirection@ImGui@@YAXHH_N@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
sort_order_max$ = 68
other_column_n$1 = 100
column$ = 136
other_column_n$2 = 164
other_column$3 = 200
tv146 = 404
column_n$ = 448
sort_direction$ = 456
append_to_sort_specs$ = 464
?TableSetColumnSortDirection@ImGui@@YAXHH_N@Z PROC	; ImGui::TableSetColumnSortDirection, COMDAT

; 2696 : {

$LN20:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8b fc	 mov	 rdi, rsp
  0001e	b9 72 00 00 00	 mov	 ecx, 114		; 00000072H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR [rsp+488]

; 2697 :     ImGuiContext& g = *GImGui;

  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00038	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 2698 :     ImGuiTable* table = g.CurrentTable;

  0003c	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00040	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00047	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 2699 : 
; 2700 :     if (!(table->Flags & ImGuiTableFlags_SortMulti))

  0004b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0004f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00052	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00057	85 c0		 test	 eax, eax
  00059	75 07		 jne	 SHORT $LN8@TableSetCo

; 2701 :         append_to_sort_specs = false;

  0005b	c6 85 d0 01 00
	00 00		 mov	 BYTE PTR append_to_sort_specs$[rbp], 0
$LN8@TableSetCo:

; 2702 :     if (!(table->Flags & ImGuiTableFlags_SortTristate))

  00062	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00066	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00069	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0006e	85 c0		 test	 eax, eax
  00070	75 2b		 jne	 SHORT $LN9@TableSetCo

; 2703 :         IM_ASSERT(sort_direction != ImGuiSortDirection_None);

  00072	83 bd c8 01 00
	00 00		 cmp	 DWORD PTR sort_direction$[rbp], 0
  00079	75 22		 jne	 SHORT $LN17@TableSetCo
  0007b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetColumnSortDirection@ImGui@@YAXHH_N@Z@4JA
  00081	83 c0 07	 add	 eax, 7
  00084	44 8b c0	 mov	 r8d, eax
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@KIEHIAAN@?$AAs?$AAo?$AAr?$AAt?$AA_?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAS?$AAo?$AAr?$AAt?$AAD?$AAi?$AAr?$AAe?$AAc@
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009b	33 c0		 xor	 eax, eax
$LN17@TableSetCo:
$LN9@TableSetCo:

; 2704 : 
; 2705 :     ImGuiTableColumnIdx sort_order_max = 0;

  0009d	33 c0		 xor	 eax, eax
  0009f	66 89 45 44	 mov	 WORD PTR sort_order_max$[rbp], ax

; 2706 :     if (append_to_sort_specs)

  000a3	0f b6 85 d0 01
	00 00		 movzx	 eax, BYTE PTR append_to_sort_specs$[rbp]
  000aa	85 c0		 test	 eax, eax
  000ac	74 43		 je	 SHORT $LN10@TableSetCo

; 2707 :         for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)

  000ae	c7 45 64 00 00
	00 00		 mov	 DWORD PTR other_column_n$1[rbp], 0
  000b5	eb 08		 jmp	 SHORT $LN4@TableSetCo
$LN2@TableSetCo:
  000b7	8b 45 64	 mov	 eax, DWORD PTR other_column_n$1[rbp]
  000ba	ff c0		 inc	 eax
  000bc	89 45 64	 mov	 DWORD PTR other_column_n$1[rbp], eax
$LN4@TableSetCo:
  000bf	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000c3	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000c6	39 45 64	 cmp	 DWORD PTR other_column_n$1[rbp], eax
  000c9	7d 26		 jge	 SHORT $LN3@TableSetCo

; 2708 :             sort_order_max = ImMax(sort_order_max, table->Columns[other_column_n].SortOrder);

  000cb	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000cf	48 83 c0 18	 add	 rax, 24
  000d3	8b 55 64	 mov	 edx, DWORD PTR other_column_n$1[rbp]
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  000de	0f b7 50 5a	 movzx	 edx, WORD PTR [rax+90]
  000e2	0f b7 4d 44	 movzx	 ecx, WORD PTR sort_order_max$[rbp]
  000e6	e8 00 00 00 00	 call	 ??$ImMax@F@@YAFFF@Z	; ImMax<short>
  000eb	66 89 45 44	 mov	 WORD PTR sort_order_max$[rbp], ax
  000ef	eb c6		 jmp	 SHORT $LN2@TableSetCo
$LN3@TableSetCo:
$LN10@TableSetCo:

; 2709 : 
; 2710 :     ImGuiTableColumn* column = &table->Columns[column_n];

  000f1	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000f5	48 83 c0 18	 add	 rax, 24
  000f9	8b 95 c0 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  000ff	48 8b c8	 mov	 rcx, rax
  00102	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00107	48 89 85 88 00
	00 00		 mov	 QWORD PTR column$[rbp], rax

; 2711 :     column->SortDirection = (ImU8)sort_direction;

  0010e	0f b6 85 c8 01
	00 00		 movzx	 eax, BYTE PTR sort_direction$[rbp]
  00115	24 03		 and	 al, 3
  00117	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  0011e	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  00122	80 e1 fc	 and	 cl, 252			; 000000fcH
  00125	0a c8		 or	 cl, al
  00127	0f b6 c1	 movzx	 eax, cl
  0012a	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  00131	88 41 6d	 mov	 BYTE PTR [rcx+109], al

; 2712 :     if (column->SortDirection == ImGuiSortDirection_None)

  00134	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0013b	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  0013f	24 03		 and	 al, 3
  00141	0f b6 c0	 movzx	 eax, al
  00144	85 c0		 test	 eax, eax
  00146	75 12		 jne	 SHORT $LN11@TableSetCo

; 2713 :         column->SortOrder = -1;

  00148	b8 ff ff ff ff	 mov	 eax, -1
  0014d	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  00154	66 89 41 5a	 mov	 WORD PTR [rcx+90], ax
  00158	eb 50		 jmp	 SHORT $LN12@TableSetCo
$LN11@TableSetCo:

; 2714 :     else if (column->SortOrder == -1 || !append_to_sort_specs)

  0015a	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00161	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  00165	83 f8 ff	 cmp	 eax, -1
  00168	74 0b		 je	 SHORT $LN14@TableSetCo
  0016a	0f b6 85 d0 01
	00 00		 movzx	 eax, BYTE PTR append_to_sort_specs$[rbp]
  00171	85 c0		 test	 eax, eax
  00173	75 35		 jne	 SHORT $LN13@TableSetCo
$LN14@TableSetCo:

; 2715 :         column->SortOrder = append_to_sort_specs ? sort_order_max + 1 : 0;

  00175	0f b6 85 d0 01
	00 00		 movzx	 eax, BYTE PTR append_to_sort_specs$[rbp]
  0017c	85 c0		 test	 eax, eax
  0017e	74 0e		 je	 SHORT $LN18@TableSetCo
  00180	0f bf 45 44	 movsx	 eax, WORD PTR sort_order_max$[rbp]
  00184	ff c0		 inc	 eax
  00186	89 85 94 01 00
	00		 mov	 DWORD PTR tv146[rbp], eax
  0018c	eb 0a		 jmp	 SHORT $LN19@TableSetCo
$LN18@TableSetCo:
  0018e	c7 85 94 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv146[rbp], 0
$LN19@TableSetCo:
  00198	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0019f	0f b7 8d 94 01
	00 00		 movzx	 ecx, WORD PTR tv146[rbp]
  001a6	66 89 48 5a	 mov	 WORD PTR [rax+90], cx
$LN13@TableSetCo:
$LN12@TableSetCo:

; 2716 : 
; 2717 :     for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)

  001aa	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR other_column_n$2[rbp], 0
  001b4	eb 0e		 jmp	 SHORT $LN7@TableSetCo
$LN5@TableSetCo:
  001b6	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR other_column_n$2[rbp]
  001bc	ff c0		 inc	 eax
  001be	89 85 a4 00 00
	00		 mov	 DWORD PTR other_column_n$2[rbp], eax
$LN7@TableSetCo:
  001c4	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  001c8	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  001cb	39 85 a4 00 00
	00		 cmp	 DWORD PTR other_column_n$2[rbp], eax
  001d1	7d 5a		 jge	 SHORT $LN6@TableSetCo

; 2718 :     {
; 2719 :         ImGuiTableColumn* other_column = &table->Columns[other_column_n];

  001d3	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  001d7	48 83 c0 18	 add	 rax, 24
  001db	8b 95 a4 00 00
	00		 mov	 edx, DWORD PTR other_column_n$2[rbp]
  001e1	48 8b c8	 mov	 rcx, rax
  001e4	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  001e9	48 89 85 c8 00
	00 00		 mov	 QWORD PTR other_column$3[rbp], rax

; 2720 :         if (other_column != column && !append_to_sort_specs)

  001f0	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  001f7	48 39 85 c8 00
	00 00		 cmp	 QWORD PTR other_column$3[rbp], rax
  001fe	74 1b		 je	 SHORT $LN15@TableSetCo
  00200	0f b6 85 d0 01
	00 00		 movzx	 eax, BYTE PTR append_to_sort_specs$[rbp]
  00207	85 c0		 test	 eax, eax
  00209	75 10		 jne	 SHORT $LN15@TableSetCo

; 2721 :             other_column->SortOrder = -1;

  0020b	b8 ff ff ff ff	 mov	 eax, -1
  00210	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR other_column$3[rbp]
  00217	66 89 41 5a	 mov	 WORD PTR [rcx+90], ax
$LN15@TableSetCo:

; 2722 :         TableFixColumnSortDirection(table, other_column);

  0021b	48 8b 95 c8 00
	00 00		 mov	 rdx, QWORD PTR other_column$3[rbp]
  00222	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00226	e8 00 00 00 00	 call	 ?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z ; ImGui::TableFixColumnSortDirection

; 2723 :     }

  0022b	eb 89		 jmp	 SHORT $LN5@TableSetCo
$LN6@TableSetCo:

; 2724 :     table->IsSettingsDirty = true;

  0022d	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00231	c6 80 29 02 00
	00 01		 mov	 BYTE PTR [rax+553], 1

; 2725 :     table->IsSortSpecsDirty = true;

  00238	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0023c	c6 80 25 02 00
	00 01		 mov	 BYTE PTR [rax+549], 1

; 2726 : }

  00243	48 8d a5 a8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+424]
  0024a	5f		 pop	 rdi
  0024b	5d		 pop	 rbp
  0024c	c3		 ret	 0
?TableSetColumnSortDirection@ImGui@@YAXHH_N@Z ENDP	; ImGui::TableSetColumnSortDirection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetColumnWidth@ImGui@@YAXHM@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
column_0$ = 72
column_0_width$ = 100
min_width$ = 132
max_width$ = 164
column_1$ = 200
column_1_width$ = 228
tv180 = 440
tv149 = 440
column_n$ = 480
width$ = 488
?TableSetColumnWidth@ImGui@@YAXHM@Z PROC		; ImGui::TableSetColumnWidth, COMDAT

; 2107 : {

$LN23:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 7a 00 00 00	 mov	 ecx, 122		; 0000007aH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	8b 8c 24 08 02
	00 00		 mov	 ecx, DWORD PTR [rsp+520]

; 2108 :     ImGuiContext& g = *GImGui;

  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00035	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 2109 :     ImGuiTable* table = g.CurrentTable;

  00039	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003d	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00044	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 2110 :     IM_ASSERT(table != NULL && table->IsLayoutLocked == false);

  00048	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0004d	74 0f		 je	 SHORT $LN11@TableSetCo
  0004f	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00053	0f b6 80 22 02
	00 00		 movzx	 eax, BYTE PTR [rax+546]
  0005a	85 c0		 test	 eax, eax
  0005c	74 22		 je	 SHORT $LN12@TableSetCo
$LN11@TableSetCo:
  0005e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetColumnWidth@ImGui@@YAXHM@Z@4JA
  00064	83 c0 03	 add	 eax, 3
  00067	44 8b c0	 mov	 r8d, eax
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@MHBOMDGH@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN12@TableSetCo:

; 2111 :     IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);

  00080	83 bd e0 01 00
	00 00		 cmp	 DWORD PTR column_n$[rbp], 0
  00087	7c 0f		 jl	 SHORT $LN13@TableSetCo
  00089	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0008d	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00090	39 85 e0 01 00
	00		 cmp	 DWORD PTR column_n$[rbp], eax
  00096	7c 22		 jl	 SHORT $LN14@TableSetCo
$LN13@TableSetCo:
  00098	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetColumnWidth@ImGui@@YAXHM@Z@4JA
  0009e	83 c0 04	 add	 eax, 4
  000a1	44 8b c0	 mov	 r8d, eax
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GA@OFNPMLNE@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl@
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b8	33 c0		 xor	 eax, eax
$LN14@TableSetCo:

; 2112 :     ImGuiTableColumn* column_0 = &table->Columns[column_n];

  000ba	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000be	48 83 c0 18	 add	 rax, 24
  000c2	8b 95 e0 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  000c8	48 8b c8	 mov	 rcx, rax
  000cb	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  000d0	48 89 45 48	 mov	 QWORD PTR column_0$[rbp], rax

; 2113 :     float column_0_width = width;

  000d4	f3 0f 10 85 e8
	01 00 00	 movss	 xmm0, DWORD PTR width$[rbp]
  000dc	f3 0f 11 45 64	 movss	 DWORD PTR column_0_width$[rbp], xmm0

; 2114 : 
; 2115 :     // Apply constraints early
; 2116 :     // Compare both requested and actual given width to avoid overwriting requested width when column is stuck (minimum size, bounded)
; 2117 :     IM_ASSERT(table->MinColumnWidth > 0.0f);

  000e1	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000e5	f3 0f 10 80 b4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+180]
  000ed	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000f4	77 22		 ja	 SHORT $LN15@TableSetCo
  000f6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetColumnWidth@ImGui@@YAXHM@Z@4JA
  000fc	83 c0 0a	 add	 eax, 10
  000ff	44 8b c0	 mov	 r8d, eax
  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@PGHMBBCD@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAM?$AAi?$AAn?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?$AA@
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00116	33 c0		 xor	 eax, eax
$LN15@TableSetCo:

; 2118 :     const float min_width = table->MinColumnWidth;

  00118	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0011c	f3 0f 10 80 b4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+180]
  00124	f3 0f 11 85 84
	00 00 00	 movss	 DWORD PTR min_width$[rbp], xmm0

; 2119 :     const float max_width = ImMax(min_width, TableGetMaxColumnWidth(table, column_n));

  0012c	8b 95 e0 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  00132	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00136	e8 00 00 00 00	 call	 ?TableGetMaxColumnWidth@ImGui@@YAMPEBUImGuiTable@@H@Z ; ImGui::TableGetMaxColumnWidth
  0013b	0f 28 c8	 movaps	 xmm1, xmm0
  0013e	f3 0f 10 85 84
	00 00 00	 movss	 xmm0, DWORD PTR min_width$[rbp]
  00146	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0014b	f3 0f 11 85 a4
	00 00 00	 movss	 DWORD PTR max_width$[rbp], xmm0

; 2120 :     column_0_width = ImClamp(column_0_width, min_width, max_width);

  00153	f3 0f 10 95 a4
	00 00 00	 movss	 xmm2, DWORD PTR max_width$[rbp]
  0015b	f3 0f 10 8d 84
	00 00 00	 movss	 xmm1, DWORD PTR min_width$[rbp]
  00163	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR column_0_width$[rbp]
  00168	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  0016d	f3 0f 11 45 64	 movss	 DWORD PTR column_0_width$[rbp], xmm0

; 2121 :     if (column_0->WidthGiven == column_0_width || column_0->WidthRequest == column_0_width)

  00172	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  00176	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0017b	0f 2e 45 64	 ucomiss xmm0, DWORD PTR column_0_width$[rbp]
  0017f	7a 02		 jp	 SHORT $LN22@TableSetCo
  00181	74 11		 je	 SHORT $LN3@TableSetCo
$LN22@TableSetCo:
  00183	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  00187	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  0018c	0f 2e 45 64	 ucomiss xmm0, DWORD PTR column_0_width$[rbp]
  00190	7a 07		 jp	 SHORT $LN2@TableSetCo
  00192	75 05		 jne	 SHORT $LN2@TableSetCo
$LN3@TableSetCo:

; 2122 :         return;

  00194	e9 fb 01 00 00	 jmp	 $LN1@TableSetCo
$LN2@TableSetCo:

; 2123 : 
; 2124 :     //IMGUI_DEBUG_PRINT("TableSetColumnWidth(%d, %.1f->%.1f)\n", column_0_idx, column_0->WidthGiven, column_0_width);
; 2125 :     ImGuiTableColumn* column_1 = (column_0->NextEnabledColumn != -1) ? &table->Columns[column_0->NextEnabledColumn] : NULL;

  00199	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  0019d	0f bf 40 58	 movsx	 eax, WORD PTR [rax+88]
  001a1	83 f8 ff	 cmp	 eax, -1
  001a4	74 20		 je	 SHORT $LN16@TableSetCo
  001a6	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  001aa	0f bf 40 58	 movsx	 eax, WORD PTR [rax+88]
  001ae	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  001b2	48 83 c1 18	 add	 rcx, 24
  001b6	8b d0		 mov	 edx, eax
  001b8	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  001bd	48 89 85 b8 01
	00 00		 mov	 QWORD PTR tv149[rbp], rax
  001c4	eb 0b		 jmp	 SHORT $LN17@TableSetCo
$LN16@TableSetCo:
  001c6	48 c7 85 b8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv149[rbp], 0
$LN17@TableSetCo:
  001d1	48 8b 85 b8 01
	00 00		 mov	 rax, QWORD PTR tv149[rbp]
  001d8	48 89 85 c8 00
	00 00		 mov	 QWORD PTR column_1$[rbp], rax

; 2126 : 
; 2127 :     // In this surprisingly not simple because of how we support mixing Fixed and multiple Stretch columns.
; 2128 :     // - All fixed: easy.
; 2129 :     // - All stretch: easy.
; 2130 :     // - One or more fixed + one stretch: easy.
; 2131 :     // - One or more fixed + more than one stretch: tricky.
; 2132 :     // Qt when manual resize is enabled only support a single _trailing_ stretch column.
; 2133 : 
; 2134 :     // When forwarding resize from Wn| to Fn+1| we need to be considerate of the _NoResize flag on Fn+1.
; 2135 :     // FIXME-TABLE: Find a way to rewrite all of this so interactions feel more consistent for the user.
; 2136 :     // Scenarios:
; 2137 :     // - F1 F2 F3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. Subsequent columns will be offset.
; 2138 :     // - F1 F2 F3  resize from F3|          --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered.
; 2139 :     // - F1 F2 W3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered, but it doesn't make much sense as the Stretch column will always be minimal size.
; 2140 :     // - F1 F2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
; 2141 :     // - W1 W2 W3  resize from W1| or W2|   --> ok
; 2142 :     // - W1 W2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
; 2143 :     // - W1 F2 F3  resize from F3|          --> ok: no-op (disabled by Resize Rule 1)
; 2144 :     // - W1 F2     resize from F2|          --> ok: no-op (disabled by Resize Rule 1)
; 2145 :     // - W1 W2 F3  resize from W1| or W2|   --> ok
; 2146 :     // - W1 F2 W3  resize from W1| or F2|   --> ok
; 2147 :     // - F1 W2 F3  resize from W2|          --> ok
; 2148 :     // - F1 W3 F2  resize from W3|          --> ok
; 2149 :     // - W1 F2 F3  resize from W1|          --> ok: equivalent to resizing |F2. F3 will not move.
; 2150 :     // - W1 F2 F3  resize from F2|          --> ok
; 2151 :     // All resizes from a Wx columns are locking other columns.
; 2152 : 
; 2153 :     // Possible improvements:
; 2154 :     // - W1 W2 W3  resize W1|               --> to not be stuck, both W2 and W3 would stretch down. Seems possible to fix. Would be most beneficial to simplify resize of all-weighted columns.
; 2155 :     // - W3 F1 F2  resize W3|               --> to not be stuck past F1|, both F1 and F2 would need to stretch down, which would be lossy or ambiguous. Seems hard to fix.
; 2156 : 
; 2157 :     // [Resize Rule 1] Can't resize from right of right-most visible column if there is any Stretch column. Implemented in TableUpdateLayout().
; 2158 : 
; 2159 :     // If we have all Fixed columns OR resizing a Fixed column that doesn't come after a Stretch one, we can do an offsetting resize.
; 2160 :     // This is the preferred resize path
; 2161 :     if (column_0->Flags & ImGuiTableColumnFlags_WidthFixed)

  001df	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  001e3	8b 00		 mov	 eax, DWORD PTR [rax]
  001e5	83 e0 10	 and	 eax, 16
  001e8	85 c0		 test	 eax, eax
  001ea	74 62		 je	 SHORT $LN4@TableSetCo

; 2162 :         if (!column_1 || table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder >= column_0->DisplayOrder)

  001ec	48 83 bd c8 00
	00 00 00	 cmp	 QWORD PTR column_1$[rbp], 0
  001f4	74 3a		 je	 SHORT $LN6@TableSetCo
  001f6	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  001fa	0f bf 80 0c 02
	00 00		 movsx	 eax, WORD PTR [rax+524]
  00201	83 f8 ff	 cmp	 eax, -1
  00204	74 2a		 je	 SHORT $LN6@TableSetCo
  00206	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0020a	0f bf 80 0c 02
	00 00		 movsx	 eax, WORD PTR [rax+524]
  00211	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00215	48 83 c1 18	 add	 rcx, 24
  00219	8b d0		 mov	 edx, eax
  0021b	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00220	0f bf 40 52	 movsx	 eax, WORD PTR [rax+82]
  00224	48 8b 4d 48	 mov	 rcx, QWORD PTR column_0$[rbp]
  00228	0f bf 49 52	 movsx	 ecx, WORD PTR [rcx+82]
  0022c	3b c1		 cmp	 eax, ecx
  0022e	7c 1e		 jl	 SHORT $LN5@TableSetCo
$LN6@TableSetCo:

; 2163 :         {
; 2164 :             column_0->WidthRequest = column_0_width;

  00230	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  00234	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR column_0_width$[rbp]
  00239	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 2165 :             table->IsSettingsDirty = true;

  0023e	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00242	c6 80 29 02 00
	00 01		 mov	 BYTE PTR [rax+553], 1

; 2166 :             return;

  00249	e9 46 01 00 00	 jmp	 $LN1@TableSetCo
$LN5@TableSetCo:
$LN4@TableSetCo:

; 2167 :         }
; 2168 : 
; 2169 :     // We can also use previous column if there's no next one (this is used when doing an auto-fit on the right-most stretch column)
; 2170 :     if (column_1 == NULL)

  0024e	48 83 bd c8 00
	00 00 00	 cmp	 QWORD PTR column_1$[rbp], 0
  00256	75 46		 jne	 SHORT $LN7@TableSetCo

; 2171 :         column_1 = (column_0->PrevEnabledColumn != -1) ? &table->Columns[column_0->PrevEnabledColumn] : NULL;

  00258	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  0025c	0f bf 40 56	 movsx	 eax, WORD PTR [rax+86]
  00260	83 f8 ff	 cmp	 eax, -1
  00263	74 20		 je	 SHORT $LN18@TableSetCo
  00265	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  00269	0f bf 40 56	 movsx	 eax, WORD PTR [rax+86]
  0026d	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00271	48 83 c1 18	 add	 rcx, 24
  00275	8b d0		 mov	 edx, eax
  00277	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  0027c	48 89 85 b8 01
	00 00		 mov	 QWORD PTR tv180[rbp], rax
  00283	eb 0b		 jmp	 SHORT $LN19@TableSetCo
$LN18@TableSetCo:
  00285	48 c7 85 b8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv180[rbp], 0
$LN19@TableSetCo:
  00290	48 8b 85 b8 01
	00 00		 mov	 rax, QWORD PTR tv180[rbp]
  00297	48 89 85 c8 00
	00 00		 mov	 QWORD PTR column_1$[rbp], rax
$LN7@TableSetCo:

; 2172 :     if (column_1 == NULL)

  0029e	48 83 bd c8 00
	00 00 00	 cmp	 QWORD PTR column_1$[rbp], 0
  002a6	75 05		 jne	 SHORT $LN8@TableSetCo

; 2173 :         return;

  002a8	e9 e7 00 00 00	 jmp	 $LN1@TableSetCo
$LN8@TableSetCo:

; 2174 : 
; 2175 :     // Resizing from right-side of a Stretch column before a Fixed column forward sizing to left-side of fixed column.
; 2176 :     // (old_a + old_b == new_a + new_b) --> (new_a == old_a + old_b - new_b)
; 2177 :     float column_1_width = ImMax(column_1->WidthRequest - (column_0_width - column_0->WidthRequest), min_width);

  002ad	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  002b1	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR column_0_width$[rbp]
  002b6	f3 0f 5c 40 10	 subss	 xmm0, DWORD PTR [rax+16]
  002bb	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column_1$[rbp]
  002c2	f3 0f 10 48 10	 movss	 xmm1, DWORD PTR [rax+16]
  002c7	f3 0f 5c c8	 subss	 xmm1, xmm0
  002cb	0f 28 c1	 movaps	 xmm0, xmm1
  002ce	f3 0f 10 8d 84
	00 00 00	 movss	 xmm1, DWORD PTR min_width$[rbp]
  002d6	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002db	f3 0f 11 85 e4
	00 00 00	 movss	 DWORD PTR column_1_width$[rbp], xmm0

; 2178 :     column_0_width = column_0->WidthRequest + column_1->WidthRequest - column_1_width;

  002e3	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  002e7	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column_1$[rbp]
  002ee	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  002f3	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [rcx+16]
  002f8	f3 0f 5c 85 e4
	00 00 00	 subss	 xmm0, DWORD PTR column_1_width$[rbp]
  00300	f3 0f 11 45 64	 movss	 DWORD PTR column_0_width$[rbp], xmm0

; 2179 :     IM_ASSERT(column_0_width > 0.0f && column_1_width > 0.0f);

  00305	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR column_0_width$[rbp]
  0030a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00311	76 11		 jbe	 SHORT $LN20@TableSetCo
  00313	f3 0f 10 85 e4
	00 00 00	 movss	 xmm0, DWORD PTR column_1_width$[rbp]
  0031b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00322	77 22		 ja	 SHORT $LN21@TableSetCo
$LN20@TableSetCo:
  00324	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetColumnWidth@ImGui@@YAXHM@Z@4JA
  0032a	83 c0 48	 add	 eax, 72			; 00000048H
  0032d	44 8b c0	 mov	 r8d, eax
  00330	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00337	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@DCOODALF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AA0?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_@
  0033e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00344	33 c0		 xor	 eax, eax
$LN21@TableSetCo:

; 2180 :     column_0->WidthRequest = column_0_width;

  00346	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  0034a	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR column_0_width$[rbp]
  0034f	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 2181 :     column_1->WidthRequest = column_1_width;

  00354	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR column_1$[rbp]
  0035b	f3 0f 10 85 e4
	00 00 00	 movss	 xmm0, DWORD PTR column_1_width$[rbp]
  00363	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 2182 :     if ((column_0->Flags | column_1->Flags) & ImGuiTableColumnFlags_WidthStretch)

  00368	48 8b 45 48	 mov	 rax, QWORD PTR column_0$[rbp]
  0036c	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR column_1$[rbp]
  00373	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00375	8b 00		 mov	 eax, DWORD PTR [rax]
  00377	0b c1		 or	 eax, ecx
  00379	83 e0 08	 and	 eax, 8
  0037c	85 c0		 test	 eax, eax
  0037e	74 09		 je	 SHORT $LN9@TableSetCo

; 2183 :         TableUpdateColumnsWeightFromWidth(table);

  00380	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00384	e8 00 00 00 00	 call	 ?TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableUpdateColumnsWeightFromWidth
$LN9@TableSetCo:

; 2184 :     table->IsSettingsDirty = true;

  00389	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0038d	c6 80 29 02 00
	00 01		 mov	 BYTE PTR [rax+553], 1
$LN1@TableSetCo:

; 2185 : }

  00394	48 8d a5 c8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+456]
  0039b	5f		 pop	 rdi
  0039c	5d		 pop	 rbp
  0039d	c3		 ret	 0
?TableSetColumnWidth@ImGui@@YAXHM@Z ENDP		; ImGui::TableSetColumnWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableOpenContextMenu@ImGui@@YAXH@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
context_menu_id$1 = 68
column_n$ = 320
?TableOpenContextMenu@ImGui@@YAXH@Z PROC		; ImGui::TableOpenContextMenu, COMDAT

; 3047 : {

$LN8:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR [rsp+360]

; 3048 :     ImGuiContext& g = *GImGui;

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0002f	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3049 :     ImGuiTable* table = g.CurrentTable;

  00033	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00037	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  0003e	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 3050 :     if (column_n == -1 && table->CurrentColumn != -1)   // When called within a column automatically use this one (for consistency)

  00042	83 bd 40 01 00
	00 ff		 cmp	 DWORD PTR column_n$[rbp], -1
  00049	75 17		 jne	 SHORT $LN2@TableOpenC
  0004b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0004f	83 78 74 ff	 cmp	 DWORD PTR [rax+116], -1
  00053	74 0d		 je	 SHORT $LN2@TableOpenC

; 3051 :         column_n = table->CurrentColumn;

  00055	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00059	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0005c	89 85 40 01 00
	00		 mov	 DWORD PTR column_n$[rbp], eax
$LN2@TableOpenC:

; 3052 :     if (column_n == table->ColumnsCount)                // To facilitate using with TableGetHoveredColumn()

  00062	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00066	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00069	39 85 40 01 00
	00		 cmp	 DWORD PTR column_n$[rbp], eax
  0006f	75 0a		 jne	 SHORT $LN3@TableOpenC

; 3053 :         column_n = -1;

  00071	c7 85 40 01 00
	00 ff ff ff ff	 mov	 DWORD PTR column_n$[rbp], -1
$LN3@TableOpenC:

; 3054 :     IM_ASSERT(column_n >= -1 && column_n < table->ColumnsCount);

  0007b	83 bd 40 01 00
	00 ff		 cmp	 DWORD PTR column_n$[rbp], -1
  00082	7c 0f		 jl	 SHORT $LN6@TableOpenC
  00084	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00088	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0008b	39 85 40 01 00
	00		 cmp	 DWORD PTR column_n$[rbp], eax
  00091	7c 22		 jl	 SHORT $LN7@TableOpenC
$LN6@TableOpenC:
  00093	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableOpenContextMenu@ImGui@@YAXH@Z@4JA
  00099	83 c0 07	 add	 eax, 7
  0009c	44 8b c0	 mov	 r8d, eax
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GC@CPFLEHCP@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb@
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b3	33 c0		 xor	 eax, eax
$LN7@TableOpenC:

; 3055 :     if (table->Flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))

  000b5	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000b9	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000bc	83 e0 07	 and	 eax, 7
  000bf	85 c0		 test	 eax, eax
  000c1	74 4f		 je	 SHORT $LN4@TableOpenC

; 3056 :     {
; 3057 :         table->IsContextPopupOpen = true;

  000c3	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000c7	c6 80 27 02 00
	00 01		 mov	 BYTE PTR [rax+551], 1

; 3058 :         table->ContextPopupColumn = (ImGuiTableColumnIdx)column_n;

  000ce	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000d2	0f b7 8d 40 01
	00 00		 movzx	 ecx, WORD PTR column_n$[rbp]
  000d9	66 89 88 10 02
	00 00		 mov	 WORD PTR [rax+528], cx

; 3059 :         table->InstanceInteracted = table->InstanceCurrent;

  000e0	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000e4	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  000e8	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  000ec	66 89 48 7a	 mov	 WORD PTR [rax+122], cx

; 3060 :         const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);

  000f0	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000f4	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000f7	33 d2		 xor	 edx, edx
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@BMOANCPA@?$CD?$CDContextMenu?$AA@
  00100	e8 00 00 00 00	 call	 ?ImHashStr@@YAIPEBD_KI@Z ; ImHashStr
  00105	89 45 44	 mov	 DWORD PTR context_menu_id$1[rbp], eax

; 3061 :         OpenPopupEx(context_menu_id, ImGuiPopupFlags_None);

  00108	33 d2		 xor	 edx, edx
  0010a	8b 4d 44	 mov	 ecx, DWORD PTR context_menu_id$1[rbp]
  0010d	e8 00 00 00 00	 call	 ?OpenPopupEx@ImGui@@YAXIH@Z ; ImGui::OpenPopupEx
$LN4@TableOpenC:

; 3062 :     }
; 3063 : }

  00112	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00119	5f		 pop	 rdi
  0011a	5d		 pop	 rbp
  0011b	c3		 ret	 0
?TableOpenContextMenu@ImGui@@YAXH@Z ENDP		; ImGui::TableOpenContextMenu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z
_TEXT	SEGMENT
columns$ = 224
offset$ = 232
?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z PROC ; ImGui::GetColumnNormFromOffset, COMDAT

; 3717 : {

$LN3:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	55		 push	 rbp
  0000c	57		 push	 rdi
  0000d	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00014	48 8d 6c 24 10	 lea	 rbp, QWORD PTR [rsp+16]
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+248]

; 3718 :     return offset / (columns->OffMaxX - columns->OffMinX);

  00030	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR columns$[rbp]
  00037	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR columns$[rbp]
  0003e	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  00043	f3 0f 5c 41 14	 subss	 xmm0, DWORD PTR [rcx+20]
  00048	f3 0f 10 8d e8
	00 00 00	 movss	 xmm1, DWORD PTR offset$[rbp]
  00050	f3 0f 5e c8	 divss	 xmm1, xmm0
  00054	0f 28 c1	 movaps	 xmm0, xmm1

; 3719 : }

  00057	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005e	5f		 pop	 rdi
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ENDP ; ImGui::GetColumnNormFromOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z
_TEXT	SEGMENT
columns$ = 224
offset_norm$ = 232
?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z PROC ; ImGui::GetColumnOffsetFromNorm, COMDAT

; 3712 : {

$LN3:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	55		 push	 rbp
  0000c	57		 push	 rdi
  0000d	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00014	48 8d 6c 24 10	 lea	 rbp, QWORD PTR [rsp+16]
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+248]

; 3713 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

  00030	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR columns$[rbp]
  00037	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR columns$[rbp]
  0003e	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  00043	f3 0f 5c 41 14	 subss	 xmm0, DWORD PTR [rcx+20]
  00048	f3 0f 10 8d e8
	00 00 00	 movss	 xmm1, DWORD PTR offset_norm$[rbp]
  00050	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00054	0f 28 c1	 movaps	 xmm0, xmm1

; 3714 : }

  00057	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005e	5f		 pop	 rdi
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ENDP ; ImGui::GetColumnOffsetFromNorm
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
_TEXT	SEGMENT
n$1 = 4
columns$ = 40
$T2 = 264
$T3 = 424
tv91 = 440
tv90 = 448
window$ = 496
id$ = 504
?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z PROC ; ImGui::FindOrCreateColumns, COMDAT

; 3853 : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 7e 00 00 00	 mov	 ecx, 126		; 0000007eH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR [rsp+536]
  0002e	48 c7 85 a8 01
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T3[rbp], -2

; 3854 :     // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
; 3855 :     for (int n = 0; n < window->ColumnsStorage.Size; n++)

  00039	c7 45 04 00 00
	00 00		 mov	 DWORD PTR n$1[rbp], 0
  00040	eb 08		 jmp	 SHORT $LN4@FindOrCrea
$LN2@FindOrCrea:
  00042	8b 45 04	 mov	 eax, DWORD PTR n$1[rbp]
  00045	ff c0		 inc	 eax
  00047	89 45 04	 mov	 DWORD PTR n$1[rbp], eax
$LN4@FindOrCrea:
  0004a	48 8b 85 f0 01
	00 00		 mov	 rax, QWORD PTR window$[rbp]
  00051	8b 80 78 02 00
	00		 mov	 eax, DWORD PTR [rax+632]
  00057	39 45 04	 cmp	 DWORD PTR n$1[rbp], eax
  0005a	7d 3e		 jge	 SHORT $LN3@FindOrCrea

; 3856 :         if (window->ColumnsStorage[n].ID == id)

  0005c	48 8b 85 f0 01
	00 00		 mov	 rax, QWORD PTR window$[rbp]
  00063	48 05 78 02 00
	00		 add	 rax, 632		; 00000278H
  00069	8b 55 04	 mov	 edx, DWORD PTR n$1[rbp]
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@H@Z ; ImVector<ImGuiOldColumns>::operator[]
  00074	8b 8d f8 01 00
	00		 mov	 ecx, DWORD PTR id$[rbp]
  0007a	39 08		 cmp	 DWORD PTR [rax], ecx
  0007c	75 1a		 jne	 SHORT $LN5@FindOrCrea

; 3857 :             return &window->ColumnsStorage[n];

  0007e	48 8b 85 f0 01
	00 00		 mov	 rax, QWORD PTR window$[rbp]
  00085	48 05 78 02 00
	00		 add	 rax, 632		; 00000278H
  0008b	8b 55 04	 mov	 edx, DWORD PTR n$1[rbp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@H@Z ; ImVector<ImGuiOldColumns>::operator[]
  00096	eb 75		 jmp	 SHORT $LN1@FindOrCrea
$LN5@FindOrCrea:

; 3858 : 
; 3859 :     window->ColumnsStorage.push_back(ImGuiOldColumns());

  00098	eb a8		 jmp	 SHORT $LN2@FindOrCrea
$LN3@FindOrCrea:
  0009a	48 8d 8d 08 01
	00 00		 lea	 rcx, QWORD PTR $T2[rbp]
  000a1	e8 00 00 00 00	 call	 ??0ImGuiOldColumns@@QEAA@XZ ; ImGuiOldColumns::ImGuiOldColumns
  000a6	48 89 85 b8 01
	00 00		 mov	 QWORD PTR tv91[rbp], rax
  000ad	48 8b 85 b8 01
	00 00		 mov	 rax, QWORD PTR tv91[rbp]
  000b4	48 89 85 c0 01
	00 00		 mov	 QWORD PTR tv90[rbp], rax
  000bb	48 8b 85 f0 01
	00 00		 mov	 rax, QWORD PTR window$[rbp]
  000c2	48 05 78 02 00
	00		 add	 rax, 632		; 00000278H
  000c8	48 8b 95 c0 01
	00 00		 mov	 rdx, QWORD PTR tv90[rbp]
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z ; ImVector<ImGuiOldColumns>::push_back
  000d7	90		 npad	 1
  000d8	48 8d 8d 08 01
	00 00		 lea	 rcx, QWORD PTR $T2[rbp]
  000df	e8 00 00 00 00	 call	 ??1ImGuiOldColumns@@QEAA@XZ

; 3860 :     ImGuiOldColumns* columns = &window->ColumnsStorage.back();

  000e4	48 8b 85 f0 01
	00 00		 mov	 rax, QWORD PTR window$[rbp]
  000eb	48 05 78 02 00
	00		 add	 rax, 632		; 00000278H
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	e8 00 00 00 00	 call	 ?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ ; ImVector<ImGuiOldColumns>::back
  000f9	48 89 45 28	 mov	 QWORD PTR columns$[rbp], rax

; 3861 :     columns->ID = id;

  000fd	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  00101	8b 8d f8 01 00
	00		 mov	 ecx, DWORD PTR id$[rbp]
  00107	89 08		 mov	 DWORD PTR [rax], ecx

; 3862 :     return columns;

  00109	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
$LN1@FindOrCrea:

; 3863 : }

  0010d	48 8d a5 d8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+472]
  00114	5f		 pop	 rdi
  00115	5d		 pop	 rbp
  00116	c3		 ret	 0
?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z ENDP ; ImGui::FindOrCreateColumns
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
n$1 = 4
columns$ = 40
$T2 = 264
$T3 = 424
tv91 = 440
tv90 = 448
window$ = 496
id$ = 504
?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA PROC ; `ImGui::FindOrCreateColumns'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8d 8d 08 01
	00 00		 lea	 rcx, QWORD PTR $T2[rbp]
  0001b	e8 00 00 00 00	 call	 ??1ImGuiOldColumns@@QEAA@XZ
  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	5f		 pop	 rdi
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA ENDP ; `ImGui::FindOrCreateColumns'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
n$1 = 4
columns$ = 40
$T2 = 264
$T3 = 424
tv91 = 440
tv90 = 448
window$ = 496
id$ = 504
?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA PROC ; `ImGui::FindOrCreateColumns'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8d 8d 08 01
	00 00		 lea	 rcx, QWORD PTR $T2[rbp]
  0001b	e8 00 00 00 00	 call	 ??1ImGuiOldColumns@@QEAA@XZ
  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	5f		 pop	 rdi
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA ENDP ; `ImGui::FindOrCreateColumns'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnsID@ImGui@@YAIPEBDH@Z
_TEXT	SEGMENT
window$ = 8
id$ = 36
tv66 = 244
tv73 = 248
str_id$ = 288
columns_count$ = 296
?GetColumnsID@ImGui@@YAIPEBDH@Z PROC			; ImGui::GetColumnsID, COMDAT

; 3866 : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]

; 3867 :     ImGuiWindow* window = GetCurrentWindow();

  0002e	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00033	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 3868 : 
; 3869 :     // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
; 3870 :     // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
; 3871 :     PushID(0x11223347 + (str_id ? 0 : columns_count));

  00037	48 83 bd 20 01
	00 00 00	 cmp	 QWORD PTR str_id$[rbp], 0
  0003f	74 0c		 je	 SHORT $LN3@GetColumns
  00041	c7 85 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv66[rbp], 0
  0004b	eb 0c		 jmp	 SHORT $LN4@GetColumns
$LN3@GetColumns:
  0004d	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR columns_count$[rbp]
  00053	89 85 f4 00 00
	00		 mov	 DWORD PTR tv66[rbp], eax
$LN4@GetColumns:
  00059	8b 85 f4 00 00
	00		 mov	 eax, DWORD PTR tv66[rbp]
  0005f	05 47 33 22 11	 add	 eax, 287454023		; 11223347H
  00064	8b c8		 mov	 ecx, eax
  00066	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXH@Z	; ImGui::PushID

; 3872 :     ImGuiID id = window->GetID(str_id ? str_id : "columns");

  0006b	48 83 bd 20 01
	00 00 00	 cmp	 QWORD PTR str_id$[rbp], 0
  00073	74 10		 je	 SHORT $LN5@GetColumns
  00075	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR str_id$[rbp]
  0007c	48 89 85 f8 00
	00 00		 mov	 QWORD PTR tv73[rbp], rax
  00083	eb 0e		 jmp	 SHORT $LN6@GetColumns
$LN5@GetColumns:
  00085	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07HIFEPIJN@columns?$AA@
  0008c	48 89 85 f8 00
	00 00		 mov	 QWORD PTR tv73[rbp], rax
$LN6@GetColumns:
  00093	45 33 c0	 xor	 r8d, r8d
  00096	48 8b 95 f8 00
	00 00		 mov	 rdx, QWORD PTR tv73[rbp]
  0009d	48 8b 4d 08	 mov	 rcx, QWORD PTR window$[rbp]
  000a1	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QEAAIPEBD0@Z ; ImGuiWindow::GetID
  000a6	89 45 24	 mov	 DWORD PTR id$[rbp], eax

; 3873 :     PopID();

  000a9	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 3874 : 
; 3875 :     return id;

  000ae	8b 45 24	 mov	 eax, DWORD PTR id$[rbp]

; 3876 : }

  000b1	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000b8	5f		 pop	 rdi
  000b9	5d		 pop	 rbp
  000ba	c3		 ret	 0
?GetColumnsID@ImGui@@YAIPEBDH@Z ENDP			; ImGui::GetColumnsID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?PopColumnsBackground@ImGui@@YAXXZ
_TEXT	SEGMENT
window$ = 8
columns$ = 40
?PopColumnsBackground@ImGui@@YAXXZ PROC			; ImGui::PopColumnsBackground, COMDAT

; 3841 : {

$LN4:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3842 :     ImGuiWindow* window = GetCurrentWindowRead();

  0001e	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  00023	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 3843 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

  00027	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0002b	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  00032	48 89 45 28	 mov	 QWORD PTR columns$[rbp], rax

; 3844 :     if (columns->Count == 1)

  00036	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  0003a	83 78 10 01	 cmp	 DWORD PTR [rax+16], 1
  0003e	75 02		 jne	 SHORT $LN2@PopColumns

; 3845 :         return;

  00040	eb 38		 jmp	 SHORT $LN1@PopColumns
$LN2@PopColumns:

; 3846 : 
; 3847 :     // Optimization: avoid PopClipRect() + SetCurrentChannel()
; 3848 :     SetWindowClipRectBeforeSetChannel(window, columns->HostBackupClipRect);

  00042	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  00046	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  0004a	48 8b d0	 mov	 rdx, rax
  0004d	48 8b 4d 08	 mov	 rcx, QWORD PTR window$[rbp]
  00051	e8 00 00 00 00	 call	 ?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; ImGui::SetWindowClipRectBeforeSetChannel

; 3849 :     columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);

  00056	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  0005a	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0005d	ff c0		 inc	 eax
  0005f	48 8b 4d 28	 mov	 rcx, QWORD PTR columns$[rbp]
  00063	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00067	44 8b c0	 mov	 r8d, eax
  0006a	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0006e	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  00075	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN1@PopColumns:

; 3850 : }

  0007a	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00081	5f		 pop	 rdi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
?PopColumnsBackground@ImGui@@YAXXZ ENDP			; ImGui::PopColumnsBackground
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?PushColumnsBackground@ImGui@@YAXXZ
_TEXT	SEGMENT
window$ = 8
columns$ = 40
?PushColumnsBackground@ImGui@@YAXXZ PROC		; ImGui::PushColumnsBackground, COMDAT

; 3828 : {

$LN4:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H
  0000b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00010	48 8b fc	 mov	 rdi, rsp
  00013	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd

; 3829 :     ImGuiWindow* window = GetCurrentWindowRead();

  0001f	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  00024	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 3830 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

  00028	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0002c	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  00033	48 89 45 28	 mov	 QWORD PTR columns$[rbp], rax

; 3831 :     if (columns->Count == 1)

  00037	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  0003b	83 78 10 01	 cmp	 DWORD PTR [rax+16], 1
  0003f	75 02		 jne	 SHORT $LN2@PushColumn

; 3832 :         return;

  00041	eb 4c		 jmp	 SHORT $LN1@PushColumn
$LN2@PushColumn:

; 3833 : 
; 3834 :     // Optimization: avoid SetCurrentChannel() + PushClipRect()
; 3835 :     columns->HostBackupClipRect = window->ClipRect;

  00043	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  00047	48 8b 4d 08	 mov	 rcx, QWORD PTR window$[rbp]
  0004b	48 8d 78 3c	 lea	 rdi, QWORD PTR [rax+60]
  0004f	48 8d b1 30 02
	00 00		 lea	 rsi, QWORD PTR [rcx+560]
  00056	b9 10 00 00 00	 mov	 ecx, 16
  0005b	f3 a4		 rep movsb

; 3836 :     SetWindowClipRectBeforeSetChannel(window, columns->HostInitialClipRect);

  0005d	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  00061	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00065	48 8b d0	 mov	 rdx, rax
  00068	48 8b 4d 08	 mov	 rcx, QWORD PTR window$[rbp]
  0006c	e8 00 00 00 00	 call	 ?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; ImGui::SetWindowClipRectBeforeSetChannel

; 3837 :     columns->Splitter.SetCurrentChannel(window->DrawList, 0);

  00071	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  00075	48 83 c0 70	 add	 rax, 112		; 00000070H
  00079	45 33 c0	 xor	 r8d, r8d
  0007c	48 8b 4d 08	 mov	 rcx, QWORD PTR window$[rbp]
  00080	48 8b 91 90 02
	00 00		 mov	 rdx, QWORD PTR [rcx+656]
  00087	48 8b c8	 mov	 rcx, rax
  0008a	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN1@PushColumn:

; 3838 : }

  0008f	48 8d a5 00 01
	00 00		 lea	 rsp, QWORD PTR [rbp+256]
  00096	5f		 pop	 rdi
  00097	5e		 pop	 rsi
  00098	5d		 pop	 rbp
  00099	c3		 ret	 0
?PushColumnsBackground@ImGui@@YAXXZ ENDP		; ImGui::PushColumnsBackground
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?PushColumnClipRect@ImGui@@YAXH@Z
_TEXT	SEGMENT
window$ = 8
columns$ = 40
column$ = 72
column_index$ = 320
?PushColumnClipRect@ImGui@@YAXH@Z PROC			; ImGui::PushColumnClipRect, COMDAT

; 3816 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR [rsp+360]

; 3817 :     ImGuiWindow* window = GetCurrentWindowRead();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  0002d	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 3818 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

  00031	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00035	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  0003c	48 89 45 28	 mov	 QWORD PTR columns$[rbp], rax

; 3819 :     if (column_index < 0)

  00040	83 bd 40 01 00
	00 00		 cmp	 DWORD PTR column_index$[rbp], 0
  00047	7d 0d		 jge	 SHORT $LN2@PushColumn

; 3820 :         column_index = columns->Current;

  00049	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  0004d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00050	89 85 40 01 00
	00		 mov	 DWORD PTR column_index$[rbp], eax
$LN2@PushColumn:

; 3821 : 
; 3822 :     ImGuiOldColumnData* column = &columns->Columns[column_index];

  00056	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  0005a	48 83 c0 60	 add	 rax, 96			; 00000060H
  0005e	8b 95 40 01 00
	00		 mov	 edx, DWORD PTR column_index$[rbp]
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  0006c	48 89 45 48	 mov	 QWORD PTR column$[rbp], rax

; 3823 :     PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);

  00070	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  00074	48 83 c0 14	 add	 rax, 20
  00078	48 8b 4d 48	 mov	 rcx, QWORD PTR column$[rbp]
  0007c	48 83 c1 0c	 add	 rcx, 12
  00080	45 33 c0	 xor	 r8d, r8d
  00083	48 8b d0	 mov	 rdx, rax
  00086	e8 00 00 00 00	 call	 ?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect

; 3824 : }

  0008b	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00092	5f		 pop	 rdi
  00093	5d		 pop	 rbp
  00094	c3		 ret	 0
?PushColumnClipRect@ImGui@@YAXH@Z ENDP			; ImGui::PushColumnClipRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?EndColumns@ImGui@@YAXXZ
_TEXT	SEGMENT
g$ = 8
window$ = 40
columns$ = 72
flags$ = 100
is_being_resized$ = 132
y1$6 = 164
y2$7 = 196
dragging_column$8 = 228
n$9 = 260
column$10 = 296
x$11 = 324
column_id$12 = 356
column_hit_hw$13 = 388
column_hit_rect$14 = 424
hovered$15 = 468
held$16 = 500
col$17 = 532
xi$18 = 564
n$19 = 596
x$20 = 628
$T21 = 1044
$T22 = 1076
$T23 = 1108
$T24 = 1140
tv209 = 1156
tv243 = 1160
tv218 = 1160
tv206 = 1160
tv168 = 1160
__$ArrayPad$ = 1168
?EndColumns@ImGui@@YAXXZ PROC				; ImGui::EndColumns, COMDAT

; 4012 : {

$LN24:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 81 ec d0 04
	00 00		 sub	 rsp, 1232		; 000004d0H
  0000b	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00010	48 8b fc	 mov	 rdi, rsp
  00013	b9 34 01 00 00	 mov	 ecx, 308		; 00000134H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c5	 xor	 rax, rbp
  00029	48 89 85 90 04
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 4013 :     ImGuiContext& g = *GImGui;

  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00037	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 4014 :     ImGuiWindow* window = GetCurrentWindow();

  0003b	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00040	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 4015 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

  00044	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00048	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  0004f	48 89 45 48	 mov	 QWORD PTR columns$[rbp], rax

; 4016 :     IM_ASSERT(columns != NULL);

  00053	48 83 7d 48 00	 cmp	 QWORD PTR columns$[rbp], 0
  00058	75 22		 jne	 SHORT $LN19@EndColumns
  0005a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndColumns@ImGui@@YAXXZ@4JA
  00060	83 c0 04	 add	 eax, 4
  00063	44 8b c0	 mov	 r8d, eax
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007a	33 c0		 xor	 eax, eax
$LN19@EndColumns:

; 4017 : 
; 4018 :     PopItemWidth();

  0007c	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 4019 :     if (columns->Count > 1)

  00081	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00085	83 78 10 01	 cmp	 DWORD PTR [rax+16], 1
  00089	7e 20		 jle	 SHORT $LN8@EndColumns

; 4020 :     {
; 4021 :         PopClipRect();

  0008b	e8 00 00 00 00	 call	 ?PopClipRect@ImGui@@YAXXZ ; ImGui::PopClipRect

; 4022 :         columns->Splitter.Merge(window->DrawList);

  00090	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00094	48 83 c0 70	 add	 rax, 112		; 00000070H
  00098	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  0009c	48 8b 91 90 02
	00 00		 mov	 rdx, QWORD PTR [rcx+656]
  000a3	48 8b c8	 mov	 rcx, rax
  000a6	e8 00 00 00 00	 call	 ?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z ; ImDrawListSplitter::Merge
$LN8@EndColumns:

; 4023 :     }
; 4024 : 
; 4025 :     const ImGuiOldColumnFlags flags = columns->Flags;

  000ab	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000af	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000b2	89 45 64	 mov	 DWORD PTR flags$[rbp], eax

; 4026 :     columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);

  000b5	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000b9	f3 0f 10 88 fc
	00 00 00	 movss	 xmm1, DWORD PTR [rax+252]
  000c1	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000c5	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [rax+32]
  000ca	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000cf	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000d3	f3 0f 11 40 20	 movss	 DWORD PTR [rax+32], xmm0

; 4027 :     window->DC.CursorPos.y = columns->LineMaxY;

  000d8	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000dc	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  000e0	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  000e5	f3 0f 11 80 fc
	00 00 00	 movss	 DWORD PTR [rax+252], xmm0

; 4028 :     if (!(flags & ImGuiOldColumnFlags_GrowParentContentsSize))

  000ed	8b 45 64	 mov	 eax, DWORD PTR flags$[rbp]
  000f0	83 e0 10	 and	 eax, 16
  000f3	85 c0		 test	 eax, eax
  000f5	75 15		 jne	 SHORT $LN9@EndColumns

; 4029 :         window->DC.CursorMaxPos.x = columns->HostCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent

  000f7	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  000fb	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  000ff	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  00104	f3 0f 11 80 10
	01 00 00	 movss	 DWORD PTR [rax+272], xmm0
$LN9@EndColumns:

; 4030 : 
; 4031 :     // Draw columns borders and handle resize
; 4032 :     // The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy
; 4033 :     bool is_being_resized = false;

  0010c	c6 85 84 00 00
	00 00		 mov	 BYTE PTR is_being_resized$[rbp], 0

; 4034 :     if (!(flags & ImGuiOldColumnFlags_NoBorder) && !window->SkipItems)

  00113	8b 45 64	 mov	 eax, DWORD PTR flags$[rbp]
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	0f 85 cb 03 00
	00		 jne	 $LN10@EndColumns
  00121	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00125	0f b6 80 b3 00
	00 00		 movzx	 eax, BYTE PTR [rax+179]
  0012c	85 c0		 test	 eax, eax
  0012e	0f 85 b8 03 00
	00		 jne	 $LN10@EndColumns

; 4035 :     {
; 4036 :         // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
; 4037 :         const float y1 = ImMax(columns->HostCursorPosY, window->ClipRect.Min.y);

  00134	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00138	f3 0f 10 88 34
	02 00 00	 movss	 xmm1, DWORD PTR [rax+564]
  00140	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00144	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [rax+36]
  00149	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0014e	f3 0f 11 85 a4
	00 00 00	 movss	 DWORD PTR y1$6[rbp], xmm0

; 4038 :         const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);

  00156	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0015a	f3 0f 10 88 3c
	02 00 00	 movss	 xmm1, DWORD PTR [rax+572]
  00162	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00166	f3 0f 10 80 fc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+252]
  0016e	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00173	f3 0f 11 85 c4
	00 00 00	 movss	 DWORD PTR y2$7[rbp], xmm0

; 4039 :         int dragging_column = -1;

  0017b	c7 85 e4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR dragging_column$8[rbp], -1

; 4040 :         for (int n = 1; n < columns->Count; n++)

  00185	c7 85 04 01 00
	00 01 00 00 00	 mov	 DWORD PTR n$9[rbp], 1
  0018f	eb 0e		 jmp	 SHORT $LN4@EndColumns
$LN2@EndColumns:
  00191	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR n$9[rbp]
  00197	ff c0		 inc	 eax
  00199	89 85 04 01 00
	00		 mov	 DWORD PTR n$9[rbp], eax
$LN4@EndColumns:
  0019f	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  001a3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001a6	39 85 04 01 00
	00		 cmp	 DWORD PTR n$9[rbp], eax
  001ac	0f 8d 75 02 00
	00		 jge	 $LN3@EndColumns

; 4041 :         {
; 4042 :             ImGuiOldColumnData* column = &columns->Columns[n];

  001b2	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  001b6	48 83 c0 60	 add	 rax, 96			; 00000060H
  001ba	8b 95 04 01 00
	00		 mov	 edx, DWORD PTR n$9[rbp]
  001c0	48 8b c8	 mov	 rcx, rax
  001c3	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  001c8	48 89 85 28 01
	00 00		 mov	 QWORD PTR column$10[rbp], rax

; 4043 :             float x = window->Pos.x + GetColumnOffset(n);

  001cf	8b 8d 04 01 00
	00		 mov	 ecx, DWORD PTR n$9[rbp]
  001d5	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  001da	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  001de	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [rax+24]
  001e3	f3 0f 58 c8	 addss	 xmm1, xmm0
  001e7	0f 28 c1	 movaps	 xmm0, xmm1
  001ea	f3 0f 11 85 44
	01 00 00	 movss	 DWORD PTR x$11[rbp], xmm0

; 4044 :             const ImGuiID column_id = columns->ID + ImGuiID(n);

  001f2	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  001f6	8b 00		 mov	 eax, DWORD PTR [rax]
  001f8	03 85 04 01 00
	00		 add	 eax, DWORD PTR n$9[rbp]
  001fe	89 85 64 01 00
	00		 mov	 DWORD PTR column_id$12[rbp], eax

; 4045 :             const float column_hit_hw = COLUMNS_HIT_RECT_HALF_WIDTH;

  00204	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  0020c	f3 0f 11 85 84
	01 00 00	 movss	 DWORD PTR column_hit_hw$13[rbp], xmm0

; 4046 :             const ImRect column_hit_rect(ImVec2(x - column_hit_hw, y1), ImVec2(x + column_hit_hw, y2));

  00214	f3 0f 10 85 44
	01 00 00	 movss	 xmm0, DWORD PTR x$11[rbp]
  0021c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40800000
  00224	f3 0f 10 95 c4
	00 00 00	 movss	 xmm2, DWORD PTR y2$7[rbp]
  0022c	0f 28 c8	 movaps	 xmm1, xmm0
  0022f	48 8d 8d 14 04
	00 00		 lea	 rcx, QWORD PTR $T21[rbp]
  00236	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  0023b	48 89 85 88 04
	00 00		 mov	 QWORD PTR tv168[rbp], rax
  00242	f3 0f 10 85 44
	01 00 00	 movss	 xmm0, DWORD PTR x$11[rbp]
  0024a	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40800000
  00252	f3 0f 10 95 a4
	00 00 00	 movss	 xmm2, DWORD PTR y1$6[rbp]
  0025a	0f 28 c8	 movaps	 xmm1, xmm0
  0025d	48 8d 8d 34 04
	00 00		 lea	 rcx, QWORD PTR $T22[rbp]
  00264	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00269	48 8b 8d 88 04
	00 00		 mov	 rcx, QWORD PTR tv168[rbp]
  00270	4c 8b c1	 mov	 r8, rcx
  00273	48 8b d0	 mov	 rdx, rax
  00276	48 8d 8d a8 01
	00 00		 lea	 rcx, QWORD PTR column_hit_rect$14[rbp]
  0027d	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@AEBUImVec2@@0@Z ; ImRect::ImRect

; 4047 :             if (!ItemAdd(column_hit_rect, column_id, NULL, ImGuiItemFlags_NoNav))

  00282	41 b9 08 00 00
	00		 mov	 r9d, 8
  00288	45 33 c0	 xor	 r8d, r8d
  0028b	8b 95 64 01 00
	00		 mov	 edx, DWORD PTR column_id$12[rbp]
  00291	48 8d 8d a8 01
	00 00		 lea	 rcx, QWORD PTR column_hit_rect$14[rbp]
  00298	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
  0029d	0f b6 c0	 movzx	 eax, al
  002a0	85 c0		 test	 eax, eax
  002a2	75 05		 jne	 SHORT $LN11@EndColumns

; 4048 :                 continue;

  002a4	e9 e8 fe ff ff	 jmp	 $LN2@EndColumns
$LN11@EndColumns:

; 4049 : 
; 4050 :             bool hovered = false, held = false;

  002a9	c6 85 d4 01 00
	00 00		 mov	 BYTE PTR hovered$15[rbp], 0
  002b0	c6 85 f4 01 00
	00 00		 mov	 BYTE PTR held$16[rbp], 0

; 4051 :             if (!(flags & ImGuiOldColumnFlags_NoResize))

  002b7	8b 45 64	 mov	 eax, DWORD PTR flags$[rbp]
  002ba	83 e0 02	 and	 eax, 2
  002bd	85 c0		 test	 eax, eax
  002bf	75 74		 jne	 SHORT $LN12@EndColumns

; 4052 :             {
; 4053 :                 ButtonBehavior(column_hit_rect, column_id, &hovered, &held);

  002c1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  002c9	4c 8d 8d f4 01
	00 00		 lea	 r9, QWORD PTR held$16[rbp]
  002d0	4c 8d 85 d4 01
	00 00		 lea	 r8, QWORD PTR hovered$15[rbp]
  002d7	8b 95 64 01 00
	00		 mov	 edx, DWORD PTR column_id$12[rbp]
  002dd	48 8d 8d a8 01
	00 00		 lea	 rcx, QWORD PTR column_hit_rect$14[rbp]
  002e4	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 4054 :                 if (hovered || held)

  002e9	0f b6 85 d4 01
	00 00		 movzx	 eax, BYTE PTR hovered$15[rbp]
  002f0	85 c0		 test	 eax, eax
  002f2	75 0b		 jne	 SHORT $LN14@EndColumns
  002f4	0f b6 85 f4 01
	00 00		 movzx	 eax, BYTE PTR held$16[rbp]
  002fb	85 c0		 test	 eax, eax
  002fd	74 0e		 je	 SHORT $LN13@EndColumns
$LN14@EndColumns:

; 4055 :                     g.MouseCursor = ImGuiMouseCursor_ResizeEW;

  002ff	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00303	c7 80 28 4a 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+18984], 4
$LN13@EndColumns:

; 4056 :                 if (held && !(column->Flags & ImGuiOldColumnFlags_NoResize))

  0030d	0f b6 85 f4 01
	00 00		 movzx	 eax, BYTE PTR held$16[rbp]
  00314	85 c0		 test	 eax, eax
  00316	74 1d		 je	 SHORT $LN15@EndColumns
  00318	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  0031f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00322	83 e0 02	 and	 eax, 2
  00325	85 c0		 test	 eax, eax
  00327	75 0c		 jne	 SHORT $LN15@EndColumns

; 4057 :                     dragging_column = n;

  00329	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR n$9[rbp]
  0032f	89 85 e4 00 00
	00		 mov	 DWORD PTR dragging_column$8[rbp], eax
$LN15@EndColumns:
$LN12@EndColumns:

; 4058 :             }
; 4059 : 
; 4060 :             // Draw column
; 4061 :             const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);

  00335	0f b6 85 f4 01
	00 00		 movzx	 eax, BYTE PTR held$16[rbp]
  0033c	85 c0		 test	 eax, eax
  0033e	74 0c		 je	 SHORT $LN22@EndColumns
  00340	c7 85 84 04 00
	00 1d 00 00 00	 mov	 DWORD PTR tv209[rbp], 29
  0034a	eb 2d		 jmp	 SHORT $LN23@EndColumns
$LN22@EndColumns:
  0034c	0f b6 85 d4 01
	00 00		 movzx	 eax, BYTE PTR hovered$15[rbp]
  00353	85 c0		 test	 eax, eax
  00355	74 0c		 je	 SHORT $LN20@EndColumns
  00357	c7 85 88 04 00
	00 1c 00 00 00	 mov	 DWORD PTR tv206[rbp], 28
  00361	eb 0a		 jmp	 SHORT $LN21@EndColumns
$LN20@EndColumns:
  00363	c7 85 88 04 00
	00 1b 00 00 00	 mov	 DWORD PTR tv206[rbp], 27
$LN21@EndColumns:
  0036d	8b 85 88 04 00
	00		 mov	 eax, DWORD PTR tv206[rbp]
  00373	89 85 84 04 00
	00		 mov	 DWORD PTR tv209[rbp], eax
$LN23@EndColumns:
  00379	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00381	8b 8d 84 04 00
	00		 mov	 ecx, DWORD PTR tv209[rbp]
  00387	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0038c	89 85 14 02 00
	00		 mov	 DWORD PTR col$17[rbp], eax

; 4062 :             const float xi = IM_FLOOR(x);

  00392	f3 0f 2c 85 44
	01 00 00	 cvttss2si eax, DWORD PTR x$11[rbp]
  0039a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0039e	f3 0f 11 85 34
	02 00 00	 movss	 DWORD PTR xi$18[rbp], xmm0

; 4063 :             window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);

  003a6	f3 0f 10 95 c4
	00 00 00	 movss	 xmm2, DWORD PTR y2$7[rbp]
  003ae	f3 0f 10 8d 34
	02 00 00	 movss	 xmm1, DWORD PTR xi$18[rbp]
  003b6	48 8d 8d 54 04
	00 00		 lea	 rcx, QWORD PTR $T23[rbp]
  003bd	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  003c2	48 89 85 88 04
	00 00		 mov	 QWORD PTR tv218[rbp], rax
  003c9	f3 0f 10 85 a4
	00 00 00	 movss	 xmm0, DWORD PTR y1$6[rbp]
  003d1	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  003d9	0f 28 d0	 movaps	 xmm2, xmm0
  003dc	f3 0f 10 8d 34
	02 00 00	 movss	 xmm1, DWORD PTR xi$18[rbp]
  003e4	48 8d 8d 74 04
	00 00		 lea	 rcx, QWORD PTR $T24[rbp]
  003eb	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  003f0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003f8	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  003fe	44 8b 8d 14 02
	00 00		 mov	 r9d, DWORD PTR col$17[rbp]
  00405	48 8b 8d 88 04
	00 00		 mov	 rcx, QWORD PTR tv218[rbp]
  0040c	4c 8b c1	 mov	 r8, rcx
  0040f	48 8b d0	 mov	 rdx, rax
  00412	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00416	48 8b 88 90 02
	00 00		 mov	 rcx, QWORD PTR [rax+656]
  0041d	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine

; 4064 :         }

  00422	e9 6a fd ff ff	 jmp	 $LN2@EndColumns
$LN3@EndColumns:

; 4065 : 
; 4066 :         // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
; 4067 :         if (dragging_column != -1)

  00427	83 bd e4 00 00
	00 ff		 cmp	 DWORD PTR dragging_column$8[rbp], -1
  0042e	0f 84 b8 00 00
	00		 je	 $LN16@EndColumns

; 4068 :         {
; 4069 :             if (!columns->IsBeingResized)

  00434	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00438	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  0043c	85 c0		 test	 eax, eax
  0043e	75 6d		 jne	 SHORT $LN17@EndColumns

; 4070 :                 for (int n = 0; n < columns->Count + 1; n++)

  00440	c7 85 54 02 00
	00 00 00 00 00	 mov	 DWORD PTR n$19[rbp], 0
  0044a	eb 0e		 jmp	 SHORT $LN7@EndColumns
$LN5@EndColumns:
  0044c	8b 85 54 02 00
	00		 mov	 eax, DWORD PTR n$19[rbp]
  00452	ff c0		 inc	 eax
  00454	89 85 54 02 00
	00		 mov	 DWORD PTR n$19[rbp], eax
$LN7@EndColumns:
  0045a	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  0045e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00461	ff c0		 inc	 eax
  00463	39 85 54 02 00
	00		 cmp	 DWORD PTR n$19[rbp], eax
  00469	7d 42		 jge	 SHORT $LN6@EndColumns

; 4071 :                     columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;

  0046b	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  0046f	48 83 c0 60	 add	 rax, 96			; 00000060H
  00473	8b 95 54 02 00
	00		 mov	 edx, DWORD PTR n$19[rbp]
  00479	48 8b c8	 mov	 rcx, rax
  0047c	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  00481	48 89 85 88 04
	00 00		 mov	 QWORD PTR tv243[rbp], rax
  00488	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  0048c	48 83 c1 60	 add	 rcx, 96			; 00000060H
  00490	8b 95 54 02 00
	00		 mov	 edx, DWORD PTR n$19[rbp]
  00496	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  0049b	48 8b 8d 88 04
	00 00		 mov	 rcx, QWORD PTR tv243[rbp]
  004a2	f3 0f 10 01	 movss	 xmm0, DWORD PTR [rcx]
  004a6	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
  004ab	eb 9f		 jmp	 SHORT $LN5@EndColumns
$LN6@EndColumns:
$LN17@EndColumns:

; 4072 :             columns->IsBeingResized = is_being_resized = true;

  004ad	c6 85 84 00 00
	00 01		 mov	 BYTE PTR is_being_resized$[rbp], 1
  004b4	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  004b8	0f b6 8d 84 00
	00 00		 movzx	 ecx, BYTE PTR is_being_resized$[rbp]
  004bf	88 48 09	 mov	 BYTE PTR [rax+9], cl

; 4073 :             float x = GetDraggedColumnOffset(columns, dragging_column);

  004c2	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR dragging_column$8[rbp]
  004c8	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  004cc	e8 00 00 00 00	 call	 ?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z ; GetDraggedColumnOffset
  004d1	f3 0f 11 85 74
	02 00 00	 movss	 DWORD PTR x$20[rbp], xmm0

; 4074 :             SetColumnOffset(dragging_column, x);

  004d9	f3 0f 10 8d 74
	02 00 00	 movss	 xmm1, DWORD PTR x$20[rbp]
  004e1	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR dragging_column$8[rbp]
  004e7	e8 00 00 00 00	 call	 ?SetColumnOffset@ImGui@@YAXHM@Z ; ImGui::SetColumnOffset
$LN16@EndColumns:
$LN10@EndColumns:

; 4075 :         }
; 4076 :     }
; 4077 :     columns->IsBeingResized = is_being_resized;

  004ec	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  004f0	0f b6 8d 84 00
	00 00		 movzx	 ecx, BYTE PTR is_being_resized$[rbp]
  004f7	88 48 09	 mov	 BYTE PTR [rax+9], cl

; 4078 : 
; 4079 :     window->WorkRect = window->ParentWorkRect;

  004fa	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  004fe	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00502	48 8d b8 10 02
	00 00		 lea	 rdi, QWORD PTR [rax+528]
  00509	48 8d b1 20 02
	00 00		 lea	 rsi, QWORD PTR [rcx+544]
  00510	b9 10 00 00 00	 mov	 ecx, 16
  00515	f3 a4		 rep movsb

; 4080 :     window->ParentWorkRect = columns->HostBackupParentWorkRect;

  00517	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0051b	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  0051f	48 8d b8 20 02
	00 00		 lea	 rdi, QWORD PTR [rax+544]
  00526	48 8d 71 4c	 lea	 rsi, QWORD PTR [rcx+76]
  0052a	b9 10 00 00 00	 mov	 ecx, 16
  0052f	f3 a4		 rep movsb

; 4081 :     window->DC.CurrentColumns = NULL;

  00531	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00535	48 c7 80 a0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+416], 0

; 4082 :     window->DC.ColumnsOffset.x = 0.0f;

  00540	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00544	0f 57 c0	 xorps	 xmm0, xmm0
  00547	f3 0f 11 80 40
	01 00 00	 movss	 DWORD PTR [rax+320], xmm0

; 4083 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

  0054f	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00553	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00557	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  0055c	f3 0f 58 81 3c
	01 00 00	 addss	 xmm0, DWORD PTR [rcx+316]
  00564	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00568	f3 0f 58 80 40
	01 00 00	 addss	 xmm0, DWORD PTR [rax+320]
  00570	f3 0f 2c c0	 cvttss2si eax, xmm0
  00574	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00578	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0057c	f3 0f 11 80 f8
	00 00 00	 movss	 DWORD PTR [rax+248], xmm0

; 4084 : }

  00584	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  00588	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EndColumns@ImGui@@YAXXZ$rtcFrameData
  0058f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00594	48 8b 8d 90 04
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0059b	48 33 cd	 xor	 rcx, rbp
  0059e	e8 00 00 00 00	 call	 __security_check_cookie
  005a3	48 8d a5 a0 04
	00 00		 lea	 rsp, QWORD PTR [rbp+1184]
  005aa	5f		 pop	 rdi
  005ab	5e		 pop	 rsi
  005ac	5d		 pop	 rbp
  005ad	c3		 ret	 0
?EndColumns@ImGui@@YAXXZ ENDP				; ImGui::EndColumns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?BeginColumns@ImGui@@YAXPEBDHH@Z
_TEXT	SEGMENT
g$ = 8
window$ = 40
id$ = 68
columns$ = 104
column_padding$ = 132
half_clip_extend_x$ = 164
max_1$ = 196
max_2$ = 228
n$4 = 260
column$5 = 296
n$6 = 356
column$7 = 392
clip_x1$8 = 420
clip_x2$9 = 452
offset_0$ = 484
offset_1$ = 516
width$ = 548
$T10 = 964
tv217 = 996
tv188 = 996
tv177 = 996
tv161 = 996
tv182 = 1000
tv166 = 1000
__$ArrayPad$ = 1008
str_id$ = 1056
columns_count$ = 1064
flags$ = 1072
?BeginColumns@ImGui@@YAXPEBDHH@Z PROC			; ImGui::BeginColumns, COMDAT

; 3879 : {

$LN17:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 30 04
	00 00		 sub	 rsp, 1072		; 00000430H
  00018	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001d	48 8b fc	 mov	 rdi, rsp
  00020	b9 0c 01 00 00	 mov	 ecx, 268		; 0000010cH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR [rsp+1112]
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003b	48 33 c5	 xor	 rax, rbp
  0003e	48 89 85 f0 03
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 3880 :     ImGuiContext& g = *GImGui;

  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0004c	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3881 :     ImGuiWindow* window = GetCurrentWindow();

  00050	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00055	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 3882 : 
; 3883 :     IM_ASSERT(columns_count >= 1);

  00059	83 bd 28 04 00
	00 01		 cmp	 DWORD PTR columns_count$[rbp], 1
  00060	7d 22		 jge	 SHORT $LN12@BeginColum
  00062	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??BeginColumns@ImGui@@YAXPEBDHH@Z@4JA
  00068	83 c0 04	 add	 eax, 4
  0006b	44 8b c0	 mov	 r8d, eax
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GDAJJGIO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00082	33 c0		 xor	 eax, eax
$LN12@BeginColum:

; 3884 :     IM_ASSERT(window->DC.CurrentColumns == NULL);   // Nested columns are currently not supported

  00084	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00088	48 83 b8 a0 01
	00 00 00	 cmp	 QWORD PTR [rax+416], 0
  00090	74 22		 je	 SHORT $LN13@BeginColum
  00092	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??BeginColumns@ImGui@@YAXPEBDHH@Z@4JA
  00098	83 c0 05	 add	 eax, 5
  0009b	44 8b c0	 mov	 r8d, eax
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@BPFJENMI@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b2	33 c0		 xor	 eax, eax
$LN13@BeginColum:

; 3885 : 
; 3886 :     // Acquire storage for the columns set
; 3887 :     ImGuiID id = GetColumnsID(str_id, columns_count);

  000b4	8b 95 28 04 00
	00		 mov	 edx, DWORD PTR columns_count$[rbp]
  000ba	48 8b 8d 20 04
	00 00		 mov	 rcx, QWORD PTR str_id$[rbp]
  000c1	e8 00 00 00 00	 call	 ?GetColumnsID@ImGui@@YAIPEBDH@Z ; ImGui::GetColumnsID
  000c6	89 45 44	 mov	 DWORD PTR id$[rbp], eax

; 3888 :     ImGuiOldColumns* columns = FindOrCreateColumns(window, id);

  000c9	8b 55 44	 mov	 edx, DWORD PTR id$[rbp]
  000cc	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  000d0	e8 00 00 00 00	 call	 ?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z ; ImGui::FindOrCreateColumns
  000d5	48 89 45 68	 mov	 QWORD PTR columns$[rbp], rax

; 3889 :     IM_ASSERT(columns->ID == id);

  000d9	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  000dd	8b 4d 44	 mov	 ecx, DWORD PTR id$[rbp]
  000e0	39 08		 cmp	 DWORD PTR [rax], ecx
  000e2	74 22		 je	 SHORT $LN14@BeginColum
  000e4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??BeginColumns@ImGui@@YAXPEBDHH@Z@4JA
  000ea	83 c0 0a	 add	 eax, 10
  000ed	44 8b c0	 mov	 r8d, eax
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@IJEAECLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAd?$AA?$AA@
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00104	33 c0		 xor	 eax, eax
$LN14@BeginColum:

; 3890 :     columns->Current = 0;

  00106	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  0010a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 3891 :     columns->Count = columns_count;

  00111	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00115	8b 8d 28 04 00
	00		 mov	 ecx, DWORD PTR columns_count$[rbp]
  0011b	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 3892 :     columns->Flags = flags;

  0011e	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00122	8b 8d 30 04 00
	00		 mov	 ecx, DWORD PTR flags$[rbp]
  00128	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 3893 :     window->DC.CurrentColumns = columns;

  0012b	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0012f	48 8b 4d 68	 mov	 rcx, QWORD PTR columns$[rbp]
  00133	48 89 88 a0 01
	00 00		 mov	 QWORD PTR [rax+416], rcx

; 3894 : 
; 3895 :     columns->HostCursorPosY = window->DC.CursorPos.y;

  0013a	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  0013e	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00142	f3 0f 10 81 fc
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+252]
  0014a	f3 0f 11 40 24	 movss	 DWORD PTR [rax+36], xmm0

; 3896 :     columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;

  0014f	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00153	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00157	f3 0f 10 81 10
	01 00 00	 movss	 xmm0, DWORD PTR [rcx+272]
  0015f	f3 0f 11 40 28	 movss	 DWORD PTR [rax+40], xmm0

; 3897 :     columns->HostInitialClipRect = window->ClipRect;

  00164	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00168	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  0016c	48 8d 78 2c	 lea	 rdi, QWORD PTR [rax+44]
  00170	48 8d b1 30 02
	00 00		 lea	 rsi, QWORD PTR [rcx+560]
  00177	b9 10 00 00 00	 mov	 ecx, 16
  0017c	f3 a4		 rep movsb

; 3898 :     columns->HostBackupParentWorkRect = window->ParentWorkRect;

  0017e	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00182	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00186	48 8d 78 4c	 lea	 rdi, QWORD PTR [rax+76]
  0018a	48 8d b1 20 02
	00 00		 lea	 rsi, QWORD PTR [rcx+544]
  00191	b9 10 00 00 00	 mov	 ecx, 16
  00196	f3 a4		 rep movsb

; 3899 :     window->ParentWorkRect = window->WorkRect;

  00198	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0019c	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  001a0	48 8d b8 20 02
	00 00		 lea	 rdi, QWORD PTR [rax+544]
  001a7	48 8d b1 10 02
	00 00		 lea	 rsi, QWORD PTR [rcx+528]
  001ae	b9 10 00 00 00	 mov	 ecx, 16
  001b3	f3 a4		 rep movsb

; 3900 : 
; 3901 :     // Set state for first column
; 3902 :     // We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect
; 3903 :     const float column_padding = g.Style.ItemSpacing.x;

  001b5	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  001b9	f3 0f 10 80 2c
	38 00 00	 movss	 xmm0, DWORD PTR [rax+14380]
  001c1	f3 0f 11 85 84
	00 00 00	 movss	 DWORD PTR column_padding$[rbp], xmm0

; 3904 :     const float half_clip_extend_x = ImFloor(ImMax(window->WindowPadding.x * 0.5f, window->WindowBorderSize));

  001c9	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  001cd	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [rax+72]
  001d2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001da	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  001de	f3 0f 10 48 54	 movss	 xmm1, DWORD PTR [rax+84]
  001e3	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001e8	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  001ed	f3 0f 11 85 a4
	00 00 00	 movss	 DWORD PTR half_clip_extend_x$[rbp], xmm0

; 3905 :     const float max_1 = window->WorkRect.Max.x + column_padding - ImMax(column_padding - window->WindowPadding.x, 0.0f);

  001f5	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  001f9	f3 0f 10 80 18
	02 00 00	 movss	 xmm0, DWORD PTR [rax+536]
  00201	f3 0f 58 85 84
	00 00 00	 addss	 xmm0, DWORD PTR column_padding$[rbp]
  00209	f3 0f 11 85 e4
	03 00 00	 movss	 DWORD PTR tv161[rbp], xmm0
  00211	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00215	f3 0f 10 8d 84
	00 00 00	 movss	 xmm1, DWORD PTR column_padding$[rbp]
  0021d	f3 0f 5c 48 48	 subss	 xmm1, DWORD PTR [rax+72]
  00222	f3 0f 11 8d e8
	03 00 00	 movss	 DWORD PTR tv166[rbp], xmm1
  0022a	0f 57 c9	 xorps	 xmm1, xmm1
  0022d	f3 0f 10 95 e8
	03 00 00	 movss	 xmm2, DWORD PTR tv166[rbp]
  00235	0f 28 c2	 movaps	 xmm0, xmm2
  00238	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0023d	f3 0f 10 8d e4
	03 00 00	 movss	 xmm1, DWORD PTR tv161[rbp]
  00245	f3 0f 5c c8	 subss	 xmm1, xmm0
  00249	0f 28 c1	 movaps	 xmm0, xmm1
  0024c	f3 0f 11 85 c4
	00 00 00	 movss	 DWORD PTR max_1$[rbp], xmm0

; 3906 :     const float max_2 = window->WorkRect.Max.x + half_clip_extend_x;

  00254	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00258	f3 0f 10 80 18
	02 00 00	 movss	 xmm0, DWORD PTR [rax+536]
  00260	f3 0f 58 85 a4
	00 00 00	 addss	 xmm0, DWORD PTR half_clip_extend_x$[rbp]
  00268	f3 0f 11 85 e4
	00 00 00	 movss	 DWORD PTR max_2$[rbp], xmm0

; 3907 :     columns->OffMinX = window->DC.Indent.x - column_padding + ImMax(column_padding - window->WindowPadding.x, 0.0f);

  00270	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00274	f3 0f 10 80 3c
	01 00 00	 movss	 xmm0, DWORD PTR [rax+316]
  0027c	f3 0f 5c 85 84
	00 00 00	 subss	 xmm0, DWORD PTR column_padding$[rbp]
  00284	f3 0f 11 85 e4
	03 00 00	 movss	 DWORD PTR tv177[rbp], xmm0
  0028c	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00290	f3 0f 10 8d 84
	00 00 00	 movss	 xmm1, DWORD PTR column_padding$[rbp]
  00298	f3 0f 5c 48 48	 subss	 xmm1, DWORD PTR [rax+72]
  0029d	f3 0f 11 8d e8
	03 00 00	 movss	 DWORD PTR tv182[rbp], xmm1
  002a5	0f 57 c9	 xorps	 xmm1, xmm1
  002a8	f3 0f 10 95 e8
	03 00 00	 movss	 xmm2, DWORD PTR tv182[rbp]
  002b0	0f 28 c2	 movaps	 xmm0, xmm2
  002b3	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002b8	f3 0f 10 8d e4
	03 00 00	 movss	 xmm1, DWORD PTR tv177[rbp]
  002c0	f3 0f 58 c8	 addss	 xmm1, xmm0
  002c4	0f 28 c1	 movaps	 xmm0, xmm1
  002c7	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  002cb	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0

; 3908 :     columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);

  002d0	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  002d4	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  002d9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  002e1	f3 0f 11 85 e4
	03 00 00	 movss	 DWORD PTR tv188[rbp], xmm0
  002e9	f3 0f 10 8d e4
	00 00 00	 movss	 xmm1, DWORD PTR max_2$[rbp]
  002f1	f3 0f 10 85 c4
	00 00 00	 movss	 xmm0, DWORD PTR max_1$[rbp]
  002f9	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  002fe	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00302	f3 0f 5c 40 18	 subss	 xmm0, DWORD PTR [rax+24]
  00307	f3 0f 10 8d e4
	03 00 00	 movss	 xmm1, DWORD PTR tv188[rbp]
  0030f	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00314	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00318	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0

; 3909 :     columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;

  0031d	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00321	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00325	f3 0f 10 81 fc
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+252]
  0032d	f3 0f 11 40 20	 movss	 DWORD PTR [rax+32], xmm0
  00332	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00336	48 8b 4d 68	 mov	 rcx, QWORD PTR columns$[rbp]
  0033a	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  0033f	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0

; 3910 : 
; 3911 :     // Clear data if columns count changed
; 3912 :     if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)

  00344	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00348	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0034c	74 23		 je	 SHORT $LN8@BeginColum
  0034e	8b 85 28 04 00
	00		 mov	 eax, DWORD PTR columns_count$[rbp]
  00354	ff c0		 inc	 eax
  00356	48 8b 4d 68	 mov	 rcx, QWORD PTR columns$[rbp]
  0035a	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  0035d	74 12		 je	 SHORT $LN8@BeginColum

; 3913 :         columns->Columns.resize(0);

  0035f	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00363	48 83 c0 60	 add	 rax, 96			; 00000060H
  00367	33 d2		 xor	 edx, edx
  00369	48 8b c8	 mov	 rcx, rax
  0036c	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::resize
$LN8@BeginColum:

; 3914 : 
; 3915 :     // Initialize default widths
; 3916 :     columns->IsFirstFrame = (columns->Columns.Size == 0);

  00371	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00375	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00379	75 0c		 jne	 SHORT $LN15@BeginColum
  0037b	c7 85 e4 03 00
	00 01 00 00 00	 mov	 DWORD PTR tv217[rbp], 1
  00385	eb 0a		 jmp	 SHORT $LN16@BeginColum
$LN15@BeginColum:
  00387	c7 85 e4 03 00
	00 00 00 00 00	 mov	 DWORD PTR tv217[rbp], 0
$LN16@BeginColum:
  00391	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00395	0f b6 8d e4 03
	00 00		 movzx	 ecx, BYTE PTR tv217[rbp]
  0039c	88 48 08	 mov	 BYTE PTR [rax+8], cl

; 3917 :     if (columns->Columns.Size == 0)

  0039f	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  003a3	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  003a7	0f 85 82 00 00
	00		 jne	 $LN9@BeginColum

; 3918 :     {
; 3919 :         columns->Columns.reserve(columns_count + 1);

  003ad	8b 85 28 04 00
	00		 mov	 eax, DWORD PTR columns_count$[rbp]
  003b3	ff c0		 inc	 eax
  003b5	48 8b 4d 68	 mov	 rcx, QWORD PTR columns$[rbp]
  003b9	48 83 c1 60	 add	 rcx, 96			; 00000060H
  003bd	8b d0		 mov	 edx, eax
  003bf	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::reserve

; 3920 :         for (int n = 0; n < columns_count + 1; n++)

  003c4	c7 85 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR n$4[rbp], 0
  003ce	eb 0e		 jmp	 SHORT $LN4@BeginColum
$LN2@BeginColum:
  003d0	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR n$4[rbp]
  003d6	ff c0		 inc	 eax
  003d8	89 85 04 01 00
	00		 mov	 DWORD PTR n$4[rbp], eax
$LN4@BeginColum:
  003de	8b 85 28 04 00
	00		 mov	 eax, DWORD PTR columns_count$[rbp]
  003e4	ff c0		 inc	 eax
  003e6	39 85 04 01 00
	00		 cmp	 DWORD PTR n$4[rbp], eax
  003ec	7d 41		 jge	 SHORT $LN3@BeginColum

; 3921 :         {
; 3922 :             ImGuiOldColumnData column;

  003ee	48 8d 8d 28 01
	00 00		 lea	 rcx, QWORD PTR column$5[rbp]
  003f5	e8 00 00 00 00	 call	 ??0ImGuiOldColumnData@@QEAA@XZ ; ImGuiOldColumnData::ImGuiOldColumnData

; 3923 :             column.OffsetNorm = n / (float)columns_count;

  003fa	f3 0f 2a 85 04
	01 00 00	 cvtsi2ss xmm0, DWORD PTR n$4[rbp]
  00402	f3 0f 2a 8d 28
	04 00 00	 cvtsi2ss xmm1, DWORD PTR columns_count$[rbp]
  0040a	f3 0f 5e c1	 divss	 xmm0, xmm1
  0040e	f3 0f 11 85 28
	01 00 00	 movss	 DWORD PTR column$5[rbp], xmm0

; 3924 :             columns->Columns.push_back(column);

  00416	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  0041a	48 83 c0 60	 add	 rax, 96			; 00000060H
  0041e	48 8d 95 28 01
	00 00		 lea	 rdx, QWORD PTR column$5[rbp]
  00425	48 8b c8	 mov	 rcx, rax
  00428	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z ; ImVector<ImGuiOldColumnData>::push_back

; 3925 :         }

  0042d	eb a1		 jmp	 SHORT $LN2@BeginColum
$LN3@BeginColum:
$LN9@BeginColum:

; 3926 :     }
; 3927 : 
; 3928 :     for (int n = 0; n < columns_count; n++)

  0042f	c7 85 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR n$6[rbp], 0
  00439	eb 0e		 jmp	 SHORT $LN7@BeginColum
$LN5@BeginColum:
  0043b	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR n$6[rbp]
  00441	ff c0		 inc	 eax
  00443	89 85 64 01 00
	00		 mov	 DWORD PTR n$6[rbp], eax
$LN7@BeginColum:
  00449	8b 85 28 04 00
	00		 mov	 eax, DWORD PTR columns_count$[rbp]
  0044f	39 85 64 01 00
	00		 cmp	 DWORD PTR n$6[rbp], eax
  00455	0f 8d f8 00 00
	00		 jge	 $LN6@BeginColum

; 3929 :     {
; 3930 :         // Compute clipping rectangle
; 3931 :         ImGuiOldColumnData* column = &columns->Columns[n];

  0045b	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  0045f	48 83 c0 60	 add	 rax, 96			; 00000060H
  00463	8b 95 64 01 00
	00		 mov	 edx, DWORD PTR n$6[rbp]
  00469	48 8b c8	 mov	 rcx, rax
  0046c	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  00471	48 89 85 88 01
	00 00		 mov	 QWORD PTR column$7[rbp], rax

; 3932 :         float clip_x1 = IM_ROUND(window->Pos.x + GetColumnOffset(n));

  00478	8b 8d 64 01 00
	00		 mov	 ecx, DWORD PTR n$6[rbp]
  0047e	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  00483	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00487	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [rax+24]
  0048c	f3 0f 58 c8	 addss	 xmm1, xmm0
  00490	0f 28 c1	 movaps	 xmm0, xmm1
  00493	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0049b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0049f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004a3	f3 0f 11 85 a4
	01 00 00	 movss	 DWORD PTR clip_x1$8[rbp], xmm0

; 3933 :         float clip_x2 = IM_ROUND(window->Pos.x + GetColumnOffset(n + 1) - 1.0f);

  004ab	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR n$6[rbp]
  004b1	ff c0		 inc	 eax
  004b3	8b c8		 mov	 ecx, eax
  004b5	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  004ba	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  004be	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [rax+24]
  004c3	f3 0f 58 c8	 addss	 xmm1, xmm0
  004c7	0f 28 c1	 movaps	 xmm0, xmm1
  004ca	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  004d2	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  004da	f3 0f 2c c0	 cvttss2si eax, xmm0
  004de	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004e2	f3 0f 11 85 c4
	01 00 00	 movss	 DWORD PTR clip_x2$9[rbp], xmm0

; 3934 :         column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);

  004ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  004f2	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  004f8	f3 0f 10 9d c4
	01 00 00	 movss	 xmm3, DWORD PTR clip_x2$9[rbp]
  00500	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@ff7fffff
  00508	f3 0f 10 8d a4
	01 00 00	 movss	 xmm1, DWORD PTR clip_x1$8[rbp]
  00510	48 8d 8d c4 03
	00 00		 lea	 rcx, QWORD PTR $T10[rbp]
  00517	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@MMMM@Z	; ImRect::ImRect
  0051c	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  00523	48 8d 79 0c	 lea	 rdi, QWORD PTR [rcx+12]
  00527	48 8b f0	 mov	 rsi, rax
  0052a	b9 10 00 00 00	 mov	 ecx, 16
  0052f	f3 a4		 rep movsb

; 3935 :         column->ClipRect.ClipWithFull(window->ClipRect);

  00531	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00535	48 05 30 02 00
	00		 add	 rax, 560		; 00000230H
  0053b	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR column$7[rbp]
  00542	48 83 c1 0c	 add	 rcx, 12
  00546	48 8b d0	 mov	 rdx, rax
  00549	e8 00 00 00 00	 call	 ?ClipWithFull@ImRect@@QEAAXAEBU1@@Z ; ImRect::ClipWithFull

; 3936 :     }

  0054e	e9 e8 fe ff ff	 jmp	 $LN5@BeginColum
$LN6@BeginColum:

; 3937 : 
; 3938 :     if (columns->Count > 1)

  00553	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00557	83 78 10 01	 cmp	 DWORD PTR [rax+16], 1
  0055b	7e 4c		 jle	 SHORT $LN10@BeginColum

; 3939 :     {
; 3940 :         columns->Splitter.Split(window->DrawList, 1 + columns->Count);

  0055d	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00561	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00564	ff c0		 inc	 eax
  00566	48 8b 4d 68	 mov	 rcx, QWORD PTR columns$[rbp]
  0056a	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0056e	44 8b c0	 mov	 r8d, eax
  00571	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00575	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  0057c	e8 00 00 00 00	 call	 ?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::Split

; 3941 :         columns->Splitter.SetCurrentChannel(window->DrawList, 1);

  00581	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  00585	48 83 c0 70	 add	 rax, 112		; 00000070H
  00589	41 b8 01 00 00
	00		 mov	 r8d, 1
  0058f	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  00593	48 8b 91 90 02
	00 00		 mov	 rdx, QWORD PTR [rcx+656]
  0059a	48 8b c8	 mov	 rcx, rax
  0059d	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 3942 :         PushColumnClipRect(0);

  005a2	33 c9		 xor	 ecx, ecx
  005a4	e8 00 00 00 00	 call	 ?PushColumnClipRect@ImGui@@YAXH@Z ; ImGui::PushColumnClipRect
$LN10@BeginColum:

; 3943 :     }
; 3944 : 
; 3945 :     // We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.
; 3946 :     float offset_0 = GetColumnOffset(columns->Current);

  005a9	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  005ad	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  005b0	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  005b5	f3 0f 11 85 e4
	01 00 00	 movss	 DWORD PTR offset_0$[rbp], xmm0

; 3947 :     float offset_1 = GetColumnOffset(columns->Current + 1);

  005bd	48 8b 45 68	 mov	 rax, QWORD PTR columns$[rbp]
  005c1	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  005c4	ff c0		 inc	 eax
  005c6	8b c8		 mov	 ecx, eax
  005c8	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  005cd	f3 0f 11 85 04
	02 00 00	 movss	 DWORD PTR offset_1$[rbp], xmm0

; 3948 :     float width = offset_1 - offset_0;

  005d5	f3 0f 10 85 04
	02 00 00	 movss	 xmm0, DWORD PTR offset_1$[rbp]
  005dd	f3 0f 5c 85 e4
	01 00 00	 subss	 xmm0, DWORD PTR offset_0$[rbp]
  005e5	f3 0f 11 85 24
	02 00 00	 movss	 DWORD PTR width$[rbp], xmm0

; 3949 :     PushItemWidth(width * 0.65f);

  005ed	f3 0f 10 85 24
	02 00 00	 movss	 xmm0, DWORD PTR width$[rbp]
  005f5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f266666
  005fd	e8 00 00 00 00	 call	 ?PushItemWidth@ImGui@@YAXM@Z ; ImGui::PushItemWidth

; 3950 :     window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);

  00602	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00606	f3 0f 10 85 84
	00 00 00	 movss	 xmm0, DWORD PTR column_padding$[rbp]
  0060e	f3 0f 5c 40 48	 subss	 xmm0, DWORD PTR [rax+72]
  00613	0f 57 c9	 xorps	 xmm1, xmm1
  00616	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0061b	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0061f	f3 0f 11 80 40
	01 00 00	 movss	 DWORD PTR [rax+320], xmm0

; 3951 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

  00627	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0062b	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  0062f	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  00634	f3 0f 58 81 3c
	01 00 00	 addss	 xmm0, DWORD PTR [rcx+316]
  0063c	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00640	f3 0f 58 80 40
	01 00 00	 addss	 xmm0, DWORD PTR [rax+320]
  00648	f3 0f 2c c0	 cvttss2si eax, xmm0
  0064c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00650	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00654	f3 0f 11 80 f8
	00 00 00	 movss	 DWORD PTR [rax+248], xmm0

; 3952 :     window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;

  0065c	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00660	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  00665	f3 0f 58 85 04
	02 00 00	 addss	 xmm0, DWORD PTR offset_1$[rbp]
  0066d	f3 0f 5c 85 84
	00 00 00	 subss	 xmm0, DWORD PTR column_padding$[rbp]
  00675	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00679	f3 0f 11 80 18
	02 00 00	 movss	 DWORD PTR [rax+536], xmm0

; 3953 : }

  00681	48 8d 4d d0	 lea	 rcx, QWORD PTR [rbp-48]
  00685	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?BeginColumns@ImGui@@YAXPEBDHH@Z$rtcFrameData
  0068c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00691	48 8b 8d f0 03
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00698	48 33 cd	 xor	 rcx, rbp
  0069b	e8 00 00 00 00	 call	 __security_check_cookie
  006a0	48 8d a5 00 04
	00 00		 lea	 rsp, QWORD PTR [rbp+1024]
  006a7	5f		 pop	 rdi
  006a8	5e		 pop	 rsi
  006a9	5d		 pop	 rbp
  006aa	c3		 ret	 0
?BeginColumns@ImGui@@YAXPEBDHH@Z ENDP			; ImGui::BeginColumns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z
_TEXT	SEGMENT
clip_rect_vec4$ = 8
__$ArrayPad$ = 232
window$ = 272
clip_rect$ = 280
?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z PROC ; ImGui::SetWindowClipRectBeforeSetChannel, COMDAT

; 3692 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR [rsp+312]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c5	 xor	 rax, rbp
  0003a	48 89 85 e8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 3693 :     ImVec4 clip_rect_vec4 = clip_rect.ToVec4();

  00041	48 8d 55 08	 lea	 rdx, QWORD PTR clip_rect_vec4$[rbp]
  00045	48 8b 8d 18 01
	00 00		 mov	 rcx, QWORD PTR clip_rect$[rbp]
  0004c	e8 00 00 00 00	 call	 ?ToVec4@ImRect@@QEBA?AUImVec4@@XZ ; ImRect::ToVec4

; 3694 :     window->ClipRect = clip_rect;

  00051	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR window$[rbp]
  00058	48 8d b8 30 02
	00 00		 lea	 rdi, QWORD PTR [rax+560]
  0005f	48 8b b5 18 01
	00 00		 mov	 rsi, QWORD PTR clip_rect$[rbp]
  00066	b9 10 00 00 00	 mov	 ecx, 16
  0006b	f3 a4		 rep movsb

; 3695 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

  0006d	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR window$[rbp]
  00074	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0007b	48 8d 4d 08	 lea	 rcx, QWORD PTR clip_rect_vec4$[rbp]
  0007f	48 8d b8 88 00
	00 00		 lea	 rdi, QWORD PTR [rax+136]
  00086	48 8b f1	 mov	 rsi, rcx
  00089	b9 10 00 00 00	 mov	 ecx, 16
  0008e	f3 a4		 rep movsb

; 3696 :     window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;

  00090	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR window$[rbp]
  00097	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0009e	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR window$[rbp]
  000a5	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  000ac	8b 49 58	 mov	 ecx, DWORD PTR [rcx+88]
  000af	ff c9		 dec	 ecx
  000b1	48 63 c9	 movsxd	 rcx, ecx
  000b4	48 6b c9 10	 imul	 rcx, rcx, 16
  000b8	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000bc	48 8d 55 08	 lea	 rdx, QWORD PTR clip_rect_vec4$[rbp]
  000c0	48 8d 3c 08	 lea	 rdi, QWORD PTR [rax+rcx]
  000c4	48 8b f2	 mov	 rsi, rdx
  000c7	b9 10 00 00 00	 mov	 ecx, 16
  000cc	f3 a4		 rep movsb

; 3697 : }

  000ce	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z$rtcFrameData
  000d9	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000de	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000e5	48 33 cd	 xor	 rcx, rbp
  000e8	e8 00 00 00 00	 call	 __security_check_cookie
  000ed	48 8d a5 f0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+240]
  000f4	5f		 pop	 rdi
  000f5	5e		 pop	 rsi
  000f6	5d		 pop	 rbp
  000f7	c3		 ret	 0
?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ENDP ; ImGui::SetWindowClipRectBeforeSetChannel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ItemSize@ImGui@@YAXAEBUImRect@@M@Z
_TEXT	SEGMENT
$T1 = 196
bb$ = 256
text_baseline_y$ = 264
?ItemSize@ImGui@@YAXAEBUImRect@@M@Z PROC		; ImGui::ItemSize, COMDAT

; 2812 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

$LN3:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	55		 push	 rbp
  0000c	57		 push	 rdi
  0000d	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  00030	48 8d 95 c4 00
	00 00		 lea	 rdx, QWORD PTR $T1[rbp]
  00037	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR bb$[rbp]
  0003e	e8 00 00 00 00	 call	 ?GetSize@ImRect@@QEBA?AUImVec2@@XZ ; ImRect::GetSize
  00043	f3 0f 10 8d 08
	01 00 00	 movss	 xmm1, DWORD PTR text_baseline_y$[rbp]
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z ; ImGui::ItemSize
  00053	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0005a	5f		 pop	 rdi
  0005b	5d		 pop	 rbp
  0005c	c3		 ret	 0
?ItemSize@ImGui@@YAXAEBUImRect@@M@Z ENDP		; ImGui::ItemSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z
_TEXT	SEGMENT
g$ = 8
msg$ = 40
tv69 = 248
key$ = 288
?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z PROC	; ImGui::LocalizeGetMsg, COMDAT

; 2779 :     inline const char*      LocalizeGetMsg(ImGuiLocKey key) { ImGuiContext& g = *GImGui; const char* msg = g.LocalizationTable[key]; return msg ? msg : "*Missing Text*"; }

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000d	48 8b ec	 mov	 rbp, rsp
  00010	48 8b fc	 mov	 rdi, rsp
  00013	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR [rsp+296]
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0002d	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax
  00031	48 63 85 20 01
	00 00		 movsxd	 rax, DWORD PTR key$[rbp]
  00038	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  0003c	48 8b 84 c1 d8
	5b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+23512]
  00044	48 89 45 28	 mov	 QWORD PTR msg$[rbp], rax
  00048	48 83 7d 28 00	 cmp	 QWORD PTR msg$[rbp], 0
  0004d	74 0d		 je	 SHORT $LN3@LocalizeGe
  0004f	48 8b 45 28	 mov	 rax, QWORD PTR msg$[rbp]
  00053	48 89 85 f8 00
	00 00		 mov	 QWORD PTR tv69[rbp], rax
  0005a	eb 0e		 jmp	 SHORT $LN4@LocalizeGe
$LN3@LocalizeGe:
  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0P@HEMCFMMD@?$CKMissing?5Text?$CK?$AA@
  00063	48 89 85 f8 00
	00 00		 mov	 QWORD PTR tv69[rbp], rax
$LN4@LocalizeGe:
  0006a	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR tv69[rbp]
  00071	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00078	5f		 pop	 rdi
  00079	5d		 pop	 rbp
  0007a	c3		 ret	 0
?LocalizeGetMsg@ImGui@@YAPEBDW4ImGuiLocKey@@@Z ENDP	; ImGui::LocalizeGetMsg
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ
_TEXT	SEGMENT
g$ = 8
?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ PROC	; ImGui::GetCurrentWindow, COMDAT

; 2714 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00023	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax
  00027	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0002b	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  00032	c6 80 b0 00 00
	00 01		 mov	 BYTE PTR [rax+176], 1
  00039	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003d	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  00044	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0004b	5f		 pop	 rdi
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ENDP	; ImGui::GetCurrentWindow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ
_TEXT	SEGMENT
g$ = 8
?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ PROC	; ImGui::GetCurrentWindowRead, COMDAT

; 2713 :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00023	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax
  00027	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0002b	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  00032	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00039	5f		 pop	 rdi
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ENDP	; ImGui::GetCurrentWindowRead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ
_TEXT	SEGMENT
this$ = 224
?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ PROC ; ImGuiTableSettings::GetColumnSettings, COMDAT

; 2698 :     ImGuiTableColumnSettings*   GetColumnSettings()     { return (ImGuiTableColumnSettings*)(this + 1); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 83 c0 14	 add	 rax, 20
  00033	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0003a	5f		 pop	 rdi
  0003b	5d		 pop	 rbp
  0003c	c3		 ret	 0
?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ ENDP ; ImGuiTableSettings::GetColumnSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTableSettings@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0ImGuiTableSettings@@QEAA@XZ PROC			; ImGuiTableSettings::ImGuiTableSettings, COMDAT

; 2697 :     ImGuiTableSettings()        { memset(this, 0, sizeof(*this)); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	41 b8 14 00 00
	00		 mov	 r8d, 20
  00030	33 d2		 xor	 edx, edx
  00032	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00039	e8 00 00 00 00	 call	 memset
  0003e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004c	5f		 pop	 rdi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??0ImGuiTableSettings@@QEAA@XZ ENDP			; ImGuiTableSettings::ImGuiTableSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTableColumnSettings@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0ImGuiTableColumnSettings@@QEAA@XZ PROC		; ImGuiTableColumnSettings::ImGuiTableColumnSettings, COMDAT

; 2675 :     ImGuiTableColumnSettings()

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]

; 2676 :     {
; 2677 :         WidthOrWeight = 0.0f;

  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	0f 57 c0	 xorps	 xmm0, xmm0
  00032	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 2678 :         UserID = 0;

  00036	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 2679 :         Index = -1;

  00044	b8 ff ff ff ff	 mov	 eax, -1
  00049	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00050	66 89 41 08	 mov	 WORD PTR [rcx+8], ax

; 2680 :         DisplayOrder = SortOrder = -1;

  00054	b8 ff ff ff ff	 mov	 eax, -1
  00059	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00060	66 89 41 0c	 mov	 WORD PTR [rcx+12], ax
  00064	b8 ff ff ff ff	 mov	 eax, -1
  00069	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00070	66 89 41 0a	 mov	 WORD PTR [rcx+10], ax

; 2681 :         SortDirection = ImGuiSortDirection_None;

  00074	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007b	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  0007f	24 fc		 and	 al, 252			; 000000fcH
  00081	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00088	88 41 0e	 mov	 BYTE PTR [rcx+14], al

; 2682 :         IsEnabled = 1;

  0008b	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00092	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  00096	0c 04		 or	 al, 4
  00098	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009f	88 41 0e	 mov	 BYTE PTR [rcx+14], al

; 2683 :         IsStretch = 0;

  000a2	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a9	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  000ad	24 f7		 and	 al, 247			; 000000f7H
  000af	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000b6	88 41 0e	 mov	 BYTE PTR [rcx+14], al

; 2684 :     }

  000b9	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c0	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000c7	5f		 pop	 rdi
  000c8	5d		 pop	 rbp
  000c9	c3		 ret	 0
??0ImGuiTableColumnSettings@@QEAA@XZ ENDP		; ImGuiTableColumnSettings::ImGuiTableColumnSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1ImGuiTableTempData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1ImGuiTableTempData@@QEAA@XZ PROC			; ImGuiTableTempData::~ImGuiTableTempData, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 83 c0 10	 add	 rax, 16
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ??1ImDrawListSplitter@@QEAA@XZ ; ImDrawListSplitter::~ImDrawListSplitter
  0003d	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00044	5f		 pop	 rdi
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
??1ImGuiTableTempData@@QEAA@XZ ENDP			; ImGuiTableTempData::~ImGuiTableTempData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTableTempData@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??0ImGuiTableTempData@@QEAA@XZ PROC			; ImGuiTableTempData::ImGuiTableTempData, COMDAT

; 2660 :     ImGuiTableTempData()        { memset(this, 0, sizeof(*this)); LastTimeActive = -1.0f; }

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002a	48 c7 85 c8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T1[rbp], -2
  00035	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 83 c0 08	 add	 rax, 8
  00040	48 8b c8	 mov	 rcx, rax
  00043	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@XZ	; ImVec2::ImVec2
  00048	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004f	48 83 c0 10	 add	 rax, 16
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ??0ImDrawListSplitter@@QEAA@XZ ; ImDrawListSplitter::ImDrawListSplitter
  0005b	90		 npad	 1
  0005c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00063	48 83 c0 28	 add	 rax, 40			; 00000028H
  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  0006f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00076	48 83 c0 38	 add	 rax, 56			; 00000038H
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  00082	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00089	48 83 c0 48	 add	 rax, 72			; 00000048H
  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@XZ	; ImVec2::ImVec2
  00095	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0009c	48 83 c0 50	 add	 rax, 80			; 00000050H
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@XZ	; ImVec2::ImVec2
  000a8	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000af	48 83 c0 58	 add	 rax, 88			; 00000058H
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@XZ	; ImVec2::ImVec2
  000bb	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c2	48 83 c0 60	 add	 rax, 96			; 00000060H
  000c6	48 8b c8	 mov	 rcx, rax
  000c9	e8 00 00 00 00	 call	 ??0ImVec1@@QEAA@XZ	; ImVec1::ImVec1
  000ce	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  000d4	33 d2		 xor	 edx, edx
  000d6	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000dd	e8 00 00 00 00	 call	 memset
  000e2	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000e9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000f1	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
  000f6	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000fd	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00104	5f		 pop	 rdi
  00105	5d		 pop	 rbp
  00106	c3		 ret	 0
??0ImGuiTableTempData@@QEAA@XZ ENDP			; ImGuiTableTempData::ImGuiTableTempData
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ImGuiTableTempData@@QEAA@XZ@4HA PROC	; `ImGuiTableTempData::ImGuiTableTempData'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 83 c1 10	 add	 rcx, 16
  0001f	e8 00 00 00 00	 call	 ??1ImDrawListSplitter@@QEAA@XZ ; ImDrawListSplitter::~ImDrawListSplitter
  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	5f		 pop	 rdi
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?dtor$0@?0???0ImGuiTableTempData@@QEAA@XZ@4HA ENDP	; `ImGuiTableTempData::ImGuiTableTempData'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ImGuiTableTempData@@QEAA@XZ@4HA PROC	; `ImGuiTableTempData::ImGuiTableTempData'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 83 c1 10	 add	 rcx, 16
  0001f	e8 00 00 00 00	 call	 ??1ImDrawListSplitter@@QEAA@XZ ; ImDrawListSplitter::~ImDrawListSplitter
  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	5f		 pop	 rdi
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?dtor$0@?0???0ImGuiTableTempData@@QEAA@XZ@4HA ENDP	; `ImGuiTableTempData::ImGuiTableTempData'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GImGuiTable@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_GImGuiTable@@QEAAPEAXI@Z PROC			; ImGuiTable::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00035	e8 00 00 00 00	 call	 ??1ImGuiTable@@QEAA@XZ	; ImGuiTable::~ImGuiTable
  0003a	8b 85 e8 00 00
	00		 mov	 eax, DWORD PTR __flags$[rbp]
  00040	83 e0 01	 and	 eax, 1
  00043	85 c0		 test	 eax, eax
  00045	74 11		 je	 SHORT $LN2@scalar
  00047	ba 38 02 00 00	 mov	 edx, 568		; 00000238H
  0004c	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00053	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00058	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00066	5f		 pop	 rdi
  00067	5d		 pop	 rbp
  00068	c3		 ret	 0
??_GImGuiTable@@QEAAPEAXI@Z ENDP			; ImGuiTable::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??1ImGuiTable@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1ImGuiTable@@QEAA@XZ PROC				; ImGuiTable::~ImGuiTable, COMDAT

; 2637 :     ~ImGuiTable()               { IM_FREE(RawData); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002a	48 c7 85 c8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T1[rbp], -2
  00035	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00040	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
  00045	90		 npad	 1
  00046	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004d	48 05 d0 01 00
	00		 add	 rax, 464		; 000001d0H
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ ; ImVector<ImGuiTableColumnSortSpecs>::~ImVector<ImGuiTableColumnSortSpecs>
  0005b	90		 npad	 1
  0005c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00063	48 05 b0 01 00
	00		 add	 rax, 432		; 000001b0H
  00069	48 8b c8	 mov	 rcx, rax
  0006c	e8 00 00 00 00	 call	 ??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ ; ImVector<ImGuiTableInstanceData>::~ImVector<ImGuiTableInstanceData>
  00071	90		 npad	 1
  00072	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00079	48 05 88 01 00
	00		 add	 rax, 392		; 00000188H
  0007f	48 8b c8	 mov	 rcx, rax
  00082	e8 00 00 00 00	 call	 ??1ImGuiTextBuffer@@QEAA@XZ
  00087	90		 npad	 1
  00088	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0008f	5f		 pop	 rdi
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
??1ImGuiTable@@QEAA@XZ ENDP				; ImGuiTable::~ImGuiTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTable@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??0ImGuiTable@@QEAA@XZ PROC				; ImGuiTable::ImGuiTable, COMDAT

; 2636 :     ImGuiTable()                { memset(this, 0, sizeof(*this)); LastFrameActive = -1; }

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002a	48 c7 85 c8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T1[rbp], -2
  00035	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 83 c0 18	 add	 rax, 24
  00040	48 8b c8	 mov	 rcx, rax
  00043	e8 00 00 00 00	 call	 ??0?$ImSpan@UImGuiTableColumn@@@@QEAA@XZ ; ImSpan<ImGuiTableColumn>::ImSpan<ImGuiTableColumn>
  00048	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004f	48 83 c0 28	 add	 rax, 40			; 00000028H
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ??0?$ImSpan@F@@QEAA@XZ	; ImSpan<short>::ImSpan<short>
  0005b	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00062	48 83 c0 38	 add	 rax, 56			; 00000038H
  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 ??0?$ImSpan@UImGuiTableCellData@@@@QEAA@XZ ; ImSpan<ImGuiTableCellData>::ImSpan<ImGuiTableCellData>
  0006e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00075	48 05 e8 00 00
	00		 add	 rax, 232		; 000000e8H
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  00083	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008a	48 05 f8 00 00
	00		 add	 rax, 248		; 000000f8H
  00090	48 8b c8	 mov	 rcx, rax
  00093	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  00098	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0009f	48 05 08 01 00
	00		 add	 rax, 264		; 00000108H
  000a5	48 8b c8	 mov	 rcx, rax
  000a8	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  000ad	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b4	48 05 18 01 00
	00		 add	 rax, 280		; 00000118H
  000ba	48 8b c8	 mov	 rcx, rax
  000bd	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  000c2	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c9	48 05 28 01 00
	00		 add	 rax, 296		; 00000128H
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  000d7	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000de	48 05 38 01 00
	00		 add	 rax, 312		; 00000138H
  000e4	48 8b c8	 mov	 rcx, rax
  000e7	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  000ec	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000f3	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  000f9	48 8b c8	 mov	 rcx, rax
  000fc	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  00101	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00108	48 05 58 01 00
	00		 add	 rax, 344		; 00000158H
  0010e	48 8b c8	 mov	 rcx, rax
  00111	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  00116	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0011d	48 05 68 01 00
	00		 add	 rax, 360		; 00000168H
  00123	48 8b c8	 mov	 rcx, rax
  00126	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  0012b	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00132	48 05 88 01 00
	00		 add	 rax, 392		; 00000188H
  00138	48 8b c8	 mov	 rcx, rax
  0013b	e8 00 00 00 00	 call	 ??0ImGuiTextBuffer@@QEAA@XZ ; ImGuiTextBuffer::ImGuiTextBuffer
  00140	90		 npad	 1
  00141	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00148	48 05 a0 01 00
	00		 add	 rax, 416		; 000001a0H
  0014e	48 8b c8	 mov	 rcx, rax
  00151	e8 00 00 00 00	 call	 ??0ImGuiTableInstanceData@@QEAA@XZ ; ImGuiTableInstanceData::ImGuiTableInstanceData
  00156	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0015d	48 05 b0 01 00
	00		 add	 rax, 432		; 000001b0H
  00163	48 8b c8	 mov	 rcx, rax
  00166	e8 00 00 00 00	 call	 ??0?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ ; ImVector<ImGuiTableInstanceData>::ImVector<ImGuiTableInstanceData>
  0016b	90		 npad	 1
  0016c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00173	48 05 c0 01 00
	00		 add	 rax, 448		; 000001c0H
  00179	48 8b c8	 mov	 rcx, rax
  0017c	e8 00 00 00 00	 call	 ??0ImGuiTableColumnSortSpecs@@QEAA@XZ ; ImGuiTableColumnSortSpecs::ImGuiTableColumnSortSpecs
  00181	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00188	48 05 d0 01 00
	00		 add	 rax, 464		; 000001d0H
  0018e	48 8b c8	 mov	 rcx, rax
  00191	e8 00 00 00 00	 call	 ??0?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ ; ImVector<ImGuiTableColumnSortSpecs>::ImVector<ImGuiTableColumnSortSpecs>
  00196	90		 npad	 1
  00197	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0019e	48 05 e0 01 00
	00		 add	 rax, 480		; 000001e0H
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	e8 00 00 00 00	 call	 ??0ImGuiTableSortSpecs@@QEAA@XZ ; ImGuiTableSortSpecs::ImGuiTableSortSpecs
  001ac	41 b8 38 02 00
	00		 mov	 r8d, 568		; 00000238H
  001b2	33 d2		 xor	 edx, edx
  001b4	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001bb	e8 00 00 00 00	 call	 memset
  001c0	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001c7	c7 40 68 ff ff
	ff ff		 mov	 DWORD PTR [rax+104], -1
  001ce	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001d5	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  001dc	5f		 pop	 rdi
  001dd	5d		 pop	 rbp
  001de	c3		 ret	 0
??0ImGuiTable@@QEAA@XZ ENDP				; ImGuiTable::ImGuiTable
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ImGuiTable@@QEAA@XZ@4HA PROC		; `ImGuiTable::ImGuiTable'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 88 01
	00 00		 add	 rcx, 392		; 00000188H
  00022	e8 00 00 00 00	 call	 ??1ImGuiTextBuffer@@QEAA@XZ
  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	5f		 pop	 rdi
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0ImGuiTable@@QEAA@XZ@4HA ENDP		; `ImGuiTable::ImGuiTable'::`1'::dtor$0
$T1 = 200
this$ = 256
?dtor$1@?0???0ImGuiTable@@QEAA@XZ@4HA PROC		; `ImGuiTable::ImGuiTable'::`1'::dtor$1
  0002e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00033	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00038	55		 push	 rbp
  00039	57		 push	 rdi
  0003a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0003e	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00042	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	48 81 c1 b0 01
	00 00		 add	 rcx, 432		; 000001b0H
  00050	e8 00 00 00 00	 call	 ??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ ; ImVector<ImGuiTableInstanceData>::~ImVector<ImGuiTableInstanceData>
  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	5f		 pop	 rdi
  0005a	5d		 pop	 rbp
  0005b	c3		 ret	 0
?dtor$1@?0???0ImGuiTable@@QEAA@XZ@4HA ENDP		; `ImGuiTable::ImGuiTable'::`1'::dtor$1
$T1 = 200
this$ = 256
?dtor$2@?0???0ImGuiTable@@QEAA@XZ@4HA PROC		; `ImGuiTable::ImGuiTable'::`1'::dtor$2
  0005c	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00061	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00066	55		 push	 rbp
  00067	57		 push	 rdi
  00068	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0006c	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00070	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00077	48 81 c1 d0 01
	00 00		 add	 rcx, 464		; 000001d0H
  0007e	e8 00 00 00 00	 call	 ??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ ; ImVector<ImGuiTableColumnSortSpecs>::~ImVector<ImGuiTableColumnSortSpecs>
  00083	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00087	5f		 pop	 rdi
  00088	5d		 pop	 rbp
  00089	c3		 ret	 0
?dtor$2@?0???0ImGuiTable@@QEAA@XZ@4HA ENDP		; `ImGuiTable::ImGuiTable'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ImGuiTable@@QEAA@XZ@4HA PROC		; `ImGuiTable::ImGuiTable'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 88 01
	00 00		 add	 rcx, 392		; 00000188H
  00022	e8 00 00 00 00	 call	 ??1ImGuiTextBuffer@@QEAA@XZ
  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	5f		 pop	 rdi
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0ImGuiTable@@QEAA@XZ@4HA ENDP		; `ImGuiTable::ImGuiTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$1@?0???0ImGuiTable@@QEAA@XZ@4HA PROC		; `ImGuiTable::ImGuiTable'::`1'::dtor$1
  0002e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00033	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00038	55		 push	 rbp
  00039	57		 push	 rdi
  0003a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0003e	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00042	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	48 81 c1 b0 01
	00 00		 add	 rcx, 432		; 000001b0H
  00050	e8 00 00 00 00	 call	 ??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ ; ImVector<ImGuiTableInstanceData>::~ImVector<ImGuiTableInstanceData>
  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	5f		 pop	 rdi
  0005a	5d		 pop	 rbp
  0005b	c3		 ret	 0
?dtor$1@?0???0ImGuiTable@@QEAA@XZ@4HA ENDP		; `ImGuiTable::ImGuiTable'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$2@?0???0ImGuiTable@@QEAA@XZ@4HA PROC		; `ImGuiTable::ImGuiTable'::`1'::dtor$2
  0005c	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00061	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00066	55		 push	 rbp
  00067	57		 push	 rdi
  00068	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0006c	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00070	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00077	48 81 c1 d0 01
	00 00		 add	 rcx, 464		; 000001d0H
  0007e	e8 00 00 00 00	 call	 ??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ ; ImVector<ImGuiTableColumnSortSpecs>::~ImVector<ImGuiTableColumnSortSpecs>
  00083	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00087	5f		 pop	 rdi
  00088	5d		 pop	 rbp
  00089	c3		 ret	 0
?dtor$2@?0???0ImGuiTable@@QEAA@XZ@4HA ENDP		; `ImGuiTable::ImGuiTable'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 8
this$ = 256
new_capacity$ = 264
?reserve@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z PROC ; ImVector<ImGuiTableColumnSortSpecs>::reserve, COMDAT

; 1803 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 08 01 00
	00		 cmp	 DWORD PTR new_capacity$[rbp], eax
  0003e	7f 02		 jg	 SHORT $LN2@reserve
  00040	eb 79		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  00042	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR new_capacity$[rbp]
  00049	48 6b c0 0c	 imul	 rax, rax, 12
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  00055	48 89 45 08	 mov	 QWORD PTR new_data$[rbp], rax
  00059	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00060	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00065	74 35		 je	 SHORT $LN3@reserve
  00067	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006e	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00071	48 6b c0 0c	 imul	 rax, rax, 12
  00075	4c 8b c0	 mov	 r8, rax
  00078	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00083	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  00087	e8 00 00 00 00	 call	 memcpy
  0008c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00093	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00097	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN3@reserve:
  0009c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a3	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  000a7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000ab	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b2	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_capacity$[rbp]
  000b8	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN1@reserve:
  000bb	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	c3		 ret	 0
?reserve@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z ENDP ; ImVector<ImGuiTableColumnSortSpecs>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 224
new_size$ = 232
?resize@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z PROC ; ImVector<ImGuiTableColumnSortSpecs>::resize, COMDAT

; 1800 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 e8 00 00
	00		 cmp	 DWORD PTR new_size$[rbp], eax
  0003e	7e 20		 jle	 SHORT $LN2@resize
  00040	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR new_size$[rbp]
  00046	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004d	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEBAHH@Z ; ImVector<ImGuiTableColumnSortSpecs>::_grow_capacity
  00052	8b d0		 mov	 edx, eax
  00054	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005b	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z ; ImVector<ImGuiTableColumnSortSpecs>::reserve
$LN2@resize:
  00060	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00067	8b 8d e8 00 00
	00		 mov	 ecx, DWORD PTR new_size$[rbp]
  0006d	89 08		 mov	 DWORD PTR [rax], ecx
  0006f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00076	5f		 pop	 rdi
  00077	5d		 pop	 rbp
  00078	c3		 ret	 0
?resize@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXH@Z ENDP ; ImVector<ImGuiTableColumnSortSpecs>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEBAHH@Z
_TEXT	SEGMENT
new_capacity$ = 4
tv72 = 212
tv70 = 212
this$ = 256
sz$ = 264
?_grow_capacity@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEBAHH@Z PROC ; ImVector<ImGuiTableColumnSortSpecs>::_grow_capacity, COMDAT

; 1799 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 8b fc	 mov	 rdi, rsp
  00018	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00037	74 21		 je	 SHORT $LN3@grow_capac
  00039	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00043	99		 cdq
  00044	2b c2		 sub	 eax, edx
  00046	d1 f8		 sar	 eax, 1
  00048	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004f	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00052	89 85 d4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00058	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0005a	c7 85 d4 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv70[rbp], 8
$LN4@grow_capac:
  00064	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  0006a	89 45 04	 mov	 DWORD PTR new_capacity$[rbp], eax
  0006d	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00073	39 45 04	 cmp	 DWORD PTR new_capacity$[rbp], eax
  00076	7e 0b		 jle	 SHORT $LN5@grow_capac
  00078	8b 45 04	 mov	 eax, DWORD PTR new_capacity$[rbp]
  0007b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00081	eb 0c		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00083	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00089	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
$LN6@grow_capac:
  0008f	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  00095	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0009c	5f		 pop	 rdi
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
?_grow_capacity@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEBAHH@Z ENDP ; ImVector<ImGuiTableColumnSortSpecs>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ PROC ; ImVector<ImGuiTableColumnSortSpecs>::clear, COMDAT

; 1777 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00036	74 3a		 je	 SHORT $LN2@clear
  00038	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00046	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00053	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0005e	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
  00063	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN2@clear:
  00072	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00079	5f		 pop	 rdi
  0007a	5d		 pop	 rbp
  0007b	c3		 ret	 0
?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ ENDP ; ImVector<ImGuiTableColumnSortSpecs>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ PROC ; ImVector<ImGuiTableColumnSortSpecs>::~ImVector<ImGuiTableColumnSortSpecs>, COMDAT

; 1775 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002a	48 c7 85 c8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T1[rbp], -2
  00035	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00041	74 11		 je	 SHORT $LN2@ImVector
  00043	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0004e	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
  00053	90		 npad	 1
$LN2@ImVector:
  00054	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0005b	5f		 pop	 rdi
  0005c	5d		 pop	 rbp
  0005d	c3		 ret	 0
??1?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ ENDP ; ImVector<ImGuiTableColumnSortSpecs>::~ImVector<ImGuiTableColumnSortSpecs>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ PROC ; ImVector<ImGuiTableColumnSortSpecs>::ImVector<ImGuiTableColumnSortSpecs>, COMDAT

; 1772 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00036	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00043	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00060	5f		 pop	 rdi
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
??0?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAA@XZ ENDP ; ImVector<ImGuiTableColumnSortSpecs>::ImVector<ImGuiTableColumnSortSpecs>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiTableInstanceData@@@@QEAAXAEBUImGuiTableInstanceData@@@Z
_TEXT	SEGMENT
this$ = 224
v$ = 232
?push_back@?$ImVector@UImGuiTableInstanceData@@@@QEAAXAEBUImGuiTableInstanceData@@@Z PROC ; ImVector<ImGuiTableInstanceData>::push_back, COMDAT

; 1807 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003d	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00040	39 08		 cmp	 DWORD PTR [rax], ecx
  00042	75 27		 jne	 SHORT $LN2@push_back
  00044	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004b	8b 00		 mov	 eax, DWORD PTR [rax]
  0004d	ff c0		 inc	 eax
  0004f	8b d0		 mov	 edx, eax
  00051	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00058	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiTableInstanceData@@@@QEBAHH@Z ; ImVector<ImGuiTableInstanceData>::_grow_capacity
  0005d	8b d0		 mov	 edx, eax
  0005f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00066	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiTableInstanceData@@@@QEAAXH@Z ; ImVector<ImGuiTableInstanceData>::reserve
$LN2@push_back:
  0006b	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00072	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00075	48 6b c0 0c	 imul	 rax, rax, 12
  00079	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00080	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00084	41 b8 0c 00 00
	00		 mov	 r8d, 12
  0008a	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  00091	48 8b c8	 mov	 rcx, rax
  00094	e8 00 00 00 00	 call	 memcpy
  00099	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a0	8b 00		 mov	 eax, DWORD PTR [rax]
  000a2	ff c0		 inc	 eax
  000a4	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000ab	89 01		 mov	 DWORD PTR [rcx], eax
  000ad	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000b4	5f		 pop	 rdi
  000b5	5d		 pop	 rbp
  000b6	c3		 ret	 0
?push_back@?$ImVector@UImGuiTableInstanceData@@@@QEAAXAEBUImGuiTableInstanceData@@@Z ENDP ; ImVector<ImGuiTableInstanceData>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiTableInstanceData@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 8
this$ = 256
new_capacity$ = 264
?reserve@?$ImVector@UImGuiTableInstanceData@@@@QEAAXH@Z PROC ; ImVector<ImGuiTableInstanceData>::reserve, COMDAT

; 1803 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 08 01 00
	00		 cmp	 DWORD PTR new_capacity$[rbp], eax
  0003e	7f 02		 jg	 SHORT $LN2@reserve
  00040	eb 79		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  00042	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR new_capacity$[rbp]
  00049	48 6b c0 0c	 imul	 rax, rax, 12
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  00055	48 89 45 08	 mov	 QWORD PTR new_data$[rbp], rax
  00059	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00060	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00065	74 35		 je	 SHORT $LN3@reserve
  00067	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006e	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00071	48 6b c0 0c	 imul	 rax, rax, 12
  00075	4c 8b c0	 mov	 r8, rax
  00078	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00083	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  00087	e8 00 00 00 00	 call	 memcpy
  0008c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00093	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00097	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN3@reserve:
  0009c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a3	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  000a7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000ab	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b2	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_capacity$[rbp]
  000b8	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN1@reserve:
  000bb	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	c3		 ret	 0
?reserve@?$ImVector@UImGuiTableInstanceData@@@@QEAAXH@Z ENDP ; ImVector<ImGuiTableInstanceData>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiTableInstanceData@@@@QEBAHH@Z
_TEXT	SEGMENT
new_capacity$ = 4
tv72 = 212
tv70 = 212
this$ = 256
sz$ = 264
?_grow_capacity@?$ImVector@UImGuiTableInstanceData@@@@QEBAHH@Z PROC ; ImVector<ImGuiTableInstanceData>::_grow_capacity, COMDAT

; 1799 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 8b fc	 mov	 rdi, rsp
  00018	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00037	74 21		 je	 SHORT $LN3@grow_capac
  00039	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00043	99		 cdq
  00044	2b c2		 sub	 eax, edx
  00046	d1 f8		 sar	 eax, 1
  00048	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004f	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00052	89 85 d4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00058	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0005a	c7 85 d4 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv70[rbp], 8
$LN4@grow_capac:
  00064	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  0006a	89 45 04	 mov	 DWORD PTR new_capacity$[rbp], eax
  0006d	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00073	39 45 04	 cmp	 DWORD PTR new_capacity$[rbp], eax
  00076	7e 0b		 jle	 SHORT $LN5@grow_capac
  00078	8b 45 04	 mov	 eax, DWORD PTR new_capacity$[rbp]
  0007b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00081	eb 0c		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00083	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00089	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
$LN6@grow_capac:
  0008f	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  00095	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0009c	5f		 pop	 rdi
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
?_grow_capacity@?$ImVector@UImGuiTableInstanceData@@@@QEBAHH@Z ENDP ; ImVector<ImGuiTableInstanceData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiTableInstanceData@@@@QEAAAEAUImGuiTableInstanceData@@H@Z
_TEXT	SEGMENT
this$ = 224
i$ = 232
??A?$ImVector@UImGuiTableInstanceData@@@@QEAAAEAUImGuiTableInstanceData@@H@Z PROC ; ImVector<ImGuiTableInstanceData>::operator[], COMDAT

; 1786 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  00035	7c 11		 jl	 SHORT $LN3@operator
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00048	41 b8 fa 06 00
	00		 mov	 r8d, 1786		; 000006faH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@operator:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0006b	48 6b c0 0c	 imul	 rax, rax, 12
  0006f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00076	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0007a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00081	5f		 pop	 rdi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
??A?$ImVector@UImGuiTableInstanceData@@@@QEAAAEAUImGuiTableInstanceData@@H@Z ENDP ; ImVector<ImGuiTableInstanceData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ PROC	; ImVector<ImGuiTableInstanceData>::~ImVector<ImGuiTableInstanceData>, COMDAT

; 1775 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002a	48 c7 85 c8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T1[rbp], -2
  00035	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00041	74 11		 je	 SHORT $LN2@ImVector
  00043	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0004e	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
  00053	90		 npad	 1
$LN2@ImVector:
  00054	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0005b	5f		 pop	 rdi
  0005c	5d		 pop	 rbp
  0005d	c3		 ret	 0
??1?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ ENDP	; ImVector<ImGuiTableInstanceData>::~ImVector<ImGuiTableInstanceData>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ PROC	; ImVector<ImGuiTableInstanceData>::ImVector<ImGuiTableInstanceData>, COMDAT

; 1772 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00036	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00043	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00060	5f		 pop	 rdi
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
??0?$ImVector@UImGuiTableInstanceData@@@@QEAA@XZ ENDP	; ImVector<ImGuiTableInstanceData>::ImVector<ImGuiTableInstanceData>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z
_TEXT	SEGMENT
p$ = 8
this$ = 256
i$ = 264
??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z PROC ; ImSpan<ImGuiTableCellData>::operator[], COMDAT

; 621  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  00035	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003f	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00043	48 89 45 08	 mov	 QWORD PTR p$[rbp], rax
  00047	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00051	48 39 45 08	 cmp	 QWORD PTR p$[rbp], rax
  00055	72 11		 jb	 SHORT $LN3@operator
  00057	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00062	48 39 45 08	 cmp	 QWORD PTR p$[rbp], rax
  00066	72 1c		 jb	 SHORT $LN4@operator
$LN3@operator:
  00068	41 b8 6d 02 00
	00		 mov	 r8d, 621		; 0000026dH
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@DHFOGPCD@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00082	33 c0		 xor	 eax, eax
$LN4@operator:
  00084	48 8b 45 08	 mov	 rax, QWORD PTR p$[rbp]
  00088	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0008f	5f		 pop	 rdi
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z ENDP ; ImSpan<ImGuiTableCellData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?set@?$ImSpan@UImGuiTableCellData@@@@QEAAXPEAUImGuiTableCellData@@0@Z
_TEXT	SEGMENT
this$ = 224
data$ = 232
data_end$ = 240
?set@?$ImSpan@UImGuiTableCellData@@@@QEAAXPEAUImGuiTableCellData@@0@Z PROC ; ImSpan<ImGuiTableCellData>::set, COMDAT

; 618  :     inline void         set(T* data, T* data_end)   { Data = data; DataEnd = data_end; }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 8b fc	 mov	 rdi, rsp
  0001e	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00032	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00039	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx
  00043	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR data_end$[rbp]
  00051	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00055	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005c	5f		 pop	 rdi
  0005d	5d		 pop	 rbp
  0005e	c3		 ret	 0
?set@?$ImSpan@UImGuiTableCellData@@@@QEAAXPEAUImGuiTableCellData@@0@Z ENDP ; ImSpan<ImGuiTableCellData>::set
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0?$ImSpan@UImGuiTableCellData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$ImSpan@UImGuiTableCellData@@@@QEAA@XZ PROC		; ImSpan<ImGuiTableCellData>::ImSpan<ImGuiTableCellData>, COMDAT

; 613  :     inline ImSpan()                                 { Data = DataEnd = NULL; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00045	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00053	5f		 pop	 rdi
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??0?$ImSpan@UImGuiTableCellData@@@@QEAA@XZ ENDP		; ImSpan<ImGuiTableCellData>::ImSpan<ImGuiTableCellData>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??A?$ImSpan@F@@QEAAAEAFH@Z
_TEXT	SEGMENT
p$ = 8
this$ = 256
i$ = 264
??A?$ImSpan@F@@QEAAAEAFH@Z PROC				; ImSpan<short>::operator[], COMDAT

; 621  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  00035	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003f	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00043	48 89 45 08	 mov	 QWORD PTR p$[rbp], rax
  00047	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00051	48 39 45 08	 cmp	 QWORD PTR p$[rbp], rax
  00055	72 11		 jb	 SHORT $LN3@operator
  00057	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00062	48 39 45 08	 cmp	 QWORD PTR p$[rbp], rax
  00066	72 1c		 jb	 SHORT $LN4@operator
$LN3@operator:
  00068	41 b8 6d 02 00
	00		 mov	 r8d, 621		; 0000026dH
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@DHFOGPCD@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00082	33 c0		 xor	 eax, eax
$LN4@operator:
  00084	48 8b 45 08	 mov	 rax, QWORD PTR p$[rbp]
  00088	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0008f	5f		 pop	 rdi
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
??A?$ImSpan@F@@QEAAAEAFH@Z ENDP				; ImSpan<short>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?set@?$ImSpan@F@@QEAAXPEAF0@Z
_TEXT	SEGMENT
this$ = 224
data$ = 232
data_end$ = 240
?set@?$ImSpan@F@@QEAAXPEAF0@Z PROC			; ImSpan<short>::set, COMDAT

; 618  :     inline void         set(T* data, T* data_end)   { Data = data; DataEnd = data_end; }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 8b fc	 mov	 rdi, rsp
  0001e	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00032	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00039	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx
  00043	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR data_end$[rbp]
  00051	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00055	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005c	5f		 pop	 rdi
  0005d	5d		 pop	 rbp
  0005e	c3		 ret	 0
?set@?$ImSpan@F@@QEAAXPEAF0@Z ENDP			; ImSpan<short>::set
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0?$ImSpan@F@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$ImSpan@F@@QEAA@XZ PROC				; ImSpan<short>::ImSpan<short>, COMDAT

; 613  :     inline ImSpan()                                 { Data = DataEnd = NULL; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00045	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00053	5f		 pop	 rdi
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??0?$ImSpan@F@@QEAA@XZ ENDP				; ImSpan<short>::ImSpan<short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?index_from_ptr@?$ImSpan@UImGuiTableColumn@@@@QEBAHPEBUImGuiTableColumn@@@Z
_TEXT	SEGMENT
off$ = 8
this$ = 256
it$ = 264
?index_from_ptr@?$ImSpan@UImGuiTableColumn@@@@QEBAHPEBUImGuiTableColumn@@@Z PROC ; ImSpan<ImGuiTableColumn>::index_from_ptr, COMDAT

; 630  :     inline int  index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < DataEnd); const ptrdiff_t off = it - Data; return (int)off; }

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 39 85 08 01
	00 00		 cmp	 QWORD PTR it$[rbp], rax
  00040	72 14		 jb	 SHORT $LN3@index_from
  00042	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00049	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004d	48 39 85 08 01
	00 00		 cmp	 QWORD PTR it$[rbp], rax
  00054	72 1c		 jb	 SHORT $LN4@index_from
$LN3@index_from:
  00056	41 b8 76 02 00
	00		 mov	 r8d, 630		; 00000276H
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@OANBFKML@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAt?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00070	33 c0		 xor	 eax, eax
$LN4@index_from:
  00072	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00079	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007c	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR it$[rbp]
  00083	48 2b c8	 sub	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	48 99		 cdq
  0008b	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00090	48 f7 f9	 idiv	 rcx
  00093	48 89 45 08	 mov	 QWORD PTR off$[rbp], rax
  00097	8b 45 08	 mov	 eax, DWORD PTR off$[rbp]
  0009a	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000a1	5f		 pop	 rdi
  000a2	5d		 pop	 rbp
  000a3	c3		 ret	 0
?index_from_ptr@?$ImSpan@UImGuiTableColumn@@@@QEBAHPEBUImGuiTableColumn@@@Z ENDP ; ImSpan<ImGuiTableColumn>::index_from_ptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z
_TEXT	SEGMENT
p$ = 8
this$ = 256
i$ = 264
??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z PROC ; ImSpan<ImGuiTableColumn>::operator[], COMDAT

; 622  :     inline const T&     operator[](int i) const     { const T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  00035	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00039	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00040	48 03 01	 add	 rax, QWORD PTR [rcx]
  00043	48 89 45 08	 mov	 QWORD PTR p$[rbp], rax
  00047	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00051	48 39 45 08	 cmp	 QWORD PTR p$[rbp], rax
  00055	72 11		 jb	 SHORT $LN3@operator
  00057	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00062	48 39 45 08	 cmp	 QWORD PTR p$[rbp], rax
  00066	72 1c		 jb	 SHORT $LN4@operator
$LN3@operator:
  00068	41 b8 6e 02 00
	00		 mov	 r8d, 622		; 0000026eH
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@DHFOGPCD@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00082	33 c0		 xor	 eax, eax
$LN4@operator:
  00084	48 8b 45 08	 mov	 rax, QWORD PTR p$[rbp]
  00088	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0008f	5f		 pop	 rdi
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z ENDP ; ImSpan<ImGuiTableColumn>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z
_TEXT	SEGMENT
p$ = 8
this$ = 256
i$ = 264
??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z PROC ; ImSpan<ImGuiTableColumn>::operator[], COMDAT

; 621  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  00035	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00039	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00040	48 03 01	 add	 rax, QWORD PTR [rcx]
  00043	48 89 45 08	 mov	 QWORD PTR p$[rbp], rax
  00047	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00051	48 39 45 08	 cmp	 QWORD PTR p$[rbp], rax
  00055	72 11		 jb	 SHORT $LN3@operator
  00057	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00062	48 39 45 08	 cmp	 QWORD PTR p$[rbp], rax
  00066	72 1c		 jb	 SHORT $LN4@operator
$LN3@operator:
  00068	41 b8 6d 02 00
	00		 mov	 r8d, 621		; 0000026dH
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@DHFOGPCD@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAD?$AAa?$AAt?$AAa?$AAE?$AAn?$AAd?$AA?$AA@
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00082	33 c0		 xor	 eax, eax
$LN4@operator:
  00084	48 8b 45 08	 mov	 rax, QWORD PTR p$[rbp]
  00088	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0008f	5f		 pop	 rdi
  00090	5d		 pop	 rbp
  00091	c3		 ret	 0
??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ENDP ; ImSpan<ImGuiTableColumn>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?size@?$ImSpan@UImGuiTableColumn@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 224
?size@?$ImSpan@UImGuiTableColumn@@@@QEBAHXZ PROC	; ImSpan<ImGuiTableColumn>::size, COMDAT

; 619  :     inline int          size() const                { return (int)(ptrdiff_t)(DataEnd - Data); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00036	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00039	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003d	48 2b c1	 sub	 rax, rcx
  00040	48 99		 cdq
  00042	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00047	48 f7 f9	 idiv	 rcx
  0004a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00051	5f		 pop	 rdi
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
?size@?$ImSpan@UImGuiTableColumn@@@@QEBAHXZ ENDP	; ImSpan<ImGuiTableColumn>::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?set@?$ImSpan@UImGuiTableColumn@@@@QEAAXPEAUImGuiTableColumn@@0@Z
_TEXT	SEGMENT
this$ = 224
data$ = 232
data_end$ = 240
?set@?$ImSpan@UImGuiTableColumn@@@@QEAAXPEAUImGuiTableColumn@@0@Z PROC ; ImSpan<ImGuiTableColumn>::set, COMDAT

; 618  :     inline void         set(T* data, T* data_end)   { Data = data; DataEnd = data_end; }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 8b fc	 mov	 rdi, rsp
  0001e	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00032	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00039	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx
  00043	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR data_end$[rbp]
  00051	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00055	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005c	5f		 pop	 rdi
  0005d	5d		 pop	 rbp
  0005e	c3		 ret	 0
?set@?$ImSpan@UImGuiTableColumn@@@@QEAAXPEAUImGuiTableColumn@@0@Z ENDP ; ImSpan<ImGuiTableColumn>::set
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0?$ImSpan@UImGuiTableColumn@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$ImSpan@UImGuiTableColumn@@@@QEAA@XZ PROC		; ImSpan<ImGuiTableColumn>::ImSpan<ImGuiTableColumn>, COMDAT

; 613  :     inline ImSpan()                                 { Data = DataEnd = NULL; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00045	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00053	5f		 pop	 rdi
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??0?$ImSpan@UImGuiTableColumn@@@@QEAA@XZ ENDP		; ImSpan<ImGuiTableColumn>::ImSpan<ImGuiTableColumn>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTableInstanceData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0ImGuiTableInstanceData@@QEAA@XZ PROC			; ImGuiTableInstanceData::ImGuiTableInstanceData, COMDAT

; 2524 :     ImGuiTableInstanceData()    { LastOuterHeight = LastFirstRowHeight = LastFrozenHeight = 0.0f; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	0f 57 c0	 xorps	 xmm0, xmm0
  00032	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	0f 57 c0	 xorps	 xmm0, xmm0
  00041	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
  00046	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004d	0f 57 c0	 xorps	 xmm0, xmm0
  00050	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00054	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005b	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00062	5f		 pop	 rdi
  00063	5d		 pop	 rbp
  00064	c3		 ret	 0
??0ImGuiTableInstanceData@@QEAA@XZ ENDP			; ImGuiTableInstanceData::ImGuiTableInstanceData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTableColumn@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0ImGuiTableColumn@@QEAA@XZ PROC			; ImGuiTableColumn::ImGuiTableColumn, COMDAT

; 2496 :     ImGuiTableColumn()

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]

; 2497 :     {

  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 83 c0 20	 add	 rax, 32			; 00000020H
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect

; 2498 :         memset(this, 0, sizeof(*this));

  0003d	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  00043	33 d2		 xor	 edx, edx
  00045	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004c	e8 00 00 00 00	 call	 memset

; 2499 :         StretchWeight = WidthRequest = -1.0f;

  00051	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00058	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00060	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
  00065	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00074	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0

; 2500 :         NameOffset = -1;

  00079	b8 ff ff ff ff	 mov	 eax, -1
  0007e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00085	66 89 41 50	 mov	 WORD PTR [rcx+80], ax

; 2501 :         DisplayOrder = IndexWithinEnabledSet = -1;

  00089	b8 ff ff ff ff	 mov	 eax, -1
  0008e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00095	66 89 41 54	 mov	 WORD PTR [rcx+84], ax
  00099	b8 ff ff ff ff	 mov	 eax, -1
  0009e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a5	66 89 41 52	 mov	 WORD PTR [rcx+82], ax

; 2502 :         PrevEnabledColumn = NextEnabledColumn = -1;

  000a9	b8 ff ff ff ff	 mov	 eax, -1
  000ae	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000b5	66 89 41 58	 mov	 WORD PTR [rcx+88], ax
  000b9	b8 ff ff ff ff	 mov	 eax, -1
  000be	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c5	66 89 41 56	 mov	 WORD PTR [rcx+86], ax

; 2503 :         SortOrder = -1;

  000c9	b8 ff ff ff ff	 mov	 eax, -1
  000ce	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d5	66 89 41 5a	 mov	 WORD PTR [rcx+90], ax

; 2504 :         SortDirection = ImGuiSortDirection_None;

  000d9	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000e0	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  000e4	24 fc		 and	 al, 252			; 000000fcH
  000e6	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000ed	88 41 6d	 mov	 BYTE PTR [rcx+109], al

; 2505 :         DrawChannelCurrent = DrawChannelFrozen = DrawChannelUnfrozen = (ImU8)-1;

  000f0	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000f5	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fc	66 89 41 60	 mov	 WORD PTR [rcx+96], ax
  00100	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00105	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0010c	66 89 41 5e	 mov	 WORD PTR [rcx+94], ax
  00110	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00115	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011c	66 89 41 5c	 mov	 WORD PTR [rcx+92], ax

; 2506 :     }

  00120	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00127	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0012e	5f		 pop	 rdi
  0012f	5d		 pop	 rbp
  00130	c3		 ret	 0
??0ImGuiTableColumn@@QEAA@XZ ENDP			; ImGuiTableColumn::ImGuiTableColumn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ
_TEXT	SEGMENT
this$ = 224
__$ReturnUdt$ = 232
?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ PROC		; ImGuiWindow::Rect, COMDAT

; 2352 :     ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR [rsp+280]
  0002f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003d	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  00042	f3 0f 58 41 24	 addss	 xmm0, DWORD PTR [rcx+36]
  00047	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [rax+24]
  0005a	f3 0f 58 49 20	 addss	 xmm1, DWORD PTR [rcx+32]
  0005f	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00065	0f 28 d9	 movaps	 xmm3, xmm1
  00068	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006f	f3 0f 10 50 1c	 movss	 xmm2, DWORD PTR [rax+28]
  00074	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007b	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [rax+24]
  00080	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00087	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@MMMM@Z	; ImRect::ImRect
  0008c	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00093	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0009a	5f		 pop	 rdi
  0009b	5d		 pop	 rbp
  0009c	c3		 ret	 0
?Rect@ImGuiWindow@@QEBA?AUImRect@@XZ ENDP		; ImGuiWindow::Rect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z
_TEXT	SEGMENT
this$ = 224
v$ = 232
?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z PROC ; ImVector<ImGuiOldColumns>::push_back, COMDAT

; 1807 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003d	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00040	39 08		 cmp	 DWORD PTR [rax], ecx
  00042	75 27		 jne	 SHORT $LN2@push_back
  00044	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004b	8b 00		 mov	 eax, DWORD PTR [rax]
  0004d	ff c0		 inc	 eax
  0004f	8b d0		 mov	 edx, eax
  00051	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00058	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z ; ImVector<ImGuiOldColumns>::_grow_capacity
  0005d	8b d0		 mov	 edx, eax
  0005f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00066	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z ; ImVector<ImGuiOldColumns>::reserve
$LN2@push_back:
  0006b	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00072	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00075	48 69 c0 88 00
	00 00		 imul	 rax, rax, 136		; 00000088H
  0007c	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00083	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00087	41 b8 88 00 00
	00		 mov	 r8d, 136		; 00000088H
  0008d	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	e8 00 00 00 00	 call	 memcpy
  0009c	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a3	8b 00		 mov	 eax, DWORD PTR [rax]
  000a5	ff c0		 inc	 eax
  000a7	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000ae	89 01		 mov	 DWORD PTR [rcx], eax
  000b0	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000b7	5f		 pop	 rdi
  000b8	5d		 pop	 rbp
  000b9	c3		 ret	 0
?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z ENDP ; ImVector<ImGuiOldColumns>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 8
this$ = 256
new_capacity$ = 264
?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z PROC	; ImVector<ImGuiOldColumns>::reserve, COMDAT

; 1803 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 08 01 00
	00		 cmp	 DWORD PTR new_capacity$[rbp], eax
  0003e	7f 02		 jg	 SHORT $LN2@reserve
  00040	eb 7f		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  00042	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR new_capacity$[rbp]
  00049	48 69 c0 88 00
	00 00		 imul	 rax, rax, 136		; 00000088H
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  00058	48 89 45 08	 mov	 QWORD PTR new_data$[rbp], rax
  0005c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00063	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00068	74 38		 je	 SHORT $LN3@reserve
  0006a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00071	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00074	48 69 c0 88 00
	00 00		 imul	 rax, rax, 136		; 00000088H
  0007b	4c 8b c0	 mov	 r8, rax
  0007e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00085	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00089	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  0008d	e8 00 00 00 00	 call	 memcpy
  00092	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00099	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0009d	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN3@reserve:
  000a2	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a9	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  000ad	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000b1	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b8	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_capacity$[rbp]
  000be	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN1@reserve:
  000c1	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000c8	5f		 pop	 rdi
  000c9	5d		 pop	 rbp
  000ca	c3		 ret	 0
?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z ENDP	; ImVector<ImGuiOldColumns>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z
_TEXT	SEGMENT
new_capacity$ = 4
tv72 = 212
tv70 = 212
this$ = 256
sz$ = 264
?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z PROC ; ImVector<ImGuiOldColumns>::_grow_capacity, COMDAT

; 1799 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 8b fc	 mov	 rdi, rsp
  00018	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00037	74 21		 je	 SHORT $LN3@grow_capac
  00039	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00043	99		 cdq
  00044	2b c2		 sub	 eax, edx
  00046	d1 f8		 sar	 eax, 1
  00048	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004f	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00052	89 85 d4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00058	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0005a	c7 85 d4 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv70[rbp], 8
$LN4@grow_capac:
  00064	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  0006a	89 45 04	 mov	 DWORD PTR new_capacity$[rbp], eax
  0006d	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00073	39 45 04	 cmp	 DWORD PTR new_capacity$[rbp], eax
  00076	7e 0b		 jle	 SHORT $LN5@grow_capac
  00078	8b 45 04	 mov	 eax, DWORD PTR new_capacity$[rbp]
  0007b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00081	eb 0c		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00083	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00089	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
$LN6@grow_capac:
  0008f	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  00095	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0009c	5f		 pop	 rdi
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z ENDP ; ImVector<ImGuiOldColumns>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ
_TEXT	SEGMENT
this$ = 224
?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ PROC ; ImVector<ImGuiOldColumns>::back, COMDAT

; 1795 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	83 38 00	 cmp	 DWORD PTR [rax], 0
  00034	7f 1c		 jg	 SHORT $LN3@back
  00036	41 b8 03 07 00
	00		 mov	 r8d, 1795		; 00000703H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN3@back:
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	8b 00		 mov	 eax, DWORD PTR [rax]
  0005b	ff c8		 dec	 eax
  0005d	48 98		 cdqe
  0005f	48 69 c0 88 00
	00 00		 imul	 rax, rax, 136		; 00000088H
  00066	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006d	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00071	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00078	5f		 pop	 rdi
  00079	5d		 pop	 rbp
  0007a	c3		 ret	 0
?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ ENDP ; ImVector<ImGuiOldColumns>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@H@Z
_TEXT	SEGMENT
this$ = 224
i$ = 232
??A?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@H@Z PROC ; ImVector<ImGuiOldColumns>::operator[], COMDAT

; 1786 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  00035	7c 11		 jl	 SHORT $LN3@operator
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00048	41 b8 fa 06 00
	00		 mov	 r8d, 1786		; 000006faH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@operator:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0006b	48 69 c0 88 00
	00 00		 imul	 rax, rax, 136		; 00000088H
  00072	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00079	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0007d	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00084	5f		 pop	 rdi
  00085	5d		 pop	 rbp
  00086	c3		 ret	 0
??A?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@H@Z ENDP ; ImVector<ImGuiOldColumns>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ PROC	; ImChunkStream<ImGuiTableSettings>::~ImChunkStream<ImGuiTableSettings>, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ??1?$ImVector@D@@QEAA@XZ ; ImVector<char>::~ImVector<char>
  00039	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00040	5f		 pop	 rdi
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ ENDP	; ImChunkStream<ImGuiTableSettings>::~ImChunkStream<ImGuiTableSettings>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ PROC	; ImChunkStream<ImGuiTableSettings>::ImChunkStream<ImGuiTableSettings>, COMDAT
$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ??0?$ImVector@D@@QEAA@XZ ; ImVector<char>::ImVector<char>
  00039	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00047	5f		 pop	 rdi
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??0?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ ENDP	; ImChunkStream<ImGuiTableSettings>::ImChunkStream<ImGuiTableSettings>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z
_TEXT	SEGMENT
this$ = 224
rhs$ = 232
?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z PROC ; ImChunkStream<ImGuiTableSettings>::swap, COMDAT

; 711  :     void    swap(ImChunkStream<T>& rhs) { rhs.Buf.swap(Buf); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR rhs$[rbp]
  0003d	48 8b d0	 mov	 rdx, rax
  00040	e8 00 00 00 00	 call	 ?swap@?$ImVector@D@@QEAAXAEAU1@@Z ; ImVector<char>::swap
  00045	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004c	5f		 pop	 rdi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z ENDP ; ImChunkStream<ImGuiTableSettings>::swap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ptr_from_offset@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@H@Z
_TEXT	SEGMENT
this$ = 224
off$ = 232
?ptr_from_offset@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@H@Z PROC ; ImChunkStream<ImGuiTableSettings>::ptr_from_offset, COMDAT

; 710  :     T*      ptr_from_offset(int off)    { IM_ASSERT(off >= 4 && off < Buf.Size); return (T*)(void*)(Buf.Data + off); }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 04		 cmp	 DWORD PTR off$[rbp], 4
  00035	7c 11		 jl	 SHORT $LN3@ptr_from_o
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR off$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@ptr_from_o
$LN3@ptr_from_o:
  00048	41 b8 c6 02 00
	00		 mov	 r8d, 710		; 000002c6H
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@EPOMENA@?$AAo?$AAf?$AAf?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA4?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAf?$AAf?$AA?5?$AA?$DM?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@ptr_from_o:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR off$[rbp]
  0006b	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00072	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00076	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0007d	5f		 pop	 rdi
  0007e	5d		 pop	 rbp
  0007f	c3		 ret	 0
?ptr_from_offset@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@H@Z ENDP ; ImChunkStream<ImGuiTableSettings>::ptr_from_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?offset_from_ptr@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z
_TEXT	SEGMENT
off$ = 8
this$ = 256
p$ = 264
?offset_from_ptr@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z PROC ; ImChunkStream<ImGuiTableSettings>::offset_from_ptr, COMDAT

; 709  :     int     offset_from_ptr(const T* p) { IM_ASSERT(p >= begin() && p < end()); const ptrdiff_t off = (const char*)p - Buf.Data; return (int)off; }

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00036	e8 00 00 00 00	 call	 ?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::begin
  0003b	48 39 85 08 01
	00 00		 cmp	 QWORD PTR p$[rbp], rax
  00042	72 15		 jb	 SHORT $LN3@offset_fro
  00044	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004b	e8 00 00 00 00	 call	 ?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::end
  00050	48 39 85 08 01
	00 00		 cmp	 QWORD PTR p$[rbp], rax
  00057	72 1c		 jb	 SHORT $LN4@offset_fro
$LN3@offset_fro:
  00059	41 b8 c5 02 00
	00		 mov	 r8d, 709		; 000002c5H
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@BDDBABLK@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAe?$AAg?$AAi?$AAn?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAe?$AAn?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00073	33 c0		 xor	 eax, eax
$LN4@offset_fro:
  00075	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00080	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  00087	48 2b c8	 sub	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 89 45 08	 mov	 QWORD PTR off$[rbp], rax
  00091	8b 45 08	 mov	 eax, DWORD PTR off$[rbp]
  00094	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0009b	5f		 pop	 rdi
  0009c	5d		 pop	 rbp
  0009d	c3		 ret	 0
?offset_from_ptr@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z ENDP ; ImChunkStream<ImGuiTableSettings>::offset_from_ptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ
_TEXT	SEGMENT
this$ = 224
?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ PROC ; ImChunkStream<ImGuiTableSettings>::end, COMDAT

; 708  :     T*      end()                       { return (T*)(void*)(Buf.Data + Buf.Size); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00032	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00039	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0003d	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00044	5f		 pop	 rdi
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ENDP ; ImChunkStream<ImGuiTableSettings>::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?chunk_size@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z
_TEXT	SEGMENT
this$ = 224
p$ = 232
?chunk_size@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z PROC ; ImChunkStream<ImGuiTableSettings>::chunk_size, COMDAT

; 707  :     int     chunk_size(const T* p)      { return ((const int*)p)[-1]; }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b ec	 mov	 rbp, rsp
  00016	48 8b fc	 mov	 rdi, rsp
  00019	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  0002d	b8 04 00 00 00	 mov	 eax, 4
  00032	48 6b c0 ff	 imul	 rax, rax, -1
  00036	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  0003d	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00040	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00047	5f		 pop	 rdi
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
?chunk_size@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z ENDP ; ImChunkStream<ImGuiTableSettings>::chunk_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z
_TEXT	SEGMENT
HDR_SZ$ = 8
this$ = 256
p$ = 264
?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z PROC ; ImChunkStream<ImGuiTableSettings>::next_chunk, COMDAT

; 706  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002f	48 c7 45 08 04
	00 00 00	 mov	 QWORD PTR HDR_SZ$[rbp], 4
  00037	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003e	e8 00 00 00 00	 call	 ?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::begin
  00043	48 39 85 08 01
	00 00		 cmp	 QWORD PTR p$[rbp], rax
  0004a	72 15		 jb	 SHORT $LN4@next_chunk
  0004c	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00053	e8 00 00 00 00	 call	 ?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::end
  00058	48 39 85 08 01
	00 00		 cmp	 QWORD PTR p$[rbp], rax
  0005f	72 1c		 jb	 SHORT $LN5@next_chunk
$LN4@next_chunk:
  00061	41 b8 c2 02 00
	00		 mov	 r8d, 706		; 000002c2H
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@BDDBABLK@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAb?$AAe?$AAg?$AAi?$AAn?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAe?$AAn?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007b	33 c0		 xor	 eax, eax
$LN5@next_chunk:
  0007d	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR p$[rbp]
  00084	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0008b	e8 00 00 00 00	 call	 ?chunk_size@?$ImChunkStream@UImGuiTableSettings@@@@QEAAHPEBUImGuiTableSettings@@@Z ; ImChunkStream<ImGuiTableSettings>::chunk_size
  00090	48 98		 cdqe
  00092	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  00099	48 03 c8	 add	 rcx, rax
  0009c	48 8b c1	 mov	 rax, rcx
  0009f	48 89 85 08 01
	00 00		 mov	 QWORD PTR p$[rbp], rax
  000a6	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000ad	e8 00 00 00 00	 call	 ?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::end
  000b2	48 03 45 08	 add	 rax, QWORD PTR HDR_SZ$[rbp]
  000b6	48 39 85 08 01
	00 00		 cmp	 QWORD PTR p$[rbp], rax
  000bd	75 04		 jne	 SHORT $LN2@next_chunk
  000bf	33 c0		 xor	 eax, eax
  000c1	eb 38		 jmp	 SHORT $LN1@next_chunk
$LN2@next_chunk:
  000c3	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000ca	e8 00 00 00 00	 call	 ?end@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ; ImChunkStream<ImGuiTableSettings>::end
  000cf	48 39 85 08 01
	00 00		 cmp	 QWORD PTR p$[rbp], rax
  000d6	72 1c		 jb	 SHORT $LN6@next_chunk
  000d8	41 b8 c2 02 00
	00		 mov	 r8d, 706		; 000002c2H
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@OEELIPPM@?$AAp?$AA?5?$AA?$DM?$AA?5?$AAe?$AAn?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f2	33 c0		 xor	 eax, eax
$LN6@next_chunk:
  000f4	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR p$[rbp]
$LN1@next_chunk:
  000fb	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00102	5f		 pop	 rdi
  00103	5d		 pop	 rbp
  00104	c3		 ret	 0
?next_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@PEAU2@@Z ENDP ; ImChunkStream<ImGuiTableSettings>::next_chunk
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ
_TEXT	SEGMENT
HDR_SZ$ = 8
this$ = 256
?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ PROC ; ImChunkStream<ImGuiTableSettings>::begin, COMDAT

; 705  :     T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  00028	48 c7 45 08 04
	00 00 00	 mov	 QWORD PTR HDR_SZ$[rbp], 4
  00030	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00037	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003c	75 04		 jne	 SHORT $LN2@begin
  0003e	33 c0		 xor	 eax, eax
  00040	eb 0f		 jmp	 SHORT $LN1@begin
$LN2@begin:
  00042	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00049	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004d	48 03 45 08	 add	 rax, QWORD PTR HDR_SZ$[rbp]
$LN1@begin:
  00051	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00058	5f		 pop	 rdi
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?begin@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@XZ ENDP ; ImChunkStream<ImGuiTableSettings>::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z
_TEXT	SEGMENT
HDR_SZ$ = 8
off$ = 36
this$ = 288
sz$ = 296
?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z PROC ; ImChunkStream<ImGuiTableSettings>::alloc_chunk, COMDAT

; 704  :     T*      alloc_chunk(size_t sz)      { size_t HDR_SZ = 4; sz = IM_MEMALIGN(HDR_SZ + sz, 4u); int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]
  0002f	48 c7 45 08 04
	00 00 00	 mov	 QWORD PTR HDR_SZ$[rbp], 4
  00037	48 8b 45 08	 mov	 rax, QWORD PTR HDR_SZ$[rbp]
  0003b	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR sz$[rbp]
  00042	48 8d 44 08 03	 lea	 rax, QWORD PTR [rax+rcx+3]
  00047	b9 fc ff ff ff	 mov	 ecx, -4			; fffffffcH
  0004c	48 23 c1	 and	 rax, rcx
  0004f	48 89 85 28 01
	00 00		 mov	 QWORD PTR sz$[rbp], rax
  00056	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005d	8b 00		 mov	 eax, DWORD PTR [rax]
  0005f	89 45 24	 mov	 DWORD PTR off$[rbp], eax
  00062	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00068	8b 4d 24	 mov	 ecx, DWORD PTR off$[rbp]
  0006b	03 c8		 add	 ecx, eax
  0006d	8b c1		 mov	 eax, ecx
  0006f	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00076	8b d0		 mov	 edx, eax
  00078	e8 00 00 00 00	 call	 ?resize@?$ImVector@D@@QEAAXH@Z ; ImVector<char>::resize
  0007d	48 63 45 24	 movsxd	 rax, DWORD PTR off$[rbp]
  00081	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00088	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0008c	b9 04 00 00 00	 mov	 ecx, 4
  00091	48 6b c9 00	 imul	 rcx, rcx, 0
  00095	8b 95 28 01 00
	00		 mov	 edx, DWORD PTR sz$[rbp]
  0009b	89 14 08	 mov	 DWORD PTR [rax+rcx], edx
  0009e	48 63 45 24	 movsxd	 rax, DWORD PTR off$[rbp]
  000a2	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 63 4d 08	 movsxd	 rcx, DWORD PTR HDR_SZ$[rbp]
  000b7	48 03 c1	 add	 rax, rcx
  000ba	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000c1	5f		 pop	 rdi
  000c2	5d		 pop	 rbp
  000c3	c3		 ret	 0
?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z ENDP ; ImChunkStream<ImGuiTableSettings>::alloc_chunk
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ PROC ; ImChunkStream<ImGuiTableSettings>::clear, COMDAT

; 701  :     void    clear()                     { Buf.clear(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ?clear@?$ImVector@D@@QEAAXXZ ; ImVector<char>::clear
  00039	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00040	5f		 pop	 rdi
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ ENDP ; ImChunkStream<ImGuiTableSettings>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?TryGetMapData@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z
_TEXT	SEGMENT
idx$ = 4
this$ = 256
n$ = 264
?TryGetMapData@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z PROC ; ImPool<ImGuiTable>::TryGetMapData, COMDAT

; 685  :     T*          TryGetMapData(ImPoolIdx n)          { int idx = Map.Data[n].val_i; if (idx == -1) return NULL; return GetByIndex(idx); }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	48 83 c0 10	 add	 rax, 16
  00039	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiStoragePair@ImGuiStorage@@@@QEAAAEAUImGuiStoragePair@ImGuiStorage@@H@Z ; ImVector<ImGuiStorage::ImGuiStoragePair>::operator[]
  00047	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004a	89 45 04	 mov	 DWORD PTR idx$[rbp], eax
  0004d	83 7d 04 ff	 cmp	 DWORD PTR idx$[rbp], -1
  00051	75 04		 jne	 SHORT $LN2@TryGetMapD
  00053	33 c0		 xor	 eax, eax
  00055	eb 0f		 jmp	 SHORT $LN1@TryGetMapD
$LN2@TryGetMapD:
  00057	8b 55 04	 mov	 edx, DWORD PTR idx$[rbp]
  0005a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00061	e8 00 00 00 00	 call	 ?GetByIndex@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z ; ImPool<ImGuiTable>::GetByIndex
$LN1@TryGetMapD:
  00066	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0006d	5f		 pop	 rdi
  0006e	5d		 pop	 rbp
  0006f	c3		 ret	 0
?TryGetMapData@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z ENDP ; ImPool<ImGuiTable>::TryGetMapData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetMapSize@?$ImPool@UImGuiTable@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 224
?GetMapSize@?$ImPool@UImGuiTable@@@@QEBAHXZ PROC	; ImPool<ImGuiTable>::GetMapSize, COMDAT

; 684  :     int         GetMapSize() const                  { return Map.Data.Size; }   // It is the map we need iterate to find valid items, since we don't have "alive" storage anywhere

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00032	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00039	5f		 pop	 rdi
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
?GetMapSize@?$ImPool@UImGuiTable@@@@QEBAHXZ ENDP	; ImPool<ImGuiTable>::GetMapSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?Remove@?$ImPool@UImGuiTable@@@@QEAAXIH@Z
_TEXT	SEGMENT
this$ = 224
key$ = 232
idx$ = 240
?Remove@?$ImPool@UImGuiTable@@@@QEAAXIH@Z PROC		; ImPool<ImGuiTable>::Remove, COMDAT

; 677  :     void        Remove(ImGuiID key, ImPoolIdx idx)  { Buf[idx].~T(); *(int*)&Buf[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); AliveCount--; }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  00033	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003a	8b 95 f0 00 00
	00		 mov	 edx, DWORD PTR idx$[rbp]
  00040	48 8b c8	 mov	 rcx, rax
  00043	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z ; ImVector<ImGuiTable>::operator[]
  00048	33 d2		 xor	 edx, edx
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 ??_GImGuiTable@@QEAAPEAXI@Z
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	8b 95 f0 00 00
	00		 mov	 edx, DWORD PTR idx$[rbp]
  0005f	48 8b c8	 mov	 rcx, rax
  00062	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z ; ImVector<ImGuiTable>::operator[]
  00067	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006e	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00071	89 08		 mov	 DWORD PTR [rax], ecx
  00073	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007a	8b 8d f0 00 00
	00		 mov	 ecx, DWORD PTR idx$[rbp]
  00080	89 48 20	 mov	 DWORD PTR [rax+32], ecx
  00083	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008a	48 83 c0 10	 add	 rax, 16
  0008e	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00094	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR key$[rbp]
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 ?SetInt@ImGuiStorage@@QEAAXIH@Z ; ImGuiStorage::SetInt
  000a2	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a9	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000ac	ff c8		 dec	 eax
  000ae	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000b5	89 41 24	 mov	 DWORD PTR [rcx+36], eax
  000b8	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000bf	5f		 pop	 rdi
  000c0	5d		 pop	 rbp
  000c1	c3		 ret	 0
?Remove@?$ImPool@UImGuiTable@@@@QEAAXIH@Z ENDP		; ImPool<ImGuiTable>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?Remove@?$ImPool@UImGuiTable@@@@QEAAXIPEBUImGuiTable@@@Z
_TEXT	SEGMENT
this$ = 224
key$ = 232
p$ = 240
?Remove@?$ImPool@UImGuiTable@@@@QEAAXIPEBUImGuiTable@@@Z PROC ; ImPool<ImGuiTable>::Remove, COMDAT

; 676  :     void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  00033	48 8b 95 f0 00
	00 00		 mov	 rdx, QWORD PTR p$[rbp]
  0003a	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00041	e8 00 00 00 00	 call	 ?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z ; ImPool<ImGuiTable>::GetIndex
  00046	44 8b c0	 mov	 r8d, eax
  00049	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR key$[rbp]
  0004f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00056	e8 00 00 00 00	 call	 ?Remove@?$ImPool@UImGuiTable@@@@QEAAXIH@Z ; ImPool<ImGuiTable>::Remove
  0005b	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00062	5f		 pop	 rdi
  00063	5d		 pop	 rbp
  00064	c3		 ret	 0
?Remove@?$ImPool@UImGuiTable@@@@QEAAXIPEBUImGuiTable@@@Z ENDP ; ImPool<ImGuiTable>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ
_TEXT	SEGMENT
idx$ = 4
$T1 = 232
$T2 = 264
$T3 = 296
$T4 = 328
$T5 = 356
$T6 = 392
tv133 = 408
this$ = 448
?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ PROC ; ImPool<ImGuiTable>::Add, COMDAT

; 675  :     T*          Add()                               { int idx = FreeIdx; if (idx == Buf.Size) { Buf.resize(Buf.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Buf[idx]; } IM_PLACEMENT_NEW(&Buf[idx]) T(); AliveCount++; return &Buf[idx]; }

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 72 00 00 00	 mov	 ecx, 114		; 00000072H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+488]
  0002a	48 c7 85 88 01
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T6[rbp], -2
  00035	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0003f	89 45 04	 mov	 DWORD PTR idx$[rbp], eax
  00042	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00049	8b 00		 mov	 eax, DWORD PTR [rax]
  0004b	39 45 04	 cmp	 DWORD PTR idx$[rbp], eax
  0004e	75 31		 jne	 SHORT $LN2@Add
  00050	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00057	8b 00		 mov	 eax, DWORD PTR [rax]
  00059	ff c0		 inc	 eax
  0005b	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00062	8b d0		 mov	 edx, eax
  00064	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImGuiTable@@@@QEAAXH@Z ; ImVector<ImGuiTable>::resize
  00069	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00070	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00073	ff c0		 inc	 eax
  00075	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007c	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  0007f	eb 1e		 jmp	 SHORT $LN3@Add
$LN2@Add:
  00081	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00088	8b 55 04	 mov	 edx, DWORD PTR idx$[rbp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z ; ImVector<ImGuiTable>::operator[]
  00093	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009a	8b 00		 mov	 eax, DWORD PTR [rax]
  0009c	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN3@Add:
  0009f	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a6	8b 55 04	 mov	 edx, DWORD PTR idx$[rbp]
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z ; ImVector<ImGuiTable>::operator[]
  000b1	48 89 85 28 01
	00 00		 mov	 QWORD PTR $T3[rbp], rax
  000b8	48 8d 85 64 01
	00 00		 lea	 rax, QWORD PTR $T5[rbp]
  000bf	48 89 85 48 01
	00 00		 mov	 QWORD PTR $T4[rbp], rax
  000c6	4c 8b 85 28 01
	00 00		 mov	 r8, QWORD PTR $T3[rbp]
  000cd	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR $T4[rbp]
  000d4	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000d7	b9 38 02 00 00	 mov	 ecx, 568		; 00000238H
  000dc	e8 00 00 00 00	 call	 ??2@YAPEAX_KUImNewWrapper@@PEAX@Z ; operator new
  000e1	48 89 85 08 01
	00 00		 mov	 QWORD PTR $T2[rbp], rax
  000e8	48 83 bd 08 01
	00 00 00	 cmp	 QWORD PTR $T2[rbp], 0
  000f0	74 15		 je	 SHORT $LN5@Add
  000f2	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR $T2[rbp]
  000f9	e8 00 00 00 00	 call	 ??0ImGuiTable@@QEAA@XZ	; ImGuiTable::ImGuiTable
  000fe	48 89 85 98 01
	00 00		 mov	 QWORD PTR tv133[rbp], rax
  00105	eb 0b		 jmp	 SHORT $LN6@Add
$LN5@Add:
  00107	48 c7 85 98 01
	00 00 00 00 00
	00		 mov	 QWORD PTR tv133[rbp], 0
$LN6@Add:
  00112	48 8b 85 98 01
	00 00		 mov	 rax, QWORD PTR tv133[rbp]
  00119	48 89 85 e8 00
	00 00		 mov	 QWORD PTR $T1[rbp], rax
  00120	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00127	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0012a	ff c0		 inc	 eax
  0012c	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00133	89 41 24	 mov	 DWORD PTR [rcx+36], eax
  00136	48 8b 85 c0 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0013d	8b 55 04	 mov	 edx, DWORD PTR idx$[rbp]
  00140	48 8b c8	 mov	 rcx, rax
  00143	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z ; ImVector<ImGuiTable>::operator[]
  00148	48 8d a5 a8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+424]
  0014f	5f		 pop	 rdi
  00150	5d		 pop	 rbp
  00151	c3		 ret	 0
?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ ENDP ; ImPool<ImGuiTable>::Add
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
idx$ = 4
$T1 = 232
$T2 = 264
$T3 = 296
$T4 = 328
$T5 = 356
$T6 = 392
tv133 = 408
this$ = 448
?dtor$0@?0??Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ@4HA PROC ; `ImPool<ImGuiTable>::Add'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	4c 8b 85 28 01
	00 00		 mov	 r8, QWORD PTR $T3[rbp]
  0001b	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR $T4[rbp]
  00022	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00025	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR $T2[rbp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAXUImNewWrapper@@0@Z ; operator delete
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?dtor$0@?0??Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ@4HA ENDP ; `ImPool<ImGuiTable>::Add'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
idx$ = 4
$T1 = 232
$T2 = 264
$T3 = 296
$T4 = 328
$T5 = 356
$T6 = 392
tv133 = 408
this$ = 448
?dtor$0@?0??Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ@4HA PROC ; `ImPool<ImGuiTable>::Add'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	4c 8b 85 28 01
	00 00		 mov	 r8, QWORD PTR $T3[rbp]
  0001b	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR $T4[rbp]
  00022	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00025	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR $T2[rbp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAXUImNewWrapper@@0@Z ; operator delete
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
?dtor$0@?0??Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ@4HA ENDP ; `ImPool<ImGuiTable>::Add'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetOrAddByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z
_TEXT	SEGMENT
p_idx$ = 8
this$ = 256
key$ = 264
?GetOrAddByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z PROC ; ImPool<ImGuiTable>::GetOrAddByKey, COMDAT

; 672  :     T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Buf[*p_idx]; *p_idx = FreeIdx; return Add(); }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	48 83 c0 10	 add	 rax, 16
  00039	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  0003f	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR key$[rbp]
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z ; ImGuiStorage::GetIntRef
  0004d	48 89 45 08	 mov	 QWORD PTR p_idx$[rbp], rax
  00051	48 8b 45 08	 mov	 rax, QWORD PTR p_idx$[rbp]
  00055	83 38 ff	 cmp	 DWORD PTR [rax], -1
  00058	74 17		 je	 SHORT $LN2@GetOrAddBy
  0005a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00061	48 8b 4d 08	 mov	 rcx, QWORD PTR p_idx$[rbp]
  00065	8b 11		 mov	 edx, DWORD PTR [rcx]
  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z ; ImVector<ImGuiTable>::operator[]
  0006f	eb 1c		 jmp	 SHORT $LN1@GetOrAddBy
$LN2@GetOrAddBy:
  00071	48 8b 45 08	 mov	 rax, QWORD PTR p_idx$[rbp]
  00075	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007c	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  0007f	89 08		 mov	 DWORD PTR [rax], ecx
  00081	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00088	e8 00 00 00 00	 call	 ?Add@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@XZ ; ImPool<ImGuiTable>::Add
$LN1@GetOrAddBy:
  0008d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00094	5f		 pop	 rdi
  00095	5d		 pop	 rbp
  00096	c3		 ret	 0
?GetOrAddByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z ENDP ; ImPool<ImGuiTable>::GetOrAddByKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z
_TEXT	SEGMENT
this$ = 224
p$ = 232
?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z PROC ; ImPool<ImGuiTable>::GetIndex, COMDAT

; 671  :     ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003a	48 39 85 e8 00
	00 00		 cmp	 QWORD PTR p$[rbp], rax
  00041	72 25		 jb	 SHORT $LN3@GetIndex
  00043	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0004d	48 69 c0 38 02
	00 00		 imul	 rax, rax, 568		; 00000238H
  00054	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005b	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0005f	48 39 85 e8 00
	00 00		 cmp	 QWORD PTR p$[rbp], rax
  00066	72 1c		 jb	 SHORT $LN4@GetIndex
$LN3@GetIndex:
  00068	41 b8 9f 02 00
	00		 mov	 r8d, 671		; 0000029fH
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@FAIKKLKG@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@BIEMKEOL@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DM?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CL?$AA?5@
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00082	33 c0		 xor	 eax, eax
$LN4@GetIndex:
  00084	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008f	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR p$[rbp]
  00096	48 2b c8	 sub	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 99		 cdq
  0009e	b9 38 02 00 00	 mov	 ecx, 568		; 00000238H
  000a3	48 f7 f9	 idiv	 rcx
  000a6	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000ad	5f		 pop	 rdi
  000ae	5d		 pop	 rbp
  000af	c3		 ret	 0
?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z ENDP ; ImPool<ImGuiTable>::GetIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetByIndex@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z
_TEXT	SEGMENT
this$ = 224
n$ = 232
?GetByIndex@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z PROC ; ImPool<ImGuiTable>::GetByIndex, COMDAT

; 670  :     T*          GetByIndex(ImPoolIdx n)             { return &Buf[n]; }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR n$[rbp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z ; ImVector<ImGuiTable>::operator[]
  00043	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004a	5f		 pop	 rdi
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
?GetByIndex@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z ENDP ; ImPool<ImGuiTable>::GetByIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z
_TEXT	SEGMENT
idx$ = 4
tv74 = 216
this$ = 256
key$ = 264
?GetByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z PROC ; ImPool<ImGuiTable>::GetByKey, COMDAT

; 669  :     T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Buf[idx] : NULL; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	48 83 c0 10	 add	 rax, 16
  00039	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  0003f	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR key$[rbp]
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?GetInt@ImGuiStorage@@QEBAHIH@Z ; ImGuiStorage::GetInt
  0004d	89 45 04	 mov	 DWORD PTR idx$[rbp], eax
  00050	83 7d 04 ff	 cmp	 DWORD PTR idx$[rbp], -1
  00054	74 1b		 je	 SHORT $LN3@GetByKey
  00056	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005d	8b 55 04	 mov	 edx, DWORD PTR idx$[rbp]
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z ; ImVector<ImGuiTable>::operator[]
  00068	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv74[rbp], rax
  0006f	eb 0b		 jmp	 SHORT $LN4@GetByKey
$LN3@GetByKey:
  00071	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv74[rbp], 0
$LN4@GetByKey:
  0007c	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv74[rbp]
  00083	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0008a	5f		 pop	 rdi
  0008b	5d		 pop	 rbp
  0008c	c3		 ret	 0
?GetByKey@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@I@Z ENDP ; ImPool<ImGuiTable>::GetByKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiTable@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 8
this$ = 256
new_capacity$ = 264
?reserve@?$ImVector@UImGuiTable@@@@QEAAXH@Z PROC	; ImVector<ImGuiTable>::reserve, COMDAT

; 1803 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 08 01 00
	00		 cmp	 DWORD PTR new_capacity$[rbp], eax
  0003e	7f 02		 jg	 SHORT $LN2@reserve
  00040	eb 7f		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  00042	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR new_capacity$[rbp]
  00049	48 69 c0 38 02
	00 00		 imul	 rax, rax, 568		; 00000238H
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  00058	48 89 45 08	 mov	 QWORD PTR new_data$[rbp], rax
  0005c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00063	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00068	74 38		 je	 SHORT $LN3@reserve
  0006a	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00071	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00074	48 69 c0 38 02
	00 00		 imul	 rax, rax, 568		; 00000238H
  0007b	4c 8b c0	 mov	 r8, rax
  0007e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00085	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00089	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  0008d	e8 00 00 00 00	 call	 memcpy
  00092	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00099	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0009d	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN3@reserve:
  000a2	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a9	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  000ad	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000b1	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b8	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_capacity$[rbp]
  000be	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN1@reserve:
  000c1	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000c8	5f		 pop	 rdi
  000c9	5d		 pop	 rbp
  000ca	c3		 ret	 0
?reserve@?$ImVector@UImGuiTable@@@@QEAAXH@Z ENDP	; ImVector<ImGuiTable>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiTable@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 224
new_size$ = 232
?resize@?$ImVector@UImGuiTable@@@@QEAAXH@Z PROC		; ImVector<ImGuiTable>::resize, COMDAT

; 1800 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 e8 00 00
	00		 cmp	 DWORD PTR new_size$[rbp], eax
  0003e	7e 20		 jle	 SHORT $LN2@resize
  00040	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR new_size$[rbp]
  00046	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004d	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiTable@@@@QEBAHH@Z ; ImVector<ImGuiTable>::_grow_capacity
  00052	8b d0		 mov	 edx, eax
  00054	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005b	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiTable@@@@QEAAXH@Z ; ImVector<ImGuiTable>::reserve
$LN2@resize:
  00060	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00067	8b 8d e8 00 00
	00		 mov	 ecx, DWORD PTR new_size$[rbp]
  0006d	89 08		 mov	 DWORD PTR [rax], ecx
  0006f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00076	5f		 pop	 rdi
  00077	5d		 pop	 rbp
  00078	c3		 ret	 0
?resize@?$ImVector@UImGuiTable@@@@QEAAXH@Z ENDP		; ImVector<ImGuiTable>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiTable@@@@QEBAHH@Z
_TEXT	SEGMENT
new_capacity$ = 4
tv72 = 212
tv70 = 212
this$ = 256
sz$ = 264
?_grow_capacity@?$ImVector@UImGuiTable@@@@QEBAHH@Z PROC	; ImVector<ImGuiTable>::_grow_capacity, COMDAT

; 1799 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 8b fc	 mov	 rdi, rsp
  00018	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00037	74 21		 je	 SHORT $LN3@grow_capac
  00039	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00043	99		 cdq
  00044	2b c2		 sub	 eax, edx
  00046	d1 f8		 sar	 eax, 1
  00048	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004f	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00052	89 85 d4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00058	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0005a	c7 85 d4 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv70[rbp], 8
$LN4@grow_capac:
  00064	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  0006a	89 45 04	 mov	 DWORD PTR new_capacity$[rbp], eax
  0006d	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00073	39 45 04	 cmp	 DWORD PTR new_capacity$[rbp], eax
  00076	7e 0b		 jle	 SHORT $LN5@grow_capac
  00078	8b 45 04	 mov	 eax, DWORD PTR new_capacity$[rbp]
  0007b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00081	eb 0c		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00083	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00089	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
$LN6@grow_capac:
  0008f	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  00095	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0009c	5f		 pop	 rdi
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
?_grow_capacity@?$ImVector@UImGuiTable@@@@QEBAHH@Z ENDP	; ImVector<ImGuiTable>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z
_TEXT	SEGMENT
this$ = 224
i$ = 232
??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z PROC ; ImVector<ImGuiTable>::operator[], COMDAT

; 1786 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  00035	7c 11		 jl	 SHORT $LN3@operator
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00048	41 b8 fa 06 00
	00		 mov	 r8d, 1786		; 000006faH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@operator:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0006b	48 69 c0 38 02
	00 00		 imul	 rax, rax, 568		; 00000238H
  00072	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00079	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0007d	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00084	5f		 pop	 rdi
  00085	5d		 pop	 rbp
  00086	c3		 ret	 0
??A?$ImVector@UImGuiTable@@@@QEAAAEAUImGuiTable@@H@Z ENDP ; ImVector<ImGuiTable>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiTableTempData@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 8
this$ = 256
new_capacity$ = 264
?reserve@?$ImVector@UImGuiTableTempData@@@@QEAAXH@Z PROC ; ImVector<ImGuiTableTempData>::reserve, COMDAT

; 1803 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 08 01 00
	00		 cmp	 DWORD PTR new_capacity$[rbp], eax
  0003e	7f 02		 jg	 SHORT $LN2@reserve
  00040	eb 79		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  00042	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR new_capacity$[rbp]
  00049	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  00055	48 89 45 08	 mov	 QWORD PTR new_data$[rbp], rax
  00059	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00060	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00065	74 35		 je	 SHORT $LN3@reserve
  00067	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006e	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00071	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00075	4c 8b c0	 mov	 r8, rax
  00078	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00083	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  00087	e8 00 00 00 00	 call	 memcpy
  0008c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00093	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00097	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN3@reserve:
  0009c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a3	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  000a7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000ab	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b2	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_capacity$[rbp]
  000b8	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN1@reserve:
  000bb	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	c3		 ret	 0
?reserve@?$ImVector@UImGuiTableTempData@@@@QEAAXH@Z ENDP ; ImVector<ImGuiTableTempData>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiTableTempData@@@@QEAAXHAEBUImGuiTableTempData@@@Z
_TEXT	SEGMENT
n$1 = 4
this$ = 256
new_size$ = 264
v$ = 272
?resize@?$ImVector@UImGuiTableTempData@@@@QEAAXHAEBUImGuiTableTempData@@@Z PROC ; ImVector<ImGuiTableTempData>::resize, COMDAT

; 1801 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  00033	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0003d	39 85 08 01 00
	00		 cmp	 DWORD PTR new_size$[rbp], eax
  00043	7e 20		 jle	 SHORT $LN5@resize
  00045	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR new_size$[rbp]
  0004b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00052	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiTableTempData@@@@QEBAHH@Z ; ImVector<ImGuiTableTempData>::_grow_capacity
  00057	8b d0		 mov	 edx, eax
  00059	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00060	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiTableTempData@@@@QEAAXH@Z ; ImVector<ImGuiTableTempData>::reserve
$LN5@resize:
  00065	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006c	8b 00		 mov	 eax, DWORD PTR [rax]
  0006e	39 85 08 01 00
	00		 cmp	 DWORD PTR new_size$[rbp], eax
  00074	7e 4b		 jle	 SHORT $LN6@resize
  00076	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007d	8b 00		 mov	 eax, DWORD PTR [rax]
  0007f	89 45 04	 mov	 DWORD PTR n$1[rbp], eax
  00082	eb 08		 jmp	 SHORT $LN4@resize
$LN2@resize:
  00084	8b 45 04	 mov	 eax, DWORD PTR n$1[rbp]
  00087	ff c0		 inc	 eax
  00089	89 45 04	 mov	 DWORD PTR n$1[rbp], eax
$LN4@resize:
  0008c	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR new_size$[rbp]
  00092	39 45 04	 cmp	 DWORD PTR n$1[rbp], eax
  00095	7d 2a		 jge	 SHORT $LN3@resize
  00097	48 63 45 04	 movsxd	 rax, DWORD PTR n$1[rbp]
  0009b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0009f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a6	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  000aa	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  000b0	48 8b 95 10 01
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  000b7	48 8b c8	 mov	 rcx, rax
  000ba	e8 00 00 00 00	 call	 memcpy
  000bf	eb c3		 jmp	 SHORT $LN2@resize
$LN3@resize:
$LN6@resize:
  000c1	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c8	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_size$[rbp]
  000ce	89 08		 mov	 DWORD PTR [rax], ecx
  000d0	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000d7	5f		 pop	 rdi
  000d8	5d		 pop	 rbp
  000d9	c3		 ret	 0
?resize@?$ImVector@UImGuiTableTempData@@@@QEAAXHAEBUImGuiTableTempData@@@Z ENDP ; ImVector<ImGuiTableTempData>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiTableTempData@@@@QEBAHH@Z
_TEXT	SEGMENT
new_capacity$ = 4
tv72 = 212
tv70 = 212
this$ = 256
sz$ = 264
?_grow_capacity@?$ImVector@UImGuiTableTempData@@@@QEBAHH@Z PROC ; ImVector<ImGuiTableTempData>::_grow_capacity, COMDAT

; 1799 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 8b fc	 mov	 rdi, rsp
  00018	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00037	74 21		 je	 SHORT $LN3@grow_capac
  00039	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00043	99		 cdq
  00044	2b c2		 sub	 eax, edx
  00046	d1 f8		 sar	 eax, 1
  00048	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004f	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00052	89 85 d4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00058	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0005a	c7 85 d4 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv70[rbp], 8
$LN4@grow_capac:
  00064	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  0006a	89 45 04	 mov	 DWORD PTR new_capacity$[rbp], eax
  0006d	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00073	39 45 04	 cmp	 DWORD PTR new_capacity$[rbp], eax
  00076	7e 0b		 jle	 SHORT $LN5@grow_capac
  00078	8b 45 04	 mov	 eax, DWORD PTR new_capacity$[rbp]
  0007b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00081	eb 0c		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00083	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00089	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
$LN6@grow_capac:
  0008f	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  00095	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0009c	5f		 pop	 rdi
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
?_grow_capacity@?$ImVector@UImGuiTableTempData@@@@QEBAHH@Z ENDP ; ImVector<ImGuiTableTempData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiTableTempData@@@@QEAAAEAUImGuiTableTempData@@H@Z
_TEXT	SEGMENT
this$ = 224
i$ = 232
??A?$ImVector@UImGuiTableTempData@@@@QEAAAEAUImGuiTableTempData@@H@Z PROC ; ImVector<ImGuiTableTempData>::operator[], COMDAT

; 1786 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  00035	7c 11		 jl	 SHORT $LN3@operator
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00048	41 b8 fa 06 00
	00		 mov	 r8d, 1786		; 000006faH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@operator:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0006b	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  0006f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00076	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0007a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00081	5f		 pop	 rdi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
??A?$ImVector@UImGuiTableTempData@@@@QEAAAEAUImGuiTableTempData@@H@Z ENDP ; ImVector<ImGuiTableTempData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImGuiSettingsHandler@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0ImGuiSettingsHandler@@QEAA@XZ PROC			; ImGuiSettingsHandler::ImGuiSettingsHandler, COMDAT

; 1625 :     ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00030	33 d2		 xor	 edx, edx
  00032	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00039	e8 00 00 00 00	 call	 memset
  0003e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004c	5f		 pop	 rdi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??0ImGuiSettingsHandler@@QEAA@XZ ENDP			; ImGuiSettingsHandler::ImGuiSettingsHandler
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1ImGuiOldColumns@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1ImGuiOldColumns@@QEAA@XZ PROC			; ImGuiOldColumns::~ImGuiOldColumns, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 83 c0 70	 add	 rax, 112		; 00000070H
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ??1ImDrawListSplitter@@QEAA@XZ ; ImDrawListSplitter::~ImDrawListSplitter
  0003d	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00044	48 83 c0 60	 add	 rax, 96			; 00000060H
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 ??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ ; ImVector<ImGuiOldColumnData>::~ImVector<ImGuiOldColumnData>
  00050	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00057	5f		 pop	 rdi
  00058	5d		 pop	 rbp
  00059	c3		 ret	 0
??1ImGuiOldColumns@@QEAA@XZ ENDP			; ImGuiOldColumns::~ImGuiOldColumns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImGuiOldColumns@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??0ImGuiOldColumns@@QEAA@XZ PROC			; ImGuiOldColumns::ImGuiOldColumns, COMDAT

; 1543 :     ImGuiOldColumns()   { memset(this, 0, sizeof(*this)); }

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002a	48 c7 85 c8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T1[rbp], -2
  00035	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00040	48 8b c8	 mov	 rcx, rax
  00043	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  00048	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004f	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  0005b	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00062	48 83 c0 4c	 add	 rax, 76			; 0000004cH
  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  0006e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00075	48 83 c0 60	 add	 rax, 96			; 00000060H
  00079	48 8b c8	 mov	 rcx, rax
  0007c	e8 00 00 00 00	 call	 ??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ ; ImVector<ImGuiOldColumnData>::ImVector<ImGuiOldColumnData>
  00081	90		 npad	 1
  00082	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00089	48 83 c0 70	 add	 rax, 112		; 00000070H
  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 ??0ImDrawListSplitter@@QEAA@XZ ; ImDrawListSplitter::ImDrawListSplitter
  00095	41 b8 88 00 00
	00		 mov	 r8d, 136		; 00000088H
  0009b	33 d2		 xor	 edx, edx
  0009d	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a4	e8 00 00 00 00	 call	 memset
  000a9	90		 npad	 1
  000aa	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b1	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000b8	5f		 pop	 rdi
  000b9	5d		 pop	 rbp
  000ba	c3		 ret	 0
??0ImGuiOldColumns@@QEAA@XZ ENDP			; ImGuiOldColumns::ImGuiOldColumns
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ImGuiOldColumns@@QEAA@XZ@4HA PROC		; `ImGuiOldColumns::ImGuiOldColumns'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 83 c1 60	 add	 rcx, 96			; 00000060H
  0001f	e8 00 00 00 00	 call	 ??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ ; ImVector<ImGuiOldColumnData>::~ImVector<ImGuiOldColumnData>
  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	5f		 pop	 rdi
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?dtor$0@?0???0ImGuiOldColumns@@QEAA@XZ@4HA ENDP		; `ImGuiOldColumns::ImGuiOldColumns'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 200
this$ = 256
?dtor$0@?0???0ImGuiOldColumns@@QEAA@XZ@4HA PROC		; `ImGuiOldColumns::ImGuiOldColumns'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 83 c1 60	 add	 rcx, 96			; 00000060H
  0001f	e8 00 00 00 00	 call	 ??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ ; ImVector<ImGuiOldColumnData>::~ImVector<ImGuiOldColumnData>
  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	5f		 pop	 rdi
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?dtor$0@?0???0ImGuiOldColumns@@QEAA@XZ@4HA ENDP		; `ImGuiOldColumns::ImGuiOldColumns'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z
_TEXT	SEGMENT
this$ = 224
v$ = 232
?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z PROC ; ImVector<ImGuiOldColumnData>::push_back, COMDAT

; 1807 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00036	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003d	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00040	39 08		 cmp	 DWORD PTR [rax], ecx
  00042	75 27		 jne	 SHORT $LN2@push_back
  00044	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004b	8b 00		 mov	 eax, DWORD PTR [rax]
  0004d	ff c0		 inc	 eax
  0004f	8b d0		 mov	 edx, eax
  00051	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00058	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z ; ImVector<ImGuiOldColumnData>::_grow_capacity
  0005d	8b d0		 mov	 edx, eax
  0005f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00066	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::reserve
$LN2@push_back:
  0006b	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00072	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00075	48 6b c0 1c	 imul	 rax, rax, 28
  00079	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00080	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00084	41 b8 1c 00 00
	00		 mov	 r8d, 28
  0008a	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  00091	48 8b c8	 mov	 rcx, rax
  00094	e8 00 00 00 00	 call	 memcpy
  00099	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a0	8b 00		 mov	 eax, DWORD PTR [rax]
  000a2	ff c0		 inc	 eax
  000a4	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000ab	89 01		 mov	 DWORD PTR [rcx], eax
  000ad	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  000b4	5f		 pop	 rdi
  000b5	5d		 pop	 rbp
  000b6	c3		 ret	 0
?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z ENDP ; ImVector<ImGuiOldColumnData>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 8
this$ = 256
new_capacity$ = 264
?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z PROC ; ImVector<ImGuiOldColumnData>::reserve, COMDAT

; 1803 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 08 01 00
	00		 cmp	 DWORD PTR new_capacity$[rbp], eax
  0003e	7f 02		 jg	 SHORT $LN2@reserve
  00040	eb 79		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  00042	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR new_capacity$[rbp]
  00049	48 6b c0 1c	 imul	 rax, rax, 28
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  00055	48 89 45 08	 mov	 QWORD PTR new_data$[rbp], rax
  00059	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00060	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00065	74 35		 je	 SHORT $LN3@reserve
  00067	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006e	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00071	48 6b c0 1c	 imul	 rax, rax, 28
  00075	4c 8b c0	 mov	 r8, rax
  00078	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00083	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  00087	e8 00 00 00 00	 call	 memcpy
  0008c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00093	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00097	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN3@reserve:
  0009c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a3	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  000a7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000ab	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b2	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_capacity$[rbp]
  000b8	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN1@reserve:
  000bb	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	c3		 ret	 0
?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ENDP ; ImVector<ImGuiOldColumnData>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 224
new_size$ = 232
?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z PROC	; ImVector<ImGuiOldColumnData>::resize, COMDAT

; 1800 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 e8 00 00
	00		 cmp	 DWORD PTR new_size$[rbp], eax
  0003e	7e 20		 jle	 SHORT $LN2@resize
  00040	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR new_size$[rbp]
  00046	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004d	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z ; ImVector<ImGuiOldColumnData>::_grow_capacity
  00052	8b d0		 mov	 edx, eax
  00054	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005b	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::reserve
$LN2@resize:
  00060	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00067	8b 8d e8 00 00
	00		 mov	 ecx, DWORD PTR new_size$[rbp]
  0006d	89 08		 mov	 DWORD PTR [rax], ecx
  0006f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00076	5f		 pop	 rdi
  00077	5d		 pop	 rbp
  00078	c3		 ret	 0
?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ENDP	; ImVector<ImGuiOldColumnData>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z
_TEXT	SEGMENT
new_capacity$ = 4
tv72 = 212
tv70 = 212
this$ = 256
sz$ = 264
?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z PROC ; ImVector<ImGuiOldColumnData>::_grow_capacity, COMDAT

; 1799 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 8b fc	 mov	 rdi, rsp
  00018	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00037	74 21		 je	 SHORT $LN3@grow_capac
  00039	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00043	99		 cdq
  00044	2b c2		 sub	 eax, edx
  00046	d1 f8		 sar	 eax, 1
  00048	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004f	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00052	89 85 d4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00058	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0005a	c7 85 d4 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv70[rbp], 8
$LN4@grow_capac:
  00064	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  0006a	89 45 04	 mov	 DWORD PTR new_capacity$[rbp], eax
  0006d	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00073	39 45 04	 cmp	 DWORD PTR new_capacity$[rbp], eax
  00076	7e 0b		 jle	 SHORT $LN5@grow_capac
  00078	8b 45 04	 mov	 eax, DWORD PTR new_capacity$[rbp]
  0007b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00081	eb 0c		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00083	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00089	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
$LN6@grow_capac:
  0008f	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  00095	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0009c	5f		 pop	 rdi
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z ENDP ; ImVector<ImGuiOldColumnData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z
_TEXT	SEGMENT
this$ = 224
i$ = 232
??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z PROC ; ImVector<ImGuiOldColumnData>::operator[], COMDAT

; 1786 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  00035	7c 11		 jl	 SHORT $LN3@operator
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00048	41 b8 fa 06 00
	00		 mov	 r8d, 1786		; 000006faH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@operator:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0006b	48 6b c0 1c	 imul	 rax, rax, 28
  0006f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00076	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0007a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00081	5f		 pop	 rdi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ENDP ; ImVector<ImGuiOldColumnData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ PROC	; ImVector<ImGuiOldColumnData>::~ImVector<ImGuiOldColumnData>, COMDAT

; 1775 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002a	48 c7 85 c8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T1[rbp], -2
  00035	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00041	74 11		 je	 SHORT $LN2@ImVector
  00043	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0004e	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
  00053	90		 npad	 1
$LN2@ImVector:
  00054	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0005b	5f		 pop	 rdi
  0005c	5d		 pop	 rbp
  0005d	c3		 ret	 0
??1?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ ENDP	; ImVector<ImGuiOldColumnData>::~ImVector<ImGuiOldColumnData>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ PROC	; ImVector<ImGuiOldColumnData>::ImVector<ImGuiOldColumnData>, COMDAT

; 1772 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00036	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00043	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00060	5f		 pop	 rdi
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ ENDP	; ImVector<ImGuiOldColumnData>::ImVector<ImGuiOldColumnData>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImGuiOldColumnData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0ImGuiOldColumnData@@QEAA@XZ PROC			; ImGuiOldColumnData::ImGuiOldColumnData, COMDAT

; 1522 :     ImGuiOldColumnData() { memset(this, 0, sizeof(*this)); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 83 c0 0c	 add	 rax, 12
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@XZ	; ImRect::ImRect
  0003d	41 b8 1c 00 00
	00		 mov	 r8d, 28
  00043	33 d2		 xor	 edx, edx
  00045	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004c	e8 00 00 00 00	 call	 memset
  00051	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00058	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005f	5f		 pop	 rdi
  00060	5d		 pop	 rbp
  00061	c3		 ret	 0
??0ImGuiOldColumnData@@QEAA@XZ ENDP			; ImGuiOldColumnData::ImGuiOldColumnData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??$ImMin@H@@YAHHH@Z
_TEXT	SEGMENT
tv65 = 192
lhs$ = 240
rhs$ = 248
??$ImMin@H@@YAHHH@Z PROC				; ImMin<int>, COMDAT

; 452  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b ec	 mov	 rbp, rsp
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR [rsp+248]
  0002a	8b 85 f8 00 00
	00		 mov	 eax, DWORD PTR rhs$[rbp]
  00030	39 85 f0 00 00
	00		 cmp	 DWORD PTR lhs$[rbp], eax
  00036	7d 0e		 jge	 SHORT $LN3@ImMin
  00038	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR lhs$[rbp]
  0003e	89 85 c0 00 00
	00		 mov	 DWORD PTR tv65[rbp], eax
  00044	eb 0c		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  00046	8b 85 f8 00 00
	00		 mov	 eax, DWORD PTR rhs$[rbp]
  0004c	89 85 c0 00 00
	00		 mov	 DWORD PTR tv65[rbp], eax
$LN4@ImMin:
  00052	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv65[rbp]
  00058	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0005f	5f		 pop	 rdi
  00060	5d		 pop	 rbp
  00061	c3		 ret	 0
??$ImMin@H@@YAHHH@Z ENDP				; ImMin<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ImBitArraySetBitRange@@YAXPEAIHH@Z
_TEXT	SEGMENT
a_mod$1 = 0
b_mod$2 = 4
mask$3 = 8
tv70 = 76
tv133 = 80
arr$ = 112
n$ = 120
n2$ = 128
?ImBitArraySetBitRange@@YAXPEAIHH@Z PROC		; ImBitArraySetBitRange, COMDAT

; 561  : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8b ec	 mov	 rbp, rsp

; 562  :     n2--;

  00016	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR n2$[rbp]
  0001c	ff c8		 dec	 eax
  0001e	89 85 80 00 00
	00		 mov	 DWORD PTR n2$[rbp], eax
$LN2@ImBitArray:

; 563  :     while (n <= n2)

  00024	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR n2$[rbp]
  0002a	39 45 78	 cmp	 DWORD PTR n$[rbp], eax
  0002d	0f 8f 9a 00 00
	00		 jg	 $LN3@ImBitArray

; 564  :     {
; 565  :         int a_mod = (n & 31);

  00033	8b 45 78	 mov	 eax, DWORD PTR n$[rbp]
  00036	83 e0 1f	 and	 eax, 31
  00039	89 45 00	 mov	 DWORD PTR a_mod$1[rbp], eax

; 566  :         int b_mod = (n2 > (n | 31) ? 31 : (n2 & 31)) + 1;

  0003c	8b 45 78	 mov	 eax, DWORD PTR n$[rbp]
  0003f	83 c8 1f	 or	 eax, 31
  00042	39 85 80 00 00
	00		 cmp	 DWORD PTR n2$[rbp], eax
  00048	7e 09		 jle	 SHORT $LN5@ImBitArray
  0004a	c7 45 4c 1f 00
	00 00		 mov	 DWORD PTR tv70[rbp], 31
  00051	eb 0c		 jmp	 SHORT $LN6@ImBitArray
$LN5@ImBitArray:
  00053	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR n2$[rbp]
  00059	83 e0 1f	 and	 eax, 31
  0005c	89 45 4c	 mov	 DWORD PTR tv70[rbp], eax
$LN6@ImBitArray:
  0005f	8b 45 4c	 mov	 eax, DWORD PTR tv70[rbp]
  00062	ff c0		 inc	 eax
  00064	89 45 04	 mov	 DWORD PTR b_mod$2[rbp], eax

; 567  :         ImU32 mask = (ImU32)(((ImU64)1 << b_mod) - 1) & ~(ImU32)(((ImU64)1 << a_mod) - 1);

  00067	8b 45 04	 mov	 eax, DWORD PTR b_mod$2[rbp]
  0006a	b9 01 00 00 00	 mov	 ecx, 1
  0006f	48 89 4d 50	 mov	 QWORD PTR tv133[rbp], rcx
  00073	0f b6 c8	 movzx	 ecx, al
  00076	48 8b 45 50	 mov	 rax, QWORD PTR tv133[rbp]
  0007a	48 d3 e0	 shl	 rax, cl
  0007d	48 ff c8	 dec	 rax
  00080	8b 4d 00	 mov	 ecx, DWORD PTR a_mod$1[rbp]
  00083	ba 01 00 00 00	 mov	 edx, 1
  00088	48 d3 e2	 shl	 rdx, cl
  0008b	48 8b ca	 mov	 rcx, rdx
  0008e	48 ff c9	 dec	 rcx
  00091	f7 d1		 not	 ecx
  00093	23 c1		 and	 eax, ecx
  00095	89 45 08	 mov	 DWORD PTR mask$3[rbp], eax

; 568  :         arr[n >> 5] |= mask;

  00098	8b 45 78	 mov	 eax, DWORD PTR n$[rbp]
  0009b	c1 f8 05	 sar	 eax, 5
  0009e	48 98		 cdqe
  000a0	48 8b 4d 70	 mov	 rcx, QWORD PTR arr$[rbp]
  000a4	8b 55 08	 mov	 edx, DWORD PTR mask$3[rbp]
  000a7	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000aa	0b c2		 or	 eax, edx
  000ac	8b 4d 78	 mov	 ecx, DWORD PTR n$[rbp]
  000af	c1 f9 05	 sar	 ecx, 5
  000b2	48 63 c9	 movsxd	 rcx, ecx
  000b5	48 8b 55 70	 mov	 rdx, QWORD PTR arr$[rbp]
  000b9	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 569  :         n = (n + 32) & ~31;

  000bc	8b 45 78	 mov	 eax, DWORD PTR n$[rbp]
  000bf	83 c0 20	 add	 eax, 32			; 00000020H
  000c2	83 e0 e0	 and	 eax, -32		; ffffffffffffffe0H
  000c5	89 45 78	 mov	 DWORD PTR n$[rbp], eax

; 570  :     }

  000c8	e9 57 ff ff ff	 jmp	 $LN2@ImBitArray
$LN3@ImBitArray:

; 571  : }

  000cd	48 8d 65 60	 lea	 rsp, QWORD PTR [rbp+96]
  000d1	5d		 pop	 rbp
  000d2	c3		 ret	 0
?ImBitArraySetBitRange@@YAXPEAIHH@Z ENDP		; ImBitArraySetBitRange
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ImBitArraySetBit@@YAXPEAIH@Z
_TEXT	SEGMENT
mask$ = 0
tv78 = 68
arr$ = 96
n$ = 104
?ImBitArraySetBit@@YAXPEAIH@Z PROC			; ImBitArraySetBit, COMDAT

; 559  : inline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	8b 45 68	 mov	 eax, DWORD PTR n$[rbp]
  00014	83 e0 1f	 and	 eax, 31
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	89 4d 44	 mov	 DWORD PTR tv78[rbp], ecx
  0001f	0f b6 c8	 movzx	 ecx, al
  00022	8b 45 44	 mov	 eax, DWORD PTR tv78[rbp]
  00025	d3 e0		 shl	 eax, cl
  00027	89 45 00	 mov	 DWORD PTR mask$[rbp], eax
  0002a	8b 45 68	 mov	 eax, DWORD PTR n$[rbp]
  0002d	c1 f8 05	 sar	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4d 60	 mov	 rcx, QWORD PTR arr$[rbp]
  00036	8b 55 00	 mov	 edx, DWORD PTR mask$[rbp]
  00039	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0003c	0b c2		 or	 eax, edx
  0003e	8b 4d 68	 mov	 ecx, DWORD PTR n$[rbp]
  00041	c1 f9 05	 sar	 ecx, 5
  00044	48 63 c9	 movsxd	 rcx, ecx
  00047	48 8b 55 60	 mov	 rdx, QWORD PTR arr$[rbp]
  0004b	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  0004e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
?ImBitArraySetBit@@YAXPEAIH@Z ENDP			; ImBitArraySetBit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ImBitArrayClearBit@@YAXPEAIH@Z
_TEXT	SEGMENT
mask$ = 0
tv79 = 68
arr$ = 96
n$ = 104
?ImBitArrayClearBit@@YAXPEAIH@Z PROC			; ImBitArrayClearBit, COMDAT

; 558  : inline void     ImBitArrayClearBit(ImU32* arr, int n)           { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] &= ~mask; }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	8b 45 68	 mov	 eax, DWORD PTR n$[rbp]
  00014	83 e0 1f	 and	 eax, 31
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	89 4d 44	 mov	 DWORD PTR tv79[rbp], ecx
  0001f	0f b6 c8	 movzx	 ecx, al
  00022	8b 45 44	 mov	 eax, DWORD PTR tv79[rbp]
  00025	d3 e0		 shl	 eax, cl
  00027	89 45 00	 mov	 DWORD PTR mask$[rbp], eax
  0002a	8b 45 68	 mov	 eax, DWORD PTR n$[rbp]
  0002d	c1 f8 05	 sar	 eax, 5
  00030	48 98		 cdqe
  00032	8b 4d 00	 mov	 ecx, DWORD PTR mask$[rbp]
  00035	f7 d1		 not	 ecx
  00037	48 8b 55 60	 mov	 rdx, QWORD PTR arr$[rbp]
  0003b	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  0003e	23 c1		 and	 eax, ecx
  00040	8b 4d 68	 mov	 ecx, DWORD PTR n$[rbp]
  00043	c1 f9 05	 sar	 ecx, 5
  00046	48 63 c9	 movsxd	 rcx, ecx
  00049	48 8b 55 60	 mov	 rdx, QWORD PTR arr$[rbp]
  0004d	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  00050	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
?ImBitArrayClearBit@@YAXPEAIH@Z ENDP			; ImBitArrayClearBit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ImBitArrayClearAllBits@@YAXPEAIH@Z
_TEXT	SEGMENT
arr$ = 80
bitcount$ = 88
?ImBitArrayClearAllBits@@YAXPEAIH@Z PROC		; ImBitArrayClearAllBits, COMDAT

; 556  : inline void     ImBitArrayClearAllBits(ImU32* arr, int bitcount){ memset(arr, 0, ImBitArrayGetStorageSizeInBytes(bitcount)); }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	8b 4d 58	 mov	 ecx, DWORD PTR bitcount$[rbp]
  00016	e8 00 00 00 00	 call	 ?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z ; ImBitArrayGetStorageSizeInBytes
  0001b	4c 8b c0	 mov	 r8, rax
  0001e	33 d2		 xor	 edx, edx
  00020	48 8b 4d 50	 mov	 rcx, QWORD PTR arr$[rbp]
  00024	e8 00 00 00 00	 call	 memset
  00029	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002d	5d		 pop	 rbp
  0002e	c3		 ret	 0
?ImBitArrayClearAllBits@@YAXPEAIH@Z ENDP		; ImBitArrayClearAllBits
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z
_TEXT	SEGMENT
bitcount$ = 80
?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z PROC		; ImBitArrayGetStorageSizeInBytes, COMDAT

; 555  : inline size_t   ImBitArrayGetStorageSizeInBytes(int bitcount)   { return (size_t)((bitcount + 31) >> 5) << 2; }

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00009	48 8b ec	 mov	 rbp, rsp
  0000c	8b 45 50	 mov	 eax, DWORD PTR bitcount$[rbp]
  0000f	83 c0 1f	 add	 eax, 31
  00012	c1 f8 05	 sar	 eax, 5
  00015	48 98		 cdqe
  00017	48 c1 e0 02	 shl	 rax, 2
  0001b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001f	5d		 pop	 rbp
  00020	c3		 ret	 0
?ImBitArrayGetStorageSizeInBytes@@YA_KH@Z ENDP		; ImBitArrayGetStorageSizeInBytes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ToVec4@ImRect@@QEBA?AUImVec4@@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?ToVec4@ImRect@@QEBA?AUImVec4@@XZ PROC			; ImRect::ToVec4, COMDAT

; 549  :     ImVec4      ToVec4() const                      { return ImVec4(Min.x, Min.y, Max.x, Max.y); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00014	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00018	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  0001d	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00023	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00027	f3 0f 10 58 08	 movss	 xmm3, DWORD PTR [rax+8]
  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00030	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [rax+4]
  00035	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00039	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  0003d	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00041	e8 00 00 00 00	 call	 ??0ImVec4@@QEAA@MMMM@Z	; ImVec4::ImVec4
  00046	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0004a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
?ToVec4@ImRect@@QEBA?AUImVec4@@XZ ENDP			; ImRect::ToVec4
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ClipWithFull@ImRect@@QEAAXAEBU1@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
this$ = 96
r$ = 104
?ClipWithFull@ImRect@@QEAAXAEBU1@@Z PROC		; ImRect::ClipWithFull, COMDAT

; 546  :     void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 45 68	 mov	 rax, QWORD PTR r$[rbp]
  00018	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	48 8b 55 68	 mov	 rdx, QWORD PTR r$[rbp]
  00020	4c 8b 4a 08	 mov	 r9, QWORD PTR [rdx+8]
  00024	4c 8b c0	 mov	 r8, rax
  00027	48 8b d1	 mov	 rdx, rcx
  0002a	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  0002e	e8 00 00 00 00	 call	 ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z ; ImClamp
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0003a	48 89 01	 mov	 QWORD PTR [rcx], rax
  0003d	48 8b 45 68	 mov	 rax, QWORD PTR r$[rbp]
  00041	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00045	48 83 c1 08	 add	 rcx, 8
  00049	48 8b 55 68	 mov	 rdx, QWORD PTR r$[rbp]
  0004d	4c 8b 4a 08	 mov	 r9, QWORD PTR [rdx+8]
  00051	4c 8b c0	 mov	 r8, rax
  00054	48 8b d1	 mov	 rdx, rcx
  00057	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  0005b	e8 00 00 00 00	 call	 ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z ; ImClamp
  00060	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00063	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00067	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0006b	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
?ClipWithFull@ImRect@@QEAAXAEBU1@@Z ENDP		; ImRect::ClipWithFull
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ClipWith@ImRect@@QEAAXAEBU1@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 72
this$ = 96
r$ = 104
?ClipWith@ImRect@@QEAAXAEBU1@@Z PROC			; ImRect::ClipWith, COMDAT

; 545  :     void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 45 68	 mov	 rax, QWORD PTR r$[rbp]
  00018	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	4c 8b c0	 mov	 r8, rax
  0001f	48 8b d1	 mov	 rdx, rcx
  00022	48 8d 4d 40	 lea	 rcx, QWORD PTR $T1[rbp]
  00026	e8 00 00 00 00	 call	 ?ImMax@@YA?AUImVec2@@AEBU1@0@Z ; ImMax
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00032	48 89 01	 mov	 QWORD PTR [rcx], rax
  00035	48 8b 45 68	 mov	 rax, QWORD PTR r$[rbp]
  00039	48 83 c0 08	 add	 rax, 8
  0003d	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00041	48 83 c1 08	 add	 rcx, 8
  00045	4c 8b c0	 mov	 r8, rax
  00048	48 8b d1	 mov	 rdx, rcx
  0004b	48 8d 4d 48	 lea	 rcx, QWORD PTR $T2[rbp]
  0004f	e8 00 00 00 00	 call	 ?ImMin@@YA?AUImVec2@@AEBU1@0@Z ; ImMin
  00054	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00057	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0005b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0005f	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00063	5d		 pop	 rbp
  00064	c3		 ret	 0
?ClipWith@ImRect@@QEAAXAEBU1@@Z ENDP			; ImRect::ClipWith
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?Add@ImRect@@QEAAXAEBU1@@Z
_TEXT	SEGMENT
this$ = 80
r$ = 88
?Add@ImRect@@QEAAXAEBU1@@Z PROC				; ImRect::Add, COMDAT

; 539  :     void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b ec	 mov	 rbp, rsp
  00012	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00016	48 8b 4d 58	 mov	 rcx, QWORD PTR r$[rbp]
  0001a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0001e	0f 2f 01	 comiss	 xmm0, DWORD PTR [rcx]
  00021	76 10		 jbe	 SHORT $LN2@Add
  00023	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00027	48 8b 4d 58	 mov	 rcx, QWORD PTR r$[rbp]
  0002b	f3 0f 10 01	 movss	 xmm0, DWORD PTR [rcx]
  0002f	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
$LN2@Add:
  00033	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00037	48 8b 4d 58	 mov	 rcx, QWORD PTR r$[rbp]
  0003b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00040	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [rcx+4]
  00044	76 12		 jbe	 SHORT $LN3@Add
  00046	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8b 4d 58	 mov	 rcx, QWORD PTR r$[rbp]
  0004e	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [rcx+4]
  00053	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
$LN3@Add:
  00058	48 8b 45 58	 mov	 rax, QWORD PTR r$[rbp]
  0005c	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00060	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00065	0f 2f 41 08	 comiss	 xmm0, DWORD PTR [rcx+8]
  00069	76 12		 jbe	 SHORT $LN4@Add
  0006b	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0006f	48 8b 4d 58	 mov	 rcx, QWORD PTR r$[rbp]
  00073	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [rcx+8]
  00078	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0
$LN4@Add:
  0007d	48 8b 45 58	 mov	 rax, QWORD PTR r$[rbp]
  00081	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00085	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  0008a	0f 2f 41 0c	 comiss	 xmm0, DWORD PTR [rcx+12]
  0008e	76 12		 jbe	 SHORT $LN5@Add
  00090	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00094	48 8b 4d 58	 mov	 rcx, QWORD PTR r$[rbp]
  00098	f3 0f 10 41 0c	 movss	 xmm0, DWORD PTR [rcx+12]
  0009d	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0
$LN5@Add:
  000a2	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  000a6	5d		 pop	 rbp
  000a7	c3		 ret	 0
?Add@ImRect@@QEAAXAEBU1@@Z ENDP				; ImRect::Add
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?Overlaps@ImRect@@QEBA_NAEBU1@@Z
_TEXT	SEGMENT
tv84 = 64
this$ = 96
r$ = 104
?Overlaps@ImRect@@QEBA_NAEBU1@@Z PROC			; ImRect::Overlaps, COMDAT

; 537  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b ec	 mov	 rbp, rsp
  00012	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  00016	48 8b 4d 68	 mov	 rcx, QWORD PTR r$[rbp]
  0001a	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  0001f	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [rcx+4]
  00023	76 40		 jbe	 SHORT $LN3@Overlaps
  00025	48 8b 45 68	 mov	 rax, QWORD PTR r$[rbp]
  00029	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  00032	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [rcx+4]
  00036	76 2d		 jbe	 SHORT $LN3@Overlaps
  00038	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 8b 4d 68	 mov	 rcx, QWORD PTR r$[rbp]
  00040	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00045	0f 2f 01	 comiss	 xmm0, DWORD PTR [rcx]
  00048	76 1b		 jbe	 SHORT $LN3@Overlaps
  0004a	48 8b 45 68	 mov	 rax, QWORD PTR r$[rbp]
  0004e	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  00052	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00057	0f 2f 01	 comiss	 xmm0, DWORD PTR [rcx]
  0005a	76 09		 jbe	 SHORT $LN3@Overlaps
  0005c	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv84[rbp], 1
  00063	eb 07		 jmp	 SHORT $LN4@Overlaps
$LN3@Overlaps:
  00065	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv84[rbp], 0
$LN4@Overlaps:
  0006c	0f b6 45 40	 movzx	 eax, BYTE PTR tv84[rbp]
  00070	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00074	5d		 pop	 rbp
  00075	c3		 ret	 0
?Overlaps@ImRect@@QEBA_NAEBU1@@Z ENDP			; ImRect::Overlaps
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QEBA_NAEBU1@@Z
_TEXT	SEGMENT
tv84 = 64
this$ = 96
r$ = 104
?Contains@ImRect@@QEBA_NAEBU1@@Z PROC			; ImRect::Contains, COMDAT

; 536  :     bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b ec	 mov	 rbp, rsp
  00012	48 8b 45 68	 mov	 rax, QWORD PTR r$[rbp]
  00016	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0001a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0001e	0f 2f 01	 comiss	 xmm0, DWORD PTR [rcx]
  00021	72 42		 jb	 SHORT $LN3@Contains
  00023	48 8b 45 68	 mov	 rax, QWORD PTR r$[rbp]
  00027	48 8b 4d 60	 mov	 rcx, QWORD PTR this$[rbp]
  0002b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00030	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [rcx+4]
  00034	72 2f		 jb	 SHORT $LN3@Contains
  00036	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0003a	48 8b 4d 68	 mov	 rcx, QWORD PTR r$[rbp]
  0003e	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00043	0f 2f 41 08	 comiss	 xmm0, DWORD PTR [rcx+8]
  00047	72 1c		 jb	 SHORT $LN3@Contains
  00049	48 8b 45 60	 mov	 rax, QWORD PTR this$[rbp]
  0004d	48 8b 4d 68	 mov	 rcx, QWORD PTR r$[rbp]
  00051	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  00056	0f 2f 41 0c	 comiss	 xmm0, DWORD PTR [rcx+12]
  0005a	72 09		 jb	 SHORT $LN3@Contains
  0005c	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv84[rbp], 1
  00063	eb 07		 jmp	 SHORT $LN4@Contains
$LN3@Contains:
  00065	c7 45 40 00 00
	00 00		 mov	 DWORD PTR tv84[rbp], 0
$LN4@Contains:
  0006c	0f b6 45 40	 movzx	 eax, BYTE PTR tv84[rbp]
  00070	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00074	5d		 pop	 rbp
  00075	c3		 ret	 0
?Contains@ImRect@@QEBA_NAEBU1@@Z ENDP			; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetHeight@ImRect@@QEBAMXZ
_TEXT	SEGMENT
this$ = 80
?GetHeight@ImRect@@QEBAMXZ PROC				; ImRect::GetHeight, COMDAT

; 529  :     float       GetHeight() const                   { return Max.y - Min.y; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00011	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00015	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  0001a	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [rcx+4]
  0001f	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00023	5d		 pop	 rbp
  00024	c3		 ret	 0
?GetHeight@ImRect@@QEBAMXZ ENDP				; ImRect::GetHeight
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetWidth@ImRect@@QEBAMXZ
_TEXT	SEGMENT
this$ = 80
?GetWidth@ImRect@@QEBAMXZ PROC				; ImRect::GetWidth, COMDAT

; 528  :     float       GetWidth() const                    { return Max.x - Min.x; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00011	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00015	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  0001a	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [rcx]
  0001e	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00022	5d		 pop	 rbp
  00023	c3		 ret	 0
?GetWidth@ImRect@@QEBAMXZ ENDP				; ImRect::GetWidth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?GetSize@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?GetSize@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetSize, COMDAT

; 527  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00018	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0001c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  00021	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [rcx+4]
  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  0002e	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  00033	f3 0f 5c 09	 subss	 xmm1, DWORD PTR [rcx]
  00037	0f 28 d0	 movaps	 xmm2, xmm0
  0003a	48 8b 4d 58	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0003e	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00043	48 8b 45 58	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  00047	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
?GetSize@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 80
x1$ = 88
y1$ = 96
x2$ = 104
y2$ = 112
??0ImRect@@QEAA@MMMM@Z PROC				; ImRect::ImRect, COMDAT

; 524  :     constexpr ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}

$LN3:
  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	55		 push	 rbp
  00018	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	f3 0f 10 55 60	 movss	 xmm2, DWORD PTR y1$[rbp]
  0002a	f3 0f 10 4d 58	 movss	 xmm1, DWORD PTR x1$[rbp]
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 83 c0 08	 add	 rax, 8
  0003f	f3 0f 10 55 70	 movss	 xmm2, DWORD PTR y2$[rbp]
  00044	f3 0f 10 4d 68	 movss	 xmm1, DWORD PTR x2$[rbp]
  00049	48 8b c8	 mov	 rcx, rax
  0004c	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00051	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00055	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
??0ImRect@@QEAA@MMMM@Z ENDP				; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@AEBUImVec4@@@Z
_TEXT	SEGMENT
this$ = 80
v$ = 88
??0ImRect@@QEAA@AEBUImVec4@@@Z PROC			; ImRect::ImRect, COMDAT

; 523  :     constexpr ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)      {}

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00014	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00018	48 8b 4d 58	 mov	 rcx, QWORD PTR v$[rbp]
  0001c	f3 0f 10 51 04	 movss	 xmm2, DWORD PTR [rcx+4]
  00021	48 8b 4d 58	 mov	 rcx, QWORD PTR v$[rbp]
  00025	f3 0f 10 09	 movss	 xmm1, DWORD PTR [rcx]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00031	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00035	48 83 c0 08	 add	 rax, 8
  00039	48 8b 4d 58	 mov	 rcx, QWORD PTR v$[rbp]
  0003d	f3 0f 10 51 0c	 movss	 xmm2, DWORD PTR [rcx+12]
  00042	48 8b 4d 58	 mov	 rcx, QWORD PTR v$[rbp]
  00046	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [rcx+8]
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00053	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00057	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0005b	5d		 pop	 rbp
  0005c	c3		 ret	 0
??0ImRect@@QEAA@AEBUImVec4@@@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@AEBUImVec2@@0@Z
_TEXT	SEGMENT
this$ = 80
min$ = 88
max$ = 96
??0ImRect@@QEAA@AEBUImVec2@@0@Z PROC			; ImRect::ImRect, COMDAT

; 522  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8b ec	 mov	 rbp, rsp
  00017	48 8b 45 58	 mov	 rax, QWORD PTR min$[rbp]
  0001b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001e	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00022	48 89 01	 mov	 QWORD PTR [rcx], rax
  00025	48 8b 45 60	 mov	 rax, QWORD PTR max$[rbp]
  00029	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002c	48 8b 4d 50	 mov	 rcx, QWORD PTR this$[rbp]
  00030	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??0ImRect@@QEAA@AEBUImVec2@@0@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0ImRect@@QEAA@XZ PROC					; ImRect::ImRect, COMDAT

; 521  :     constexpr ImRect()                                        : Min(0.0f, 0.0f), Max(0.0f, 0.0f)  {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00013	0f 57 d2	 xorps	 xmm2, xmm2
  00016	0f 57 c9	 xorps	 xmm1, xmm1
  00019	48 8b c8	 mov	 rcx, rax
  0001c	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00021	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00025	48 83 c0 08	 add	 rax, 8
  00029	0f 57 d2	 xorps	 xmm2, xmm2
  0002c	0f 57 c9	 xorps	 xmm1, xmm1
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00037	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003f	5d		 pop	 rbp
  00040	c3		 ret	 0
??0ImRect@@QEAA@XZ ENDP					; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??0ImVec1@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0ImVec1@@QEAA@XZ PROC					; ImVec1::ImVec1, COMDAT

; 501  :     constexpr ImVec1()         : x(0.0f) { }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00011	0f 57 c0	 xorps	 xmm0, xmm0
  00014	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00018	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001c	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  00020	5d		 pop	 rbp
  00021	c3		 ret	 0
??0ImVec1@@QEAA@XZ ENDP					; ImVec1::ImVec1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??$ImMax@M@@YAMMM@Z
_TEXT	SEGMENT
tv65 = 192
lhs$ = 240
rhs$ = 248
??$ImMax@M@@YAMMM@Z PROC				; ImMax<float>, COMDAT

; 453  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  0000c	55		 push	 rbp
  0000d	57		 push	 rdi
  0000e	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00015	48 8d 6c 24 10	 lea	 rbp, QWORD PTR [rsp+16]
  0001a	48 8b fc	 mov	 rdi, rsp
  0001d	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	f3 0f 10 85 f0
	00 00 00	 movss	 xmm0, DWORD PTR lhs$[rbp]
  00031	0f 2f 85 f8 00
	00 00		 comiss	 xmm0, DWORD PTR rhs$[rbp]
  00038	72 12		 jb	 SHORT $LN3@ImMax
  0003a	f3 0f 10 85 f0
	00 00 00	 movss	 xmm0, DWORD PTR lhs$[rbp]
  00042	f3 0f 11 85 c0
	00 00 00	 movss	 DWORD PTR tv65[rbp], xmm0
  0004a	eb 10		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  0004c	f3 0f 10 85 f8
	00 00 00	 movss	 xmm0, DWORD PTR rhs$[rbp]
  00054	f3 0f 11 85 c0
	00 00 00	 movss	 DWORD PTR tv65[rbp], xmm0
$LN4@ImMax:
  0005c	f3 0f 10 85 c0
	00 00 00	 movss	 xmm0, DWORD PTR tv65[rbp]
  00064	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0006b	5f		 pop	 rdi
  0006c	5d		 pop	 rbp
  0006d	c3		 ret	 0
??$ImMax@M@@YAMMM@Z ENDP				; ImMax<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??$ImMin@M@@YAMMM@Z
_TEXT	SEGMENT
tv65 = 192
lhs$ = 240
rhs$ = 248
??$ImMin@M@@YAMMM@Z PROC				; ImMin<float>, COMDAT

; 452  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  0000c	55		 push	 rbp
  0000d	57		 push	 rdi
  0000e	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00015	48 8d 6c 24 10	 lea	 rbp, QWORD PTR [rsp+16]
  0001a	48 8b fc	 mov	 rdi, rsp
  0001d	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	f3 0f 10 85 f8
	00 00 00	 movss	 xmm0, DWORD PTR rhs$[rbp]
  00031	0f 2f 85 f0 00
	00 00		 comiss	 xmm0, DWORD PTR lhs$[rbp]
  00038	76 12		 jbe	 SHORT $LN3@ImMin
  0003a	f3 0f 10 85 f0
	00 00 00	 movss	 xmm0, DWORD PTR lhs$[rbp]
  00042	f3 0f 11 85 c0
	00 00 00	 movss	 DWORD PTR tv65[rbp], xmm0
  0004a	eb 10		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  0004c	f3 0f 10 85 f8
	00 00 00	 movss	 xmm0, DWORD PTR rhs$[rbp]
  00054	f3 0f 11 85 c0
	00 00 00	 movss	 DWORD PTR tv65[rbp], xmm0
$LN4@ImMin:
  0005c	f3 0f 10 85 c0
	00 00 00	 movss	 xmm0, DWORD PTR tv65[rbp]
  00064	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0006b	5f		 pop	 rdi
  0006c	5d		 pop	 rbp
  0006d	c3		 ret	 0
??$ImMin@M@@YAMMM@Z ENDP				; ImMin<float>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ImFloor@@YAMM@Z
_TEXT	SEGMENT
f$ = 80
?ImFloor@@YAMM@Z PROC					; ImFloor, COMDAT

; 470  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	55		 push	 rbp
  00007	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000b	48 8b ec	 mov	 rbp, rsp
  0000e	f3 0f 2c 45 50	 cvttss2si eax, DWORD PTR f$[rbp]
  00013	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00017	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z
_TEXT	SEGMENT
tv74 = 64
tv73 = 68
tv84 = 72
tv83 = 76
__$ReturnUdt$ = 96
v$ = 104
mn$ = 112
mx$ = 120
?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z PROC		; ImClamp, COMDAT

; 462  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8b 45 70	 mov	 rax, QWORD PTR mn$[rbp]
  00022	48 8b 4d 68	 mov	 rcx, QWORD PTR v$[rbp]
  00026	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0002b	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [rcx+4]
  0002f	76 10		 jbe	 SHORT $LN5@ImClamp
  00031	48 8b 45 70	 mov	 rax, QWORD PTR mn$[rbp]
  00035	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0003a	f3 0f 11 45 40	 movss	 DWORD PTR tv74[rbp], xmm0
  0003f	eb 33		 jmp	 SHORT $LN6@ImClamp
$LN5@ImClamp:
  00041	48 8b 45 68	 mov	 rax, QWORD PTR v$[rbp]
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0004a	0f 2f 45 7c	 comiss	 xmm0, DWORD PTR mx$[rbp+4]
  0004e	76 0c		 jbe	 SHORT $LN3@ImClamp
  00050	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR mx$[rbp+4]
  00055	f3 0f 11 45 44	 movss	 DWORD PTR tv73[rbp], xmm0
  0005a	eb 0e		 jmp	 SHORT $LN4@ImClamp
$LN3@ImClamp:
  0005c	48 8b 45 68	 mov	 rax, QWORD PTR v$[rbp]
  00060	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00065	f3 0f 11 45 44	 movss	 DWORD PTR tv73[rbp], xmm0
$LN4@ImClamp:
  0006a	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR tv73[rbp]
  0006f	f3 0f 11 45 40	 movss	 DWORD PTR tv74[rbp], xmm0
$LN6@ImClamp:
  00074	48 8b 45 70	 mov	 rax, QWORD PTR mn$[rbp]
  00078	48 8b 4d 68	 mov	 rcx, QWORD PTR v$[rbp]
  0007c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00080	0f 2f 01	 comiss	 xmm0, DWORD PTR [rcx]
  00083	76 0f		 jbe	 SHORT $LN9@ImClamp
  00085	48 8b 45 70	 mov	 rax, QWORD PTR mn$[rbp]
  00089	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0008d	f3 0f 11 45 48	 movss	 DWORD PTR tv84[rbp], xmm0
  00092	eb 31		 jmp	 SHORT $LN10@ImClamp
$LN9@ImClamp:
  00094	48 8b 45 68	 mov	 rax, QWORD PTR v$[rbp]
  00098	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0009c	0f 2f 45 78	 comiss	 xmm0, DWORD PTR mx$[rbp]
  000a0	76 0c		 jbe	 SHORT $LN7@ImClamp
  000a2	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR mx$[rbp]
  000a7	f3 0f 11 45 4c	 movss	 DWORD PTR tv83[rbp], xmm0
  000ac	eb 0d		 jmp	 SHORT $LN8@ImClamp
$LN7@ImClamp:
  000ae	48 8b 45 68	 mov	 rax, QWORD PTR v$[rbp]
  000b2	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  000b6	f3 0f 11 45 4c	 movss	 DWORD PTR tv83[rbp], xmm0
$LN8@ImClamp:
  000bb	f3 0f 10 45 4c	 movss	 xmm0, DWORD PTR tv83[rbp]
  000c0	f3 0f 11 45 48	 movss	 DWORD PTR tv84[rbp], xmm0
$LN10@ImClamp:
  000c5	f3 0f 10 55 40	 movss	 xmm2, DWORD PTR tv74[rbp]
  000ca	f3 0f 10 4d 48	 movss	 xmm1, DWORD PTR tv84[rbp]
  000cf	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  000d3	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  000d8	48 8b 45 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  000dc	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  000e0	5d		 pop	 rbp
  000e1	c3		 ret	 0
?ImClamp@@YA?AUImVec2@@AEBU1@0U1@@Z ENDP		; ImClamp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ImMax@@YA?AUImVec2@@AEBU1@0@Z
_TEXT	SEGMENT
tv71 = 64
tv78 = 68
__$ReturnUdt$ = 96
lhs$ = 104
rhs$ = 112
?ImMax@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMax, COMDAT

; 461  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8b 45 68	 mov	 rax, QWORD PTR lhs$[rbp]
  0001d	48 8b 4d 70	 mov	 rcx, QWORD PTR rhs$[rbp]
  00021	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00026	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [rcx+4]
  0002a	72 10		 jb	 SHORT $LN3@ImMax
  0002c	48 8b 45 68	 mov	 rax, QWORD PTR lhs$[rbp]
  00030	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00035	f3 0f 11 45 40	 movss	 DWORD PTR tv71[rbp], xmm0
  0003a	eb 0e		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  0003c	48 8b 45 70	 mov	 rax, QWORD PTR rhs$[rbp]
  00040	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00045	f3 0f 11 45 40	 movss	 DWORD PTR tv71[rbp], xmm0
$LN4@ImMax:
  0004a	48 8b 45 68	 mov	 rax, QWORD PTR lhs$[rbp]
  0004e	48 8b 4d 70	 mov	 rcx, QWORD PTR rhs$[rbp]
  00052	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00056	0f 2f 01	 comiss	 xmm0, DWORD PTR [rcx]
  00059	72 0f		 jb	 SHORT $LN5@ImMax
  0005b	48 8b 45 68	 mov	 rax, QWORD PTR lhs$[rbp]
  0005f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00063	f3 0f 11 45 44	 movss	 DWORD PTR tv78[rbp], xmm0
  00068	eb 0d		 jmp	 SHORT $LN6@ImMax
$LN5@ImMax:
  0006a	48 8b 45 70	 mov	 rax, QWORD PTR rhs$[rbp]
  0006e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00072	f3 0f 11 45 44	 movss	 DWORD PTR tv78[rbp], xmm0
$LN6@ImMax:
  00077	f3 0f 10 55 40	 movss	 xmm2, DWORD PTR tv71[rbp]
  0007c	f3 0f 10 4d 44	 movss	 xmm1, DWORD PTR tv78[rbp]
  00081	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00085	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  0008a	48 8b 45 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0008e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00092	5d		 pop	 rbp
  00093	c3		 ret	 0
?ImMax@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMax
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ImMin@@YA?AUImVec2@@AEBU1@0@Z
_TEXT	SEGMENT
tv71 = 64
tv78 = 68
__$ReturnUdt$ = 96
lhs$ = 104
rhs$ = 112
?ImMin@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMin, COMDAT

; 460  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8b 45 70	 mov	 rax, QWORD PTR rhs$[rbp]
  0001d	48 8b 4d 68	 mov	 rcx, QWORD PTR lhs$[rbp]
  00021	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00026	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [rcx+4]
  0002a	76 10		 jbe	 SHORT $LN3@ImMin
  0002c	48 8b 45 68	 mov	 rax, QWORD PTR lhs$[rbp]
  00030	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00035	f3 0f 11 45 40	 movss	 DWORD PTR tv71[rbp], xmm0
  0003a	eb 0e		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  0003c	48 8b 45 70	 mov	 rax, QWORD PTR rhs$[rbp]
  00040	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00045	f3 0f 11 45 40	 movss	 DWORD PTR tv71[rbp], xmm0
$LN4@ImMin:
  0004a	48 8b 45 70	 mov	 rax, QWORD PTR rhs$[rbp]
  0004e	48 8b 4d 68	 mov	 rcx, QWORD PTR lhs$[rbp]
  00052	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00056	0f 2f 01	 comiss	 xmm0, DWORD PTR [rcx]
  00059	76 0f		 jbe	 SHORT $LN5@ImMin
  0005b	48 8b 45 68	 mov	 rax, QWORD PTR lhs$[rbp]
  0005f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00063	f3 0f 11 45 44	 movss	 DWORD PTR tv78[rbp], xmm0
  00068	eb 0d		 jmp	 SHORT $LN6@ImMin
$LN5@ImMin:
  0006a	48 8b 45 70	 mov	 rax, QWORD PTR rhs$[rbp]
  0006e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00072	f3 0f 11 45 44	 movss	 DWORD PTR tv78[rbp], xmm0
$LN6@ImMin:
  00077	f3 0f 10 55 40	 movss	 xmm2, DWORD PTR tv71[rbp]
  0007c	f3 0f 10 4d 44	 movss	 xmm1, DWORD PTR tv78[rbp]
  00081	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00085	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  0008a	48 8b 45 60	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0008e	48 8d 65 50	 lea	 rsp, QWORD PTR [rbp+80]
  00092	5d		 pop	 rbp
  00093	c3		 ret	 0
?ImMin@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ??H@YA?AUImVec2@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 80
lhs$ = 88
rhs$ = 96
??H@YA?AUImVec2@@AEBU0@0@Z PROC				; operator+, COMDAT

; 382  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8b 45 58	 mov	 rax, QWORD PTR lhs$[rbp]
  0001d	48 8b 4d 60	 mov	 rcx, QWORD PTR rhs$[rbp]
  00021	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00026	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [rcx+4]
  0002b	48 8b 45 58	 mov	 rax, QWORD PTR lhs$[rbp]
  0002f	48 8b 4d 60	 mov	 rcx, QWORD PTR rhs$[rbp]
  00033	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  00037	f3 0f 58 09	 addss	 xmm1, DWORD PTR [rcx]
  0003b	0f 28 d0	 movaps	 xmm2, xmm0
  0003e	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00042	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00047	48 8b 45 50	 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0004b	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
??H@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_internal.h
;	COMDAT ?ImIsPowerOfTwo@@YA_NH@Z
_TEXT	SEGMENT
tv68 = 192
v$ = 240
?ImIsPowerOfTwo@@YA_NH@Z PROC				; ImIsPowerOfTwo, COMDAT

; 331  : static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0000d	48 8b ec	 mov	 rbp, rsp
  00010	48 8b fc	 mov	 rdi, rsp
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR [rsp+248]
  00026	83 bd f0 00 00
	00 00		 cmp	 DWORD PTR v$[rbp], 0
  0002d	74 22		 je	 SHORT $LN3@ImIsPowerO
  0002f	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR v$[rbp]
  00035	ff c8		 dec	 eax
  00037	8b 8d f0 00 00
	00		 mov	 ecx, DWORD PTR v$[rbp]
  0003d	23 c8		 and	 ecx, eax
  0003f	8b c1		 mov	 eax, ecx
  00041	85 c0		 test	 eax, eax
  00043	75 0c		 jne	 SHORT $LN3@ImIsPowerO
  00045	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv68[rbp], 1
  0004f	eb 0a		 jmp	 SHORT $LN4@ImIsPowerO
$LN3@ImIsPowerO:
  00051	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv68[rbp], 0
$LN4@ImIsPowerO:
  0005b	0f b6 85 c0 00
	00 00		 movzx	 eax, BYTE PTR tv68[rbp]
  00062	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00069	5f		 pop	 rdi
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
?ImIsPowerOfTwo@@YA_NH@Z ENDP				; ImIsPowerOfTwo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
__$ArrayPad$ = 248
_Buffer$ = 288
_Format$ = 296
sscanf	PROC						; COMDAT

; 2261 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8b fc	 mov	 rdi, rsp
  00025	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]
  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00040	48 33 c5	 xor	 rax, rbp
  00043	48 89 85 f8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 2262 :     int _Result;
; 2263 :     va_list _ArgList;
; 2264 :     __crt_va_start(_ArgList, _Format);

  0004a	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0004f	48 8d 85 30 01
	00 00		 lea	 rax, QWORD PTR _Format$[rbp+8]
  00056	48 89 45 28	 mov	 QWORD PTR _ArgList$[rbp], rax

; 2265 :     _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  0005a	4c 8b 4d 28	 mov	 r9, QWORD PTR _ArgList$[rbp]
  0005e	45 33 c0	 xor	 r8d, r8d
  00061	48 8b 95 28 01
	00 00		 mov	 rdx, QWORD PTR _Format$[rbp]
  00068	48 8b 8d 20 01
	00 00		 mov	 rcx, QWORD PTR _Buffer$[rbp]
  0006f	e8 00 00 00 00	 call	 _vsscanf_l
  00074	89 45 04	 mov	 DWORD PTR _Result$[rbp], eax

; 2266 :     __crt_va_end(_ArgList);

  00077	48 c7 45 28 00
	00 00 00	 mov	 QWORD PTR _ArgList$[rbp], 0

; 2267 :     return _Result;

  0007f	8b 45 04	 mov	 eax, DWORD PTR _Result$[rbp]

; 2268 : }

  00082	8b f8		 mov	 edi, eax
  00084	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sscanf$rtcFrameData
  0008f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00094	8b c7		 mov	 eax, edi
  00096	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0009d	48 33 cd	 xor	 rcx, rbp
  000a0	e8 00 00 00 00	 call	 __security_check_cookie
  000a5	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000ac	5f		 pop	 rdi
  000ad	5d		 pop	 rbp
  000ae	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 224
_Format$ = 232
_Locale$ = 240
_ArgList$ = 248
_vsscanf_l PROC						; COMDAT

; 2166 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8b fc	 mov	 rdi, rsp
  00025	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR [rsp+280]

; 2167 :     return __stdio_common_vsscanf(

  00039	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0003e	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR _ArgList$[rbp]
  00045	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR _Locale$[rbp]
  00051	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00056	4c 8b 8d e8 00
	00 00		 mov	 r9, QWORD PTR _Format$[rbp]
  0005d	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  00064	48 8b 95 e0 00
	00 00		 mov	 rdx, QWORD PTR _Buffer$[rbp]
  0006b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2168 :         _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2169 :         _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2170 : }

  00074	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0007b	5f		 pop	 rdi
  0007c	5d		 pop	 rbp
  0007d	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 144  :         {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  0001c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00023	5f		 pop	 rdi
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 82   : {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd

; 83   :     static unsigned __int64 _OptionsStorage;
; 84   :     return &_OptionsStorage;

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 85   : }

  00023	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0002a	5f		 pop	 rdi
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@M@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 8
this$ = 256
new_capacity$ = 264
?reserve@?$ImVector@M@@QEAAXH@Z PROC			; ImVector<float>::reserve, COMDAT

; 1803 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 08 01 00
	00		 cmp	 DWORD PTR new_capacity$[rbp], eax
  0003e	7f 02		 jg	 SHORT $LN2@reserve
  00040	eb 79		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  00042	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR new_capacity$[rbp]
  00049	48 c1 e0 02	 shl	 rax, 2
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  00055	48 89 45 08	 mov	 QWORD PTR new_data$[rbp], rax
  00059	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00060	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00065	74 35		 je	 SHORT $LN3@reserve
  00067	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006e	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00071	48 c1 e0 02	 shl	 rax, 2
  00075	4c 8b c0	 mov	 r8, rax
  00078	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00083	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  00087	e8 00 00 00 00	 call	 memcpy
  0008c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00093	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00097	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN3@reserve:
  0009c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a3	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  000a7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000ab	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b2	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_capacity$[rbp]
  000b8	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN1@reserve:
  000bb	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	c3		 ret	 0
?reserve@?$ImVector@M@@QEAAXH@Z ENDP			; ImVector<float>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@M@@QEAAXHAEBM@Z
_TEXT	SEGMENT
n$1 = 4
this$ = 256
new_size$ = 264
v$ = 272
?resize@?$ImVector@M@@QEAAXHAEBM@Z PROC			; ImVector<float>::resize, COMDAT

; 1801 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  00033	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0003d	39 85 08 01 00
	00		 cmp	 DWORD PTR new_size$[rbp], eax
  00043	7e 20		 jle	 SHORT $LN5@resize
  00045	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR new_size$[rbp]
  0004b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00052	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@M@@QEBAHH@Z ; ImVector<float>::_grow_capacity
  00057	8b d0		 mov	 edx, eax
  00059	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00060	e8 00 00 00 00	 call	 ?reserve@?$ImVector@M@@QEAAXH@Z ; ImVector<float>::reserve
$LN5@resize:
  00065	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006c	8b 00		 mov	 eax, DWORD PTR [rax]
  0006e	39 85 08 01 00
	00		 cmp	 DWORD PTR new_size$[rbp], eax
  00074	7e 4b		 jle	 SHORT $LN6@resize
  00076	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007d	8b 00		 mov	 eax, DWORD PTR [rax]
  0007f	89 45 04	 mov	 DWORD PTR n$1[rbp], eax
  00082	eb 08		 jmp	 SHORT $LN4@resize
$LN2@resize:
  00084	8b 45 04	 mov	 eax, DWORD PTR n$1[rbp]
  00087	ff c0		 inc	 eax
  00089	89 45 04	 mov	 DWORD PTR n$1[rbp], eax
$LN4@resize:
  0008c	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR new_size$[rbp]
  00092	39 45 04	 cmp	 DWORD PTR n$1[rbp], eax
  00095	7d 2a		 jge	 SHORT $LN3@resize
  00097	48 63 45 04	 movsxd	 rax, DWORD PTR n$1[rbp]
  0009b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a2	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a6	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000aa	41 b8 04 00 00
	00		 mov	 r8d, 4
  000b0	48 8b 95 10 01
	00 00		 mov	 rdx, QWORD PTR v$[rbp]
  000b7	48 8b c8	 mov	 rcx, rax
  000ba	e8 00 00 00 00	 call	 memcpy
  000bf	eb c3		 jmp	 SHORT $LN2@resize
$LN3@resize:
$LN6@resize:
  000c1	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000c8	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_size$[rbp]
  000ce	89 08		 mov	 DWORD PTR [rax], ecx
  000d0	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000d7	5f		 pop	 rdi
  000d8	5d		 pop	 rbp
  000d9	c3		 ret	 0
?resize@?$ImVector@M@@QEAAXHAEBM@Z ENDP			; ImVector<float>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@M@@QEBAHH@Z
_TEXT	SEGMENT
new_capacity$ = 4
tv72 = 212
tv70 = 212
this$ = 256
sz$ = 264
?_grow_capacity@?$ImVector@M@@QEBAHH@Z PROC		; ImVector<float>::_grow_capacity, COMDAT

; 1799 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 8b fc	 mov	 rdi, rsp
  00018	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00037	74 21		 je	 SHORT $LN3@grow_capac
  00039	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00043	99		 cdq
  00044	2b c2		 sub	 eax, edx
  00046	d1 f8		 sar	 eax, 1
  00048	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004f	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00052	89 85 d4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00058	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0005a	c7 85 d4 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv70[rbp], 8
$LN4@grow_capac:
  00064	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  0006a	89 45 04	 mov	 DWORD PTR new_capacity$[rbp], eax
  0006d	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00073	39 45 04	 cmp	 DWORD PTR new_capacity$[rbp], eax
  00076	7e 0b		 jle	 SHORT $LN5@grow_capac
  00078	8b 45 04	 mov	 eax, DWORD PTR new_capacity$[rbp]
  0007b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00081	eb 0c		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00083	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00089	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
$LN6@grow_capac:
  0008f	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  00095	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0009c	5f		 pop	 rdi
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
?_grow_capacity@?$ImVector@M@@QEBAHH@Z ENDP		; ImVector<float>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??A?$ImVector@M@@QEAAAEAMH@Z
_TEXT	SEGMENT
this$ = 224
i$ = 232
??A?$ImVector@M@@QEAAAEAMH@Z PROC			; ImVector<float>::operator[], COMDAT

; 1786 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  00035	7c 11		 jl	 SHORT $LN3@operator
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00048	41 b8 fa 06 00
	00		 mov	 r8d, 1786		; 000006faH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@operator:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0006b	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00072	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00076	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  0007a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00081	5f		 pop	 rdi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
??A?$ImVector@M@@QEAAAEAMH@Z ENDP			; ImVector<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?back@?$ImVector@I@@QEAAAEAIXZ
_TEXT	SEGMENT
this$ = 224
?back@?$ImVector@I@@QEAAAEAIXZ PROC			; ImVector<unsigned int>::back, COMDAT

; 1795 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	83 38 00	 cmp	 DWORD PTR [rax], 0
  00034	7f 1c		 jg	 SHORT $LN3@back
  00036	41 b8 03 07 00
	00		 mov	 r8d, 1795		; 00000703H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN3@back:
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	8b 00		 mov	 eax, DWORD PTR [rax]
  0005b	ff c8		 dec	 eax
  0005d	48 98		 cdqe
  0005f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00066	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0006a	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  0006e	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00075	5f		 pop	 rdi
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
?back@?$ImVector@I@@QEAAAEAIXZ ENDP			; ImVector<unsigned int>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ
_TEXT	SEGMENT
this$ = 224
?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ PROC	; ImVector<ImVec4>::back, COMDAT

; 1795 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	83 38 00	 cmp	 DWORD PTR [rax], 0
  00034	7f 1c		 jg	 SHORT $LN3@back
  00036	41 b8 03 07 00
	00		 mov	 r8d, 1795		; 00000703H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN3@back:
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	8b 00		 mov	 eax, DWORD PTR [rax]
  0005b	ff c8		 dec	 eax
  0005d	48 98		 cdqe
  0005f	48 6b c0 10	 imul	 rax, rax, 16
  00063	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0006e	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00075	5f		 pop	 rdi
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ ENDP	; ImVector<ImVec4>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?Clear@ImDrawListSplitter@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?Clear@ImDrawListSplitter@@QEAAXXZ PROC			; ImDrawListSplitter::Clear, COMDAT

; 2451 :     inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00035	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1
  00043	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004a	5f		 pop	 rdi
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
?Clear@ImDrawListSplitter@@QEAAXXZ ENDP			; ImDrawListSplitter::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??1ImDrawListSplitter@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1ImDrawListSplitter@@QEAA@XZ PROC			; ImDrawListSplitter::~ImDrawListSplitter, COMDAT

; 2450 :     inline ~ImDrawListSplitter() { ClearFreeMemory(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002a	48 c7 85 c8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T1[rbp], -2
  00035	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0003c	e8 00 00 00 00	 call	 ?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ ; ImDrawListSplitter::ClearFreeMemory
  00041	90		 npad	 1
  00042	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00049	48 83 c0 08	 add	 rax, 8
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ??1?$ImVector@UImDrawChannel@@@@QEAA@XZ ; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
  00055	90		 npad	 1
  00056	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0005d	5f		 pop	 rdi
  0005e	5d		 pop	 rbp
  0005f	c3		 ret	 0
??1ImDrawListSplitter@@QEAA@XZ ENDP			; ImDrawListSplitter::~ImDrawListSplitter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0ImDrawListSplitter@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0ImDrawListSplitter@@QEAA@XZ PROC			; ImDrawListSplitter::ImDrawListSplitter, COMDAT

; 2449 :     inline ImDrawListSplitter()  { memset(this, 0, sizeof(*this)); }

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 83 c0 08	 add	 rax, 8
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 ??0?$ImVector@UImDrawChannel@@@@QEAA@XZ ; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
  0003d	41 b8 18 00 00
	00		 mov	 r8d, 24
  00043	33 d2		 xor	 edx, edx
  00045	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004c	e8 00 00 00 00	 call	 memset
  00051	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00058	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005f	5f		 pop	 rdi
  00060	5d		 pop	 rbp
  00061	c3		 ret	 0
??0ImDrawListSplitter@@QEAA@XZ ENDP			; ImDrawListSplitter::ImDrawListSplitter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 8
this$ = 256
new_capacity$ = 264
?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z PROC	; ImVector<ImDrawChannel>::reserve, COMDAT

; 1803 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 08 01 00
	00		 cmp	 DWORD PTR new_capacity$[rbp], eax
  0003e	7f 02		 jg	 SHORT $LN2@reserve
  00040	eb 79		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  00042	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR new_capacity$[rbp]
  00049	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  00055	48 89 45 08	 mov	 QWORD PTR new_data$[rbp], rax
  00059	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00060	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00065	74 35		 je	 SHORT $LN3@reserve
  00067	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006e	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00071	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00075	4c 8b c0	 mov	 r8, rax
  00078	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00083	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  00087	e8 00 00 00 00	 call	 memcpy
  0008c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00093	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00097	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN3@reserve:
  0009c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000a3	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  000a7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000ab	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b2	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_capacity$[rbp]
  000b8	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN1@reserve:
  000bb	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	c3		 ret	 0
?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ENDP	; ImVector<ImDrawChannel>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 224
new_size$ = 232
?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z PROC	; ImVector<ImDrawChannel>::resize, COMDAT

; 1800 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 e8 00 00
	00		 cmp	 DWORD PTR new_size$[rbp], eax
  0003e	7e 20		 jle	 SHORT $LN2@resize
  00040	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR new_size$[rbp]
  00046	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004d	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z ; ImVector<ImDrawChannel>::_grow_capacity
  00052	8b d0		 mov	 edx, eax
  00054	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005b	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ; ImVector<ImDrawChannel>::reserve
$LN2@resize:
  00060	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00067	8b 8d e8 00 00
	00		 mov	 ecx, DWORD PTR new_size$[rbp]
  0006d	89 08		 mov	 DWORD PTR [rax], ecx
  0006f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00076	5f		 pop	 rdi
  00077	5d		 pop	 rbp
  00078	c3		 ret	 0
?resize@?$ImVector@UImDrawChannel@@@@QEAAXH@Z ENDP	; ImVector<ImDrawChannel>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z
_TEXT	SEGMENT
new_capacity$ = 4
tv72 = 212
tv70 = 212
this$ = 256
sz$ = 264
?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z PROC ; ImVector<ImDrawChannel>::_grow_capacity, COMDAT

; 1799 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 8b fc	 mov	 rdi, rsp
  00018	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00037	74 21		 je	 SHORT $LN3@grow_capac
  00039	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00043	99		 cdq
  00044	2b c2		 sub	 eax, edx
  00046	d1 f8		 sar	 eax, 1
  00048	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004f	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00052	89 85 d4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00058	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0005a	c7 85 d4 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv70[rbp], 8
$LN4@grow_capac:
  00064	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  0006a	89 45 04	 mov	 DWORD PTR new_capacity$[rbp], eax
  0006d	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00073	39 45 04	 cmp	 DWORD PTR new_capacity$[rbp], eax
  00076	7e 0b		 jle	 SHORT $LN5@grow_capac
  00078	8b 45 04	 mov	 eax, DWORD PTR new_capacity$[rbp]
  0007b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00081	eb 0c		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00083	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00089	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
$LN6@grow_capac:
  0008f	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  00095	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0009c	5f		 pop	 rdi
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
?_grow_capacity@?$ImVector@UImDrawChannel@@@@QEBAHH@Z ENDP ; ImVector<ImDrawChannel>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z
_TEXT	SEGMENT
this$ = 224
i$ = 232
??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z PROC ; ImVector<ImDrawChannel>::operator[], COMDAT

; 1786 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  00035	7c 11		 jl	 SHORT $LN3@operator
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00048	41 b8 fa 06 00
	00		 mov	 r8d, 1786		; 000006faH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@operator:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0006b	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0006f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00076	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0007a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00081	5f		 pop	 rdi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ENDP ; ImVector<ImDrawChannel>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawChannel@@@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1?$ImVector@UImDrawChannel@@@@QEAA@XZ PROC		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>, COMDAT

; 1775 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002a	48 c7 85 c8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T1[rbp], -2
  00035	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00041	74 11		 je	 SHORT $LN2@ImVector
  00043	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0004e	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
  00053	90		 npad	 1
$LN2@ImVector:
  00054	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0005b	5f		 pop	 rdi
  0005c	5d		 pop	 rbp
  0005d	c3		 ret	 0
??1?$ImVector@UImDrawChannel@@@@QEAA@XZ ENDP		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawChannel@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$ImVector@UImDrawChannel@@@@QEAA@XZ PROC		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>, COMDAT

; 1772 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00036	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00043	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00060	5f		 pop	 rdi
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
??0?$ImVector@UImDrawChannel@@@@QEAA@XZ ENDP		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ PROC		; ImVector<ImDrawCmd>::pop_back, COMDAT

; 1808 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	83 38 00	 cmp	 DWORD PTR [rax], 0
  00034	7f 1c		 jg	 SHORT $LN3@pop_back
  00036	41 b8 10 07 00
	00		 mov	 r8d, 1808		; 00000710H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN3@pop_back:
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	8b 00		 mov	 eax, DWORD PTR [rax]
  0005b	ff c8		 dec	 eax
  0005d	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00064	89 01		 mov	 DWORD PTR [rcx], eax
  00066	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0006d	5f		 pop	 rdi
  0006e	5d		 pop	 rbp
  0006f	c3		 ret	 0
?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ENDP		; ImVector<ImDrawCmd>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ
_TEXT	SEGMENT
this$ = 224
?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ PROC ; ImVector<ImDrawCmd>::back, COMDAT

; 1795 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	83 38 00	 cmp	 DWORD PTR [rax], 0
  00034	7f 1c		 jg	 SHORT $LN3@back
  00036	41 b8 03 07 00
	00		 mov	 r8d, 1795		; 00000703H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN3@back:
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	8b 00		 mov	 eax, DWORD PTR [rax]
  0005b	ff c8		 dec	 eax
  0005d	48 98		 cdqe
  0005f	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00063	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0006e	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00075	5f		 pop	 rdi
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ENDP ; ImVector<ImDrawCmd>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z
_TEXT	SEGMENT
this$ = 224
i$ = 232
??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT

; 1786 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  00035	7c 11		 jl	 SHORT $LN3@operator
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00048	41 b8 fa 06 00
	00		 mov	 r8d, 1786		; 000006faH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@operator:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0006b	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0006f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00076	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0007a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00081	5f		 pop	 rdi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
??A?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiStoragePair@ImGuiStorage@@@@QEAAAEAUImGuiStoragePair@ImGuiStorage@@H@Z
_TEXT	SEGMENT
this$ = 224
i$ = 232
??A?$ImVector@UImGuiStoragePair@ImGuiStorage@@@@QEAAAEAUImGuiStoragePair@ImGuiStorage@@H@Z PROC ; ImVector<ImGuiStorage::ImGuiStoragePair>::operator[], COMDAT

; 1786 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  00035	7c 11		 jl	 SHORT $LN3@operator
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00048	41 b8 fa 06 00
	00		 mov	 r8d, 1786		; 000006faH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@operator:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0006b	48 6b c0 10	 imul	 rax, rax, 16
  0006f	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00076	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0007a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00081	5f		 pop	 rdi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
??A?$ImVector@UImGuiStoragePair@ImGuiStorage@@@@QEAAAEAUImGuiStoragePair@ImGuiStorage@@H@Z ENDP ; ImVector<ImGuiStorage::ImGuiStoragePair>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1ImGuiTextBuffer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1ImGuiTextBuffer@@QEAA@XZ PROC			; ImGuiTextBuffer::~ImGuiTextBuffer, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ??1?$ImVector@D@@QEAA@XZ ; ImVector<char>::~ImVector<char>
  00039	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00040	5f		 pop	 rdi
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
??1ImGuiTextBuffer@@QEAA@XZ ENDP			; ImGuiTextBuffer::~ImGuiTextBuffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?reserve@ImGuiTextBuffer@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 224
capacity$ = 232
?reserve@ImGuiTextBuffer@@QEAAXH@Z PROC			; ImGuiTextBuffer::reserve, COMDAT

; 2215 :     void                reserve(int capacity)   { Buf.reserve(capacity); }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR capacity$[rbp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 ?reserve@?$ImVector@D@@QEAAXH@Z ; ImVector<char>::reserve
  00043	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004a	5f		 pop	 rdi
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
?reserve@ImGuiTextBuffer@@QEAAXH@Z ENDP			; ImGuiTextBuffer::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?clear@ImGuiTextBuffer@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?clear@ImGuiTextBuffer@@QEAAXXZ PROC			; ImGuiTextBuffer::clear, COMDAT

; 2214 :     void                clear()                 { Buf.clear(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ?clear@?$ImVector@D@@QEAAXXZ ; ImVector<char>::clear
  00039	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00040	5f		 pop	 rdi
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?clear@ImGuiTextBuffer@@QEAAXXZ ENDP			; ImGuiTextBuffer::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?size@ImGuiTextBuffer@@QEBAHXZ
_TEXT	SEGMENT
tv70 = 192
this$ = 240
?size@ImGuiTextBuffer@@QEBAHXZ PROC			; ImGuiTextBuffer::size, COMDAT

; 2212 :     int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+248]
  00028	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00032	74 13		 je	 SHORT $LN3@size
  00034	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003b	8b 00		 mov	 eax, DWORD PTR [rax]
  0003d	ff c8		 dec	 eax
  0003f	89 85 c0 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00045	eb 0a		 jmp	 SHORT $LN4@size
$LN3@size:
  00047	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv70[rbp], 0
$LN4@size:
  00051	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  00057	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0005e	5f		 pop	 rdi
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
?size@ImGuiTextBuffer@@QEBAHXZ ENDP			; ImGuiTextBuffer::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0ImGuiTextBuffer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0ImGuiTextBuffer@@QEAA@XZ PROC			; ImGuiTextBuffer::ImGuiTextBuffer, COMDAT

; 2208 :     ImGuiTextBuffer()   { }

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ??0?$ImVector@D@@QEAA@XZ ; ImVector<char>::ImVector<char>
  00039	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00047	5f		 pop	 rdi
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
??0ImGuiTextBuffer@@QEAA@XZ ENDP			; ImGuiTextBuffer::ImGuiTextBuffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@D@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 8
this$ = 256
new_capacity$ = 264
?reserve@?$ImVector@D@@QEAAXH@Z PROC			; ImVector<char>::reserve, COMDAT

; 1803 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 08 01 00
	00		 cmp	 DWORD PTR new_capacity$[rbp], eax
  0003e	7f 02		 jg	 SHORT $LN2@reserve
  00040	eb 71		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  00042	48 63 85 08 01
	00 00		 movsxd	 rax, DWORD PTR new_capacity$[rbp]
  00049	48 8b c8	 mov	 rcx, rax
  0004c	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  00051	48 89 45 08	 mov	 QWORD PTR new_data$[rbp], rax
  00055	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00061	74 31		 je	 SHORT $LN3@reserve
  00063	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006a	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0006d	4c 8b c0	 mov	 r8, rax
  00070	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00077	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0007b	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  0007f	e8 00 00 00 00	 call	 memcpy
  00084	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0008f	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN3@reserve:
  00094	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0009b	48 8b 4d 08	 mov	 rcx, QWORD PTR new_data$[rbp]
  0009f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000a3	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000aa	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR new_capacity$[rbp]
  000b0	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN1@reserve:
  000b3	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000ba	5f		 pop	 rdi
  000bb	5d		 pop	 rbp
  000bc	c3		 ret	 0
?reserve@?$ImVector@D@@QEAAXH@Z ENDP			; ImVector<char>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@D@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 224
new_size$ = 232
?resize@?$ImVector@D@@QEAAXH@Z PROC			; ImVector<char>::resize, COMDAT

; 1800 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00038	39 85 e8 00 00
	00		 cmp	 DWORD PTR new_size$[rbp], eax
  0003e	7e 20		 jle	 SHORT $LN2@resize
  00040	8b 95 e8 00 00
	00		 mov	 edx, DWORD PTR new_size$[rbp]
  00046	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004d	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@D@@QEBAHH@Z ; ImVector<char>::_grow_capacity
  00052	8b d0		 mov	 edx, eax
  00054	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0005b	e8 00 00 00 00	 call	 ?reserve@?$ImVector@D@@QEAAXH@Z ; ImVector<char>::reserve
$LN2@resize:
  00060	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00067	8b 8d e8 00 00
	00		 mov	 ecx, DWORD PTR new_size$[rbp]
  0006d	89 08		 mov	 DWORD PTR [rax], ecx
  0006f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00076	5f		 pop	 rdi
  00077	5d		 pop	 rbp
  00078	c3		 ret	 0
?resize@?$ImVector@D@@QEAAXH@Z ENDP			; ImVector<char>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@D@@QEBAHH@Z
_TEXT	SEGMENT
new_capacity$ = 4
tv72 = 212
tv70 = 212
this$ = 256
sz$ = 264
?_grow_capacity@?$ImVector@D@@QEBAHH@Z PROC		; ImVector<char>::_grow_capacity, COMDAT

; 1799 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 8b fc	 mov	 rdi, rsp
  00018	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00033	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00037	74 21		 je	 SHORT $LN3@grow_capac
  00039	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00043	99		 cdq
  00044	2b c2		 sub	 eax, edx
  00046	d1 f8		 sar	 eax, 1
  00048	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0004f	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00052	89 85 d4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00058	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0005a	c7 85 d4 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv70[rbp], 8
$LN4@grow_capac:
  00064	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv70[rbp]
  0006a	89 45 04	 mov	 DWORD PTR new_capacity$[rbp], eax
  0006d	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00073	39 45 04	 cmp	 DWORD PTR new_capacity$[rbp], eax
  00076	7e 0b		 jle	 SHORT $LN5@grow_capac
  00078	8b 45 04	 mov	 eax, DWORD PTR new_capacity$[rbp]
  0007b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00081	eb 0c		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00083	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR sz$[rbp]
  00089	89 85 d4 00 00
	00		 mov	 DWORD PTR tv72[rbp], eax
$LN6@grow_capac:
  0008f	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  00095	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0009c	5f		 pop	 rdi
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
?_grow_capacity@?$ImVector@D@@QEBAHH@Z ENDP		; ImVector<char>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?swap@?$ImVector@D@@QEAAXAEAU1@@Z
_TEXT	SEGMENT
rhs_size$ = 4
rhs_cap$ = 36
rhs_data$ = 72
this$ = 320
rhs$ = 328
?swap@?$ImVector@D@@QEAAXAEAU1@@Z PROC			; ImVector<char>::swap, COMDAT

; 1797 :     inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00013	48 8b ec	 mov	 rbp, rsp
  00016	48 8b fc	 mov	 rdi, rsp
  00019	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]
  0002d	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR rhs$[rbp]
  00034	8b 00		 mov	 eax, DWORD PTR [rax]
  00036	89 45 04	 mov	 DWORD PTR rhs_size$[rbp], eax
  00039	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR rhs$[rbp]
  00040	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00047	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00049	89 08		 mov	 DWORD PTR [rax], ecx
  0004b	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00052	8b 4d 04	 mov	 ecx, DWORD PTR rhs_size$[rbp]
  00055	89 08		 mov	 DWORD PTR [rax], ecx
  00057	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR rhs$[rbp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00061	89 45 24	 mov	 DWORD PTR rhs_cap$[rbp], eax
  00064	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR rhs$[rbp]
  0006b	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00072	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00075	89 48 04	 mov	 DWORD PTR [rax+4], ecx
  00078	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0007f	8b 4d 24	 mov	 ecx, DWORD PTR rhs_cap$[rbp]
  00082	89 48 04	 mov	 DWORD PTR [rax+4], ecx
  00085	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR rhs$[rbp]
  0008c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00090	48 89 45 48	 mov	 QWORD PTR rhs_data$[rbp], rax
  00094	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR rhs$[rbp]
  0009b	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a2	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000aa	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b1	48 8b 4d 48	 mov	 rcx, QWORD PTR rhs_data$[rbp]
  000b5	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000b9	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000c0	5f		 pop	 rdi
  000c1	5d		 pop	 rbp
  000c2	c3		 ret	 0
?swap@?$ImVector@D@@QEAAXAEAU1@@Z ENDP			; ImVector<char>::swap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??A?$ImVector@D@@QEBAAEBDH@Z
_TEXT	SEGMENT
this$ = 224
i$ = 232
??A?$ImVector@D@@QEBAAEBDH@Z PROC			; ImVector<char>::operator[], COMDAT

; 1787 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002e	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR i$[rbp], 0
  00035	7c 11		 jl	 SHORT $LN3@operator
  00037	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 85 e8 00 00
	00		 cmp	 DWORD PTR i$[rbp], eax
  00046	7c 1c		 jl	 SHORT $LN4@operator
$LN3@operator:
  00048	41 b8 fb 06 00
	00		 mov	 r8d, 1787		; 000006fbH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EO@MGODAGF@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	33 c0		 xor	 eax, eax
$LN4@operator:
  00064	48 63 85 e8 00
	00 00		 movsxd	 rax, DWORD PTR i$[rbp]
  0006b	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00072	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00076	48 03 c8	 add	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00083	5f		 pop	 rdi
  00084	5d		 pop	 rbp
  00085	c3		 ret	 0
??A?$ImVector@D@@QEBAAEBDH@Z ENDP			; ImVector<char>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@D@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?clear@?$ImVector@D@@QEAAXXZ PROC			; ImVector<char>::clear, COMDAT

; 1777 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00036	74 3a		 je	 SHORT $LN2@clear
  00038	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00046	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00053	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0005a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0005e	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
  00063	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN2@clear:
  00072	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00079	5f		 pop	 rdi
  0007a	5d		 pop	 rbp
  0007b	c3		 ret	 0
?clear@?$ImVector@D@@QEAAXXZ ENDP			; ImVector<char>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??1?$ImVector@D@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
this$ = 256
??1?$ImVector@D@@QEAA@XZ PROC				; ImVector<char>::~ImVector<char>, COMDAT

; 1775 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  0002a	48 c7 85 c8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T1[rbp], -2
  00035	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00041	74 11		 je	 SHORT $LN2@ImVector
  00043	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0004e	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
  00053	90		 npad	 1
$LN2@ImVector:
  00054	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0005b	5f		 pop	 rdi
  0005c	5d		 pop	 rbp
  0005d	c3		 ret	 0
??1?$ImVector@D@@QEAA@XZ ENDP				; ImVector<char>::~ImVector<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0?$ImVector@D@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$ImVector@D@@QEAA@XZ PROC				; ImVector<char>::ImVector<char>, COMDAT

; 1772 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00028	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00036	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00043	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0004a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00052	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00059	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00060	5f		 pop	 rdi
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
??0?$ImVector@D@@QEAA@XZ ENDP				; ImVector<char>::ImVector<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0ImGuiTableSortSpecs@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0ImGuiTableSortSpecs@@QEAA@XZ PROC			; ImGuiTableSortSpecs::ImGuiTableSortSpecs, COMDAT

; 2151 :     ImGuiTableSortSpecs()       { memset(this, 0, sizeof(*this)); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	41 b8 10 00 00
	00		 mov	 r8d, 16
  00030	33 d2		 xor	 edx, edx
  00032	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00039	e8 00 00 00 00	 call	 memset
  0003e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004c	5f		 pop	 rdi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??0ImGuiTableSortSpecs@@QEAA@XZ ENDP			; ImGuiTableSortSpecs::ImGuiTableSortSpecs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0ImGuiTableColumnSortSpecs@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0ImGuiTableColumnSortSpecs@@QEAA@XZ PROC		; ImGuiTableColumnSortSpecs::ImGuiTableColumnSortSpecs, COMDAT

; 2138 :     ImGuiTableColumnSortSpecs() { memset(this, 0, sizeof(*this)); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR [rsp+264]
  0002a	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00030	33 d2		 xor	 edx, edx
  00032	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00039	e8 00 00 00 00	 call	 memset
  0003e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00045	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0004c	5f		 pop	 rdi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
??0ImGuiTableColumnSortSpecs@@QEAA@XZ ENDP		; ImGuiTableColumnSortSpecs::ImGuiTableColumnSortSpecs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??3@YAXPEAXUImNewWrapper@@0@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
__formal$ = 240
??3@YAXPEAXUImNewWrapper@@0@Z PROC			; operator delete, COMDAT

; 1740 : inline void  operator delete(void*, ImNewWrapper, void*)   {} // This is only required so we can use the symmetrical new()

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00017	48 8b ec	 mov	 rbp, rsp
  0001a	48 8b fc	 mov	 rdi, rsp
  0001d	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00031	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00038	5f		 pop	 rdi
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
??3@YAXPEAXUImNewWrapper@@0@Z ENDP			; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??2@YAPEAX_KUImNewWrapper@@PEAX@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
ptr$ = 240
??2@YAPEAX_KUImNewWrapper@@PEAX@Z PROC			; operator new, COMDAT

; 1739 : inline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00017	48 8b ec	 mov	 rbp, rsp
  0001a	48 8b fc	 mov	 rdi, rsp
  0001d	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR [rsp+232]
  00031	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR ptr$[rbp]
  00038	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0003f	5f		 pop	 rdi
  00040	5d		 pop	 rbp
  00041	c3		 ret	 0
??2@YAPEAX_KUImNewWrapper@@PEAX@Z ENDP			; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnsCount@ImGui@@YAHXZ
_TEXT	SEGMENT
window$ = 8
tv71 = 212
?GetColumnsCount@ImGui@@YAHXZ PROC			; ImGui::GetColumnsCount, COMDAT

; 3706 : {

$LN5:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3707 :     ImGuiWindow* window = GetCurrentWindowRead();

  0001e	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  00023	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 3708 :     return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;

  00027	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0002b	48 83 b8 a0 01
	00 00 00	 cmp	 QWORD PTR [rax+416], 0
  00033	74 16		 je	 SHORT $LN3@GetColumns
  00035	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00039	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  00040	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00043	89 85 d4 00 00
	00		 mov	 DWORD PTR tv71[rbp], eax
  00049	eb 0a		 jmp	 SHORT $LN4@GetColumns
$LN3@GetColumns:
  0004b	c7 85 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv71[rbp], 1
$LN4@GetColumns:
  00055	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv71[rbp]

; 3709 : }

  0005b	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00062	5f		 pop	 rdi
  00063	5d		 pop	 rbp
  00064	c3		 ret	 0
?GetColumnsCount@ImGui@@YAHXZ ENDP			; ImGui::GetColumnsCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?SetColumnOffset@ImGui@@YAXHM@Z
_TEXT	SEGMENT
g$ = 8
window$ = 40
columns$ = 72
preserve_width$ = 100
width$ = 132
tv149 = 340
tv129 = 340
tv89 = 340
column_index$ = 384
offset$ = 392
?SetColumnOffset@ImGui@@YAXHM@Z PROC			; ImGui::SetColumnOffset, COMDAT

; 3783 : {

$LN12:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 62 00 00 00	 mov	 ecx, 98			; 00000062H
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	8b 8c 24 a8 01
	00 00		 mov	 ecx, DWORD PTR [rsp+424]

; 3784 :     ImGuiContext& g = *GImGui;

  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00035	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3785 :     ImGuiWindow* window = g.CurrentWindow;

  00039	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003d	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  00044	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 3786 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

  00048	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  0004c	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  00053	48 89 45 48	 mov	 QWORD PTR columns$[rbp], rax

; 3787 :     IM_ASSERT(columns != NULL);

  00057	48 83 7d 48 00	 cmp	 QWORD PTR columns$[rbp], 0
  0005c	75 22		 jne	 SHORT $LN6@SetColumnO
  0005e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??SetColumnOffset@ImGui@@YAXHM@Z@4JA
  00064	83 c0 04	 add	 eax, 4
  00067	44 8b c0	 mov	 r8d, eax
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN6@SetColumnO:

; 3788 : 
; 3789 :     if (column_index < 0)

  00080	83 bd 80 01 00
	00 00		 cmp	 DWORD PTR column_index$[rbp], 0
  00087	7d 0d		 jge	 SHORT $LN2@SetColumnO

; 3790 :         column_index = columns->Current;

  00089	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  0008d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00090	89 85 80 01 00
	00		 mov	 DWORD PTR column_index$[rbp], eax
$LN2@SetColumnO:

; 3791 :     IM_ASSERT(column_index < columns->Columns.Size);

  00096	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  0009a	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0009d	39 85 80 01 00
	00		 cmp	 DWORD PTR column_index$[rbp], eax
  000a3	7c 22		 jl	 SHORT $LN7@SetColumnO
  000a5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??SetColumnOffset@ImGui@@YAXHM@Z@4JA
  000ab	83 c0 08	 add	 eax, 8
  000ae	44 8b c0	 mov	 r8d, eax
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@FCGFMMCK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?4@
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c5	33 c0		 xor	 eax, eax
$LN7@SetColumnO:

; 3792 : 
; 3793 :     const bool preserve_width = !(columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths) && (column_index < columns->Count - 1);

  000c7	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000cb	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000ce	83 e0 04	 and	 eax, 4
  000d1	85 c0		 test	 eax, eax
  000d3	75 1a		 jne	 SHORT $LN8@SetColumnO
  000d5	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000d9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000dc	ff c8		 dec	 eax
  000de	39 85 80 01 00
	00		 cmp	 DWORD PTR column_index$[rbp], eax
  000e4	7d 09		 jge	 SHORT $LN8@SetColumnO
  000e6	c6 85 54 01 00
	00 01		 mov	 BYTE PTR tv89[rbp], 1
  000ed	eb 07		 jmp	 SHORT $LN9@SetColumnO
$LN8@SetColumnO:
  000ef	c6 85 54 01 00
	00 00		 mov	 BYTE PTR tv89[rbp], 0
$LN9@SetColumnO:
  000f6	0f b6 85 54 01
	00 00		 movzx	 eax, BYTE PTR tv89[rbp]
  000fd	88 45 64	 mov	 BYTE PTR preserve_width$[rbp], al

; 3794 :     const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

  00100	0f b6 45 64	 movzx	 eax, BYTE PTR preserve_width$[rbp]
  00104	85 c0		 test	 eax, eax
  00106	74 22		 je	 SHORT $LN10@SetColumnO
  00108	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  0010c	44 0f b6 40 09	 movzx	 r8d, BYTE PTR [rax+9]
  00111	8b 95 80 01 00
	00		 mov	 edx, DWORD PTR column_index$[rbp]
  00117	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  0011b	e8 00 00 00 00	 call	 ?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z ; GetColumnWidthEx
  00120	f3 0f 11 85 54
	01 00 00	 movss	 DWORD PTR tv129[rbp], xmm0
  00128	eb 0b		 jmp	 SHORT $LN11@SetColumnO
$LN10@SetColumnO:
  0012a	0f 57 c0	 xorps	 xmm0, xmm0
  0012d	f3 0f 11 85 54
	01 00 00	 movss	 DWORD PTR tv129[rbp], xmm0
$LN11@SetColumnO:
  00135	f3 0f 10 85 54
	01 00 00	 movss	 xmm0, DWORD PTR tv129[rbp]
  0013d	f3 0f 11 85 84
	00 00 00	 movss	 DWORD PTR width$[rbp], xmm0

; 3795 : 
; 3796 :     if (!(columns->Flags & ImGuiOldColumnFlags_NoForceWithinWindow))

  00145	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00149	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0014c	83 e0 08	 and	 eax, 8
  0014f	85 c0		 test	 eax, eax
  00151	75 4e		 jne	 SHORT $LN3@SetColumnO

; 3797 :         offset = ImMin(offset, columns->OffMaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));

  00153	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00157	8b 8d 80 01 00
	00		 mov	 ecx, DWORD PTR column_index$[rbp]
  0015d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00160	2b c1		 sub	 eax, ecx
  00162	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00166	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0016a	f3 0f 10 88 50
	38 00 00	 movss	 xmm1, DWORD PTR [rax+14416]
  00172	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00176	0f 28 c1	 movaps	 xmm0, xmm1
  00179	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  0017d	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [rax+24]
  00182	f3 0f 5c c8	 subss	 xmm1, xmm0
  00186	0f 28 c1	 movaps	 xmm0, xmm1
  00189	0f 28 c8	 movaps	 xmm1, xmm0
  0018c	f3 0f 10 85 88
	01 00 00	 movss	 xmm0, DWORD PTR offset$[rbp]
  00194	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00199	f3 0f 11 85 88
	01 00 00	 movss	 DWORD PTR offset$[rbp], xmm0
$LN3@SetColumnO:

; 3798 :     columns->Columns[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns->OffMinX);

  001a1	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  001a5	f3 0f 10 85 88
	01 00 00	 movss	 xmm0, DWORD PTR offset$[rbp]
  001ad	f3 0f 5c 40 14	 subss	 xmm0, DWORD PTR [rax+20]
  001b2	0f 28 c8	 movaps	 xmm1, xmm0
  001b5	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  001b9	e8 00 00 00 00	 call	 ?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ; ImGui::GetColumnNormFromOffset
  001be	f3 0f 11 85 54
	01 00 00	 movss	 DWORD PTR tv149[rbp], xmm0
  001c6	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  001ca	48 83 c0 60	 add	 rax, 96			; 00000060H
  001ce	8b 95 80 01 00
	00		 mov	 edx, DWORD PTR column_index$[rbp]
  001d4	48 8b c8	 mov	 rcx, rax
  001d7	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  001dc	f3 0f 10 85 54
	01 00 00	 movss	 xmm0, DWORD PTR tv149[rbp]
  001e4	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 3799 : 
; 3800 :     if (preserve_width)

  001e8	0f b6 45 64	 movzx	 eax, BYTE PTR preserve_width$[rbp]
  001ec	85 c0		 test	 eax, eax
  001ee	74 3a		 je	 SHORT $LN4@SetColumnO

; 3801 :         SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));

  001f0	f3 0f 10 8d 84
	00 00 00	 movss	 xmm1, DWORD PTR width$[rbp]
  001f8	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  001fc	f3 0f 10 80 50
	38 00 00	 movss	 xmm0, DWORD PTR [rax+14416]
  00204	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00209	f3 0f 10 8d 88
	01 00 00	 movss	 xmm1, DWORD PTR offset$[rbp]
  00211	f3 0f 58 c8	 addss	 xmm1, xmm0
  00215	0f 28 c1	 movaps	 xmm0, xmm1
  00218	8b 85 80 01 00
	00		 mov	 eax, DWORD PTR column_index$[rbp]
  0021e	ff c0		 inc	 eax
  00220	0f 28 c8	 movaps	 xmm1, xmm0
  00223	8b c8		 mov	 ecx, eax
  00225	e8 00 00 00 00	 call	 ?SetColumnOffset@ImGui@@YAXHM@Z ; ImGui::SetColumnOffset
$LN4@SetColumnO:

; 3802 : }

  0022a	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  00231	5f		 pop	 rdi
  00232	5d		 pop	 rbp
  00233	c3		 ret	 0
?SetColumnOffset@ImGui@@YAXHM@Z ENDP			; ImGui::SetColumnOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnOffset@ImGui@@YAMH@Z
_TEXT	SEGMENT
window$ = 8
columns$ = 40
t$ = 68
x_offset$ = 100
column_index$ = 352
?GetColumnOffset@ImGui@@YAMH@Z PROC			; ImGui::GetColumnOffset, COMDAT

; 3741 : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 8c 24 98 01
	00 00		 mov	 ecx, DWORD PTR [rsp+408]

; 3742 :     ImGuiWindow* window = GetCurrentWindowRead();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  0002d	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 3743 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

  00031	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00035	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  0003c	48 89 45 28	 mov	 QWORD PTR columns$[rbp], rax

; 3744 :     if (columns == NULL)

  00040	48 83 7d 28 00	 cmp	 QWORD PTR columns$[rbp], 0
  00045	75 08		 jne	 SHORT $LN2@GetColumnO

; 3745 :         return 0.0f;

  00047	0f 57 c0	 xorps	 xmm0, xmm0
  0004a	e9 8c 00 00 00	 jmp	 $LN1@GetColumnO
$LN2@GetColumnO:

; 3746 : 
; 3747 :     if (column_index < 0)

  0004f	83 bd 60 01 00
	00 00		 cmp	 DWORD PTR column_index$[rbp], 0
  00056	7d 0d		 jge	 SHORT $LN3@GetColumnO

; 3748 :         column_index = columns->Current;

  00058	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  0005c	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0005f	89 85 60 01 00
	00		 mov	 DWORD PTR column_index$[rbp], eax
$LN3@GetColumnO:

; 3749 :     IM_ASSERT(column_index < columns->Columns.Size);

  00065	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  00069	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0006c	39 85 60 01 00
	00		 cmp	 DWORD PTR column_index$[rbp], eax
  00072	7c 22		 jl	 SHORT $LN5@GetColumnO
  00074	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetColumnOffset@ImGui@@YAMH@Z@4JA
  0007a	83 c0 08	 add	 eax, 8
  0007d	44 8b c0	 mov	 r8d, eax
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@FCGFMMCK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?4@
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00094	33 c0		 xor	 eax, eax
$LN5@GetColumnO:

; 3750 : 
; 3751 :     const float t = columns->Columns[column_index].OffsetNorm;

  00096	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  0009a	48 83 c0 60	 add	 rax, 96			; 00000060H
  0009e	8b 95 60 01 00
	00		 mov	 edx, DWORD PTR column_index$[rbp]
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  000ac	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  000b0	f3 0f 11 45 44	 movss	 DWORD PTR t$[rbp], xmm0

; 3752 :     const float x_offset = ImLerp(columns->OffMinX, columns->OffMaxX, t);

  000b5	f3 0f 10 55 44	 movss	 xmm2, DWORD PTR t$[rbp]
  000ba	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  000be	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [rax+24]
  000c3	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  000c7	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  000cc	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  000d1	f3 0f 11 45 64	 movss	 DWORD PTR x_offset$[rbp], xmm0

; 3753 :     return x_offset;

  000d6	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR x_offset$[rbp]
$LN1@GetColumnO:

; 3754 : }

  000db	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  000e2	5f		 pop	 rdi
  000e3	5d		 pop	 rbp
  000e4	c3		 ret	 0
?GetColumnOffset@ImGui@@YAMH@Z ENDP			; ImGui::GetColumnOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?SetColumnWidth@ImGui@@YAXHM@Z
_TEXT	SEGMENT
window$ = 8
columns$ = 40
column_index$ = 288
width$ = 296
?SetColumnWidth@ImGui@@YAXHM@Z PROC			; ImGui::SetColumnWidth, COMDAT

; 3805 : {

$LN5:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR [rsp+328]

; 3806 :     ImGuiWindow* window = GetCurrentWindowRead();

  0002e	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  00033	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 3807 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

  00037	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0003b	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  00042	48 89 45 28	 mov	 QWORD PTR columns$[rbp], rax

; 3808 :     IM_ASSERT(columns != NULL);

  00046	48 83 7d 28 00	 cmp	 QWORD PTR columns$[rbp], 0
  0004b	75 22		 jne	 SHORT $LN4@SetColumnW
  0004d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??SetColumnWidth@ImGui@@YAXHM@Z@4JA
  00053	83 c0 03	 add	 eax, 3
  00056	44 8b c0	 mov	 r8d, eax
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006d	33 c0		 xor	 eax, eax
$LN4@SetColumnW:

; 3809 : 
; 3810 :     if (column_index < 0)

  0006f	83 bd 20 01 00
	00 00		 cmp	 DWORD PTR column_index$[rbp], 0
  00076	7d 0d		 jge	 SHORT $LN2@SetColumnW

; 3811 :         column_index = columns->Current;

  00078	48 8b 45 28	 mov	 rax, QWORD PTR columns$[rbp]
  0007c	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0007f	89 85 20 01 00
	00		 mov	 DWORD PTR column_index$[rbp], eax
$LN2@SetColumnW:

; 3812 :     SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);

  00085	8b 8d 20 01 00
	00		 mov	 ecx, DWORD PTR column_index$[rbp]
  0008b	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  00090	f3 0f 58 85 28
	01 00 00	 addss	 xmm0, DWORD PTR width$[rbp]
  00098	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR column_index$[rbp]
  0009e	ff c0		 inc	 eax
  000a0	0f 28 c8	 movaps	 xmm1, xmm0
  000a3	8b c8		 mov	 ecx, eax
  000a5	e8 00 00 00 00	 call	 ?SetColumnOffset@ImGui@@YAXHM@Z ; ImGui::SetColumnOffset

; 3813 : }

  000aa	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000b1	5f		 pop	 rdi
  000b2	5d		 pop	 rbp
  000b3	c3		 ret	 0
?SetColumnWidth@ImGui@@YAXHM@Z ENDP			; ImGui::SetColumnWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnWidth@ImGui@@YAMH@Z
_TEXT	SEGMENT
g$ = 8
window$ = 40
columns$ = 72
$T1 = 292
tv76 = 312
column_index$ = 352
?GetColumnWidth@ImGui@@YAMH@Z PROC			; ImGui::GetColumnWidth, COMDAT

; 3770 : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0000d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 8c 24 98 01
	00 00		 mov	 ecx, DWORD PTR [rsp+408]

; 3771 :     ImGuiContext& g = *GImGui;

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0002f	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 3772 :     ImGuiWindow* window = g.CurrentWindow;

  00033	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00037	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  0003e	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 3773 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

  00042	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00046	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  0004d	48 89 45 48	 mov	 QWORD PTR columns$[rbp], rax

; 3774 :     if (columns == NULL)

  00051	48 83 7d 48 00	 cmp	 QWORD PTR columns$[rbp], 0
  00056	75 12		 jne	 SHORT $LN2@GetColumnW

; 3775 :         return GetContentRegionAvail().x;

  00058	48 8d 8d 24 01
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  0005f	e8 00 00 00 00	 call	 ?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
  00064	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00068	eb 62		 jmp	 SHORT $LN1@GetColumnW
$LN2@GetColumnW:

; 3776 : 
; 3777 :     if (column_index < 0)

  0006a	83 bd 60 01 00
	00 00		 cmp	 DWORD PTR column_index$[rbp], 0
  00071	7d 0d		 jge	 SHORT $LN3@GetColumnW

; 3778 :         column_index = columns->Current;

  00073	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00077	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0007a	89 85 60 01 00
	00		 mov	 DWORD PTR column_index$[rbp], eax
$LN3@GetColumnW:

; 3779 :     return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);

  00080	8b 85 60 01 00
	00		 mov	 eax, DWORD PTR column_index$[rbp]
  00086	ff c0		 inc	 eax
  00088	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  0008c	48 83 c1 60	 add	 rcx, 96			; 00000060H
  00090	8b d0		 mov	 edx, eax
  00092	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  00097	48 89 85 38 01
	00 00		 mov	 QWORD PTR tv76[rbp], rax
  0009e	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  000a2	48 83 c1 60	 add	 rcx, 96			; 00000060H
  000a6	8b 95 60 01 00
	00		 mov	 edx, DWORD PTR column_index$[rbp]
  000ac	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  000b1	48 8b 8d 38 01
	00 00		 mov	 rcx, QWORD PTR tv76[rbp]
  000b8	f3 0f 10 01	 movss	 xmm0, DWORD PTR [rcx]
  000bc	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [rax]
  000c0	0f 28 c8	 movaps	 xmm1, xmm0
  000c3	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  000c7	e8 00 00 00 00	 call	 ?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ; ImGui::GetColumnOffsetFromNorm
$LN1@GetColumnW:

; 3780 : }

  000cc	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  000d3	5f		 pop	 rdi
  000d4	5d		 pop	 rbp
  000d5	c3		 ret	 0
?GetColumnWidth@ImGui@@YAMH@Z ENDP			; ImGui::GetColumnWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnIndex@ImGui@@YAHXZ
_TEXT	SEGMENT
window$ = 8
tv71 = 212
?GetColumnIndex@ImGui@@YAHXZ PROC			; ImGui::GetColumnIndex, COMDAT

; 3700 : {

$LN5:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3701 :     ImGuiWindow* window = GetCurrentWindowRead();

  0001e	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  00023	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 3702 :     return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;

  00027	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0002b	48 83 b8 a0 01
	00 00 00	 cmp	 QWORD PTR [rax+416], 0
  00033	74 16		 je	 SHORT $LN3@GetColumnI
  00035	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00039	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  00040	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00043	89 85 d4 00 00
	00		 mov	 DWORD PTR tv71[rbp], eax
  00049	eb 0a		 jmp	 SHORT $LN4@GetColumnI
$LN3@GetColumnI:
  0004b	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv71[rbp], 0
$LN4@GetColumnI:
  00055	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv71[rbp]

; 3703 : }

  0005b	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00062	5f		 pop	 rdi
  00063	5d		 pop	 rbp
  00064	c3		 ret	 0
?GetColumnIndex@ImGui@@YAHXZ ENDP			; ImGui::GetColumnIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?NextColumn@ImGui@@YAXXZ
_TEXT	SEGMENT
window$ = 8
g$ = 40
columns$ = 72
column$ = 104
column_padding$ = 132
offset_0$ = 164
offset_1$ = 196
width$ = 228
$T1 = 452
tv132 = 468
?NextColumn@ImGui@@YAXXZ PROC				; ImGui::NextColumn, COMDAT

; 3956 : {

$LN10:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 02
	00 00		 sub	 rsp, 520		; 00000208H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3957 :     ImGuiWindow* window = GetCurrentWindow();

  0001e	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00023	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 3958 :     if (window->SkipItems || window->DC.CurrentColumns == NULL)

  00027	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0002b	0f b6 80 b3 00
	00 00		 movzx	 eax, BYTE PTR [rax+179]
  00032	85 c0		 test	 eax, eax
  00034	75 0e		 jne	 SHORT $LN3@NextColumn
  00036	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0003a	48 83 b8 a0 01
	00 00 00	 cmp	 QWORD PTR [rax+416], 0
  00042	75 05		 jne	 SHORT $LN2@NextColumn
$LN3@NextColumn:

; 3959 :         return;

  00044	e9 c0 02 00 00	 jmp	 $LN1@NextColumn
$LN2@NextColumn:

; 3960 : 
; 3961 :     ImGuiContext& g = *GImGui;

  00049	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00050	48 89 45 28	 mov	 QWORD PTR g$[rbp], rax

; 3962 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

  00054	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00058	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  0005f	48 89 45 48	 mov	 QWORD PTR columns$[rbp], rax

; 3963 : 
; 3964 :     if (columns->Count == 1)

  00063	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00067	83 78 10 01	 cmp	 DWORD PTR [rax+16], 1
  0006b	75 66		 jne	 SHORT $LN4@NextColumn

; 3965 :     {
; 3966 :         window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

  0006d	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00071	48 8b 4d 08	 mov	 rcx, QWORD PTR window$[rbp]
  00075	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  0007a	f3 0f 58 81 3c
	01 00 00	 addss	 xmm0, DWORD PTR [rcx+316]
  00082	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00086	f3 0f 58 80 40
	01 00 00	 addss	 xmm0, DWORD PTR [rax+320]
  0008e	f3 0f 2c c0	 cvttss2si eax, xmm0
  00092	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00096	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0009a	f3 0f 11 80 f8
	00 00 00	 movss	 DWORD PTR [rax+248], xmm0

; 3967 :         IM_ASSERT(columns->Current == 0);

  000a2	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000a6	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  000aa	74 22		 je	 SHORT $LN9@NextColumn
  000ac	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??NextColumn@ImGui@@YAXXZ@4JA
  000b2	83 c0 0b	 add	 eax, 11
  000b5	44 8b c0	 mov	 r8d, eax
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@HCFAHNAF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000cc	33 c0		 xor	 eax, eax
$LN9@NextColumn:

; 3968 :         return;

  000ce	e9 36 02 00 00	 jmp	 $LN1@NextColumn
$LN4@NextColumn:

; 3969 :     }
; 3970 : 
; 3971 :     // Next column
; 3972 :     if (++columns->Current == columns->Count)

  000d3	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000d7	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000da	ff c0		 inc	 eax
  000dc	89 85 d4 01 00
	00		 mov	 DWORD PTR tv132[rbp], eax
  000e2	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000e6	8b 8d d4 01 00
	00		 mov	 ecx, DWORD PTR tv132[rbp]
  000ec	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
  000ef	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000f3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000f6	39 85 d4 01 00
	00		 cmp	 DWORD PTR tv132[rbp], eax
  000fc	75 0b		 jne	 SHORT $LN5@NextColumn

; 3973 :         columns->Current = 0;

  000fe	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00102	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0
$LN5@NextColumn:

; 3974 : 
; 3975 :     PopItemWidth();

  00109	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 3976 : 
; 3977 :     // Optimization: avoid PopClipRect() + SetCurrentChannel() + PushClipRect()
; 3978 :     // (which would needlessly attempt to update commands in the wrong channel, then pop or overwrite them),
; 3979 :     ImGuiOldColumnData* column = &columns->Columns[columns->Current];

  0010e	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00112	48 83 c0 60	 add	 rax, 96			; 00000060H
  00116	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  0011a	8b 51 0c	 mov	 edx, DWORD PTR [rcx+12]
  0011d	48 8b c8	 mov	 rcx, rax
  00120	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiOldColumnData@@@@QEAAAEAUImGuiOldColumnData@@H@Z ; ImVector<ImGuiOldColumnData>::operator[]
  00125	48 89 45 68	 mov	 QWORD PTR column$[rbp], rax

; 3980 :     SetWindowClipRectBeforeSetChannel(window, column->ClipRect);

  00129	48 8b 45 68	 mov	 rax, QWORD PTR column$[rbp]
  0012d	48 83 c0 0c	 add	 rax, 12
  00131	48 8b d0	 mov	 rdx, rax
  00134	48 8b 4d 08	 mov	 rcx, QWORD PTR window$[rbp]
  00138	e8 00 00 00 00	 call	 ?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; ImGui::SetWindowClipRectBeforeSetChannel

; 3981 :     columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);

  0013d	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00141	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00144	ff c0		 inc	 eax
  00146	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  0014a	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0014e	44 8b c0	 mov	 r8d, eax
  00151	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00155	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  0015c	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 3982 : 
; 3983 :     const float column_padding = g.Style.ItemSpacing.x;

  00161	48 8b 45 28	 mov	 rax, QWORD PTR g$[rbp]
  00165	f3 0f 10 80 2c
	38 00 00	 movss	 xmm0, DWORD PTR [rax+14380]
  0016d	f3 0f 11 85 84
	00 00 00	 movss	 DWORD PTR column_padding$[rbp], xmm0

; 3984 :     columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);

  00175	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00179	f3 0f 10 88 fc
	00 00 00	 movss	 xmm1, DWORD PTR [rax+252]
  00181	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00185	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [rax+32]
  0018a	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0018f	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00193	f3 0f 11 40 20	 movss	 DWORD PTR [rax+32], xmm0

; 3985 :     if (columns->Current > 0)

  00198	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  0019c	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  001a0	7e 2e		 jle	 SHORT $LN6@NextColumn

; 3986 :     {
; 3987 :         // Columns 1+ ignore IndentX (by canceling it out)
; 3988 :         // FIXME-COLUMNS: Unnecessary, could be locked?
; 3989 :         window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + column_padding;

  001a2	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  001a6	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  001a9	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  001ae	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  001b2	f3 0f 5c 80 3c
	01 00 00	 subss	 xmm0, DWORD PTR [rax+316]
  001ba	f3 0f 58 85 84
	00 00 00	 addss	 xmm0, DWORD PTR column_padding$[rbp]
  001c2	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  001c6	f3 0f 11 80 40
	01 00 00	 movss	 DWORD PTR [rax+320], xmm0

; 3990 :     }
; 3991 :     else

  001ce	eb 42		 jmp	 SHORT $LN7@NextColumn
$LN6@NextColumn:

; 3992 :     {
; 3993 :         // New row/line: column 0 honor IndentX.
; 3994 :         window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);

  001d0	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  001d4	f3 0f 10 85 84
	00 00 00	 movss	 xmm0, DWORD PTR column_padding$[rbp]
  001dc	f3 0f 5c 40 48	 subss	 xmm0, DWORD PTR [rax+72]
  001e1	0f 57 c9	 xorps	 xmm1, xmm1
  001e4	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001e9	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  001ed	f3 0f 11 80 40
	01 00 00	 movss	 DWORD PTR [rax+320], xmm0

; 3995 :         window->DC.IsSameLine = false;

  001f5	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  001f9	c6 80 38 01 00
	00 00		 mov	 BYTE PTR [rax+312], 0

; 3996 :         columns->LineMinY = columns->LineMaxY;

  00200	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  00204	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  00208	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  0020d	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0
$LN7@NextColumn:

; 3997 :     }
; 3998 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

  00212	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00216	48 8b 4d 08	 mov	 rcx, QWORD PTR window$[rbp]
  0021a	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  0021f	f3 0f 58 81 3c
	01 00 00	 addss	 xmm0, DWORD PTR [rcx+316]
  00227	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0022b	f3 0f 58 80 40
	01 00 00	 addss	 xmm0, DWORD PTR [rax+320]
  00233	f3 0f 2c c0	 cvttss2si eax, xmm0
  00237	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0023b	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0023f	f3 0f 11 80 f8
	00 00 00	 movss	 DWORD PTR [rax+248], xmm0

; 3999 :     window->DC.CursorPos.y = columns->LineMinY;

  00247	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  0024b	48 8b 4d 48	 mov	 rcx, QWORD PTR columns$[rbp]
  0024f	f3 0f 10 41 1c	 movss	 xmm0, DWORD PTR [rcx+28]
  00254	f3 0f 11 80 fc
	00 00 00	 movss	 DWORD PTR [rax+252], xmm0

; 4000 :     window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);

  0025c	0f 57 d2	 xorps	 xmm2, xmm2
  0025f	0f 57 c9	 xorps	 xmm1, xmm1
  00262	48 8d 8d c4 01
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  00269	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  0026e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00271	48 8b 4d 08	 mov	 rcx, QWORD PTR window$[rbp]
  00275	48 89 81 20 01
	00 00		 mov	 QWORD PTR [rcx+288], rax

; 4001 :     window->DC.CurrLineTextBaseOffset = 0.0f;

  0027c	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00280	0f 57 c0	 xorps	 xmm0, xmm0
  00283	f3 0f 11 80 30
	01 00 00	 movss	 DWORD PTR [rax+304], xmm0

; 4002 : 
; 4003 :     // FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
; 4004 :     float offset_0 = GetColumnOffset(columns->Current);

  0028b	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  0028f	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  00292	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  00297	f3 0f 11 85 a4
	00 00 00	 movss	 DWORD PTR offset_0$[rbp], xmm0

; 4005 :     float offset_1 = GetColumnOffset(columns->Current + 1);

  0029f	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  002a3	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  002a6	ff c0		 inc	 eax
  002a8	8b c8		 mov	 ecx, eax
  002aa	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  002af	f3 0f 11 85 c4
	00 00 00	 movss	 DWORD PTR offset_1$[rbp], xmm0

; 4006 :     float width = offset_1 - offset_0;

  002b7	f3 0f 10 85 c4
	00 00 00	 movss	 xmm0, DWORD PTR offset_1$[rbp]
  002bf	f3 0f 5c 85 a4
	00 00 00	 subss	 xmm0, DWORD PTR offset_0$[rbp]
  002c7	f3 0f 11 85 e4
	00 00 00	 movss	 DWORD PTR width$[rbp], xmm0

; 4007 :     PushItemWidth(width * 0.65f);

  002cf	f3 0f 10 85 e4
	00 00 00	 movss	 xmm0, DWORD PTR width$[rbp]
  002d7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f266666
  002df	e8 00 00 00 00	 call	 ?PushItemWidth@ImGui@@YAXM@Z ; ImGui::PushItemWidth

; 4008 :     window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;

  002e4	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  002e8	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  002ed	f3 0f 58 85 c4
	00 00 00	 addss	 xmm0, DWORD PTR offset_1$[rbp]
  002f5	f3 0f 5c 85 84
	00 00 00	 subss	 xmm0, DWORD PTR column_padding$[rbp]
  002fd	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00301	f3 0f 11 80 18
	02 00 00	 movss	 DWORD PTR [rax+536], xmm0
$LN1@NextColumn:

; 4009 : }

  00309	48 8d a5 e8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+488]
  00310	5f		 pop	 rdi
  00311	5d		 pop	 rbp
  00312	c3		 ret	 0
?NextColumn@ImGui@@YAXXZ ENDP				; ImGui::NextColumn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?Columns@ImGui@@YAXHPEBD_N@Z
_TEXT	SEGMENT
window$ = 8
flags$ = 36
columns$ = 72
tv73 = 276
columns_count$ = 320
id$ = 328
border$ = 336
?Columns@ImGui@@YAXHPEBD_N@Z PROC			; ImGui::Columns, COMDAT

; 4087 : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR [rsp+360]

; 4088 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	48 89 45 08	 mov	 QWORD PTR window$[rbp], rax

; 4089 :     IM_ASSERT(columns_count >= 1);

  0003b	83 bd 40 01 00
	00 01		 cmp	 DWORD PTR columns_count$[rbp], 1
  00042	7d 22		 jge	 SHORT $LN6@Columns
  00044	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??Columns@ImGui@@YAXHPEBD_N@Z@4JA
  0004a	83 c0 02	 add	 eax, 2
  0004d	44 8b c0	 mov	 r8d, eax
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GDAJJGIO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00064	33 c0		 xor	 eax, eax
$LN6@Columns:

; 4090 : 
; 4091 :     ImGuiOldColumnFlags flags = (border ? 0 : ImGuiOldColumnFlags_NoBorder);

  00066	0f b6 85 50 01
	00 00		 movzx	 eax, BYTE PTR border$[rbp]
  0006d	85 c0		 test	 eax, eax
  0006f	74 0c		 je	 SHORT $LN7@Columns
  00071	c7 85 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv73[rbp], 0
  0007b	eb 0a		 jmp	 SHORT $LN8@Columns
$LN7@Columns:
  0007d	c7 85 14 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv73[rbp], 1
$LN8@Columns:
  00087	8b 85 14 01 00
	00		 mov	 eax, DWORD PTR tv73[rbp]
  0008d	89 45 24	 mov	 DWORD PTR flags$[rbp], eax

; 4092 :     //flags |= ImGuiOldColumnFlags_NoPreserveWidths; // NB: Legacy behavior
; 4093 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

  00090	48 8b 45 08	 mov	 rax, QWORD PTR window$[rbp]
  00094	48 8b 80 a0 01
	00 00		 mov	 rax, QWORD PTR [rax+416]
  0009b	48 89 45 48	 mov	 QWORD PTR columns$[rbp], rax

; 4094 :     if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)

  0009f	48 83 7d 48 00	 cmp	 QWORD PTR columns$[rbp], 0
  000a4	74 1d		 je	 SHORT $LN2@Columns
  000a6	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000aa	8b 8d 40 01 00
	00		 mov	 ecx, DWORD PTR columns_count$[rbp]
  000b0	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  000b3	75 0e		 jne	 SHORT $LN2@Columns
  000b5	48 8b 45 48	 mov	 rax, QWORD PTR columns$[rbp]
  000b9	8b 4d 24	 mov	 ecx, DWORD PTR flags$[rbp]
  000bc	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  000bf	75 02		 jne	 SHORT $LN2@Columns

; 4095 :         return;

  000c1	eb 2b		 jmp	 SHORT $LN1@Columns
$LN2@Columns:

; 4096 : 
; 4097 :     if (columns != NULL)

  000c3	48 83 7d 48 00	 cmp	 QWORD PTR columns$[rbp], 0
  000c8	74 05		 je	 SHORT $LN3@Columns

; 4098 :         EndColumns();

  000ca	e8 00 00 00 00	 call	 ?EndColumns@ImGui@@YAXXZ ; ImGui::EndColumns
$LN3@Columns:

; 4099 : 
; 4100 :     if (columns_count != 1)

  000cf	83 bd 40 01 00
	00 01		 cmp	 DWORD PTR columns_count$[rbp], 1
  000d6	74 16		 je	 SHORT $LN4@Columns

; 4101 :         BeginColumns(id, columns_count, flags);

  000d8	44 8b 45 24	 mov	 r8d, DWORD PTR flags$[rbp]
  000dc	8b 95 40 01 00
	00		 mov	 edx, DWORD PTR columns_count$[rbp]
  000e2	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR id$[rbp]
  000e9	e8 00 00 00 00	 call	 ?BeginColumns@ImGui@@YAXPEBDHH@Z ; ImGui::BeginColumns
$LN4@Columns:
$LN1@Columns:

; 4102 : }

  000ee	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000f5	5f		 pop	 rdi
  000f6	5d		 pop	 rbp
  000f7	c3		 ret	 0
?Columns@ImGui@@YAXHPEBD_N@Z ENDP			; ImGui::Columns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetBgColor@ImGui@@YAXHIH@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
cell_data$1 = 72
bg_idx$2 = 100
tv157 = 308
tv72 = 308
tv171 = 312
target$ = 352
color$ = 360
column_n$ = 368
?TableSetBgColor@ImGui@@YAXHIH@Z PROC			; ImGui::TableSetBgColor, COMDAT

; 1640 : {

$LN20:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8b fc	 mov	 rdi, rsp
  0001e	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	8b 8c 24 88 01
	00 00		 mov	 ecx, DWORD PTR [rsp+392]

; 1641 :     ImGuiContext& g = *GImGui;

  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00038	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1642 :     ImGuiTable* table = g.CurrentTable;

  0003c	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00040	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00047	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1643 :     IM_ASSERT(target != ImGuiTableBgTarget_None);

  0004b	83 bd 60 01 00
	00 00		 cmp	 DWORD PTR target$[rbp], 0
  00052	75 22		 jne	 SHORT $LN15@TableSetBg
  00054	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetBgColor@ImGui@@YAXHIH@Z@4JA
  0005a	83 c0 03	 add	 eax, 3
  0005d	44 8b c0	 mov	 r8d, eax
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@NMABAIJJ@?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAB?$AAg?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AA_?$AAN?$AAo?$AAn@
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00074	33 c0		 xor	 eax, eax
$LN15@TableSetBg:

; 1644 : 
; 1645 :     if (color == IM_COL32_DISABLE)

  00076	81 bd 68 01 00
	00 00 00 00 01	 cmp	 DWORD PTR color$[rbp], 16777216 ; 01000000H
  00080	75 0a		 jne	 SHORT $LN4@TableSetBg

; 1646 :         color = 0;

  00082	c7 85 68 01 00
	00 00 00 00 00	 mov	 DWORD PTR color$[rbp], 0
$LN4@TableSetBg:

; 1647 : 
; 1648 :     // We cannot draw neither the cell or row background immediately as we don't know the row height at this point in time.
; 1649 :     switch (target)

  0008c	8b 85 60 01 00
	00		 mov	 eax, DWORD PTR target$[rbp]
  00092	89 85 34 01 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00098	83 bd 34 01 00
	00 00		 cmp	 DWORD PTR tv72[rbp], 0
  0009f	0f 8e a5 01 00
	00		 jle	 $LN13@TableSetBg
  000a5	83 bd 34 01 00
	00 02		 cmp	 DWORD PTR tv72[rbp], 2
  000ac	0f 8e 13 01 00
	00		 jle	 $LN11@TableSetBg
  000b2	83 bd 34 01 00
	00 03		 cmp	 DWORD PTR tv72[rbp], 3
  000b9	74 05		 je	 SHORT $LN5@TableSetBg
  000bb	e9 8a 01 00 00	 jmp	 $LN13@TableSetBg
$LN5@TableSetBg:

; 1650 :     {
; 1651 :     case ImGuiTableBgTarget_CellBg:
; 1652 :     {
; 1653 :         if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard

  000c0	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000c4	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  000c8	f3 0f 10 40 7c	 movss	 xmm0, DWORD PTR [rax+124]
  000cd	0f 2f 81 24 01
	00 00		 comiss	 xmm0, DWORD PTR [rcx+292]
  000d4	76 05		 jbe	 SHORT $LN6@TableSetBg

; 1654 :             return;

  000d6	e9 97 01 00 00	 jmp	 $LN1@TableSetBg
$LN6@TableSetBg:

; 1655 :         if (column_n == -1)

  000db	83 bd 70 01 00
	00 ff		 cmp	 DWORD PTR column_n$[rbp], -1
  000e2	75 0d		 jne	 SHORT $LN7@TableSetBg

; 1656 :             column_n = table->CurrentColumn;

  000e4	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000e8	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  000eb	89 85 70 01 00
	00		 mov	 DWORD PTR column_n$[rbp], eax
$LN7@TableSetBg:

; 1657 :         if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))

  000f1	8b 85 70 01 00
	00		 mov	 eax, DWORD PTR column_n$[rbp]
  000f7	c1 f8 05	 sar	 eax, 5
  000fa	48 98		 cdqe
  000fc	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00100	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00104	48 89 8d 38 01
	00 00		 mov	 QWORD PTR tv171[rbp], rcx
  0010b	8b 95 70 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  00111	83 e2 1f	 and	 edx, 31
  00114	41 b8 01 00 00
	00		 mov	 r8d, 1
  0011a	0f b6 ca	 movzx	 ecx, dl
  0011d	41 8b d0	 mov	 edx, r8d
  00120	d3 e2		 shl	 edx, cl
  00122	8b ca		 mov	 ecx, edx
  00124	48 8b 95 38 01
	00 00		 mov	 rdx, QWORD PTR tv171[rbp]
  0012b	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  0012e	23 c1		 and	 eax, ecx
  00130	85 c0		 test	 eax, eax
  00132	75 05		 jne	 SHORT $LN8@TableSetBg

; 1658 :             return;

  00134	e9 39 01 00 00	 jmp	 $LN1@TableSetBg
$LN8@TableSetBg:

; 1659 :         if (table->RowCellDataCurrent < 0 || table->RowCellData[table->RowCellDataCurrent].Column != column_n)

  00139	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0013d	0f bf 80 1a 02
	00 00		 movsx	 eax, WORD PTR [rax+538]
  00144	85 c0		 test	 eax, eax
  00146	7c 26		 jl	 SHORT $LN10@TableSetBg
  00148	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0014c	0f bf 80 1a 02
	00 00		 movsx	 eax, WORD PTR [rax+538]
  00153	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00157	48 83 c1 38	 add	 rcx, 56			; 00000038H
  0015b	8b d0		 mov	 edx, eax
  0015d	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z ; ImSpan<ImGuiTableCellData>::operator[]
  00162	0f bf 40 04	 movsx	 eax, WORD PTR [rax+4]
  00166	3b 85 70 01 00
	00		 cmp	 eax, DWORD PTR column_n$[rbp]
  0016c	74 19		 je	 SHORT $LN9@TableSetBg
$LN10@TableSetBg:

; 1660 :             table->RowCellDataCurrent++;

  0016e	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00172	0f b7 80 1a 02
	00 00		 movzx	 eax, WORD PTR [rax+538]
  00179	66 ff c0	 inc	 ax
  0017c	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00180	66 89 81 1a 02
	00 00		 mov	 WORD PTR [rcx+538], ax
$LN9@TableSetBg:

; 1661 :         ImGuiTableCellData* cell_data = &table->RowCellData[table->RowCellDataCurrent];

  00187	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0018b	0f bf 80 1a 02
	00 00		 movsx	 eax, WORD PTR [rax+538]
  00192	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00196	48 83 c1 38	 add	 rcx, 56			; 00000038H
  0019a	8b d0		 mov	 edx, eax
  0019c	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z ; ImSpan<ImGuiTableCellData>::operator[]
  001a1	48 89 45 48	 mov	 QWORD PTR cell_data$1[rbp], rax

; 1662 :         cell_data->BgColor = color;

  001a5	48 8b 45 48	 mov	 rax, QWORD PTR cell_data$1[rbp]
  001a9	8b 8d 68 01 00
	00		 mov	 ecx, DWORD PTR color$[rbp]
  001af	89 08		 mov	 DWORD PTR [rax], ecx

; 1663 :         cell_data->Column = (ImGuiTableColumnIdx)column_n;

  001b1	48 8b 45 48	 mov	 rax, QWORD PTR cell_data$1[rbp]
  001b5	0f b7 8d 70 01
	00 00		 movzx	 ecx, WORD PTR column_n$[rbp]
  001bc	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 1664 :         break;

  001c0	e9 ad 00 00 00	 jmp	 $LN2@TableSetBg
$LN11@TableSetBg:

; 1665 :     }
; 1666 :     case ImGuiTableBgTarget_RowBg0:
; 1667 :     case ImGuiTableBgTarget_RowBg1:
; 1668 :     {
; 1669 :         if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard

  001c5	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  001c9	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  001cd	f3 0f 10 40 7c	 movss	 xmm0, DWORD PTR [rax+124]
  001d2	0f 2f 81 24 01
	00 00		 comiss	 xmm0, DWORD PTR [rcx+292]
  001d9	76 05		 jbe	 SHORT $LN12@TableSetBg

; 1670 :             return;

  001db	e9 92 00 00 00	 jmp	 $LN1@TableSetBg
$LN12@TableSetBg:

; 1671 :         IM_ASSERT(column_n == -1);

  001e0	83 bd 70 01 00
	00 ff		 cmp	 DWORD PTR column_n$[rbp], -1
  001e7	74 22		 je	 SHORT $LN16@TableSetBg
  001e9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetBgColor@ImGui@@YAXHIH@Z@4JA
  001ef	83 c0 1f	 add	 eax, 31
  001f2	44 8b c0	 mov	 r8d, eax
  001f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@EGJMPMHM@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00209	33 c0		 xor	 eax, eax
$LN16@TableSetBg:

; 1672 :         int bg_idx = (target == ImGuiTableBgTarget_RowBg1) ? 1 : 0;

  0020b	83 bd 60 01 00
	00 02		 cmp	 DWORD PTR target$[rbp], 2
  00212	75 0c		 jne	 SHORT $LN17@TableSetBg
  00214	c7 85 34 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv157[rbp], 1
  0021e	eb 0a		 jmp	 SHORT $LN18@TableSetBg
$LN17@TableSetBg:
  00220	c7 85 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv157[rbp], 0
$LN18@TableSetBg:
  0022a	8b 85 34 01 00
	00		 mov	 eax, DWORD PTR tv157[rbp]
  00230	89 45 64	 mov	 DWORD PTR bg_idx$2[rbp], eax

; 1673 :         table->RowBgColor[bg_idx] = color;

  00233	48 63 45 64	 movsxd	 rax, DWORD PTR bg_idx$2[rbp]
  00237	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0023b	8b 95 68 01 00
	00		 mov	 edx, DWORD PTR color$[rbp]
  00241	89 94 81 98 00
	00 00		 mov	 DWORD PTR [rcx+rax*4+152], edx

; 1674 :         break;

  00248	eb 28		 jmp	 SHORT $LN2@TableSetBg
$LN13@TableSetBg:

; 1675 :     }
; 1676 :     default:
; 1677 :         IM_ASSERT(0);

  0024a	33 c0		 xor	 eax, eax
  0024c	85 c0		 test	 eax, eax
  0024e	75 22		 jne	 SHORT $LN19@TableSetBg
  00250	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetBgColor@ImGui@@YAXHIH@Z@4JA
  00256	83 c0 25	 add	 eax, 37			; 00000025H
  00259	44 8b c0	 mov	 r8d, eax
  0025c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00263	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  0026a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00270	33 c0		 xor	 eax, eax
$LN19@TableSetBg:
$LN2@TableSetBg:
$LN1@TableSetBg:

; 1678 :     }
; 1679 : }

  00272	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  00279	5f		 pop	 rdi
  0027a	5d		 pop	 rbp
  0027b	c3		 ret	 0
?TableSetBgColor@ImGui@@YAXHIH@Z ENDP			; ImGui::TableSetBgColor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetColumnEnabled@ImGui@@YAXH_N@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
column$ = 72
column_n$ = 320
enabled$ = 328
?TableSetColumnEnabled@ImGui@@YAXH_N@Z PROC		; ImGui::TableSetColumnEnabled, COMDAT

; 1573 : {

$LN9:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8b fc	 mov	 rdi, rsp
  00019	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR [rsp+360]

; 1574 :     ImGuiContext& g = *GImGui;

  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00033	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1575 :     ImGuiTable* table = g.CurrentTable;

  00037	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003b	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00042	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1576 :     IM_ASSERT(table != NULL);

  00046	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0004b	75 22		 jne	 SHORT $LN5@TableSetCo
  0004d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetColumnEnabled@ImGui@@YAXH_N@Z@4JA
  00053	83 c0 03	 add	 eax, 3
  00056	44 8b c0	 mov	 r8d, eax
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@IPNBPJPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006d	33 c0		 xor	 eax, eax
$LN5@TableSetCo:

; 1577 :     if (!table)

  0006f	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  00074	75 05		 jne	 SHORT $LN2@TableSetCo

; 1578 :         return;

  00076	e9 a8 00 00 00	 jmp	 $LN1@TableSetCo
$LN2@TableSetCo:

; 1579 :     IM_ASSERT(table->Flags & ImGuiTableFlags_Hideable); // See comments above

  0007b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0007f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00082	83 e0 04	 and	 eax, 4
  00085	85 c0		 test	 eax, eax
  00087	75 22		 jne	 SHORT $LN6@TableSetCo
  00089	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetColumnEnabled@ImGui@@YAXH_N@Z@4JA
  0008f	83 c0 06	 add	 eax, 6
  00092	44 8b c0	 mov	 r8d, eax
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@FCMNFGAM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAH@
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a9	33 c0		 xor	 eax, eax
$LN6@TableSetCo:

; 1580 :     if (column_n < 0)

  000ab	83 bd 40 01 00
	00 00		 cmp	 DWORD PTR column_n$[rbp], 0
  000b2	7d 0d		 jge	 SHORT $LN3@TableSetCo

; 1581 :         column_n = table->CurrentColumn;

  000b4	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000b8	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  000bb	89 85 40 01 00
	00		 mov	 DWORD PTR column_n$[rbp], eax
$LN3@TableSetCo:

; 1582 :     IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);

  000c1	83 bd 40 01 00
	00 00		 cmp	 DWORD PTR column_n$[rbp], 0
  000c8	7c 0f		 jl	 SHORT $LN7@TableSetCo
  000ca	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000ce	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000d1	39 85 40 01 00
	00		 cmp	 DWORD PTR column_n$[rbp], eax
  000d7	7c 22		 jl	 SHORT $LN8@TableSetCo
$LN7@TableSetCo:
  000d9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetColumnEnabled@ImGui@@YAXH_N@Z@4JA
  000df	83 c0 09	 add	 eax, 9
  000e2	44 8b c0	 mov	 r8d, eax
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GA@OFNPMLNE@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl@
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f9	33 c0		 xor	 eax, eax
$LN8@TableSetCo:

; 1583 :     ImGuiTableColumn* column = &table->Columns[column_n];

  000fb	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000ff	48 83 c0 18	 add	 rax, 24
  00103	8b 95 40 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00111	48 89 45 48	 mov	 QWORD PTR column$[rbp], rax

; 1584 :     column->IsUserEnabledNextFrame = enabled;

  00115	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  00119	0f b6 8d 48 01
	00 00		 movzx	 ecx, BYTE PTR enabled$[rbp]
  00120	88 48 64	 mov	 BYTE PTR [rax+100], cl
$LN1@TableSetCo:

; 1585 : }

  00123	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  0012a	5f		 pop	 rdi
  0012b	5d		 pop	 rbp
  0012c	c3		 ret	 0
?TableSetColumnEnabled@ImGui@@YAXH_N@Z ENDP		; ImGui::TableSetColumnEnabled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetColumnFlags@ImGui@@YAHH@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
tv73 = 244
column_n$ = 288
?TableGetColumnFlags@ImGui@@YAHH@Z PROC			; ImGui::TableGetColumnFlags, COMDAT

; 1589 : {

$LN8:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR [rsp+328]

; 1590 :     ImGuiContext& g = *GImGui;

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0002f	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1591 :     ImGuiTable* table = g.CurrentTable;

  00033	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00037	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  0003e	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1592 :     if (!table)

  00042	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  00047	75 04		 jne	 SHORT $LN2@TableGetCo

; 1593 :         return ImGuiTableColumnFlags_None;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 6e		 jmp	 SHORT $LN1@TableGetCo
$LN2@TableGetCo:

; 1594 :     if (column_n < 0)

  0004d	83 bd 20 01 00
	00 00		 cmp	 DWORD PTR column_n$[rbp], 0
  00054	7d 0d		 jge	 SHORT $LN3@TableGetCo

; 1595 :         column_n = table->CurrentColumn;

  00056	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0005a	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0005d	89 85 20 01 00
	00		 mov	 DWORD PTR column_n$[rbp], eax
$LN3@TableGetCo:

; 1596 :     if (column_n == table->ColumnsCount)

  00063	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00067	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0006a	39 85 20 01 00
	00		 cmp	 DWORD PTR column_n$[rbp], eax
  00070	75 31		 jne	 SHORT $LN4@TableGetCo

; 1597 :         return (table->HoveredColumnBody == column_n) ? ImGuiTableColumnFlags_IsHovered : ImGuiTableColumnFlags_None;

  00072	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00076	0f bf 80 f8 01
	00 00		 movsx	 eax, WORD PTR [rax+504]
  0007d	3b 85 20 01 00
	00		 cmp	 eax, DWORD PTR column_n$[rbp]
  00083	75 0c		 jne	 SHORT $LN6@TableGetCo
  00085	c7 85 f4 00 00
	00 00 00 00 08	 mov	 DWORD PTR tv73[rbp], 134217728 ; 08000000H
  0008f	eb 0a		 jmp	 SHORT $LN7@TableGetCo
$LN6@TableGetCo:
  00091	c7 85 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv73[rbp], 0
$LN7@TableGetCo:
  0009b	8b 85 f4 00 00
	00		 mov	 eax, DWORD PTR tv73[rbp]
  000a1	eb 18		 jmp	 SHORT $LN1@TableGetCo
$LN4@TableGetCo:

; 1598 :     return table->Columns[column_n].Flags;

  000a3	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000a7	48 83 c0 18	 add	 rax, 24
  000ab	8b 95 20 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  000b1	48 8b c8	 mov	 rcx, rax
  000b4	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  000b9	8b 00		 mov	 eax, DWORD PTR [rax]
$LN1@TableGetCo:

; 1599 : }

  000bb	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	c3		 ret	 0
?TableGetColumnFlags@ImGui@@YAHH@Z ENDP			; ImGui::TableGetColumnFlags
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetColumnName@ImGui@@YAPEBDH@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
column_n$ = 288
?TableGetColumnName@ImGui@@YAPEBDH@Z PROC		; ImGui::TableGetColumnName, COMDAT

; 1546 : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR [rsp+328]

; 1547 :     ImGuiContext& g = *GImGui;

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0002f	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1548 :     ImGuiTable* table = g.CurrentTable;

  00033	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00037	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  0003e	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1549 :     if (!table)

  00042	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  00047	75 04		 jne	 SHORT $LN2@TableGetCo

; 1550 :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 25		 jmp	 SHORT $LN1@TableGetCo
$LN2@TableGetCo:

; 1551 :     if (column_n < 0)

  0004d	83 bd 20 01 00
	00 00		 cmp	 DWORD PTR column_n$[rbp], 0
  00054	7d 0d		 jge	 SHORT $LN3@TableGetCo

; 1552 :         column_n = table->CurrentColumn;

  00056	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0005a	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0005d	89 85 20 01 00
	00		 mov	 DWORD PTR column_n$[rbp], eax
$LN3@TableGetCo:

; 1553 :     return TableGetColumnName(table, column_n);

  00063	8b 95 20 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  00069	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0006d	e8 00 00 00 00	 call	 ?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z ; ImGui::TableGetColumnName
$LN1@TableGetCo:

; 1554 : }

  00072	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00079	5f		 pop	 rdi
  0007a	5d		 pop	 rbp
  0007b	c3		 ret	 0
?TableGetColumnName@ImGui@@YAPEBDH@Z ENDP		; ImGui::TableGetColumnName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetRowIndex@ImGui@@YAHXZ
_TEXT	SEGMENT
g$ = 8
table$ = 40
?TableGetRowIndex@ImGui@@YAHXZ PROC			; ImGui::TableGetRowIndex, COMDAT

; 1692 : {

$LN4:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd

; 1693 :     ImGuiContext& g = *GImGui;

  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00023	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1694 :     ImGuiTable* table = g.CurrentTable;

  00027	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0002b	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00032	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1695 :     if (!table)

  00036	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0003b	75 04		 jne	 SHORT $LN2@TableGetRo

; 1696 :         return 0;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 07		 jmp	 SHORT $LN1@TableGetRo
$LN2@TableGetRo:

; 1697 :     return table->CurrentRow;

  00041	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00045	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
$LN1@TableGetRo:

; 1698 : }

  00048	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  0004f	5f		 pop	 rdi
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
?TableGetRowIndex@ImGui@@YAHXZ ENDP			; ImGui::TableGetRowIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetColumnIndex@ImGui@@YAHXZ
_TEXT	SEGMENT
g$ = 8
table$ = 40
?TableGetColumnIndex@ImGui@@YAHXZ PROC			; ImGui::TableGetColumnIndex, COMDAT

; 1906 : {

$LN4:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd

; 1907 :     ImGuiContext& g = *GImGui;

  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00023	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1908 :     ImGuiTable* table = g.CurrentTable;

  00027	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0002b	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00032	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1909 :     if (!table)

  00036	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0003b	75 04		 jne	 SHORT $LN2@TableGetCo

; 1910 :         return 0;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 07		 jmp	 SHORT $LN1@TableGetCo
$LN2@TableGetCo:

; 1911 :     return table->CurrentColumn;

  00041	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00045	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
$LN1@TableGetCo:

; 1912 : }

  00048	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  0004f	5f		 pop	 rdi
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
?TableGetColumnIndex@ImGui@@YAHXZ ENDP			; ImGui::TableGetColumnIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetColumnCount@ImGui@@YAHXZ
_TEXT	SEGMENT
g$ = 8
table$ = 40
tv67 = 244
?TableGetColumnCount@ImGui@@YAHXZ PROC			; ImGui::TableGetColumnCount, COMDAT

; 1539 : {

$LN5:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd

; 1540 :     ImGuiContext& g = *GImGui;

  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00023	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1541 :     ImGuiTable* table = g.CurrentTable;

  00027	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0002b	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00032	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1542 :     return table ? table->ColumnsCount : 0;

  00036	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0003b	74 0f		 je	 SHORT $LN3@TableGetCo
  0003d	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00041	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00044	89 85 f4 00 00
	00		 mov	 DWORD PTR tv67[rbp], eax
  0004a	eb 0a		 jmp	 SHORT $LN4@TableGetCo
$LN3@TableGetCo:
  0004c	c7 85 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv67[rbp], 0
$LN4@TableGetCo:
  00056	8b 85 f4 00 00
	00		 mov	 eax, DWORD PTR tv67[rbp]

; 1543 : }

  0005c	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00063	5f		 pop	 rdi
  00064	5d		 pop	 rbp
  00065	c3		 ret	 0
?TableGetColumnCount@ImGui@@YAHXZ ENDP			; ImGui::TableGetColumnCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ
_TEXT	SEGMENT
g$ = 8
table$ = 40
?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ PROC ; ImGui::TableGetSortSpecs, COMDAT

; 2645 : {

$LN6:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2646 :     ImGuiContext& g = *GImGui;

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00025	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 2647 :     ImGuiTable* table = g.CurrentTable;

  00029	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0002d	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00034	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 2648 :     IM_ASSERT(table != NULL);

  00038	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0003d	75 22		 jne	 SHORT $LN5@TableGetSo
  0003f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ@4JA
  00045	83 c0 03	 add	 eax, 3
  00048	44 8b c0	 mov	 r8d, eax
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@IPNBPJPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005f	33 c0		 xor	 eax, eax
$LN5@TableGetSo:

; 2649 : 
; 2650 :     if (!(table->Flags & ImGuiTableFlags_Sortable))

  00061	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00065	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00068	83 e0 08	 and	 eax, 8
  0006b	85 c0		 test	 eax, eax
  0006d	75 04		 jne	 SHORT $LN2@TableGetSo

; 2651 :         return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	eb 2b		 jmp	 SHORT $LN1@TableGetSo
$LN2@TableGetSo:

; 2652 : 
; 2653 :     // Require layout (in case TableHeadersRow() hasn't been called) as it may alter IsSortSpecsDirty in some paths.
; 2654 :     if (!table->IsLayoutLocked)

  00073	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00077	0f b6 80 22 02
	00 00		 movzx	 eax, BYTE PTR [rax+546]
  0007e	85 c0		 test	 eax, eax
  00080	75 09		 jne	 SHORT $LN3@TableGetSo

; 2655 :         TableUpdateLayout(table);

  00082	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00086	e8 00 00 00 00	 call	 ?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableUpdateLayout
$LN3@TableGetSo:

; 2656 : 
; 2657 :     TableSortSpecsBuild(table);

  0008b	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0008f	e8 00 00 00 00	 call	 ?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableSortSpecsBuild

; 2658 : 
; 2659 :     return &table->SortSpecs;

  00094	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00098	48 05 e0 01 00
	00		 add	 rax, 480		; 000001e0H
$LN1@TableGetSo:

; 2660 : }

  0009e	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000a5	5f		 pop	 rdi
  000a6	5d		 pop	 rbp
  000a7	c3		 ret	 0
?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ ENDP ; ImGui::TableGetSortSpecs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableHeader@ImGui@@YAXPEBD@Z
_TEXT	SEGMENT
g$ = 8
window$ = 40
table$ = 72
column_n$ = 100
column$ = 136
label_end$ = 168
label_size$ = 200
label_pos$ = 232
cell_r$ = 264
label_height$ = 308
w_arrow$ = 340
w_sort_text$ = 372
sort_order_suf$ = 404
ARROW_SCALE$ = 436
max_pos_x$ = 468
selected$ = 500
id$ = 532
bb$ = 568
hovered$ = 612
held$ = 644
pressed$ = 676
col$10 = 708
prev_column$11 = 744
next_column$12 = 776
ellipsis_max$ = 804
x$13 = 836
y$14 = 868
sort_direction$15 = 900
text_clipped$ = 932
$T16 = 1540
$T17 = 1572
$T18 = 1604
$T19 = 1636
$T20 = 1668
tv513 = 1684
tv468 = 1684
tv416 = 1684
tv378 = 1684
tv298 = 1684
tv213 = 1684
tv470 = 1688
tv422 = 1688
tv404 = 1688
tv384 = 1688
tv366 = 1688
tv295 = 1688
__$ArrayPad$ = 1696
label$ = 1744
?TableHeader@ImGui@@YAXPEBD@Z PROC			; ImGui::TableHeader, COMDAT

; 2900 : {

$LN54:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 06
	00 00		 sub	 rsp, 1784		; 000006f8H
  0000e	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 be 01 00 00	 mov	 ecx, 446		; 000001beH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 18
	07 00 00	 mov	 rcx, QWORD PTR [rsp+1816]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c5	 xor	 rax, rbp
  00034	48 89 85 a0 06
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 2901 :     ImGuiContext& g = *GImGui;

  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00042	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 2902 :     ImGuiWindow* window = g.CurrentWindow;

  00046	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0004a	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  00051	48 89 45 28	 mov	 QWORD PTR window$[rbp], rax

; 2903 :     if (window->SkipItems)

  00055	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00059	0f b6 80 b3 00
	00 00		 movzx	 eax, BYTE PTR [rax+179]
  00060	85 c0		 test	 eax, eax
  00062	74 05		 je	 SHORT $LN2@TableHeade

; 2904 :         return;

  00064	e9 5d 0b 00 00	 jmp	 $LN1@TableHeade
$LN2@TableHeade:

; 2905 : 
; 2906 :     ImGuiTable* table = g.CurrentTable;

  00069	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0006d	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00074	48 89 45 48	 mov	 QWORD PTR table$[rbp], rax

; 2907 :     IM_ASSERT(table != NULL && "Need to call TableHeader() after BeginTable()!");

  00078	48 83 7d 48 00	 cmp	 QWORD PTR table$[rbp], 0
  0007d	74 0c		 je	 SHORT $LN29@TableHeade
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CP@HLEIDDEE@Need?5to?5call?5TableHeader?$CI?$CJ?5after@
  00086	48 85 c0	 test	 rax, rax
  00089	75 22		 jne	 SHORT $LN30@TableHeade
$LN29@TableHeade:
  0008b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableHeader@ImGui@@YAXPEBD@Z@4JA
  00091	83 c0 07	 add	 eax, 7
  00094	44 8b c0	 mov	 r8d, eax
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HO@PDHKEBPE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ab	33 c0		 xor	 eax, eax
$LN30@TableHeade:

; 2908 :     IM_ASSERT(table->CurrentColumn != -1);

  000ad	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  000b1	83 78 74 ff	 cmp	 DWORD PTR [rax+116], -1
  000b5	75 22		 jne	 SHORT $LN31@TableHeade
  000b7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableHeader@ImGui@@YAXPEBD@Z@4JA
  000bd	83 c0 08	 add	 eax, 8
  000c0	44 8b c0	 mov	 r8d, eax
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CDIJLMHK@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d7	33 c0		 xor	 eax, eax
$LN31@TableHeade:

; 2909 :     const int column_n = table->CurrentColumn;

  000d9	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  000dd	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  000e0	89 45 64	 mov	 DWORD PTR column_n$[rbp], eax

; 2910 :     ImGuiTableColumn* column = &table->Columns[column_n];

  000e3	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  000e7	48 83 c0 18	 add	 rax, 24
  000eb	8b 55 64	 mov	 edx, DWORD PTR column_n$[rbp]
  000ee	48 8b c8	 mov	 rcx, rax
  000f1	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  000f6	48 89 85 88 00
	00 00		 mov	 QWORD PTR column$[rbp], rax

; 2911 : 
; 2912 :     // Label
; 2913 :     if (label == NULL)

  000fd	48 83 bd d0 06
	00 00 00	 cmp	 QWORD PTR label$[rbp], 0
  00105	75 0e		 jne	 SHORT $LN3@TableHeade

; 2914 :         label = "";

  00107	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0010e	48 89 85 d0 06
	00 00		 mov	 QWORD PTR label$[rbp], rax
$LN3@TableHeade:

; 2915 :     const char* label_end = FindRenderedTextEnd(label);

  00115	33 d2		 xor	 edx, edx
  00117	48 8b 8d d0 06
	00 00		 mov	 rcx, QWORD PTR label$[rbp]
  0011e	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z ; ImGui::FindRenderedTextEnd
  00123	48 89 85 a8 00
	00 00		 mov	 QWORD PTR label_end$[rbp], rax

; 2916 :     ImVec2 label_size = CalcTextSize(label, label_end, true);

  0012a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00132	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00138	41 b1 01	 mov	 r9b, 1
  0013b	4c 8b 85 a8 00
	00 00		 mov	 r8, QWORD PTR label_end$[rbp]
  00142	48 8b 95 d0 06
	00 00		 mov	 rdx, QWORD PTR label$[rbp]
  00149	48 8d 8d c8 00
	00 00		 lea	 rcx, QWORD PTR label_size$[rbp]
  00150	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize

; 2917 :     ImVec2 label_pos = window->DC.CursorPos;

  00155	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00159	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00160	48 89 85 e8 00
	00 00		 mov	 QWORD PTR label_pos$[rbp], rax

; 2918 : 
; 2919 :     // If we already got a row height, there's use that.
; 2920 :     // FIXME-TABLE: Padding problem if the correct outer-padding CellBgRect strays off our ClipRect?
; 2921 :     ImRect cell_r = TableGetCellBgRect(table, column_n);

  00167	44 8b 45 64	 mov	 r8d, DWORD PTR column_n$[rbp]
  0016b	48 8b 55 48	 mov	 rdx, QWORD PTR table$[rbp]
  0016f	48 8d 8d 08 01
	00 00		 lea	 rcx, QWORD PTR cell_r$[rbp]
  00176	e8 00 00 00 00	 call	 ?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z ; ImGui::TableGetCellBgRect

; 2922 :     float label_height = ImMax(label_size.y, table->RowMinHeight - table->CellPaddingY * 2.0f);

  0017b	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  0017f	f3 0f 10 80 c0
	00 00 00	 movss	 xmm0, DWORD PTR [rax+192]
  00187	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0018f	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00193	f3 0f 10 88 84
	00 00 00	 movss	 xmm1, DWORD PTR [rax+132]
  0019b	f3 0f 5c c8	 subss	 xmm1, xmm0
  0019f	0f 28 c1	 movaps	 xmm0, xmm1
  001a2	0f 28 c8	 movaps	 xmm1, xmm0
  001a5	f3 0f 10 85 cc
	00 00 00	 movss	 xmm0, DWORD PTR label_size$[rbp+4]
  001ad	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001b2	f3 0f 11 85 34
	01 00 00	 movss	 DWORD PTR label_height$[rbp], xmm0

; 2923 : 
; 2924 :     // Calculate ideal size for sort order arrow
; 2925 :     float w_arrow = 0.0f;

  001ba	0f 57 c0	 xorps	 xmm0, xmm0
  001bd	f3 0f 11 85 54
	01 00 00	 movss	 DWORD PTR w_arrow$[rbp], xmm0

; 2926 :     float w_sort_text = 0.0f;

  001c5	0f 57 c0	 xorps	 xmm0, xmm0
  001c8	f3 0f 11 85 74
	01 00 00	 movss	 DWORD PTR w_sort_text$[rbp], xmm0

; 2927 :     char sort_order_suf[4] = "";

  001d0	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
  001d7	88 85 94 01 00
	00		 mov	 BYTE PTR sort_order_suf$[rbp], al
  001dd	48 8d 85 95 01
	00 00		 lea	 rax, QWORD PTR sort_order_suf$[rbp+1]
  001e4	48 8b f8	 mov	 rdi, rax
  001e7	33 c0		 xor	 eax, eax
  001e9	b9 03 00 00 00	 mov	 ecx, 3
  001ee	f3 aa		 rep stosb

; 2928 :     const float ARROW_SCALE = 0.65f;

  001f0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  001f8	f3 0f 11 85 b4
	01 00 00	 movss	 DWORD PTR ARROW_SCALE$[rbp], xmm0

; 2929 :     if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))

  00200	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00204	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00207	83 e0 08	 and	 eax, 8
  0020a	85 c0		 test	 eax, eax
  0020c	0f 84 b9 00 00
	00		 je	 $LN4@TableHeade
  00212	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00219	8b 00		 mov	 eax, DWORD PTR [rax]
  0021b	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00220	85 c0		 test	 eax, eax
  00222	0f 85 a3 00 00
	00		 jne	 $LN4@TableHeade

; 2930 :     {
; 2931 :         w_arrow = ImFloor(g.FontSize * ARROW_SCALE + g.Style.FramePadding.x);

  00228	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0022c	f3 0f 10 80 00
	3c 00 00	 movss	 xmm0, DWORD PTR [rax+15360]
  00234	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f266666
  0023c	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00240	f3 0f 58 80 1c
	38 00 00	 addss	 xmm0, DWORD PTR [rax+14364]
  00248	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  0024d	f3 0f 11 85 54
	01 00 00	 movss	 DWORD PTR w_arrow$[rbp], xmm0

; 2932 :         if (column->SortOrder > 0)

  00255	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0025c	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  00260	85 c0		 test	 eax, eax
  00262	7e 67		 jle	 SHORT $LN5@TableHeade

; 2933 :         {
; 2934 :             ImFormatString(sort_order_suf, IM_ARRAYSIZE(sort_order_suf), "%d", column->SortOrder + 1);

  00264	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0026b	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  0026f	ff c0		 inc	 eax
  00271	44 8b c8	 mov	 r9d, eax
  00274	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  0027b	ba 04 00 00 00	 mov	 edx, 4
  00280	48 8d 8d 94 01
	00 00		 lea	 rcx, QWORD PTR sort_order_suf$[rbp]
  00287	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPEAD_KPEBDZZ ; ImFormatString

; 2935 :             w_sort_text = g.Style.ItemInnerSpacing.x + CalcTextSize(sort_order_suf).x;

  0028c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00294	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0029a	45 33 c9	 xor	 r9d, r9d
  0029d	45 33 c0	 xor	 r8d, r8d
  002a0	48 8d 95 94 01
	00 00		 lea	 rdx, QWORD PTR sort_order_suf$[rbp]
  002a7	48 8d 8d 04 06
	00 00		 lea	 rcx, QWORD PTR $T16[rbp]
  002ae	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z ; ImGui::CalcTextSize
  002b3	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  002b7	f3 0f 10 81 34
	38 00 00	 movss	 xmm0, DWORD PTR [rcx+14388]
  002bf	f3 0f 58 00	 addss	 xmm0, DWORD PTR [rax]
  002c3	f3 0f 11 85 74
	01 00 00	 movss	 DWORD PTR w_sort_text$[rbp], xmm0
$LN5@TableHeade:
$LN4@TableHeade:

; 2936 :         }
; 2937 :     }
; 2938 : 
; 2939 :     // We feed our unclipped width to the column without writing on CursorMaxPos, so that column is still considering for merging.
; 2940 :     float max_pos_x = label_pos.x + label_size.x + w_sort_text + w_arrow;

  002cb	f3 0f 10 85 e8
	00 00 00	 movss	 xmm0, DWORD PTR label_pos$[rbp]
  002d3	f3 0f 58 85 c8
	00 00 00	 addss	 xmm0, DWORD PTR label_size$[rbp]
  002db	f3 0f 58 85 74
	01 00 00	 addss	 xmm0, DWORD PTR w_sort_text$[rbp]
  002e3	f3 0f 58 85 54
	01 00 00	 addss	 xmm0, DWORD PTR w_arrow$[rbp]
  002eb	f3 0f 11 85 d4
	01 00 00	 movss	 DWORD PTR max_pos_x$[rbp], xmm0

; 2941 :     column->ContentMaxXHeadersUsed = ImMax(column->ContentMaxXHeadersUsed, column->WorkMaxX);

  002f3	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  002fa	f3 0f 10 48 38	 movss	 xmm1, DWORD PTR [rax+56]
  002ff	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00306	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [rax+72]
  0030b	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00310	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00317	f3 0f 11 40 48	 movss	 DWORD PTR [rax+72], xmm0

; 2942 :     column->ContentMaxXHeadersIdeal = ImMax(column->ContentMaxXHeadersIdeal, max_pos_x);

  0031c	f3 0f 10 8d d4
	01 00 00	 movss	 xmm1, DWORD PTR max_pos_x$[rbp]
  00324	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0032b	f3 0f 10 40 4c	 movss	 xmm0, DWORD PTR [rax+76]
  00330	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00335	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0033c	f3 0f 11 40 4c	 movss	 DWORD PTR [rax+76], xmm0

; 2943 : 
; 2944 :     // Keep header highlighted when context menu is open.
; 2945 :     const bool selected = (table->IsContextPopupOpen && table->ContextPopupColumn == column_n && table->InstanceInteracted == table->InstanceCurrent);

  00341	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00345	0f b6 80 27 02
	00 00		 movzx	 eax, BYTE PTR [rax+551]
  0034c	85 c0		 test	 eax, eax
  0034e	74 2d		 je	 SHORT $LN32@TableHeade
  00350	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00354	0f bf 80 10 02
	00 00		 movsx	 eax, WORD PTR [rax+528]
  0035b	3b 45 64	 cmp	 eax, DWORD PTR column_n$[rbp]
  0035e	75 1d		 jne	 SHORT $LN32@TableHeade
  00360	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00364	0f bf 40 7a	 movsx	 eax, WORD PTR [rax+122]
  00368	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  0036c	0f bf 49 78	 movsx	 ecx, WORD PTR [rcx+120]
  00370	3b c1		 cmp	 eax, ecx
  00372	75 09		 jne	 SHORT $LN32@TableHeade
  00374	c6 85 94 06 00
	00 01		 mov	 BYTE PTR tv213[rbp], 1
  0037b	eb 07		 jmp	 SHORT $LN33@TableHeade
$LN32@TableHeade:
  0037d	c6 85 94 06 00
	00 00		 mov	 BYTE PTR tv213[rbp], 0
$LN33@TableHeade:
  00384	0f b6 85 94 06
	00 00		 movzx	 eax, BYTE PTR tv213[rbp]
  0038b	88 85 f4 01 00
	00		 mov	 BYTE PTR selected$[rbp], al

; 2946 :     ImGuiID id = window->GetID(label);

  00391	45 33 c0	 xor	 r8d, r8d
  00394	48 8b 95 d0 06
	00 00		 mov	 rdx, QWORD PTR label$[rbp]
  0039b	48 8b 4d 28	 mov	 rcx, QWORD PTR window$[rbp]
  0039f	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QEAAIPEBD0@Z ; ImGuiWindow::GetID
  003a4	89 85 14 02 00
	00		 mov	 DWORD PTR id$[rbp], eax

; 2947 :     ImRect bb(cell_r.Min.x, cell_r.Min.y, cell_r.Max.x, ImMax(cell_r.Max.y, cell_r.Min.y + label_height + g.Style.CellPadding.y * 2.0f));

  003aa	f3 0f 10 85 0c
	01 00 00	 movss	 xmm0, DWORD PTR cell_r$[rbp+4]
  003b2	f3 0f 58 85 34
	01 00 00	 addss	 xmm0, DWORD PTR label_height$[rbp]
  003ba	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  003be	f3 0f 10 88 40
	38 00 00	 movss	 xmm1, DWORD PTR [rax+14400]
  003c6	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  003ce	f3 0f 58 c1	 addss	 xmm0, xmm1
  003d2	0f 28 c8	 movaps	 xmm1, xmm0
  003d5	f3 0f 10 85 14
	01 00 00	 movss	 xmm0, DWORD PTR cell_r$[rbp+12]
  003dd	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  003e2	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  003e8	f3 0f 10 9d 10
	01 00 00	 movss	 xmm3, DWORD PTR cell_r$[rbp+8]
  003f0	f3 0f 10 95 0c
	01 00 00	 movss	 xmm2, DWORD PTR cell_r$[rbp+4]
  003f8	f3 0f 10 8d 08
	01 00 00	 movss	 xmm1, DWORD PTR cell_r$[rbp]
  00400	48 8d 8d 38 02
	00 00		 lea	 rcx, QWORD PTR bb$[rbp]
  00407	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@MMMM@Z	; ImRect::ImRect

; 2948 :     ItemSize(ImVec2(0.0f, label_height)); // Don't declare unclipped width, it'll be fed ContentMaxPosHeadersIdeal

  0040c	f3 0f 10 95 34
	01 00 00	 movss	 xmm2, DWORD PTR label_height$[rbp]
  00414	0f 57 c9	 xorps	 xmm1, xmm1
  00417	48 8d 8d 24 06
	00 00		 lea	 rcx, QWORD PTR $T17[rbp]
  0041e	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00423	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  0042b	48 8b c8	 mov	 rcx, rax
  0042e	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z ; ImGui::ItemSize

; 2949 :     if (!ItemAdd(bb, id))

  00433	45 33 c9	 xor	 r9d, r9d
  00436	45 33 c0	 xor	 r8d, r8d
  00439	8b 95 14 02 00
	00		 mov	 edx, DWORD PTR id$[rbp]
  0043f	48 8d 8d 38 02
	00 00		 lea	 rcx, QWORD PTR bb$[rbp]
  00446	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
  0044b	0f b6 c0	 movzx	 eax, al
  0044e	85 c0		 test	 eax, eax
  00450	75 05		 jne	 SHORT $LN6@TableHeade

; 2950 :         return;

  00452	e9 6f 07 00 00	 jmp	 $LN1@TableHeade
$LN6@TableHeade:

; 2951 : 
; 2952 :     //GetForegroundDrawList()->AddRect(cell_r.Min, cell_r.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]
; 2953 :     //GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]
; 2954 : 
; 2955 :     // Using AllowItemOverlap mode because we cover the whole cell, and we want user to be able to submit subsequent items.
; 2956 :     bool hovered, held;
; 2957 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_AllowItemOverlap);

  00457	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR [rsp+32], 4096 ; 00001000H
  0045f	4c 8d 8d 84 02
	00 00		 lea	 r9, QWORD PTR held$[rbp]
  00466	4c 8d 85 64 02
	00 00		 lea	 r8, QWORD PTR hovered$[rbp]
  0046d	8b 95 14 02 00
	00		 mov	 edx, DWORD PTR id$[rbp]
  00473	48 8d 8d 38 02
	00 00		 lea	 rcx, QWORD PTR bb$[rbp]
  0047a	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
  0047f	88 85 a4 02 00
	00		 mov	 BYTE PTR pressed$[rbp], al

; 2958 :     if (g.ActiveId != id)

  00485	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00489	8b 8d 14 02 00
	00		 mov	 ecx, DWORD PTR id$[rbp]
  0048f	39 88 00 3f 00
	00		 cmp	 DWORD PTR [rax+16128], ecx
  00495	74 05		 je	 SHORT $LN7@TableHeade

; 2959 :         SetItemAllowOverlap();

  00497	e8 00 00 00 00	 call	 ?SetItemAllowOverlap@ImGui@@YAXXZ ; ImGui::SetItemAllowOverlap
$LN7@TableHeade:

; 2960 :     if (held || hovered || selected)

  0049c	0f b6 85 84 02
	00 00		 movzx	 eax, BYTE PTR held$[rbp]
  004a3	85 c0		 test	 eax, eax
  004a5	75 16		 jne	 SHORT $LN10@TableHeade
  004a7	0f b6 85 64 02
	00 00		 movzx	 eax, BYTE PTR hovered$[rbp]
  004ae	85 c0		 test	 eax, eax
  004b0	75 0b		 jne	 SHORT $LN10@TableHeade
  004b2	0f b6 85 f4 01
	00 00		 movzx	 eax, BYTE PTR selected$[rbp]
  004b9	85 c0		 test	 eax, eax
  004bb	74 77		 je	 SHORT $LN8@TableHeade
$LN10@TableHeade:

; 2961 :     {
; 2962 :         const ImU32 col = GetColorU32(held ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

  004bd	0f b6 85 84 02
	00 00		 movzx	 eax, BYTE PTR held$[rbp]
  004c4	85 c0		 test	 eax, eax
  004c6	74 0c		 je	 SHORT $LN36@TableHeade
  004c8	c7 85 94 06 00
	00 1a 00 00 00	 mov	 DWORD PTR tv298[rbp], 26
  004d2	eb 2d		 jmp	 SHORT $LN37@TableHeade
$LN36@TableHeade:
  004d4	0f b6 85 64 02
	00 00		 movzx	 eax, BYTE PTR hovered$[rbp]
  004db	85 c0		 test	 eax, eax
  004dd	74 0c		 je	 SHORT $LN34@TableHeade
  004df	c7 85 98 06 00
	00 19 00 00 00	 mov	 DWORD PTR tv295[rbp], 25
  004e9	eb 0a		 jmp	 SHORT $LN35@TableHeade
$LN34@TableHeade:
  004eb	c7 85 98 06 00
	00 18 00 00 00	 mov	 DWORD PTR tv295[rbp], 24
$LN35@TableHeade:
  004f5	8b 85 98 06 00
	00		 mov	 eax, DWORD PTR tv295[rbp]
  004fb	89 85 94 06 00
	00		 mov	 DWORD PTR tv298[rbp], eax
$LN37@TableHeade:
  00501	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00509	8b 8d 94 06 00
	00		 mov	 ecx, DWORD PTR tv298[rbp]
  0050f	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00514	89 85 c4 02 00
	00		 mov	 DWORD PTR col$10[rbp], eax

; 2963 :         //RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
; 2964 :         TableSetBgColor(ImGuiTableBgTarget_CellBg, col, table->CurrentColumn);

  0051a	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  0051e	44 8b 40 74	 mov	 r8d, DWORD PTR [rax+116]
  00522	8b 95 c4 02 00
	00		 mov	 edx, DWORD PTR col$10[rbp]
  00528	b9 03 00 00 00	 mov	 ecx, 3
  0052d	e8 00 00 00 00	 call	 ?TableSetBgColor@ImGui@@YAXHIH@Z ; ImGui::TableSetBgColor

; 2965 :     }
; 2966 :     else

  00532	eb 3d		 jmp	 SHORT $LN9@TableHeade
$LN8@TableHeade:

; 2967 :     {
; 2968 :         // Submit single cell bg color in the case we didn't submit a full header row
; 2969 :         if ((table->RowFlags & ImGuiTableRowFlags_Headers) == 0)

  00534	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00538	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0053e	c1 e0 10	 shl	 eax, 16
  00541	c1 f8 10	 sar	 eax, 16
  00544	83 e0 01	 and	 eax, 1
  00547	85 c0		 test	 eax, eax
  00549	75 26		 jne	 SHORT $LN11@TableHeade

; 2970 :             TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_TableHeaderBg), table->CurrentColumn);

  0054b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00553	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00558	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0055d	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  00561	44 8b 41 74	 mov	 r8d, DWORD PTR [rcx+116]
  00565	8b d0		 mov	 edx, eax
  00567	b9 03 00 00 00	 mov	 ecx, 3
  0056c	e8 00 00 00 00	 call	 ?TableSetBgColor@ImGui@@YAXHIH@Z ; ImGui::TableSetBgColor
$LN11@TableHeade:
$LN9@TableHeade:

; 2971 :     }
; 2972 :     RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);

  00571	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00577	8b 95 14 02 00
	00		 mov	 edx, DWORD PTR id$[rbp]
  0057d	48 8d 8d 38 02
	00 00		 lea	 rcx, QWORD PTR bb$[rbp]
  00584	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 2973 :     if (held)

  00589	0f b6 85 84 02
	00 00		 movzx	 eax, BYTE PTR held$[rbp]
  00590	85 c0		 test	 eax, eax
  00592	74 0f		 je	 SHORT $LN12@TableHeade

; 2974 :         table->HeldHeaderColumn = (ImGuiTableColumnIdx)column_n;

  00594	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00598	0f b7 4d 64	 movzx	 ecx, WORD PTR column_n$[rbp]
  0059c	66 89 88 02 02
	00 00		 mov	 WORD PTR [rax+514], cx
$LN12@TableHeade:

; 2975 :     window->DC.CursorPos.y -= g.Style.ItemSpacing.y * 0.5f;

  005a3	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  005a7	f3 0f 10 80 30
	38 00 00	 movss	 xmm0, DWORD PTR [rax+14384]
  005af	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  005b7	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  005bb	f3 0f 10 88 fc
	00 00 00	 movss	 xmm1, DWORD PTR [rax+252]
  005c3	f3 0f 5c c8	 subss	 xmm1, xmm0
  005c7	0f 28 c1	 movaps	 xmm0, xmm1
  005ca	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  005ce	f3 0f 11 80 fc
	00 00 00	 movss	 DWORD PTR [rax+252], xmm0

; 2976 : 
; 2977 :     // Drag and drop to re-order columns.
; 2978 :     // FIXME-TABLE: Scroll request while reordering a column and it lands out of the scrolling zone.
; 2979 :     if (held && (table->Flags & ImGuiTableFlags_Reorderable) && IsMouseDragging(0) && !g.DragDropActive)

  005d6	0f b6 85 84 02
	00 00		 movzx	 eax, BYTE PTR held$[rbp]
  005dd	85 c0		 test	 eax, eax
  005df	0f 84 a3 02 00
	00		 je	 $LN13@TableHeade
  005e5	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  005e9	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  005ec	83 e0 02	 and	 eax, 2
  005ef	85 c0		 test	 eax, eax
  005f1	0f 84 91 02 00
	00		 je	 $LN13@TableHeade
  005f7	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  005ff	33 c9		 xor	 ecx, ecx
  00601	e8 00 00 00 00	 call	 ?IsMouseDragging@ImGui@@YA_NHM@Z ; ImGui::IsMouseDragging
  00606	0f b6 c0	 movzx	 eax, al
  00609	85 c0		 test	 eax, eax
  0060b	0f 84 77 02 00
	00		 je	 $LN13@TableHeade
  00611	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00615	0f b6 80 2c 4a
	00 00		 movzx	 eax, BYTE PTR [rax+18988]
  0061c	85 c0		 test	 eax, eax
  0061e	0f 85 64 02 00
	00		 jne	 $LN13@TableHeade

; 2980 :     {
; 2981 :         // While moving a column it will jump on the other side of the mouse, so we also test for MouseDelta.x
; 2982 :         table->ReorderColumn = (ImGuiTableColumnIdx)column_n;

  00624	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00628	0f b7 4d 64	 movzx	 ecx, WORD PTR column_n$[rbp]
  0062c	66 89 88 04 02
	00 00		 mov	 WORD PTR [rax+516], cx

; 2983 :         table->InstanceInteracted = table->InstanceCurrent;

  00633	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00637	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  0063b	0f b7 49 78	 movzx	 ecx, WORD PTR [rcx+120]
  0063f	66 89 48 7a	 mov	 WORD PTR [rax+122], cx

; 2984 : 
; 2985 :         // We don't reorder: through the frozen<>unfrozen line, or through a column that is marked with ImGuiTableColumnFlags_NoReorder.
; 2986 :         if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < cell_r.Min.x)

  00643	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00647	0f 57 c0	 xorps	 xmm0, xmm0
  0064a	0f 2f 80 f8 00
	00 00		 comiss	 xmm0, DWORD PTR [rax+248]
  00651	0f 86 0c 01 00
	00		 jbe	 $LN14@TableHeade
  00657	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0065b	f3 0f 10 85 08
	01 00 00	 movss	 xmm0, DWORD PTR cell_r$[rbp]
  00663	0f 2f 80 fc 0d
	00 00		 comiss	 xmm0, DWORD PTR [rax+3580]
  0066a	0f 86 f3 00 00
	00		 jbe	 $LN14@TableHeade

; 2987 :             if (ImGuiTableColumn* prev_column = (column->PrevEnabledColumn != -1) ? &table->Columns[column->PrevEnabledColumn] : NULL)

  00670	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00677	0f bf 40 56	 movsx	 eax, WORD PTR [rax+86]
  0067b	83 f8 ff	 cmp	 eax, -1
  0067e	74 23		 je	 SHORT $LN38@TableHeade
  00680	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00687	0f bf 40 56	 movsx	 eax, WORD PTR [rax+86]
  0068b	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  0068f	48 83 c1 18	 add	 rcx, 24
  00693	8b d0		 mov	 edx, eax
  00695	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  0069a	48 89 85 98 06
	00 00		 mov	 QWORD PTR tv366[rbp], rax
  006a1	eb 0b		 jmp	 SHORT $LN39@TableHeade
$LN38@TableHeade:
  006a3	48 c7 85 98 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv366[rbp], 0
$LN39@TableHeade:
  006ae	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR tv366[rbp]
  006b5	48 89 85 e8 02
	00 00		 mov	 QWORD PTR prev_column$11[rbp], rax
  006bc	48 83 bd e8 02
	00 00 00	 cmp	 QWORD PTR prev_column$11[rbp], 0
  006c4	0f 84 99 00 00
	00		 je	 $LN15@TableHeade

; 2988 :                 if (!((column->Flags | prev_column->Flags) & ImGuiTableColumnFlags_NoReorder))

  006ca	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  006d1	48 8b 8d e8 02
	00 00		 mov	 rcx, QWORD PTR prev_column$11[rbp]
  006d8	8b 09		 mov	 ecx, DWORD PTR [rcx]
  006da	8b 00		 mov	 eax, DWORD PTR [rax]
  006dc	0b c1		 or	 eax, ecx
  006de	83 e0 40	 and	 eax, 64			; 00000040H
  006e1	85 c0		 test	 eax, eax
  006e3	75 7e		 jne	 SHORT $LN16@TableHeade

; 2989 :                     if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (prev_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))

  006e5	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  006ec	0f bf 40 54	 movsx	 eax, WORD PTR [rax+84]
  006f0	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  006f4	0f bf 89 16 02
	00 00		 movsx	 ecx, WORD PTR [rcx+534]
  006fb	3b c1		 cmp	 eax, ecx
  006fd	7d 0c		 jge	 SHORT $LN40@TableHeade
  006ff	c7 85 94 06 00
	00 01 00 00 00	 mov	 DWORD PTR tv378[rbp], 1
  00709	eb 0a		 jmp	 SHORT $LN41@TableHeade
$LN40@TableHeade:
  0070b	c7 85 94 06 00
	00 00 00 00 00	 mov	 DWORD PTR tv378[rbp], 0
$LN41@TableHeade:
  00715	48 8b 85 e8 02
	00 00		 mov	 rax, QWORD PTR prev_column$11[rbp]
  0071c	0f bf 40 54	 movsx	 eax, WORD PTR [rax+84]
  00720	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  00724	0f bf 89 16 02
	00 00		 movsx	 ecx, WORD PTR [rcx+534]
  0072b	3b c1		 cmp	 eax, ecx
  0072d	7d 0c		 jge	 SHORT $LN42@TableHeade
  0072f	c7 85 98 06 00
	00 01 00 00 00	 mov	 DWORD PTR tv384[rbp], 1
  00739	eb 0a		 jmp	 SHORT $LN43@TableHeade
$LN42@TableHeade:
  0073b	c7 85 98 06 00
	00 00 00 00 00	 mov	 DWORD PTR tv384[rbp], 0
$LN43@TableHeade:
  00745	8b 85 98 06 00
	00		 mov	 eax, DWORD PTR tv384[rbp]
  0074b	39 85 94 06 00
	00		 cmp	 DWORD PTR tv378[rbp], eax
  00751	75 10		 jne	 SHORT $LN17@TableHeade

; 2990 :                         table->ReorderColumnDir = -1;

  00753	b8 ff ff ff ff	 mov	 eax, -1
  00758	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  0075c	66 89 81 06 02
	00 00		 mov	 WORD PTR [rcx+518], ax
$LN17@TableHeade:
$LN16@TableHeade:
$LN15@TableHeade:
$LN14@TableHeade:

; 2991 :         if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > cell_r.Max.x)

  00763	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00767	f3 0f 10 80 f8
	00 00 00	 movss	 xmm0, DWORD PTR [rax+248]
  0076f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00776	0f 86 0c 01 00
	00		 jbe	 $LN18@TableHeade
  0077c	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00780	f3 0f 10 80 fc
	0d 00 00	 movss	 xmm0, DWORD PTR [rax+3580]
  00788	0f 2f 85 10 01
	00 00		 comiss	 xmm0, DWORD PTR cell_r$[rbp+8]
  0078f	0f 86 f3 00 00
	00		 jbe	 $LN18@TableHeade

; 2992 :             if (ImGuiTableColumn* next_column = (column->NextEnabledColumn != -1) ? &table->Columns[column->NextEnabledColumn] : NULL)

  00795	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0079c	0f bf 40 58	 movsx	 eax, WORD PTR [rax+88]
  007a0	83 f8 ff	 cmp	 eax, -1
  007a3	74 23		 je	 SHORT $LN44@TableHeade
  007a5	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  007ac	0f bf 40 58	 movsx	 eax, WORD PTR [rax+88]
  007b0	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  007b4	48 83 c1 18	 add	 rcx, 24
  007b8	8b d0		 mov	 edx, eax
  007ba	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  007bf	48 89 85 98 06
	00 00		 mov	 QWORD PTR tv404[rbp], rax
  007c6	eb 0b		 jmp	 SHORT $LN45@TableHeade
$LN44@TableHeade:
  007c8	48 c7 85 98 06
	00 00 00 00 00
	00		 mov	 QWORD PTR tv404[rbp], 0
$LN45@TableHeade:
  007d3	48 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR tv404[rbp]
  007da	48 89 85 08 03
	00 00		 mov	 QWORD PTR next_column$12[rbp], rax
  007e1	48 83 bd 08 03
	00 00 00	 cmp	 QWORD PTR next_column$12[rbp], 0
  007e9	0f 84 99 00 00
	00		 je	 $LN19@TableHeade

; 2993 :                 if (!((column->Flags | next_column->Flags) & ImGuiTableColumnFlags_NoReorder))

  007ef	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  007f6	48 8b 8d 08 03
	00 00		 mov	 rcx, QWORD PTR next_column$12[rbp]
  007fd	8b 09		 mov	 ecx, DWORD PTR [rcx]
  007ff	8b 00		 mov	 eax, DWORD PTR [rax]
  00801	0b c1		 or	 eax, ecx
  00803	83 e0 40	 and	 eax, 64			; 00000040H
  00806	85 c0		 test	 eax, eax
  00808	75 7e		 jne	 SHORT $LN20@TableHeade

; 2994 :                     if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (next_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))

  0080a	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  00811	0f bf 40 54	 movsx	 eax, WORD PTR [rax+84]
  00815	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  00819	0f bf 89 16 02
	00 00		 movsx	 ecx, WORD PTR [rcx+534]
  00820	3b c1		 cmp	 eax, ecx
  00822	7d 0c		 jge	 SHORT $LN46@TableHeade
  00824	c7 85 94 06 00
	00 01 00 00 00	 mov	 DWORD PTR tv416[rbp], 1
  0082e	eb 0a		 jmp	 SHORT $LN47@TableHeade
$LN46@TableHeade:
  00830	c7 85 94 06 00
	00 00 00 00 00	 mov	 DWORD PTR tv416[rbp], 0
$LN47@TableHeade:
  0083a	48 8b 85 08 03
	00 00		 mov	 rax, QWORD PTR next_column$12[rbp]
  00841	0f bf 40 54	 movsx	 eax, WORD PTR [rax+84]
  00845	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  00849	0f bf 89 16 02
	00 00		 movsx	 ecx, WORD PTR [rcx+534]
  00850	3b c1		 cmp	 eax, ecx
  00852	7d 0c		 jge	 SHORT $LN48@TableHeade
  00854	c7 85 98 06 00
	00 01 00 00 00	 mov	 DWORD PTR tv422[rbp], 1
  0085e	eb 0a		 jmp	 SHORT $LN49@TableHeade
$LN48@TableHeade:
  00860	c7 85 98 06 00
	00 00 00 00 00	 mov	 DWORD PTR tv422[rbp], 0
$LN49@TableHeade:
  0086a	8b 85 98 06 00
	00		 mov	 eax, DWORD PTR tv422[rbp]
  00870	39 85 94 06 00
	00		 cmp	 DWORD PTR tv416[rbp], eax
  00876	75 10		 jne	 SHORT $LN21@TableHeade

; 2995 :                         table->ReorderColumnDir = +1;

  00878	b8 01 00 00 00	 mov	 eax, 1
  0087d	48 8b 4d 48	 mov	 rcx, QWORD PTR table$[rbp]
  00881	66 89 81 06 02
	00 00		 mov	 WORD PTR [rcx+518], ax
$LN21@TableHeade:
$LN20@TableHeade:
$LN19@TableHeade:
$LN18@TableHeade:
$LN13@TableHeade:

; 2996 :     }
; 2997 : 
; 2998 :     // Sort order arrow
; 2999 :     const float ellipsis_max = cell_r.Max.x - w_arrow - w_sort_text;

  00888	f3 0f 10 85 10
	01 00 00	 movss	 xmm0, DWORD PTR cell_r$[rbp+8]
  00890	f3 0f 5c 85 54
	01 00 00	 subss	 xmm0, DWORD PTR w_arrow$[rbp]
  00898	f3 0f 5c 85 74
	01 00 00	 subss	 xmm0, DWORD PTR w_sort_text$[rbp]
  008a0	f3 0f 11 85 24
	03 00 00	 movss	 DWORD PTR ellipsis_max$[rbp], xmm0

; 3000 :     if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))

  008a8	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  008ac	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  008af	83 e0 08	 and	 eax, 8
  008b2	85 c0		 test	 eax, eax
  008b4	0f 84 c7 01 00
	00		 je	 $LN22@TableHeade
  008ba	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  008c1	8b 00		 mov	 eax, DWORD PTR [rax]
  008c3	25 00 02 00 00	 and	 eax, 512		; 00000200H
  008c8	85 c0		 test	 eax, eax
  008ca	0f 85 b1 01 00
	00		 jne	 $LN22@TableHeade

; 3001 :     {
; 3002 :         if (column->SortOrder != -1)

  008d0	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  008d7	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  008db	83 f8 ff	 cmp	 eax, -1
  008de	0f 84 56 01 00
	00		 je	 $LN23@TableHeade

; 3003 :         {
; 3004 :             float x = ImMax(cell_r.Min.x, cell_r.Max.x - w_arrow - w_sort_text);

  008e4	f3 0f 10 85 10
	01 00 00	 movss	 xmm0, DWORD PTR cell_r$[rbp+8]
  008ec	f3 0f 5c 85 54
	01 00 00	 subss	 xmm0, DWORD PTR w_arrow$[rbp]
  008f4	f3 0f 5c 85 74
	01 00 00	 subss	 xmm0, DWORD PTR w_sort_text$[rbp]
  008fc	0f 28 c8	 movaps	 xmm1, xmm0
  008ff	f3 0f 10 85 08
	01 00 00	 movss	 xmm0, DWORD PTR cell_r$[rbp]
  00907	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0090c	f3 0f 11 85 44
	03 00 00	 movss	 DWORD PTR x$13[rbp], xmm0

; 3005 :             float y = label_pos.y;

  00914	f3 0f 10 85 ec
	00 00 00	 movss	 xmm0, DWORD PTR label_pos$[rbp+4]
  0091c	f3 0f 11 85 64
	03 00 00	 movss	 DWORD PTR y$14[rbp], xmm0

; 3006 :             if (column->SortOrder > 0)

  00924	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  0092b	0f bf 40 5a	 movsx	 eax, WORD PTR [rax+90]
  0092f	85 c0		 test	 eax, eax
  00931	7e 7a		 jle	 SHORT $LN24@TableHeade

; 3007 :             {
; 3008 :                 PushStyleColor(ImGuiCol_Text, GetColorU32(ImGuiCol_Text, 0.70f));

  00933	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f333333
  0093b	33 c9		 xor	 ecx, ecx
  0093d	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00942	8b d0		 mov	 edx, eax
  00944	33 c9		 xor	 ecx, ecx
  00946	e8 00 00 00 00	 call	 ?PushStyleColor@ImGui@@YAXHI@Z ; ImGui::PushStyleColor

; 3009 :                 RenderText(ImVec2(x + g.Style.ItemInnerSpacing.x, y), sort_order_suf);

  0094b	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0094f	f3 0f 10 85 44
	03 00 00	 movss	 xmm0, DWORD PTR x$13[rbp]
  00957	f3 0f 58 80 34
	38 00 00	 addss	 xmm0, DWORD PTR [rax+14388]
  0095f	f3 0f 10 95 64
	03 00 00	 movss	 xmm2, DWORD PTR y$14[rbp]
  00967	0f 28 c8	 movaps	 xmm1, xmm0
  0096a	48 8d 8d 44 06
	00 00		 lea	 rcx, QWORD PTR $T18[rbp]
  00971	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00976	41 b1 01	 mov	 r9b, 1
  00979	45 33 c0	 xor	 r8d, r8d
  0097c	48 8d 95 94 01
	00 00		 lea	 rdx, QWORD PTR sort_order_suf$[rbp]
  00983	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00986	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText

; 3010 :                 PopStyleColor();

  0098b	b9 01 00 00 00	 mov	 ecx, 1
  00990	e8 00 00 00 00	 call	 ?PopStyleColor@ImGui@@YAXH@Z ; ImGui::PopStyleColor

; 3011 :                 x += w_sort_text;

  00995	f3 0f 10 85 44
	03 00 00	 movss	 xmm0, DWORD PTR x$13[rbp]
  0099d	f3 0f 58 85 74
	01 00 00	 addss	 xmm0, DWORD PTR w_sort_text$[rbp]
  009a5	f3 0f 11 85 44
	03 00 00	 movss	 DWORD PTR x$13[rbp], xmm0
$LN24@TableHeade:

; 3012 :             }
; 3013 :             RenderArrow(window->DrawList, ImVec2(x, y), GetColorU32(ImGuiCol_Text), column->SortDirection == ImGuiSortDirection_Ascending ? ImGuiDir_Up : ImGuiDir_Down, ARROW_SCALE);

  009ad	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR column$[rbp]
  009b4	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  009b8	24 03		 and	 al, 3
  009ba	0f b6 c0	 movzx	 eax, al
  009bd	83 f8 01	 cmp	 eax, 1
  009c0	75 0c		 jne	 SHORT $LN50@TableHeade
  009c2	c7 85 94 06 00
	00 02 00 00 00	 mov	 DWORD PTR tv468[rbp], 2
  009cc	eb 0a		 jmp	 SHORT $LN51@TableHeade
$LN50@TableHeade:
  009ce	c7 85 94 06 00
	00 03 00 00 00	 mov	 DWORD PTR tv468[rbp], 3
$LN51@TableHeade:
  009d8	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  009e0	33 c9		 xor	 ecx, ecx
  009e2	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  009e7	89 85 98 06 00
	00		 mov	 DWORD PTR tv470[rbp], eax
  009ed	f3 0f 10 95 64
	03 00 00	 movss	 xmm2, DWORD PTR y$14[rbp]
  009f5	f3 0f 10 8d 44
	03 00 00	 movss	 xmm1, DWORD PTR x$13[rbp]
  009fd	48 8d 8d 64 06
	00 00		 lea	 rcx, QWORD PTR $T19[rbp]
  00a04	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00a09	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f266666
  00a11	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00a17	44 8b 8d 94 06
	00 00		 mov	 r9d, DWORD PTR tv468[rbp]
  00a1e	8b 8d 98 06 00
	00		 mov	 ecx, DWORD PTR tv470[rbp]
  00a24	44 8b c1	 mov	 r8d, ecx
  00a27	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00a2a	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00a2e	48 8b 88 90 02
	00 00		 mov	 rcx, QWORD PTR [rax+656]
  00a35	e8 00 00 00 00	 call	 ?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
$LN23@TableHeade:

; 3014 :         }
; 3015 : 
; 3016 :         // Handle clicking on column header to adjust Sort Order
; 3017 :         if (pressed && table->ReorderColumn != column_n)

  00a3a	0f b6 85 a4 02
	00 00		 movzx	 eax, BYTE PTR pressed$[rbp]
  00a41	85 c0		 test	 eax, eax
  00a43	74 3c		 je	 SHORT $LN25@TableHeade
  00a45	48 8b 45 48	 mov	 rax, QWORD PTR table$[rbp]
  00a49	0f bf 80 04 02
	00 00		 movsx	 eax, WORD PTR [rax+516]
  00a50	3b 45 64	 cmp	 eax, DWORD PTR column_n$[rbp]
  00a53	74 2c		 je	 SHORT $LN25@TableHeade

; 3018 :         {
; 3019 :             ImGuiSortDirection sort_direction = TableGetColumnNextSortDirection(column);

  00a55	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR column$[rbp]
  00a5c	e8 00 00 00 00	 call	 ?TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z ; ImGui::TableGetColumnNextSortDirection
  00a61	89 85 84 03 00
	00		 mov	 DWORD PTR sort_direction$15[rbp], eax

; 3020 :             TableSetColumnSortDirection(column_n, sort_direction, g.IO.KeyShift);

  00a67	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00a6b	44 0f b6 80 15
	0e 00 00	 movzx	 r8d, BYTE PTR [rax+3605]
  00a73	8b 95 84 03 00
	00		 mov	 edx, DWORD PTR sort_direction$15[rbp]
  00a79	8b 4d 64	 mov	 ecx, DWORD PTR column_n$[rbp]
  00a7c	e8 00 00 00 00	 call	 ?TableSetColumnSortDirection@ImGui@@YAXHH_N@Z ; ImGui::TableSetColumnSortDirection
$LN25@TableHeade:
$LN22@TableHeade:

; 3021 :         }
; 3022 :     }
; 3023 : 
; 3024 :     // Render clipped label. Clipping here ensure that in the majority of situations, all our header cells will
; 3025 :     // be merged into a single draw call.
; 3026 :     //window->DrawList->AddCircleFilled(ImVec2(ellipsis_max, label_pos.y), 40, IM_COL32_WHITE);
; 3027 :     RenderTextEllipsis(window->DrawList, label_pos, ImVec2(ellipsis_max, label_pos.y + label_height + g.Style.FramePadding.y), ellipsis_max, ellipsis_max, label, label_end, &label_size);

  00a81	f3 0f 10 85 ec
	00 00 00	 movss	 xmm0, DWORD PTR label_pos$[rbp+4]
  00a89	f3 0f 58 85 34
	01 00 00	 addss	 xmm0, DWORD PTR label_height$[rbp]
  00a91	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00a95	f3 0f 58 80 20
	38 00 00	 addss	 xmm0, DWORD PTR [rax+14368]
  00a9d	0f 28 d0	 movaps	 xmm2, xmm0
  00aa0	f3 0f 10 8d 24
	03 00 00	 movss	 xmm1, DWORD PTR ellipsis_max$[rbp]
  00aa8	48 8d 8d 84 06
	00 00		 lea	 rcx, QWORD PTR $T20[rbp]
  00aaf	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00ab4	48 8d 8d c8 00
	00 00		 lea	 rcx, QWORD PTR label_size$[rbp]
  00abb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00ac0	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR label_end$[rbp]
  00ac7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00acc	48 8b 8d d0 06
	00 00		 mov	 rcx, QWORD PTR label$[rbp]
  00ad3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ad8	f3 0f 10 85 24
	03 00 00	 movss	 xmm0, DWORD PTR ellipsis_max$[rbp]
  00ae0	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00ae6	f3 0f 10 9d 24
	03 00 00	 movss	 xmm3, DWORD PTR ellipsis_max$[rbp]
  00aee	4c 8b c0	 mov	 r8, rax
  00af1	48 8d 95 e8 00
	00 00		 lea	 rdx, QWORD PTR label_pos$[rbp]
  00af8	48 8b 45 28	 mov	 rax, QWORD PTR window$[rbp]
  00afc	48 8b 88 90 02
	00 00		 mov	 rcx, QWORD PTR [rax+656]
  00b03	e8 00 00 00 00	 call	 ?RenderTextEllipsis@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1MMPEBD2PEBU3@@Z ; ImGui::RenderTextEllipsis

; 3028 : 
; 3029 :     const bool text_clipped = label_size.x > (ellipsis_max - label_pos.x);

  00b08	f3 0f 10 85 24
	03 00 00	 movss	 xmm0, DWORD PTR ellipsis_max$[rbp]
  00b10	f3 0f 5c 85 e8
	00 00 00	 subss	 xmm0, DWORD PTR label_pos$[rbp]
  00b18	f3 0f 10 8d c8
	00 00 00	 movss	 xmm1, DWORD PTR label_size$[rbp]
  00b20	0f 2f c8	 comiss	 xmm1, xmm0
  00b23	76 09		 jbe	 SHORT $LN52@TableHeade
  00b25	c6 85 94 06 00
	00 01		 mov	 BYTE PTR tv513[rbp], 1
  00b2c	eb 07		 jmp	 SHORT $LN53@TableHeade
$LN52@TableHeade:
  00b2e	c6 85 94 06 00
	00 00		 mov	 BYTE PTR tv513[rbp], 0
$LN53@TableHeade:
  00b35	0f b6 85 94 06
	00 00		 movzx	 eax, BYTE PTR tv513[rbp]
  00b3c	88 85 a4 03 00
	00		 mov	 BYTE PTR text_clipped$[rbp], al

; 3030 :     if (text_clipped && hovered && g.ActiveId == 0 && IsItemHovered(ImGuiHoveredFlags_DelayNormal))

  00b42	0f b6 85 a4 03
	00 00		 movzx	 eax, BYTE PTR text_clipped$[rbp]
  00b49	85 c0		 test	 eax, eax
  00b4b	74 52		 je	 SHORT $LN26@TableHeade
  00b4d	0f b6 85 64 02
	00 00		 movzx	 eax, BYTE PTR hovered$[rbp]
  00b54	85 c0		 test	 eax, eax
  00b56	74 47		 je	 SHORT $LN26@TableHeade
  00b58	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00b5c	83 b8 00 3f 00
	00 00		 cmp	 DWORD PTR [rax+16128], 0
  00b63	75 3a		 jne	 SHORT $LN26@TableHeade
  00b65	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00b6a	e8 00 00 00 00	 call	 ?IsItemHovered@ImGui@@YA_NH@Z ; ImGui::IsItemHovered
  00b6f	0f b6 c0	 movzx	 eax, al
  00b72	85 c0		 test	 eax, eax
  00b74	74 29		 je	 SHORT $LN26@TableHeade

; 3031 :         SetTooltip("%.*s", (int)(label_end - label), label);

  00b76	48 8b 85 d0 06
	00 00		 mov	 rax, QWORD PTR label$[rbp]
  00b7d	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR label_end$[rbp]
  00b84	48 2b c8	 sub	 rcx, rax
  00b87	48 8b c1	 mov	 rax, rcx
  00b8a	4c 8b 85 d0 06
	00 00		 mov	 r8, QWORD PTR label$[rbp]
  00b91	8b d0		 mov	 edx, eax
  00b93	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04EBNJJJJI@?$CF?4?$CKs?$AA@
  00b9a	e8 00 00 00 00	 call	 ?SetTooltip@ImGui@@YAXPEBDZZ ; ImGui::SetTooltip
$LN26@TableHeade:

; 3032 : 
; 3033 :     // We don't use BeginPopupContextItem() because we want the popup to stay up even after the column is hidden
; 3034 :     if (IsMouseReleased(1) && IsItemHovered())

  00b9f	b9 01 00 00 00	 mov	 ecx, 1
  00ba4	e8 00 00 00 00	 call	 ?IsMouseReleased@ImGui@@YA_NH@Z ; ImGui::IsMouseReleased
  00ba9	0f b6 c0	 movzx	 eax, al
  00bac	85 c0		 test	 eax, eax
  00bae	74 16		 je	 SHORT $LN27@TableHeade
  00bb0	33 c9		 xor	 ecx, ecx
  00bb2	e8 00 00 00 00	 call	 ?IsItemHovered@ImGui@@YA_NH@Z ; ImGui::IsItemHovered
  00bb7	0f b6 c0	 movzx	 eax, al
  00bba	85 c0		 test	 eax, eax
  00bbc	74 08		 je	 SHORT $LN27@TableHeade

; 3035 :         TableOpenContextMenu(column_n);

  00bbe	8b 4d 64	 mov	 ecx, DWORD PTR column_n$[rbp]
  00bc1	e8 00 00 00 00	 call	 ?TableOpenContextMenu@ImGui@@YAXH@Z ; ImGui::TableOpenContextMenu
$LN27@TableHeade:
$LN1@TableHeade:

; 3036 : }

  00bc6	48 8d 4d c0	 lea	 rcx, QWORD PTR [rbp-64]
  00bca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableHeader@ImGui@@YAXPEBD@Z$rtcFrameData
  00bd1	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00bd6	48 8b 8d a0 06
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00bdd	48 33 cd	 xor	 rcx, rbp
  00be0	e8 00 00 00 00	 call	 __security_check_cookie
  00be5	48 8d a5 b8 06
	00 00		 lea	 rsp, QWORD PTR [rbp+1720]
  00bec	5f		 pop	 rdi
  00bed	5d		 pop	 rbp
  00bee	c3		 ret	 0
?TableHeader@ImGui@@YAXPEBD@Z ENDP			; ImGui::TableHeader
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableHeadersRow@ImGui@@YAXXZ
_TEXT	SEGMENT
g$ = 8
table$ = 40
row_y1$ = 68
row_height$ = 100
columns_count$ = 132
column_n$4 = 164
name$5 = 200
mouse_pos$ = 232
$T6 = 452
tv130 = 472
__$ArrayPad$ = 480
?TableHeadersRow@ImGui@@YAXXZ PROC			; ImGui::TableHeadersRow, COMDAT

; 2858 : {

$LN15:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 18 02
	00 00		 sub	 rsp, 536		; 00000218H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 86 00 00 00	 mov	 ecx, 134		; 00000086H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00025	48 33 c5	 xor	 rax, rbp
  00028	48 89 85 e0 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 2859 :     ImGuiContext& g = *GImGui;

  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00036	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 2860 :     ImGuiTable* table = g.CurrentTable;

  0003a	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003e	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00045	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 2861 :     IM_ASSERT(table != NULL && "Need to call TableHeadersRow() after BeginTable()!");

  00049	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0004e	74 0c		 je	 SHORT $LN11@TableHeade
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DD@NCKBBGOL@Need?5to?5call?5TableHeadersRow?$CI?$CJ?5a@
  00057	48 85 c0	 test	 rax, rax
  0005a	75 22		 jne	 SHORT $LN12@TableHeade
$LN11@TableHeade:
  0005c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableHeadersRow@ImGui@@YAXXZ@4JA
  00062	83 c0 03	 add	 eax, 3
  00065	44 8b c0	 mov	 r8d, eax
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1IG@FPFBNANE@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007c	33 c0		 xor	 eax, eax
$LN12@TableHeade:

; 2862 : 
; 2863 :     // Layout if not already done (this is automatically done by TableNextRow, we do it here solely to facilitate stepping in debugger as it is frequent to step in TableUpdateLayout)
; 2864 :     if (!table->IsLayoutLocked)

  0007e	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00082	0f b6 80 22 02
	00 00		 movzx	 eax, BYTE PTR [rax+546]
  00089	85 c0		 test	 eax, eax
  0008b	75 09		 jne	 SHORT $LN5@TableHeade

; 2865 :         TableUpdateLayout(table);

  0008d	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00091	e8 00 00 00 00	 call	 ?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableUpdateLayout
$LN5@TableHeade:

; 2866 : 
; 2867 :     // Open row
; 2868 :     const float row_y1 = GetCursorScreenPos().y;

  00096	48 8d 8d c4 01
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  0009d	e8 00 00 00 00	 call	 ?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorScreenPos
  000a2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  000a7	f3 0f 11 45 44	 movss	 DWORD PTR row_y1$[rbp], xmm0

; 2869 :     const float row_height = TableGetHeaderRowHeight();

  000ac	e8 00 00 00 00	 call	 ?TableGetHeaderRowHeight@ImGui@@YAMXZ ; ImGui::TableGetHeaderRowHeight
  000b1	f3 0f 11 45 64	 movss	 DWORD PTR row_height$[rbp], xmm0

; 2870 :     TableNextRow(ImGuiTableRowFlags_Headers, row_height);

  000b6	f3 0f 10 4d 64	 movss	 xmm1, DWORD PTR row_height$[rbp]
  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	e8 00 00 00 00	 call	 ?TableNextRow@ImGui@@YAXHM@Z ; ImGui::TableNextRow

; 2871 :     if (table->HostSkipItems) // Merely an optimization, you may skip in your own code.

  000c5	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000c9	0f b6 80 32 02
	00 00		 movzx	 eax, BYTE PTR [rax+562]
  000d0	85 c0		 test	 eax, eax
  000d2	74 05		 je	 SHORT $LN6@TableHeade

; 2872 :         return;

  000d4	e9 17 01 00 00	 jmp	 $LN1@TableHeade
$LN6@TableHeade:

; 2873 : 
; 2874 :     const int columns_count = TableGetColumnCount();

  000d9	e8 00 00 00 00	 call	 ?TableGetColumnCount@ImGui@@YAHXZ ; ImGui::TableGetColumnCount
  000de	89 85 84 00 00
	00		 mov	 DWORD PTR columns_count$[rbp], eax

; 2875 :     for (int column_n = 0; column_n < columns_count; column_n++)

  000e4	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$4[rbp], 0
  000ee	eb 0e		 jmp	 SHORT $LN4@TableHeade
$LN2@TableHeade:
  000f0	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR column_n$4[rbp]
  000f6	ff c0		 inc	 eax
  000f8	89 85 a4 00 00
	00		 mov	 DWORD PTR column_n$4[rbp], eax
$LN4@TableHeade:
  000fe	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR columns_count$[rbp]
  00104	39 85 a4 00 00
	00		 cmp	 DWORD PTR column_n$4[rbp], eax
  0010a	0f 8d 8b 00 00
	00		 jge	 $LN3@TableHeade

; 2876 :     {
; 2877 :         if (!TableSetColumnIndex(column_n))

  00110	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR column_n$4[rbp]
  00116	e8 00 00 00 00	 call	 ?TableSetColumnIndex@ImGui@@YA_NH@Z ; ImGui::TableSetColumnIndex
  0011b	0f b6 c0	 movzx	 eax, al
  0011e	85 c0		 test	 eax, eax
  00120	75 02		 jne	 SHORT $LN7@TableHeade

; 2878 :             continue;

  00122	eb cc		 jmp	 SHORT $LN2@TableHeade
$LN7@TableHeade:

; 2879 : 
; 2880 :         // Push an id to allow unnamed labels (generally accidental, but let's behave nicely with them)
; 2881 :         // - in your own code you may omit the PushID/PopID all-together, provided you know they won't collide
; 2882 :         // - table->InstanceCurrent is only >0 when we use multiple BeginTable/EndTable calls with same identifier.
; 2883 :         const char* name = (TableGetColumnFlags(column_n) & ImGuiTableColumnFlags_NoHeaderLabel) ? "" : TableGetColumnName(column_n);

  00124	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR column_n$4[rbp]
  0012a	e8 00 00 00 00	 call	 ?TableGetColumnFlags@ImGui@@YAHH@Z ; ImGui::TableGetColumnFlags
  0012f	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00134	85 c0		 test	 eax, eax
  00136	74 10		 je	 SHORT $LN13@TableHeade
  00138	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0013f	48 89 85 d8 01
	00 00		 mov	 QWORD PTR tv130[rbp], rax
  00146	eb 12		 jmp	 SHORT $LN14@TableHeade
$LN13@TableHeade:
  00148	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR column_n$4[rbp]
  0014e	e8 00 00 00 00	 call	 ?TableGetColumnName@ImGui@@YAPEBDH@Z ; ImGui::TableGetColumnName
  00153	48 89 85 d8 01
	00 00		 mov	 QWORD PTR tv130[rbp], rax
$LN14@TableHeade:
  0015a	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR tv130[rbp]
  00161	48 89 85 c8 00
	00 00		 mov	 QWORD PTR name$5[rbp], rax

; 2884 :         PushID(table->InstanceCurrent * table->ColumnsCount + column_n);

  00168	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0016c	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  00170	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00174	0f af 41 6c	 imul	 eax, DWORD PTR [rcx+108]
  00178	03 85 a4 00 00
	00		 add	 eax, DWORD PTR column_n$4[rbp]
  0017e	8b c8		 mov	 ecx, eax
  00180	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXH@Z	; ImGui::PushID

; 2885 :         TableHeader(name);

  00185	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR name$5[rbp]
  0018c	e8 00 00 00 00	 call	 ?TableHeader@ImGui@@YAXPEBD@Z ; ImGui::TableHeader

; 2886 :         PopID();

  00191	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 2887 :     }

  00196	e9 55 ff ff ff	 jmp	 $LN2@TableHeade
$LN3@TableHeade:

; 2888 : 
; 2889 :     // Allow opening popup from the right-most section after the last column.
; 2890 :     ImVec2 mouse_pos = ImGui::GetMousePos();

  0019b	48 8d 8d e8 00
	00 00		 lea	 rcx, QWORD PTR mouse_pos$[rbp]
  001a2	e8 00 00 00 00	 call	 ?GetMousePos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetMousePos

; 2891 :     if (IsMouseReleased(1) && TableGetHoveredColumn() == columns_count)

  001a7	b9 01 00 00 00	 mov	 ecx, 1
  001ac	e8 00 00 00 00	 call	 ?IsMouseReleased@ImGui@@YA_NH@Z ; ImGui::IsMouseReleased
  001b1	0f b6 c0	 movzx	 eax, al
  001b4	85 c0		 test	 eax, eax
  001b6	74 38		 je	 SHORT $LN8@TableHeade
  001b8	e8 00 00 00 00	 call	 ?TableGetHoveredColumn@ImGui@@YAHXZ ; ImGui::TableGetHoveredColumn
  001bd	3b 85 84 00 00
	00		 cmp	 eax, DWORD PTR columns_count$[rbp]
  001c3	75 2b		 jne	 SHORT $LN8@TableHeade

; 2892 :         if (mouse_pos.y >= row_y1 && mouse_pos.y < row_y1 + row_height)

  001c5	f3 0f 10 85 ec
	00 00 00	 movss	 xmm0, DWORD PTR mouse_pos$[rbp+4]
  001cd	0f 2f 45 44	 comiss	 xmm0, DWORD PTR row_y1$[rbp]
  001d1	72 1d		 jb	 SHORT $LN9@TableHeade
  001d3	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR row_y1$[rbp]
  001d8	f3 0f 58 45 64	 addss	 xmm0, DWORD PTR row_height$[rbp]
  001dd	0f 2f 85 ec 00
	00 00		 comiss	 xmm0, DWORD PTR mouse_pos$[rbp+4]
  001e4	76 0a		 jbe	 SHORT $LN9@TableHeade

; 2893 :             TableOpenContextMenu(-1); // Will open a non-column-specific popup.

  001e6	b9 ff ff ff ff	 mov	 ecx, -1
  001eb	e8 00 00 00 00	 call	 ?TableOpenContextMenu@ImGui@@YAXH@Z ; ImGui::TableOpenContextMenu
$LN9@TableHeade:
$LN8@TableHeade:
$LN1@TableHeade:

; 2894 : }

  001f0	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  001f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?TableHeadersRow@ImGui@@YAXXZ$rtcFrameData
  001fb	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00200	48 8b 8d e0 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00207	48 33 cd	 xor	 rcx, rbp
  0020a	e8 00 00 00 00	 call	 __security_check_cookie
  0020f	48 8d a5 f8 01
	00 00		 lea	 rsp, QWORD PTR [rbp+504]
  00216	5f		 pop	 rdi
  00217	5d		 pop	 rbp
  00218	c3		 ret	 0
?TableHeadersRow@ImGui@@YAXXZ ENDP			; ImGui::TableHeadersRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetupScrollFreeze@ImGui@@YAXHH@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
column_n$1 = 68
order_n$2 = 100
tv168 = 308
tv162 = 308
tv153 = 308
tv146 = 308
tv137 = 308
tv207 = 312
tv192 = 312
columns$ = 352
rows$ = 360
?TableSetupScrollFreeze@ImGui@@YAXHH@Z PROC		; ImGui::TableSetupScrollFreeze, COMDAT

; 1497 : {

$LN27:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8b fc	 mov	 rdi, rsp
  00019	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	8b 8c 24 88 01
	00 00		 mov	 ecx, DWORD PTR [rsp+392]

; 1498 :     ImGuiContext& g = *GImGui;

  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00033	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1499 :     ImGuiTable* table = g.CurrentTable;

  00037	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003b	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00042	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1500 :     IM_ASSERT(table != NULL && "Need to call TableSetupColumn() after BeginTable()!");

  00046	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0004b	74 0c		 je	 SHORT $LN7@TableSetup
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DE@JMKEADIJ@Need?5to?5call?5TableSetupColumn?$CI?$CJ?5@
  00054	48 85 c0	 test	 rax, rax
  00057	75 22		 jne	 SHORT $LN8@TableSetup
$LN7@TableSetup:
  00059	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupScrollFreeze@ImGui@@YAXHH@Z@4JA
  0005f	83 c0 03	 add	 eax, 3
  00062	44 8b c0	 mov	 r8d, eax
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1II@MMHPDEP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00079	33 c0		 xor	 eax, eax
$LN8@TableSetup:

; 1501 :     IM_ASSERT(table->IsLayoutLocked == false && "Need to call TableSetupColumn() before first row!");

  0007b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0007f	0f b6 80 22 02
	00 00		 movzx	 eax, BYTE PTR [rax+546]
  00086	85 c0		 test	 eax, eax
  00088	75 0c		 jne	 SHORT $LN9@TableSetup
  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DC@CMJJAIP@Need?5to?5call?5TableSetupColumn?$CI?$CJ?5@
  00091	48 85 c0	 test	 rax, rax
  00094	75 22		 jne	 SHORT $LN10@TableSetup
$LN9@TableSetup:
  00096	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupScrollFreeze@ImGui@@YAXHH@Z@4JA
  0009c	83 c0 04	 add	 eax, 4
  0009f	44 8b c0	 mov	 r8d, eax
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KM@MPIBPMGF@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG@
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b6	33 c0		 xor	 eax, eax
$LN10@TableSetup:

; 1502 :     IM_ASSERT(columns >= 0 && columns < IMGUI_TABLE_MAX_COLUMNS);

  000b8	83 bd 60 01 00
	00 00		 cmp	 DWORD PTR columns$[rbp], 0
  000bf	7c 0c		 jl	 SHORT $LN11@TableSetup
  000c1	81 bd 60 01 00
	00 00 02 00 00	 cmp	 DWORD PTR columns$[rbp], 512 ; 00000200H
  000cb	7c 22		 jl	 SHORT $LN12@TableSetup
$LN11@TableSetup:
  000cd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupScrollFreeze@ImGui@@YAXHH@Z@4JA
  000d3	83 c0 05	 add	 eax, 5
  000d6	44 8b c0	 mov	 r8d, eax
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@GIPBLHPN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$DM?$AA?5?$AA5?$AA1?$AA2?$AA?$AA@
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ed	33 c0		 xor	 eax, eax
$LN12@TableSetup:

; 1503 :     IM_ASSERT(rows >= 0 && rows < 128); // Arbitrary limit

  000ef	83 bd 68 01 00
	00 00		 cmp	 DWORD PTR rows$[rbp], 0
  000f6	7c 0c		 jl	 SHORT $LN13@TableSetup
  000f8	81 bd 68 01 00
	00 80 00 00 00	 cmp	 DWORD PTR rows$[rbp], 128 ; 00000080H
  00102	7c 22		 jl	 SHORT $LN14@TableSetup
$LN13@TableSetup:
  00104	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupScrollFreeze@ImGui@@YAXHH@Z@4JA
  0010a	83 c0 06	 add	 eax, 6
  0010d	44 8b c0	 mov	 r8d, eax
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00117	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CGNBCADH@?$AAr?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?5?$AA?$DM?$AA?5?$AA1?$AA2?$AA8?$AA?$AA@
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00124	33 c0		 xor	 eax, eax
$LN14@TableSetup:

; 1504 : 
; 1505 :     table->FreezeColumnsRequest = (table->Flags & ImGuiTableFlags_ScrollX) ? (ImGuiTableColumnIdx)ImMin(columns, table->ColumnsCount) : 0;

  00126	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0012a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0012d	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00132	85 c0		 test	 eax, eax
  00134	74 1b		 je	 SHORT $LN15@TableSetup
  00136	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0013a	8b 50 6c	 mov	 edx, DWORD PTR [rax+108]
  0013d	8b 8d 60 01 00
	00		 mov	 ecx, DWORD PTR columns$[rbp]
  00143	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  00148	98		 cwde
  00149	89 85 34 01 00
	00		 mov	 DWORD PTR tv137[rbp], eax
  0014f	eb 0a		 jmp	 SHORT $LN16@TableSetup
$LN15@TableSetup:
  00151	c7 85 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv137[rbp], 0
$LN16@TableSetup:
  0015b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0015f	0f b7 8d 34 01
	00 00		 movzx	 ecx, WORD PTR tv137[rbp]
  00166	66 89 88 16 02
	00 00		 mov	 WORD PTR [rax+534], cx

; 1506 :     table->FreezeColumnsCount = (table->InnerWindow->Scroll.x != 0.0f) ? table->FreezeColumnsRequest : 0;

  0016d	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00171	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00178	f3 0f 10 40 7c	 movss	 xmm0, DWORD PTR [rax+124]
  0017d	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00184	7a 02		 jp	 SHORT $LN26@TableSetup
  00186	74 13		 je	 SHORT $LN17@TableSetup
$LN26@TableSetup:
  00188	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0018c	0f bf 80 16 02
	00 00		 movsx	 eax, WORD PTR [rax+534]
  00193	89 85 34 01 00
	00		 mov	 DWORD PTR tv146[rbp], eax
  00199	eb 0a		 jmp	 SHORT $LN18@TableSetup
$LN17@TableSetup:
  0019b	c7 85 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv146[rbp], 0
$LN18@TableSetup:
  001a5	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  001a9	0f b7 8d 34 01
	00 00		 movzx	 ecx, WORD PTR tv146[rbp]
  001b0	66 89 88 18 02
	00 00		 mov	 WORD PTR [rax+536], cx

; 1507 :     table->FreezeRowsRequest = (table->Flags & ImGuiTableFlags_ScrollY) ? (ImGuiTableColumnIdx)rows : 0;

  001b7	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  001bb	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001be	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  001c3	85 c0		 test	 eax, eax
  001c5	74 0f		 je	 SHORT $LN19@TableSetup
  001c7	0f bf 85 68 01
	00 00		 movsx	 eax, WORD PTR rows$[rbp]
  001ce	89 85 34 01 00
	00		 mov	 DWORD PTR tv153[rbp], eax
  001d4	eb 0a		 jmp	 SHORT $LN20@TableSetup
$LN19@TableSetup:
  001d6	c7 85 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv153[rbp], 0
$LN20@TableSetup:
  001e0	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  001e4	0f b7 8d 34 01
	00 00		 movzx	 ecx, WORD PTR tv153[rbp]
  001eb	66 89 88 12 02
	00 00		 mov	 WORD PTR [rax+530], cx

; 1508 :     table->FreezeRowsCount = (table->InnerWindow->Scroll.y != 0.0f) ? table->FreezeRowsRequest : 0;

  001f2	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  001f6	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  001fd	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  00205	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0020c	7a 02		 jp	 SHORT $LN25@TableSetup
  0020e	74 13		 je	 SHORT $LN21@TableSetup
$LN25@TableSetup:
  00210	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00214	0f bf 80 12 02
	00 00		 movsx	 eax, WORD PTR [rax+530]
  0021b	89 85 34 01 00
	00		 mov	 DWORD PTR tv162[rbp], eax
  00221	eb 0a		 jmp	 SHORT $LN22@TableSetup
$LN21@TableSetup:
  00223	c7 85 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv162[rbp], 0
$LN22@TableSetup:
  0022d	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00231	0f b7 8d 34 01
	00 00		 movzx	 ecx, WORD PTR tv162[rbp]
  00238	66 89 88 14 02
	00 00		 mov	 WORD PTR [rax+532], cx

; 1509 :     table->IsUnfrozenRows = (table->FreezeRowsCount == 0); // Make sure this is set before TableUpdateLayout() so ImGuiListClipper can benefit from it.b

  0023f	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00243	0f bf 80 14 02
	00 00		 movsx	 eax, WORD PTR [rax+532]
  0024a	85 c0		 test	 eax, eax
  0024c	75 0c		 jne	 SHORT $LN23@TableSetup
  0024e	c7 85 34 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv168[rbp], 1
  00258	eb 0a		 jmp	 SHORT $LN24@TableSetup
$LN23@TableSetup:
  0025a	c7 85 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv168[rbp], 0
$LN24@TableSetup:
  00264	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00268	0f b6 8d 34 01
	00 00		 movzx	 ecx, BYTE PTR tv168[rbp]
  0026f	88 88 2d 02 00
	00		 mov	 BYTE PTR [rax+557], cl

; 1510 : 
; 1511 :     // Ensure frozen columns are ordered in their section. We still allow multiple frozen columns to be reordered.
; 1512 :     // FIXME-TABLE: This work for preserving 2143 into 21|43. How about 4321 turning into 21|43? (preserve relative order in each section)
; 1513 :     for (int column_n = 0; column_n < table->FreezeColumnsRequest; column_n++)

  00275	c7 45 44 00 00
	00 00		 mov	 DWORD PTR column_n$1[rbp], 0
  0027c	eb 08		 jmp	 SHORT $LN4@TableSetup
$LN2@TableSetup:
  0027e	8b 45 44	 mov	 eax, DWORD PTR column_n$1[rbp]
  00281	ff c0		 inc	 eax
  00283	89 45 44	 mov	 DWORD PTR column_n$1[rbp], eax
$LN4@TableSetup:
  00286	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0028a	0f bf 80 16 02
	00 00		 movsx	 eax, WORD PTR [rax+534]
  00291	39 45 44	 cmp	 DWORD PTR column_n$1[rbp], eax
  00294	0f 8d e2 00 00
	00		 jge	 $LN3@TableSetup

; 1514 :     {
; 1515 :         int order_n = table->DisplayOrderToIndex[column_n];

  0029a	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0029e	48 83 c0 28	 add	 rax, 40			; 00000028H
  002a2	8b 55 44	 mov	 edx, DWORD PTR column_n$1[rbp]
  002a5	48 8b c8	 mov	 rcx, rax
  002a8	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  002ad	0f bf 00	 movsx	 eax, WORD PTR [rax]
  002b0	89 45 64	 mov	 DWORD PTR order_n$2[rbp], eax

; 1516 :         if (order_n != column_n && order_n >= table->FreezeColumnsRequest)

  002b3	8b 45 44	 mov	 eax, DWORD PTR column_n$1[rbp]
  002b6	39 45 64	 cmp	 DWORD PTR order_n$2[rbp], eax
  002b9	0f 84 b8 00 00
	00		 je	 $LN5@TableSetup
  002bf	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  002c3	0f bf 80 16 02
	00 00		 movsx	 eax, WORD PTR [rax+534]
  002ca	39 45 64	 cmp	 DWORD PTR order_n$2[rbp], eax
  002cd	0f 8c a4 00 00
	00		 jl	 $LN5@TableSetup

; 1517 :         {
; 1518 :             ImSwap(table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder, table->Columns[table->DisplayOrderToIndex[column_n]].DisplayOrder);

  002d3	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  002d7	48 83 c0 28	 add	 rax, 40			; 00000028H
  002db	8b 55 44	 mov	 edx, DWORD PTR column_n$1[rbp]
  002de	48 8b c8	 mov	 rcx, rax
  002e1	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  002e6	0f bf 00	 movsx	 eax, WORD PTR [rax]
  002e9	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  002ed	48 83 c1 18	 add	 rcx, 24
  002f1	8b d0		 mov	 edx, eax
  002f3	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  002f8	48 83 c0 52	 add	 rax, 82			; 00000052H
  002fc	48 89 85 38 01
	00 00		 mov	 QWORD PTR tv192[rbp], rax
  00303	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00307	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0030b	8b 55 64	 mov	 edx, DWORD PTR order_n$2[rbp]
  0030e	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  00313	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00316	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0031a	48 83 c1 18	 add	 rcx, 24
  0031e	8b d0		 mov	 edx, eax
  00320	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00325	48 83 c0 52	 add	 rax, 82			; 00000052H
  00329	48 8b 8d 38 01
	00 00		 mov	 rcx, QWORD PTR tv192[rbp]
  00330	48 8b d1	 mov	 rdx, rcx
  00333	48 8b c8	 mov	 rcx, rax
  00336	e8 00 00 00 00	 call	 ??$ImSwap@F@@YAXAEAF0@Z	; ImSwap<short>

; 1519 :             ImSwap(table->DisplayOrderToIndex[order_n], table->DisplayOrderToIndex[column_n]);

  0033b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0033f	48 83 c0 28	 add	 rax, 40			; 00000028H
  00343	8b 55 44	 mov	 edx, DWORD PTR column_n$1[rbp]
  00346	48 8b c8	 mov	 rcx, rax
  00349	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  0034e	48 89 85 38 01
	00 00		 mov	 QWORD PTR tv207[rbp], rax
  00355	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00359	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0035d	8b 55 64	 mov	 edx, DWORD PTR order_n$2[rbp]
  00360	e8 00 00 00 00	 call	 ??A?$ImSpan@F@@QEAAAEAFH@Z ; ImSpan<short>::operator[]
  00365	48 8b 8d 38 01
	00 00		 mov	 rcx, QWORD PTR tv207[rbp]
  0036c	48 8b d1	 mov	 rdx, rcx
  0036f	48 8b c8	 mov	 rcx, rax
  00372	e8 00 00 00 00	 call	 ??$ImSwap@F@@YAXAEAF0@Z	; ImSwap<short>
$LN5@TableSetup:

; 1520 :         }
; 1521 :     }

  00377	e9 02 ff ff ff	 jmp	 $LN2@TableSetup
$LN3@TableSetup:

; 1522 : }

  0037c	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  00383	5f		 pop	 rdi
  00384	5d		 pop	 rbp
  00385	c3		 ret	 0
?TableSetupScrollFreeze@ImGui@@YAXHH@Z ENDP		; ImGui::TableSetupScrollFreeze
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetupColumn@ImGui@@YAXPEBDHMI@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
column$ = 72
tv210 = 276
tv190 = 276
label$ = 320
flags$ = 328
init_width_or_weight$ = 336
user_id$ = 344
?TableSetupColumn@ImGui@@YAXPEBDHMI@Z PROC		; ImGui::TableSetupColumn, COMDAT

; 1429 : {

$LN30:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000b	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8b fc	 mov	 rdi, rsp
  00025	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR [rsp+360]

; 1430 :     ImGuiContext& g = *GImGui;

  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00040	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1431 :     ImGuiTable* table = g.CurrentTable;

  00044	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00048	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  0004f	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1432 :     IM_ASSERT(table != NULL && "Need to call TableSetupColumn() after BeginTable()!");

  00053	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  00058	74 0c		 je	 SHORT $LN16@TableSetup
  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DE@JMKEADIJ@Need?5to?5call?5TableSetupColumn?$CI?$CJ?5@
  00061	48 85 c0	 test	 rax, rax
  00064	75 22		 jne	 SHORT $LN17@TableSetup
$LN16@TableSetup:
  00066	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupColumn@ImGui@@YAXPEBDHMI@Z@4JA
  0006c	83 c0 03	 add	 eax, 3
  0006f	44 8b c0	 mov	 r8d, eax
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1II@MMHPDEP@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAN?$AAe?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAT?$AAa?$AAb?$AAl@
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00086	33 c0		 xor	 eax, eax
$LN17@TableSetup:

; 1433 :     IM_ASSERT(table->IsLayoutLocked == false && "Need to call call TableSetupColumn() before first row!");

  00088	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0008c	0f b6 80 22 02
	00 00		 movzx	 eax, BYTE PTR [rax+546]
  00093	85 c0		 test	 eax, eax
  00095	75 0c		 jne	 SHORT $LN18@TableSetup
  00097	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DH@KOGIGLHC@Need?5to?5call?5call?5TableSetupColu@
  0009e	48 85 c0	 test	 rax, rax
  000a1	75 22		 jne	 SHORT $LN19@TableSetup
$LN18@TableSetup:
  000a3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupColumn@ImGui@@YAXPEBDHMI@Z@4JA
  000a9	83 c0 04	 add	 eax, 4
  000ac	44 8b c0	 mov	 r8d, eax
  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LG@IFCOIHC@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAI?$AAs?$AAL?$AAa?$AAy?$AAo?$AAu?$AAt?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG@
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c3	33 c0		 xor	 eax, eax
$LN19@TableSetup:

; 1434 :     IM_ASSERT((flags & ImGuiTableColumnFlags_StatusMask_) == 0 && "Illegal to pass StatusMask values to TableSetupColumn()");

  000c5	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  000cb	25 00 00 00 0f	 and	 eax, 251658240		; 0f000000H
  000d0	85 c0		 test	 eax, eax
  000d2	75 0c		 jne	 SHORT $LN20@TableSetup
  000d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DI@CBJAIEBI@Illegal?5to?5pass?5StatusMask?5value@
  000db	48 85 c0	 test	 rax, rax
  000de	75 22		 jne	 SHORT $LN21@TableSetup
$LN20@TableSetup:
  000e0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupColumn@ImGui@@YAXPEBDHMI@Z@4JA
  000e6	83 c0 05	 add	 eax, 5
  000e9	44 8b c0	 mov	 r8d, eax
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1NM@DDJLAMJK@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_?$AAS@
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00100	33 c0		 xor	 eax, eax
$LN21@TableSetup:

; 1435 :     if (table->DeclColumnsCount >= table->ColumnsCount)

  00102	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00106	0f bf 80 f6 01
	00 00		 movsx	 eax, WORD PTR [rax+502]
  0010d	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00111	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  00114	7c 47		 jl	 SHORT $LN2@TableSetup

; 1436 :     {
; 1437 :         IM_ASSERT_USER_ERROR(table->DeclColumnsCount < table->ColumnsCount, "Called TableSetupColumn() too many times!");

  00116	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0011a	0f bf 80 f6 01
	00 00		 movsx	 eax, WORD PTR [rax+502]
  00121	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00125	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  00128	7d 0c		 jge	 SHORT $LN22@TableSetup
  0012a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CK@FPBLGODL@Called?5TableSetupColumn?$CI?$CJ?5too?5ma@
  00131	48 85 c0	 test	 rax, rax
  00134	75 22		 jne	 SHORT $LN23@TableSetup
$LN22@TableSetup:
  00136	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupColumn@ImGui@@YAXPEBDHMI@Z@4JA
  0013c	83 c0 08	 add	 eax, 8
  0013f	44 8b c0	 mov	 r8d, eax
  00142	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LO@INHFIFIG@?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAD?$AAe?$AAc?$AAl?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe@
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00156	33 c0		 xor	 eax, eax
$LN23@TableSetup:

; 1438 :         return;

  00158	e9 0b 03 00 00	 jmp	 $LN1@TableSetup
$LN2@TableSetup:

; 1439 :     }
; 1440 : 
; 1441 :     ImGuiTableColumn* column = &table->Columns[table->DeclColumnsCount];

  0015d	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00161	0f bf 80 f6 01
	00 00		 movsx	 eax, WORD PTR [rax+502]
  00168	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0016c	48 83 c1 18	 add	 rcx, 24
  00170	8b d0		 mov	 edx, eax
  00172	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00177	48 89 45 48	 mov	 QWORD PTR column$[rbp], rax

; 1442 :     table->DeclColumnsCount++;

  0017b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0017f	0f b7 80 f6 01
	00 00		 movzx	 eax, WORD PTR [rax+502]
  00186	66 ff c0	 inc	 ax
  00189	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0018d	66 89 81 f6 01
	00 00		 mov	 WORD PTR [rcx+502], ax

; 1443 : 
; 1444 :     // Assert when passing a width or weight if policy is entirely left to default, to avoid storing width into weight and vice-versa.
; 1445 :     // Give a grace to users of ImGuiTableFlags_ScrollX.
; 1446 :     if (table->IsDefaultSizingPolicy && (flags & ImGuiTableColumnFlags_WidthMask_) == 0 && (flags & ImGuiTableFlags_ScrollX) == 0)

  00194	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00198	0f b6 80 2e 02
	00 00		 movzx	 eax, BYTE PTR [rax+558]
  0019f	85 c0		 test	 eax, eax
  001a1	74 56		 je	 SHORT $LN3@TableSetup
  001a3	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  001a9	83 e0 18	 and	 eax, 24
  001ac	85 c0		 test	 eax, eax
  001ae	75 49		 jne	 SHORT $LN3@TableSetup
  001b0	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  001b6	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  001bb	85 c0		 test	 eax, eax
  001bd	75 3a		 jne	 SHORT $LN3@TableSetup

; 1447 :         IM_ASSERT(init_width_or_weight <= 0.0f && "Can only specify width/weight if sizing policy is set explicitly in either Table or Column.");

  001bf	0f 57 c0	 xorps	 xmm0, xmm0
  001c2	0f 2f 85 50 01
	00 00		 comiss	 xmm0, DWORD PTR init_width_or_weight$[rbp]
  001c9	72 0c		 jb	 SHORT $LN24@TableSetup
  001cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0FM@GOCDHGH@Can?5only?5specify?5width?1weight?5if@
  001d2	48 85 c0	 test	 rax, rax
  001d5	75 22		 jne	 SHORT $LN25@TableSetup
$LN24@TableSetup:
  001d7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetupColumn@ImGui@@YAXPEBDHMI@Z@4JA
  001dd	83 c0 12	 add	 eax, 18
  001e0	44 8b c0	 mov	 r8d, eax
  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  001ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1PM@LKIEMPHI@?$AAi?$AAn?$AAi?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAo?$AAr?$AA_?$AAw?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?4?$AA0?$AAf?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f7	33 c0		 xor	 eax, eax
$LN25@TableSetup:
$LN3@TableSetup:

; 1448 : 
; 1449 :     // When passing a width automatically enforce WidthFixed policy
; 1450 :     // (whereas TableSetupColumnFlags would default to WidthAuto if table is not Resizable)
; 1451 :     if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0 && init_width_or_weight > 0.0f)

  001f9	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  001ff	83 e0 18	 and	 eax, 24
  00202	85 c0		 test	 eax, eax
  00204	75 46		 jne	 SHORT $LN4@TableSetup
  00206	f3 0f 10 85 50
	01 00 00	 movss	 xmm0, DWORD PTR init_width_or_weight$[rbp]
  0020e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00215	76 35		 jbe	 SHORT $LN4@TableSetup

; 1452 :         if ((table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedFit || (table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)

  00217	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0021b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0021e	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  00223	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00228	74 13		 je	 SHORT $LN6@TableSetup
  0022a	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0022e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00231	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  00236	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0023b	75 0f		 jne	 SHORT $LN5@TableSetup
$LN6@TableSetup:

; 1453 :             flags |= ImGuiTableColumnFlags_WidthFixed;

  0023d	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00243	83 c8 10	 or	 eax, 16
  00246	89 85 48 01 00
	00		 mov	 DWORD PTR flags$[rbp], eax
$LN5@TableSetup:
$LN4@TableSetup:

; 1454 : 
; 1455 :     TableSetupColumnFlags(table, column, flags);

  0024c	44 8b 85 48 01
	00 00		 mov	 r8d, DWORD PTR flags$[rbp]
  00253	48 8b 55 48	 mov	 rdx, QWORD PTR column$[rbp]
  00257	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0025b	e8 00 00 00 00	 call	 ?TableSetupColumnFlags@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@H@Z ; TableSetupColumnFlags

; 1456 :     column->UserID = user_id;

  00260	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  00264	8b 8d 58 01 00
	00		 mov	 ecx, DWORD PTR user_id$[rbp]
  0026a	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 1457 :     flags = column->Flags;

  0026d	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  00271	8b 00		 mov	 eax, DWORD PTR [rax]
  00273	89 85 48 01 00
	00		 mov	 DWORD PTR flags$[rbp], eax

; 1458 : 
; 1459 :     // Initialize defaults
; 1460 :     column->InitStretchWeightOrWidth = init_width_or_weight;

  00279	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  0027d	f3 0f 10 85 50
	01 00 00	 movss	 xmm0, DWORD PTR init_width_or_weight$[rbp]
  00285	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0

; 1461 :     if (table->IsInitializing)

  0028a	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0028e	0f b6 80 24 02
	00 00		 movzx	 eax, BYTE PTR [rax+548]
  00295	85 c0		 test	 eax, eax
  00297	0f 84 50 01 00
	00		 je	 $LN7@TableSetup

; 1462 :     {
; 1463 :         // Init width or weight
; 1464 :         if (column->WidthRequest < 0.0f && column->StretchWeight < 0.0f)

  0029d	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  002a1	0f 57 c0	 xorps	 xmm0, xmm0
  002a4	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [rax+16]
  002a8	0f 86 aa 00 00
	00		 jbe	 $LN8@TableSetup
  002ae	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  002b2	0f 57 c0	 xorps	 xmm0, xmm0
  002b5	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [rax+24]
  002b9	0f 86 99 00 00
	00		 jbe	 $LN8@TableSetup

; 1465 :         {
; 1466 :             if ((flags & ImGuiTableColumnFlags_WidthFixed) && init_width_or_weight > 0.0f)

  002bf	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  002c5	83 e0 10	 and	 eax, 16
  002c8	85 c0		 test	 eax, eax
  002ca	74 22		 je	 SHORT $LN9@TableSetup
  002cc	f3 0f 10 85 50
	01 00 00	 movss	 xmm0, DWORD PTR init_width_or_weight$[rbp]
  002d4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002db	76 11		 jbe	 SHORT $LN9@TableSetup

; 1467 :                 column->WidthRequest = init_width_or_weight;

  002dd	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  002e1	f3 0f 10 85 50
	01 00 00	 movss	 xmm0, DWORD PTR init_width_or_weight$[rbp]
  002e9	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
$LN9@TableSetup:

; 1468 :             if (flags & ImGuiTableColumnFlags_WidthStretch)

  002ee	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  002f4	83 e0 08	 and	 eax, 8
  002f7	85 c0		 test	 eax, eax
  002f9	74 44		 je	 SHORT $LN10@TableSetup

; 1469 :                 column->StretchWeight = (init_width_or_weight > 0.0f) ? init_width_or_weight : -1.0f;

  002fb	f3 0f 10 85 50
	01 00 00	 movss	 xmm0, DWORD PTR init_width_or_weight$[rbp]
  00303	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0030a	76 12		 jbe	 SHORT $LN26@TableSetup
  0030c	f3 0f 10 85 50
	01 00 00	 movss	 xmm0, DWORD PTR init_width_or_weight$[rbp]
  00314	f3 0f 11 85 14
	01 00 00	 movss	 DWORD PTR tv190[rbp], xmm0
  0031c	eb 10		 jmp	 SHORT $LN27@TableSetup
$LN26@TableSetup:
  0031e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00326	f3 0f 11 85 14
	01 00 00	 movss	 DWORD PTR tv190[rbp], xmm0
$LN27@TableSetup:
  0032e	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  00332	f3 0f 10 85 14
	01 00 00	 movss	 xmm0, DWORD PTR tv190[rbp]
  0033a	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0
$LN10@TableSetup:

; 1470 : 
; 1471 :             // Disable auto-fit if an explicit width/weight has been specified
; 1472 :             if (init_width_or_weight > 0.0f)

  0033f	f3 0f 10 85 50
	01 00 00	 movss	 xmm0, DWORD PTR init_width_or_weight$[rbp]
  00347	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0034e	76 08		 jbe	 SHORT $LN11@TableSetup

; 1473 :                 column->AutoFitQueue = 0x00;

  00350	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  00354	c6 40 6b 00	 mov	 BYTE PTR [rax+107], 0
$LN11@TableSetup:
$LN8@TableSetup:

; 1474 :         }
; 1475 : 
; 1476 :         // Init default visibility/sort state
; 1477 :         if ((flags & ImGuiTableColumnFlags_DefaultHide) && (table->SettingsLoadedFlags & ImGuiTableFlags_Hideable) == 0)

  00358	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  0035e	83 e0 02	 and	 eax, 2
  00361	85 c0		 test	 eax, eax
  00363	74 1e		 je	 SHORT $LN12@TableSetup
  00365	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00369	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0036c	83 e0 04	 and	 eax, 4
  0036f	85 c0		 test	 eax, eax
  00371	75 10		 jne	 SHORT $LN12@TableSetup

; 1478 :             column->IsUserEnabled = column->IsUserEnabledNextFrame = false;

  00373	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  00377	c6 40 64 00	 mov	 BYTE PTR [rax+100], 0
  0037b	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  0037f	c6 40 63 00	 mov	 BYTE PTR [rax+99], 0
$LN12@TableSetup:

; 1479 :         if (flags & ImGuiTableColumnFlags_DefaultSort && (table->SettingsLoadedFlags & ImGuiTableFlags_Sortable) == 0)

  00383	8b 85 48 01 00
	00		 mov	 eax, DWORD PTR flags$[rbp]
  00389	83 e0 04	 and	 eax, 4
  0038c	85 c0		 test	 eax, eax
  0038e	74 5d		 je	 SHORT $LN13@TableSetup
  00390	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00394	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00397	83 e0 08	 and	 eax, 8
  0039a	85 c0		 test	 eax, eax
  0039c	75 4f		 jne	 SHORT $LN13@TableSetup

; 1480 :         {
; 1481 :             column->SortOrder = 0; // Multiple columns using _DefaultSort will be reassigned unique SortOrder values when building the sort specs.

  0039e	33 c0		 xor	 eax, eax
  003a0	48 8b 4d 48	 mov	 rcx, QWORD PTR column$[rbp]
  003a4	66 89 41 5a	 mov	 WORD PTR [rcx+90], ax

; 1482 :             column->SortDirection = (column->Flags & ImGuiTableColumnFlags_PreferSortDescending) ? (ImS8)ImGuiSortDirection_Descending : (ImU8)(ImGuiSortDirection_Ascending);

  003a8	48 8b 45 48	 mov	 rax, QWORD PTR column$[rbp]
  003ac	8b 00		 mov	 eax, DWORD PTR [rax]
  003ae	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  003b3	85 c0		 test	 eax, eax
  003b5	74 0c		 je	 SHORT $LN28@TableSetup
  003b7	c7 85 14 01 00
	00 02 00 00 00	 mov	 DWORD PTR tv210[rbp], 2
  003c1	eb 0a		 jmp	 SHORT $LN29@TableSetup
$LN28@TableSetup:
  003c3	c7 85 14 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv210[rbp], 1
$LN29@TableSetup:
  003cd	0f b6 85 14 01
	00 00		 movzx	 eax, BYTE PTR tv210[rbp]
  003d4	24 03		 and	 al, 3
  003d6	48 8b 4d 48	 mov	 rcx, QWORD PTR column$[rbp]
  003da	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  003de	80 e1 fc	 and	 cl, 252			; 000000fcH
  003e1	0a c8		 or	 cl, al
  003e3	0f b6 c1	 movzx	 eax, cl
  003e6	48 8b 4d 48	 mov	 rcx, QWORD PTR column$[rbp]
  003ea	88 41 6d	 mov	 BYTE PTR [rcx+109], al
$LN13@TableSetup:
$LN7@TableSetup:

; 1483 :         }
; 1484 :     }
; 1485 : 
; 1486 :     // Store name (append with zero-terminator in contiguous buffer)
; 1487 :     column->NameOffset = -1;

  003ed	b8 ff ff ff ff	 mov	 eax, -1
  003f2	48 8b 4d 48	 mov	 rcx, QWORD PTR column$[rbp]
  003f6	66 89 41 50	 mov	 WORD PTR [rcx+80], ax

; 1488 :     if (label != NULL && label[0] != 0)

  003fa	48 83 bd 40 01
	00 00 00	 cmp	 QWORD PTR label$[rbp], 0
  00402	74 64		 je	 SHORT $LN14@TableSetup
  00404	b8 01 00 00 00	 mov	 eax, 1
  00409	48 6b c0 00	 imul	 rax, rax, 0
  0040d	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR label$[rbp]
  00414	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00418	85 c0		 test	 eax, eax
  0041a	74 4c		 je	 SHORT $LN14@TableSetup

; 1489 :     {
; 1490 :         column->NameOffset = (ImS16)table->ColumnsNames.size();

  0041c	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00420	48 05 88 01 00
	00		 add	 rax, 392		; 00000188H
  00426	48 8b c8	 mov	 rcx, rax
  00429	e8 00 00 00 00	 call	 ?size@ImGuiTextBuffer@@QEBAHXZ ; ImGuiTextBuffer::size
  0042e	48 8b 4d 48	 mov	 rcx, QWORD PTR column$[rbp]
  00432	66 89 41 50	 mov	 WORD PTR [rcx+80], ax

; 1491 :         table->ColumnsNames.append(label, label + strlen(label) + 1);

  00436	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR label$[rbp]
  0043d	e8 00 00 00 00	 call	 strlen
  00442	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR label$[rbp]
  00449	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  0044e	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00452	48 81 c1 88 01
	00 00		 add	 rcx, 392		; 00000188H
  00459	4c 8b c0	 mov	 r8, rax
  0045c	48 8b 95 40 01
	00 00		 mov	 rdx, QWORD PTR label$[rbp]
  00463	e8 00 00 00 00	 call	 ?append@ImGuiTextBuffer@@QEAAXPEBD0@Z ; ImGuiTextBuffer::append
$LN14@TableSetup:
$LN1@TableSetup:

; 1492 :     }
; 1493 : }

  00468	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  0046f	5f		 pop	 rdi
  00470	5d		 pop	 rbp
  00471	c3		 ret	 0
?TableSetupColumn@ImGui@@YAXPEBDHMI@Z ENDP		; ImGui::TableSetupColumn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableSetColumnIndex@ImGui@@YA_NH@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
column_n$ = 288
?TableSetColumnIndex@ImGui@@YA_NH@Z PROC		; ImGui::TableSetColumnIndex, COMDAT

; 1916 : {

$LN8:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR [rsp+328]

; 1917 :     ImGuiContext& g = *GImGui;

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0002f	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1918 :     ImGuiTable* table = g.CurrentTable;

  00033	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00037	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  0003e	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1919 :     if (!table)

  00042	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  00047	75 07		 jne	 SHORT $LN2@TableSetCo

; 1920 :         return false;

  00049	32 c0		 xor	 al, al
  0004b	e9 80 00 00 00	 jmp	 $LN1@TableSetCo
$LN2@TableSetCo:

; 1921 : 
; 1922 :     if (table->CurrentColumn != column_n)

  00050	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00054	8b 8d 20 01 00
	00		 mov	 ecx, DWORD PTR column_n$[rbp]
  0005a	39 48 74	 cmp	 DWORD PTR [rax+116], ecx
  0005d	74 57		 je	 SHORT $LN3@TableSetCo

; 1923 :     {
; 1924 :         if (table->CurrentColumn != -1)

  0005f	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00063	83 78 74 ff	 cmp	 DWORD PTR [rax+116], -1
  00067	74 09		 je	 SHORT $LN4@TableSetCo

; 1925 :             TableEndCell(table);

  00069	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0006d	e8 00 00 00 00	 call	 ?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableEndCell
$LN4@TableSetCo:

; 1926 :         IM_ASSERT(column_n >= 0 && table->ColumnsCount);

  00072	83 bd 20 01 00
	00 00		 cmp	 DWORD PTR column_n$[rbp], 0
  00079	7c 0a		 jl	 SHORT $LN6@TableSetCo
  0007b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0007f	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00083	75 22		 jne	 SHORT $LN7@TableSetCo
$LN6@TableSetCo:
  00085	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??TableSetColumnIndex@ImGui@@YA_NH@Z@4JA
  0008b	83 c0 0a	 add	 eax, 10
  0008e	44 8b c0	 mov	 r8d, eax
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@MBNMJGKK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAC?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AAC@
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a5	33 c0		 xor	 eax, eax
$LN7@TableSetCo:

; 1927 :         TableBeginCell(table, column_n);

  000a7	8b 95 20 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  000ad	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  000b1	e8 00 00 00 00	 call	 ?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z ; ImGui::TableBeginCell
$LN3@TableSetCo:

; 1928 :     }
; 1929 : 
; 1930 :     // Return whether the column is visible. User may choose to skip submitting items based on this return value,
; 1931 :     // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
; 1932 :     return table->Columns[column_n].IsRequestOutput;

  000b6	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000ba	48 83 c0 18	 add	 rax, 24
  000be	8b 95 20 01 00
	00		 mov	 edx, DWORD PTR column_n$[rbp]
  000c4	48 8b c8	 mov	 rcx, rax
  000c7	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  000cc	0f b6 40 67	 movzx	 eax, BYTE PTR [rax+103]
$LN1@TableSetCo:

; 1933 : }

  000d0	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000d7	5f		 pop	 rdi
  000d8	5d		 pop	 rbp
  000d9	c3		 ret	 0
?TableSetColumnIndex@ImGui@@YA_NH@Z ENDP		; ImGui::TableSetColumnIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableNextColumn@ImGui@@YA_NXZ
_TEXT	SEGMENT
g$ = 8
table$ = 40
?TableNextColumn@ImGui@@YA_NXZ PROC			; ImGui::TableNextColumn, COMDAT

; 1937 : {

$LN7:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1938 :     ImGuiContext& g = *GImGui;

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00025	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1939 :     ImGuiTable* table = g.CurrentTable;

  00029	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0002d	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00034	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1940 :     if (!table)

  00038	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0003d	75 04		 jne	 SHORT $LN2@TableNextC

; 1941 :         return false;

  0003f	32 c0		 xor	 al, al
  00041	eb 7a		 jmp	 SHORT $LN1@TableNextC
$LN2@TableNextC:

; 1942 : 
; 1943 :     if (table->IsInsideRow && table->CurrentColumn + 1 < table->ColumnsCount)

  00043	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00047	0f b6 80 23 02
	00 00		 movzx	 eax, BYTE PTR [rax+547]
  0004e	85 c0		 test	 eax, eax
  00050	74 3b		 je	 SHORT $LN3@TableNextC
  00052	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00056	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00059	ff c0		 inc	 eax
  0005b	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0005f	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  00062	7d 29		 jge	 SHORT $LN3@TableNextC

; 1944 :     {
; 1945 :         if (table->CurrentColumn != -1)

  00064	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00068	83 78 74 ff	 cmp	 DWORD PTR [rax+116], -1
  0006c	74 09		 je	 SHORT $LN5@TableNextC

; 1946 :             TableEndCell(table);

  0006e	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00072	e8 00 00 00 00	 call	 ?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableEndCell
$LN5@TableNextC:

; 1947 :         TableBeginCell(table, table->CurrentColumn + 1);

  00077	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0007b	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0007e	ff c0		 inc	 eax
  00080	8b d0		 mov	 edx, eax
  00082	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00086	e8 00 00 00 00	 call	 ?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z ; ImGui::TableBeginCell

; 1948 :     }
; 1949 :     else

  0008b	eb 15		 jmp	 SHORT $LN4@TableNextC
$LN3@TableNextC:

; 1950 :     {
; 1951 :         TableNextRow();

  0008d	0f 57 c9	 xorps	 xmm1, xmm1
  00090	33 c9		 xor	 ecx, ecx
  00092	e8 00 00 00 00	 call	 ?TableNextRow@ImGui@@YAXHM@Z ; ImGui::TableNextRow

; 1952 :         TableBeginCell(table, 0);

  00097	33 d2		 xor	 edx, edx
  00099	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0009d	e8 00 00 00 00	 call	 ?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z ; ImGui::TableBeginCell
$LN4@TableNextC:

; 1953 :     }
; 1954 : 
; 1955 :     // Return whether the column is visible. User may choose to skip submitting items based on this return value,
; 1956 :     // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
; 1957 :     return table->Columns[table->CurrentColumn].IsRequestOutput;

  000a2	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000a6	48 83 c0 18	 add	 rax, 24
  000aa	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  000ae	8b 51 74	 mov	 edx, DWORD PTR [rcx+116]
  000b1	48 8b c8	 mov	 rcx, rax
  000b4	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  000b9	0f b6 40 67	 movzx	 eax, BYTE PTR [rax+103]
$LN1@TableNextC:

; 1958 : }

  000bd	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000c4	5f		 pop	 rdi
  000c5	5d		 pop	 rbp
  000c6	c3		 ret	 0
?TableNextColumn@ImGui@@YA_NXZ ENDP			; ImGui::TableNextColumn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?TableNextRow@ImGui@@YAXHM@Z
_TEXT	SEGMENT
g$ = 8
table$ = 40
row_flags$ = 288
row_min_height$ = 296
?TableNextRow@ImGui@@YAXHM@Z PROC			; ImGui::TableNextRow, COMDAT

; 1702 : {

$LN5:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR [rsp+328]

; 1703 :     ImGuiContext& g = *GImGui;

  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00035	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1704 :     ImGuiTable* table = g.CurrentTable;

  00039	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003d	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00044	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1705 : 
; 1706 :     if (!table->IsLayoutLocked)

  00048	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0004c	0f b6 80 22 02
	00 00		 movzx	 eax, BYTE PTR [rax+546]
  00053	85 c0		 test	 eax, eax
  00055	75 09		 jne	 SHORT $LN2@TableNextR

; 1707 :         TableUpdateLayout(table);

  00057	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0005b	e8 00 00 00 00	 call	 ?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableUpdateLayout
$LN2@TableNextR:

; 1708 :     if (table->IsInsideRow)

  00060	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00064	0f b6 80 23 02
	00 00		 movzx	 eax, BYTE PTR [rax+547]
  0006b	85 c0		 test	 eax, eax
  0006d	74 09		 je	 SHORT $LN3@TableNextR

; 1709 :         TableEndRow(table);

  0006f	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00073	e8 00 00 00 00	 call	 ?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableEndRow
$LN3@TableNextR:

; 1710 : 
; 1711 :     table->LastRowFlags = table->RowFlags;

  00078	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0007c	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00082	c1 e0 10	 shl	 eax, 16
  00085	c1 f8 10	 sar	 eax, 16
  00088	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0008d	c1 e0 10	 shl	 eax, 16
  00090	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00094	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0009a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000a0	0b c8		 or	 ecx, eax
  000a2	8b c1		 mov	 eax, ecx
  000a4	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  000a8	89 81 90 00 00
	00		 mov	 DWORD PTR [rcx+144], eax

; 1712 :     table->RowFlags = row_flags;

  000ae	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR row_flags$[rbp]
  000b4	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000b9	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  000bd	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  000c3	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffffffffffff0000H
  000c9	0b c8		 or	 ecx, eax
  000cb	8b c1		 mov	 eax, ecx
  000cd	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  000d1	89 81 90 00 00
	00		 mov	 DWORD PTR [rcx+144], eax

; 1713 :     table->RowMinHeight = row_min_height;

  000d7	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000db	f3 0f 10 85 28
	01 00 00	 movss	 xmm0, DWORD PTR row_min_height$[rbp]
  000e3	f3 0f 11 80 84
	00 00 00	 movss	 DWORD PTR [rax+132], xmm0

; 1714 :     TableBeginRow(table);

  000eb	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  000ef	e8 00 00 00 00	 call	 ?TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableBeginRow

; 1715 : 
; 1716 :     // We honor min_row_height requested by user, but cannot guarantee per-row maximum height,
; 1717 :     // because that would essentially require a unique clipping rectangle per-cell.
; 1718 :     table->RowPosY2 += table->CellPaddingY * 2.0f;

  000f4	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000f8	f3 0f 10 80 c0
	00 00 00	 movss	 xmm0, DWORD PTR [rax+192]
  00100	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00108	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0010c	f3 0f 10 88 80
	00 00 00	 movss	 xmm1, DWORD PTR [rax+128]
  00114	f3 0f 58 c8	 addss	 xmm1, xmm0
  00118	0f 28 c1	 movaps	 xmm0, xmm1
  0011b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0011f	f3 0f 11 80 80
	00 00 00	 movss	 DWORD PTR [rax+128], xmm0

; 1719 :     table->RowPosY2 = ImMax(table->RowPosY2, table->RowPosY1 + row_min_height);

  00127	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0012b	f3 0f 10 40 7c	 movss	 xmm0, DWORD PTR [rax+124]
  00130	f3 0f 58 85 28
	01 00 00	 addss	 xmm0, DWORD PTR row_min_height$[rbp]
  00138	0f 28 c8	 movaps	 xmm1, xmm0
  0013b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0013f	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  00147	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0014c	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00150	f3 0f 11 80 80
	00 00 00	 movss	 DWORD PTR [rax+128], xmm0

; 1720 : 
; 1721 :     // Disable output until user calls TableNextColumn()
; 1722 :     table->InnerWindow->SkipItems = true;

  00158	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0015c	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00163	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1

; 1723 : }

  0016a	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00171	5f		 pop	 rdi
  00172	5d		 pop	 rbp
  00173	c3		 ret	 0
?TableNextRow@ImGui@@YAXHM@Z ENDP			; ImGui::TableNextRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?EndTable@ImGui@@YAXXZ
_TEXT	SEGMENT
g$ = 8
table$ = 40
flags$ = 68
inner_window$ = 104
outer_window$ = 136
temp_data$ = 168
table_instance$ = 200
inner_content_max_y$ = 228
outer_padding_for_border$4 = 260
max_pos_x$5 = 292
splitter$ = 328
auto_fit_width_for_fixed$ = 356
auto_fit_width_for_stretched$ = 388
auto_fit_width_for_stretched_min$ = 420
column_n$6 = 452
column$7 = 488
column_width_request$8 = 516
width_spacings$ = 548
neighbor_width_to_keep_visible$9 = 580
column$10 = 616
column$11 = 648
new_x2$12 = 676
new_width$13 = 708
backup_outer_max_pos$ = 744
decoration_size$14 = 772
decoration_size$15 = 804
$T16 = 1220
$T17 = 1268
tv700 = 1284
tv667 = 1284
tv577 = 1284
tv524 = 1284
tv338 = 1284
tv300 = 1284
tv214 = 1284
tv186 = 1284
tv708 = 1288
tv683 = 1288
tv675 = 1288
__$ArrayPad$ = 1296
?EndTable@ImGui@@YAXXZ PROC				; ImGui::EndTable, COMDAT

; 1220 : {

$LN68:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 81 ec 40 05
	00 00		 sub	 rsp, 1344		; 00000540H
  0000b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00010	48 8b fc	 mov	 rdi, rsp
  00013	b9 50 01 00 00	 mov	 ecx, 336		; 00000150H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c5	 xor	 rax, rbp
  00029	48 89 85 10 05
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 1221 :     ImGuiContext& g = *GImGui;

  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00037	48 89 45 08	 mov	 QWORD PTR g$[rbp], rax

; 1222 :     ImGuiTable* table = g.CurrentTable;

  0003b	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  0003f	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00046	48 89 45 28	 mov	 QWORD PTR table$[rbp], rax

; 1223 :     IM_ASSERT(table != NULL && "Only call EndTable() if BeginTable() returns true!");

  0004a	48 83 7d 28 00	 cmp	 QWORD PTR table$[rbp], 0
  0004f	74 0c		 je	 SHORT $LN40@EndTable
  00051	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DD@JFFDACDB@Only?5call?5EndTable?$CI?$CJ?5if?5BeginTab@
  00058	48 85 c0	 test	 rax, rax
  0005b	75 22		 jne	 SHORT $LN41@EndTable
$LN40@EndTable:
  0005d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA
  00063	83 c0 03	 add	 eax, 3
  00066	44 8b c0	 mov	 r8d, eax
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1IG@CGOKCKPM@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAO?$AAn?$AAl?$AAy?$AA?5?$AAc?$AAa?$AAl?$AAl?$AA?5?$AAE?$AAn?$AAd?$AAT?$AAa?$AAb?$AAl@
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007d	33 c0		 xor	 eax, eax
$LN41@EndTable:

; 1224 : 
; 1225 :     // This assert would be very useful to catch a common error... unfortunately it would probably trigger in some
; 1226 :     // cases, and for consistency user may sometimes output empty tables (and still benefit from e.g. outer border)
; 1227 :     //IM_ASSERT(table->IsLayoutLocked && "Table unused: never called TableNextRow(), is that the intent?");
; 1228 : 
; 1229 :     // If the user never got to call TableNextRow() or TableNextColumn(), we call layout ourselves to ensure all our
; 1230 :     // code paths are consistent (instead of just hoping that TableBegin/TableEnd will work), get borders drawn, etc.
; 1231 :     if (!table->IsLayoutLocked)

  0007f	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00083	0f b6 80 22 02
	00 00		 movzx	 eax, BYTE PTR [rax+546]
  0008a	85 c0		 test	 eax, eax
  0008c	75 09		 jne	 SHORT $LN5@EndTable

; 1232 :         TableUpdateLayout(table);

  0008e	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00092	e8 00 00 00 00	 call	 ?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableUpdateLayout
$LN5@EndTable:

; 1233 : 
; 1234 :     const ImGuiTableFlags flags = table->Flags;

  00097	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0009b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0009e	89 45 44	 mov	 DWORD PTR flags$[rbp], eax

; 1235 :     ImGuiWindow* inner_window = table->InnerWindow;

  000a1	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000a5	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  000ac	48 89 45 68	 mov	 QWORD PTR inner_window$[rbp], rax

; 1236 :     ImGuiWindow* outer_window = table->OuterWindow;

  000b0	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000b4	48 8b 80 78 01
	00 00		 mov	 rax, QWORD PTR [rax+376]
  000bb	48 89 85 88 00
	00 00		 mov	 QWORD PTR outer_window$[rbp], rax

; 1237 :     ImGuiTableTempData* temp_data = table->TempData;

  000c2	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  000c6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ca	48 89 85 a8 00
	00 00		 mov	 QWORD PTR temp_data$[rbp], rax

; 1238 :     IM_ASSERT(inner_window == g.CurrentWindow);

  000d1	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  000d5	48 8b 80 a0 3e
	00 00		 mov	 rax, QWORD PTR [rax+16032]
  000dc	48 39 45 68	 cmp	 QWORD PTR inner_window$[rbp], rax
  000e0	74 22		 je	 SHORT $LN42@EndTable
  000e2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA
  000e8	83 c0 12	 add	 eax, 18
  000eb	44 8b c0	 mov	 r8d, eax
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@FGAGBNK@?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAg?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$AA@
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00102	33 c0		 xor	 eax, eax
$LN42@EndTable:

; 1239 :     IM_ASSERT(outer_window == inner_window || outer_window == inner_window->ParentWindow);

  00104	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00108	48 39 85 88 00
	00 00		 cmp	 QWORD PTR outer_window$[rbp], rax
  0010f	74 36		 je	 SHORT $LN43@EndTable
  00111	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00115	48 8b 80 60 03
	00 00		 mov	 rax, QWORD PTR [rax+864]
  0011c	48 39 85 88 00
	00 00		 cmp	 QWORD PTR outer_window$[rbp], rax
  00123	74 22		 je	 SHORT $LN43@EndTable
  00125	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA
  0012b	83 c0 13	 add	 eax, 19
  0012e	44 8b c0	 mov	 r8d, eax
  00131	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JG@DEMMNCCK@?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$HM?$AA?$HM?$AA?5@
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00145	33 c0		 xor	 eax, eax
$LN43@EndTable:

; 1240 : 
; 1241 :     if (table->IsInsideRow)

  00147	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0014b	0f b6 80 23 02
	00 00		 movzx	 eax, BYTE PTR [rax+547]
  00152	85 c0		 test	 eax, eax
  00154	74 09		 je	 SHORT $LN6@EndTable

; 1242 :         TableEndRow(table);

  00156	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0015a	e8 00 00 00 00	 call	 ?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableEndRow
$LN6@EndTable:

; 1243 : 
; 1244 :     // Context menu in columns body
; 1245 :     if (flags & ImGuiTableFlags_ContextMenuInBody)

  0015f	8b 45 44	 mov	 eax, DWORD PTR flags$[rbp]
  00162	83 e0 20	 and	 eax, 32			; 00000020H
  00165	85 c0		 test	 eax, eax
  00167	74 3f		 je	 SHORT $LN7@EndTable

; 1246 :         if (table->HoveredColumnBody != -1 && !IsAnyItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))

  00169	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0016d	0f bf 80 f8 01
	00 00		 movsx	 eax, WORD PTR [rax+504]
  00174	83 f8 ff	 cmp	 eax, -1
  00177	74 2f		 je	 SHORT $LN8@EndTable
  00179	e8 00 00 00 00	 call	 ?IsAnyItemHovered@ImGui@@YA_NXZ ; ImGui::IsAnyItemHovered
  0017e	0f b6 c0	 movzx	 eax, al
  00181	85 c0		 test	 eax, eax
  00183	75 23		 jne	 SHORT $LN8@EndTable
  00185	b9 01 00 00 00	 mov	 ecx, 1
  0018a	e8 00 00 00 00	 call	 ?IsMouseReleased@ImGui@@YA_NH@Z ; ImGui::IsMouseReleased
  0018f	0f b6 c0	 movzx	 eax, al
  00192	85 c0		 test	 eax, eax
  00194	74 12		 je	 SHORT $LN8@EndTable

; 1247 :             TableOpenContextMenu((int)table->HoveredColumnBody);

  00196	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0019a	0f bf 80 f8 01
	00 00		 movsx	 eax, WORD PTR [rax+504]
  001a1	8b c8		 mov	 ecx, eax
  001a3	e8 00 00 00 00	 call	 ?TableOpenContextMenu@ImGui@@YAXH@Z ; ImGui::TableOpenContextMenu
$LN8@EndTable:
$LN7@EndTable:

; 1248 : 
; 1249 :     // Finalize table height
; 1250 :     ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);

  001a8	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  001ac	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  001b0	8b d0		 mov	 edx, eax
  001b2	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  001b6	e8 00 00 00 00	 call	 ?TableGetInstanceData@ImGui@@YAPEAUImGuiTableInstanceData@@PEAUImGuiTable@@H@Z ; ImGui::TableGetInstanceData
  001bb	48 89 85 c8 00
	00 00		 mov	 QWORD PTR table_instance$[rbp], rax

; 1251 :     inner_window->DC.PrevLineSize = temp_data->HostBackupPrevLineSize;

  001c2	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  001c9	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  001cd	48 8b 4d 68	 mov	 rcx, QWORD PTR inner_window$[rbp]
  001d1	48 89 81 28 01
	00 00		 mov	 QWORD PTR [rcx+296], rax

; 1252 :     inner_window->DC.CurrLineSize = temp_data->HostBackupCurrLineSize;

  001d8	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  001df	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  001e3	48 8b 4d 68	 mov	 rcx, QWORD PTR inner_window$[rbp]
  001e7	48 89 81 20 01
	00 00		 mov	 QWORD PTR [rcx+288], rax

; 1253 :     inner_window->DC.CursorMaxPos = temp_data->HostBackupCursorMaxPos;

  001ee	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  001f5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001f9	48 8b 4d 68	 mov	 rcx, QWORD PTR inner_window$[rbp]
  001fd	48 89 81 10 01
	00 00		 mov	 QWORD PTR [rcx+272], rax

; 1254 :     const float inner_content_max_y = table->RowPosY2;

  00204	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00208	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  00210	f3 0f 11 85 e4
	00 00 00	 movss	 DWORD PTR inner_content_max_y$[rbp], xmm0

; 1255 :     IM_ASSERT(table->RowPosY2 == inner_window->DC.CursorPos.y);

  00218	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0021c	48 8b 4d 68	 mov	 rcx, QWORD PTR inner_window$[rbp]
  00220	f3 0f 10 80 80
	00 00 00	 movss	 xmm0, DWORD PTR [rax+128]
  00228	0f 2e 81 fc 00
	00 00		 ucomiss xmm0, DWORD PTR [rcx+252]
  0022f	7a 02		 jp	 SHORT $LN67@EndTable
  00231	74 22		 je	 SHORT $LN44@EndTable
$LN67@EndTable:
  00233	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA
  00239	83 c0 23	 add	 eax, 35			; 00000023H
  0023c	44 8b c0	 mov	 r8d, eax
  0023f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00246	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GA@MJADNMBJ@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAR?$AAo?$AAw?$AAP?$AAo?$AAs?$AAY?$AA2?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9@
  0024d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00253	33 c0		 xor	 eax, eax
$LN44@EndTable:

; 1256 :     if (inner_window != outer_window)

  00255	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  0025c	48 39 45 68	 cmp	 QWORD PTR inner_window$[rbp], rax
  00260	74 16		 je	 SHORT $LN9@EndTable

; 1257 :         inner_window->DC.CursorMaxPos.y = inner_content_max_y;

  00262	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00266	f3 0f 10 85 e4
	00 00 00	 movss	 xmm0, DWORD PTR inner_content_max_y$[rbp]
  0026e	f3 0f 11 80 14
	01 00 00	 movss	 DWORD PTR [rax+276], xmm0
  00276	eb 55		 jmp	 SHORT $LN10@EndTable
$LN9@EndTable:

; 1258 :     else if (!(flags & ImGuiTableFlags_NoHostExtendY))

  00278	8b 45 44	 mov	 eax, DWORD PTR flags$[rbp]
  0027b	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00280	85 c0		 test	 eax, eax
  00282	75 49		 jne	 SHORT $LN11@EndTable

; 1259 :         table->OuterRect.Max.y = table->InnerRect.Max.y = ImMax(table->OuterRect.Max.y, inner_content_max_y); // Patch OuterRect/InnerRect height

  00284	f3 0f 10 8d e4
	00 00 00	 movss	 xmm1, DWORD PTR inner_content_max_y$[rbp]
  0028c	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00290	f3 0f 10 80 f4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+244]
  00298	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0029d	f3 0f 11 85 04
	05 00 00	 movss	 DWORD PTR tv186[rbp], xmm0
  002a5	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  002a9	f3 0f 10 85 04
	05 00 00	 movss	 xmm0, DWORD PTR tv186[rbp]
  002b1	f3 0f 11 80 04
	01 00 00	 movss	 DWORD PTR [rax+260], xmm0
  002b9	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  002bd	f3 0f 10 85 04
	05 00 00	 movss	 xmm0, DWORD PTR tv186[rbp]
  002c5	f3 0f 11 80 f4
	00 00 00	 movss	 DWORD PTR [rax+244], xmm0
$LN11@EndTable:
$LN10@EndTable:

; 1260 :     table->WorkRect.Max.y = ImMax(table->WorkRect.Max.y, table->OuterRect.Max.y);

  002cd	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  002d1	f3 0f 10 88 f4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+244]
  002d9	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  002dd	f3 0f 10 80 14
	01 00 00	 movss	 xmm0, DWORD PTR [rax+276]
  002e5	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002ea	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  002ee	f3 0f 11 80 14
	01 00 00	 movss	 DWORD PTR [rax+276], xmm0

; 1261 :     table_instance->LastOuterHeight = table->OuterRect.GetHeight();

  002f6	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  002fa	48 05 e8 00 00
	00		 add	 rax, 232		; 000000e8H
  00300	48 8b c8	 mov	 rcx, rax
  00303	e8 00 00 00 00	 call	 ?GetHeight@ImRect@@QEBAMXZ ; ImRect::GetHeight
  00308	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR table_instance$[rbp]
  0030f	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 1262 : 
; 1263 :     // Setup inner scrolling range
; 1264 :     // FIXME: This ideally should be done earlier, in BeginTable() SetNextWindowContentSize call, just like writing to inner_window->DC.CursorMaxPos.y,
; 1265 :     // but since the later is likely to be impossible to do we'd rather update both axises together.
; 1266 :     if (table->Flags & ImGuiTableFlags_ScrollX)

  00313	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00317	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0031a	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0031f	85 c0		 test	 eax, eax
  00321	0f 84 0b 01 00
	00		 je	 $LN12@EndTable

; 1267 :     {
; 1268 :         const float outer_padding_for_border = (table->Flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;

  00327	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0032b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0032e	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00333	85 c0		 test	 eax, eax
  00335	74 12		 je	 SHORT $LN45@EndTable
  00337	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0033f	f3 0f 11 85 04
	05 00 00	 movss	 DWORD PTR tv214[rbp], xmm0
  00347	eb 0b		 jmp	 SHORT $LN46@EndTable
$LN45@EndTable:
  00349	0f 57 c0	 xorps	 xmm0, xmm0
  0034c	f3 0f 11 85 04
	05 00 00	 movss	 DWORD PTR tv214[rbp], xmm0
$LN46@EndTable:
  00354	f3 0f 10 85 04
	05 00 00	 movss	 xmm0, DWORD PTR tv214[rbp]
  0035c	f3 0f 11 85 04
	01 00 00	 movss	 DWORD PTR outer_padding_for_border$4[rbp], xmm0

; 1269 :         float max_pos_x = table->InnerWindow->DC.CursorMaxPos.x;

  00364	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00368	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  0036f	f3 0f 10 80 10
	01 00 00	 movss	 xmm0, DWORD PTR [rax+272]
  00377	f3 0f 11 85 24
	01 00 00	 movss	 DWORD PTR max_pos_x$5[rbp], xmm0

; 1270 :         if (table->RightMostEnabledColumn != -1)

  0037f	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00383	0f bf 80 0a 02
	00 00		 movsx	 eax, WORD PTR [rax+522]
  0038a	83 f8 ff	 cmp	 eax, -1
  0038d	74 57		 je	 SHORT $LN13@EndTable

; 1271 :             max_pos_x = ImMax(max_pos_x, table->Columns[table->RightMostEnabledColumn].WorkMaxX + table->CellPaddingX + table->OuterPaddingX - outer_padding_for_border);

  0038f	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00393	0f bf 80 0a 02
	00 00		 movsx	 eax, WORD PTR [rax+522]
  0039a	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0039e	48 83 c1 18	 add	 rcx, 24
  003a2	8b d0		 mov	 edx, eax
  003a4	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  003a9	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  003ad	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [rax+56]
  003b2	f3 0f 58 81 bc
	00 00 00	 addss	 xmm0, DWORD PTR [rcx+188]
  003ba	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  003be	f3 0f 58 80 b8
	00 00 00	 addss	 xmm0, DWORD PTR [rax+184]
  003c6	f3 0f 5c 85 04
	01 00 00	 subss	 xmm0, DWORD PTR outer_padding_for_border$4[rbp]
  003ce	0f 28 c8	 movaps	 xmm1, xmm0
  003d1	f3 0f 10 85 24
	01 00 00	 movss	 xmm0, DWORD PTR max_pos_x$5[rbp]
  003d9	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  003de	f3 0f 11 85 24
	01 00 00	 movss	 DWORD PTR max_pos_x$5[rbp], xmm0
$LN13@EndTable:

; 1272 :         if (table->ResizedColumn != -1)

  003e6	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  003ea	0f bf 80 fe 01
	00 00		 movsx	 eax, WORD PTR [rax+510]
  003f1	83 f8 ff	 cmp	 eax, -1
  003f4	74 21		 je	 SHORT $LN14@EndTable

; 1273 :             max_pos_x = ImMax(max_pos_x, table->ResizeLockMinContentsX2);

  003f6	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  003fa	f3 0f 10 88 e0
	00 00 00	 movss	 xmm1, DWORD PTR [rax+224]
  00402	f3 0f 10 85 24
	01 00 00	 movss	 xmm0, DWORD PTR max_pos_x$5[rbp]
  0040a	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0040f	f3 0f 11 85 24
	01 00 00	 movss	 DWORD PTR max_pos_x$5[rbp], xmm0
$LN14@EndTable:

; 1274 :         table->InnerWindow->DC.CursorMaxPos.x = max_pos_x;

  00417	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0041b	48 8b 80 80 01
	00 00		 mov	 rax, QWORD PTR [rax+384]
  00422	f3 0f 10 85 24
	01 00 00	 movss	 xmm0, DWORD PTR max_pos_x$5[rbp]
  0042a	f3 0f 11 80 10
	01 00 00	 movss	 DWORD PTR [rax+272], xmm0
$LN12@EndTable:

; 1275 :     }
; 1276 : 
; 1277 :     // Pop clipping rect
; 1278 :     if (!(flags & ImGuiTableFlags_NoClip))

  00432	8b 45 44	 mov	 eax, DWORD PTR flags$[rbp]
  00435	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  0043a	85 c0		 test	 eax, eax
  0043c	75 10		 jne	 SHORT $LN15@EndTable

; 1279 :         inner_window->DrawList->PopClipRect();

  0043e	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00442	48 8b 88 90 02
	00 00		 mov	 rcx, QWORD PTR [rax+656]
  00449	e8 00 00 00 00	 call	 ?PopClipRect@ImDrawList@@QEAAXXZ ; ImDrawList::PopClipRect
$LN15@EndTable:

; 1280 :     inner_window->ClipRect = inner_window->DrawList->_ClipRectStack.back();

  0044e	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00452	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00459	48 83 c0 58	 add	 rax, 88			; 00000058H
  0045d	48 8b c8	 mov	 rcx, rax
  00460	e8 00 00 00 00	 call	 ?back@?$ImVector@UImVec4@@@@QEAAAEAUImVec4@@XZ ; ImVector<ImVec4>::back
  00465	48 8b d0	 mov	 rdx, rax
  00468	48 8d 8d c4 04
	00 00		 lea	 rcx, QWORD PTR $T16[rbp]
  0046f	e8 00 00 00 00	 call	 ??0ImRect@@QEAA@AEBUImVec4@@@Z ; ImRect::ImRect
  00474	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00478	48 8d 8d c4 04
	00 00		 lea	 rcx, QWORD PTR $T16[rbp]
  0047f	48 8d b8 30 02
	00 00		 lea	 rdi, QWORD PTR [rax+560]
  00486	48 8b f1	 mov	 rsi, rcx
  00489	b9 10 00 00 00	 mov	 ecx, 16
  0048e	f3 a4		 rep movsb

; 1281 : 
; 1282 :     // Draw borders
; 1283 :     if ((flags & ImGuiTableFlags_Borders) != 0)

  00490	8b 45 44	 mov	 eax, DWORD PTR flags$[rbp]
  00493	25 80 07 00 00	 and	 eax, 1920		; 00000780H
  00498	85 c0		 test	 eax, eax
  0049a	74 09		 je	 SHORT $LN16@EndTable

; 1284 :         TableDrawBorders(table);

  0049c	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  004a0	e8 00 00 00 00	 call	 ?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableDrawBorders
$LN16@EndTable:

; 1285 : 
; 1286 : #if 0
; 1287 :     // Strip out dummy channel draw calls
; 1288 :     // We have no way to prevent user submitting direct ImDrawList calls into a hidden column (but ImGui:: calls will be clipped out)
; 1289 :     // Pros: remove draw calls which will have no effect. since they'll have zero-size cliprect they may be early out anyway.
; 1290 :     // Cons: making it harder for users watching metrics/debugger to spot the wasted vertices.
; 1291 :     if (table->DummyDrawChannel != (ImGuiTableColumnIdx)-1)
; 1292 :     {
; 1293 :         ImDrawChannel* dummy_channel = &table->DrawSplitter._Channels[table->DummyDrawChannel];
; 1294 :         dummy_channel->_CmdBuffer.resize(0);
; 1295 :         dummy_channel->_IdxBuffer.resize(0);
; 1296 :     }
; 1297 : #endif
; 1298 : 
; 1299 :     // Flatten channels and merge draw calls
; 1300 :     ImDrawListSplitter* splitter = table->DrawSplitter;

  004a5	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  004a9	48 8b 80 98 01
	00 00		 mov	 rax, QWORD PTR [rax+408]
  004b0	48 89 85 48 01
	00 00		 mov	 QWORD PTR splitter$[rbp], rax

; 1301 :     splitter->SetCurrentChannel(inner_window->DrawList, 0);

  004b7	45 33 c0	 xor	 r8d, r8d
  004ba	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  004be	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  004c5	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR splitter$[rbp]
  004cc	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 1302 :     if ((table->Flags & ImGuiTableFlags_NoClip) == 0)

  004d1	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  004d5	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  004d8	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  004dd	85 c0		 test	 eax, eax
  004df	75 09		 jne	 SHORT $LN17@EndTable

; 1303 :         TableMergeDrawChannels(table);

  004e1	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  004e5	e8 00 00 00 00	 call	 ?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableMergeDrawChannels
$LN17@EndTable:

; 1304 :     splitter->Merge(inner_window->DrawList);

  004ea	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  004ee	48 8b 90 90 02
	00 00		 mov	 rdx, QWORD PTR [rax+656]
  004f5	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR splitter$[rbp]
  004fc	e8 00 00 00 00	 call	 ?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z ; ImDrawListSplitter::Merge

; 1305 : 
; 1306 :     // Update ColumnsAutoFitWidth to get us ahead for host using our size to auto-resize without waiting for next BeginTable()
; 1307 :     float auto_fit_width_for_fixed = 0.0f;

  00501	0f 57 c0	 xorps	 xmm0, xmm0
  00504	f3 0f 11 85 64
	01 00 00	 movss	 DWORD PTR auto_fit_width_for_fixed$[rbp], xmm0

; 1308 :     float auto_fit_width_for_stretched = 0.0f;

  0050c	0f 57 c0	 xorps	 xmm0, xmm0
  0050f	f3 0f 11 85 84
	01 00 00	 movss	 DWORD PTR auto_fit_width_for_stretched$[rbp], xmm0

; 1309 :     float auto_fit_width_for_stretched_min = 0.0f;

  00517	0f 57 c0	 xorps	 xmm0, xmm0
  0051a	f3 0f 11 85 a4
	01 00 00	 movss	 DWORD PTR auto_fit_width_for_stretched_min$[rbp], xmm0

; 1310 :     for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

  00522	c7 85 c4 01 00
	00 00 00 00 00	 mov	 DWORD PTR column_n$6[rbp], 0
  0052c	eb 0e		 jmp	 SHORT $LN4@EndTable
$LN2@EndTable:
  0052e	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR column_n$6[rbp]
  00534	ff c0		 inc	 eax
  00536	89 85 c4 01 00
	00		 mov	 DWORD PTR column_n$6[rbp], eax
$LN4@EndTable:
  0053c	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00540	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00543	39 85 c4 01 00
	00		 cmp	 DWORD PTR column_n$6[rbp], eax
  00549	0f 8d 66 01 00
	00		 jge	 $LN3@EndTable

; 1311 :         if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))

  0054f	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR column_n$6[rbp]
  00555	c1 f8 05	 sar	 eax, 5
  00558	48 98		 cdqe
  0055a	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0055e	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00562	48 89 8d 08 05
	00 00		 mov	 QWORD PTR tv708[rbp], rcx
  00569	8b 95 c4 01 00
	00		 mov	 edx, DWORD PTR column_n$6[rbp]
  0056f	83 e2 1f	 and	 edx, 31
  00572	bf 01 00 00 00	 mov	 edi, 1
  00577	0f b6 ca	 movzx	 ecx, dl
  0057a	8b d7		 mov	 edx, edi
  0057c	d3 e2		 shl	 edx, cl
  0057e	8b ca		 mov	 ecx, edx
  00580	48 8b 95 08 05
	00 00		 mov	 rdx, QWORD PTR tv708[rbp]
  00587	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  0058a	23 c1		 and	 eax, ecx
  0058c	85 c0		 test	 eax, eax
  0058e	0f 84 1c 01 00
	00		 je	 $LN18@EndTable

; 1312 :         {
; 1313 :             ImGuiTableColumn* column = &table->Columns[column_n];

  00594	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00598	48 83 c0 18	 add	 rax, 24
  0059c	8b 95 c4 01 00
	00		 mov	 edx, DWORD PTR column_n$6[rbp]
  005a2	48 8b c8	 mov	 rcx, rax
  005a5	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  005aa	48 89 85 e8 01
	00 00		 mov	 QWORD PTR column$7[rbp], rax

; 1314 :             float column_width_request = ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !(column->Flags & ImGuiTableColumnFlags_NoResize)) ? column->WidthRequest : TableGetColumnWidthAuto(table, column);

  005b1	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  005b8	8b 00		 mov	 eax, DWORD PTR [rax]
  005ba	83 e0 10	 and	 eax, 16
  005bd	85 c0		 test	 eax, eax
  005bf	74 26		 je	 SHORT $LN47@EndTable
  005c1	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  005c8	8b 00		 mov	 eax, DWORD PTR [rax]
  005ca	83 e0 20	 and	 eax, 32			; 00000020H
  005cd	85 c0		 test	 eax, eax
  005cf	75 16		 jne	 SHORT $LN47@EndTable
  005d1	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  005d8	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  005dd	f3 0f 11 85 04
	05 00 00	 movss	 DWORD PTR tv300[rbp], xmm0
  005e5	eb 18		 jmp	 SHORT $LN48@EndTable
$LN47@EndTable:
  005e7	48 8b 95 e8 01
	00 00		 mov	 rdx, QWORD PTR column$7[rbp]
  005ee	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  005f2	e8 00 00 00 00	 call	 ?TableGetColumnWidthAuto@ImGui@@YAMPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z ; ImGui::TableGetColumnWidthAuto
  005f7	f3 0f 11 85 04
	05 00 00	 movss	 DWORD PTR tv300[rbp], xmm0
$LN48@EndTable:
  005ff	f3 0f 10 85 04
	05 00 00	 movss	 xmm0, DWORD PTR tv300[rbp]
  00607	f3 0f 11 85 04
	02 00 00	 movss	 DWORD PTR column_width_request$8[rbp], xmm0

; 1315 :             if (column->Flags & ImGuiTableColumnFlags_WidthFixed)

  0060f	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  00616	8b 00		 mov	 eax, DWORD PTR [rax]
  00618	83 e0 10	 and	 eax, 16
  0061b	85 c0		 test	 eax, eax
  0061d	74 1a		 je	 SHORT $LN19@EndTable

; 1316 :                 auto_fit_width_for_fixed += column_width_request;

  0061f	f3 0f 10 85 64
	01 00 00	 movss	 xmm0, DWORD PTR auto_fit_width_for_fixed$[rbp]
  00627	f3 0f 58 85 04
	02 00 00	 addss	 xmm0, DWORD PTR column_width_request$8[rbp]
  0062f	f3 0f 11 85 64
	01 00 00	 movss	 DWORD PTR auto_fit_width_for_fixed$[rbp], xmm0

; 1317 :             else

  00637	eb 18		 jmp	 SHORT $LN20@EndTable
$LN19@EndTable:

; 1318 :                 auto_fit_width_for_stretched += column_width_request;

  00639	f3 0f 10 85 84
	01 00 00	 movss	 xmm0, DWORD PTR auto_fit_width_for_stretched$[rbp]
  00641	f3 0f 58 85 04
	02 00 00	 addss	 xmm0, DWORD PTR column_width_request$8[rbp]
  00649	f3 0f 11 85 84
	01 00 00	 movss	 DWORD PTR auto_fit_width_for_stretched$[rbp], xmm0
$LN20@EndTable:

; 1319 :             if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) && (column->Flags & ImGuiTableColumnFlags_NoResize) != 0)

  00651	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  00658	8b 00		 mov	 eax, DWORD PTR [rax]
  0065a	83 e0 08	 and	 eax, 8
  0065d	85 c0		 test	 eax, eax
  0065f	74 4f		 je	 SHORT $LN21@EndTable
  00661	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  00668	8b 00		 mov	 eax, DWORD PTR [rax]
  0066a	83 e0 20	 and	 eax, 32			; 00000020H
  0066d	85 c0		 test	 eax, eax
  0066f	74 3f		 je	 SHORT $LN21@EndTable

; 1320 :                 auto_fit_width_for_stretched_min = ImMax(auto_fit_width_for_stretched_min, column_width_request / (column->StretchWeight / table->ColumnsStretchSumWeights));

  00671	48 8b 85 e8 01
	00 00		 mov	 rax, QWORD PTR column$7[rbp]
  00678	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0067c	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  00681	f3 0f 5e 81 d8
	00 00 00	 divss	 xmm0, DWORD PTR [rcx+216]
  00689	f3 0f 10 8d 04
	02 00 00	 movss	 xmm1, DWORD PTR column_width_request$8[rbp]
  00691	f3 0f 5e c8	 divss	 xmm1, xmm0
  00695	0f 28 c1	 movaps	 xmm0, xmm1
  00698	0f 28 c8	 movaps	 xmm1, xmm0
  0069b	f3 0f 10 85 a4
	01 00 00	 movss	 xmm0, DWORD PTR auto_fit_width_for_stretched_min$[rbp]
  006a3	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  006a8	f3 0f 11 85 a4
	01 00 00	 movss	 DWORD PTR auto_fit_width_for_stretched_min$[rbp], xmm0
$LN21@EndTable:
$LN18@EndTable:

; 1321 :         }

  006b0	e9 79 fe ff ff	 jmp	 $LN2@EndTable
$LN3@EndTable:

; 1322 :     const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);

  006b5	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  006b9	f3 0f 10 80 b8
	00 00 00	 movss	 xmm0, DWORD PTR [rax+184]
  006c1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  006c9	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  006cd	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  006d1	f3 0f 10 88 c4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+196]
  006d9	f3 0f 58 89 c8
	00 00 00	 addss	 xmm1, DWORD PTR [rcx+200]
  006e1	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  006e5	0f bf 80 f2 01
	00 00		 movsx	 eax, WORD PTR [rax+498]
  006ec	ff c8		 dec	 eax
  006ee	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  006f2	f3 0f 59 ca	 mulss	 xmm1, xmm2
  006f6	f3 0f 58 c1	 addss	 xmm0, xmm1
  006fa	f3 0f 11 85 24
	02 00 00	 movss	 DWORD PTR width_spacings$[rbp], xmm0

; 1323 :     table->ColumnsAutoFitWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount + auto_fit_width_for_fixed + ImMax(auto_fit_width_for_stretched, auto_fit_width_for_stretched_min);

  00702	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00706	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+188]
  0070e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00716	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0071a	0f bf 80 f2 01
	00 00		 movsx	 eax, WORD PTR [rax+498]
  00721	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00725	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00729	f3 0f 10 8d 24
	02 00 00	 movss	 xmm1, DWORD PTR width_spacings$[rbp]
  00731	f3 0f 58 c8	 addss	 xmm1, xmm0
  00735	0f 28 c1	 movaps	 xmm0, xmm1
  00738	f3 0f 58 85 64
	01 00 00	 addss	 xmm0, DWORD PTR auto_fit_width_for_fixed$[rbp]
  00740	f3 0f 11 85 04
	05 00 00	 movss	 DWORD PTR tv338[rbp], xmm0
  00748	f3 0f 10 8d a4
	01 00 00	 movss	 xmm1, DWORD PTR auto_fit_width_for_stretched_min$[rbp]
  00750	f3 0f 10 85 84
	01 00 00	 movss	 xmm0, DWORD PTR auto_fit_width_for_stretched$[rbp]
  00758	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0075d	f3 0f 10 8d 04
	05 00 00	 movss	 xmm1, DWORD PTR tv338[rbp]
  00765	f3 0f 58 c8	 addss	 xmm1, xmm0
  00769	0f 28 c1	 movaps	 xmm0, xmm1
  0076c	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00770	f3 0f 11 80 d4
	00 00 00	 movss	 DWORD PTR [rax+212], xmm0

; 1324 : 
; 1325 :     // Update scroll
; 1326 :     if ((table->Flags & ImGuiTableFlags_ScrollX) == 0 && inner_window != outer_window)

  00778	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0077c	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0077f	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00784	85 c0		 test	 eax, eax
  00786	75 1e		 jne	 SHORT $LN22@EndTable
  00788	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  0078f	48 39 45 68	 cmp	 QWORD PTR inner_window$[rbp], rax
  00793	74 11		 je	 SHORT $LN22@EndTable

; 1327 :     {
; 1328 :         inner_window->Scroll.x = 0.0f;

  00795	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00799	0f 57 c0	 xorps	 xmm0, xmm0
  0079c	f3 0f 11 40 7c	 movss	 DWORD PTR [rax+124], xmm0
  007a1	e9 39 01 00 00	 jmp	 $LN23@EndTable
$LN22@EndTable:

; 1329 :     }
; 1330 :     else if (table->LastResizedColumn != -1 && table->ResizedColumn == -1 && inner_window->ScrollbarX && table->InstanceInteracted == table->InstanceCurrent)

  007a6	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  007aa	0f bf 80 00 02
	00 00		 movsx	 eax, WORD PTR [rax+512]
  007b1	83 f8 ff	 cmp	 eax, -1
  007b4	0f 84 25 01 00
	00		 je	 $LN24@EndTable
  007ba	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  007be	0f bf 80 fe 01
	00 00		 movsx	 eax, WORD PTR [rax+510]
  007c5	83 f8 ff	 cmp	 eax, -1
  007c8	0f 85 11 01 00
	00		 jne	 $LN24@EndTable
  007ce	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  007d2	0f b6 80 ac 00
	00 00		 movzx	 eax, BYTE PTR [rax+172]
  007d9	85 c0		 test	 eax, eax
  007db	0f 84 fe 00 00
	00		 je	 $LN24@EndTable
  007e1	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  007e5	0f bf 40 7a	 movsx	 eax, WORD PTR [rax+122]
  007e9	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  007ed	0f bf 49 78	 movsx	 ecx, WORD PTR [rcx+120]
  007f1	3b c1		 cmp	 eax, ecx
  007f3	0f 85 e6 00 00
	00		 jne	 $LN24@EndTable

; 1331 :     {
; 1332 :         // When releasing a column being resized, scroll to keep the resulting column in sight
; 1333 :         const float neighbor_width_to_keep_visible = table->MinColumnWidth + table->CellPaddingX * 2.0f;

  007f9	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  007fd	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [rax+188]
  00805	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0080d	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00811	f3 0f 10 88 b4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+180]
  00819	f3 0f 58 c8	 addss	 xmm1, xmm0
  0081d	0f 28 c1	 movaps	 xmm0, xmm1
  00820	f3 0f 11 85 44
	02 00 00	 movss	 DWORD PTR neighbor_width_to_keep_visible$9[rbp], xmm0

; 1334 :         ImGuiTableColumn* column = &table->Columns[table->LastResizedColumn];

  00828	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0082c	0f bf 80 00 02
	00 00		 movsx	 eax, WORD PTR [rax+512]
  00833	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00837	48 83 c1 18	 add	 rcx, 24
  0083b	8b d0		 mov	 edx, eax
  0083d	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00842	48 89 85 68 02
	00 00		 mov	 QWORD PTR column$10[rbp], rax

; 1335 :         if (column->MaxX < table->InnerClipRect.Min.x)

  00849	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0084d	48 8b 8d 68 02
	00 00		 mov	 rcx, QWORD PTR column$10[rbp]
  00854	f3 0f 10 80 18
	01 00 00	 movss	 xmm0, DWORD PTR [rax+280]
  0085c	0f 2f 41 0c	 comiss	 xmm0, DWORD PTR [rcx+12]
  00860	76 33		 jbe	 SHORT $LN25@EndTable

; 1336 :             SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x - neighbor_width_to_keep_visible, 1.0f);

  00862	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  00869	48 8b 4d 68	 mov	 rcx, QWORD PTR inner_window$[rbp]
  0086d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  00872	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [rcx+24]
  00877	f3 0f 5c 85 44
	02 00 00	 subss	 xmm0, DWORD PTR neighbor_width_to_keep_visible$9[rbp]
  0087f	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  00887	0f 28 c8	 movaps	 xmm1, xmm0
  0088a	48 8b 4d 68	 mov	 rcx, QWORD PTR inner_window$[rbp]
  0088e	e8 00 00 00 00	 call	 ?SetScrollFromPosX@ImGui@@YAXPEAUImGuiWindow@@MM@Z ; ImGui::SetScrollFromPosX
  00893	eb 4a		 jmp	 SHORT $LN26@EndTable
$LN25@EndTable:

; 1337 :         else if (column->MaxX > table->InnerClipRect.Max.x)

  00895	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  0089c	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  008a0	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  008a5	0f 2f 81 20 01
	00 00		 comiss	 xmm0, DWORD PTR [rcx+288]
  008ac	76 31		 jbe	 SHORT $LN27@EndTable

; 1338 :             SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x + neighbor_width_to_keep_visible, 1.0f);

  008ae	48 8b 85 68 02
	00 00		 mov	 rax, QWORD PTR column$10[rbp]
  008b5	48 8b 4d 68	 mov	 rcx, QWORD PTR inner_window$[rbp]
  008b9	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  008be	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [rcx+24]
  008c3	f3 0f 58 85 44
	02 00 00	 addss	 xmm0, DWORD PTR neighbor_width_to_keep_visible$9[rbp]
  008cb	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  008d3	0f 28 c8	 movaps	 xmm1, xmm0
  008d6	48 8b 4d 68	 mov	 rcx, QWORD PTR inner_window$[rbp]
  008da	e8 00 00 00 00	 call	 ?SetScrollFromPosX@ImGui@@YAXPEAUImGuiWindow@@MM@Z ; ImGui::SetScrollFromPosX
$LN27@EndTable:
$LN26@EndTable:
$LN24@EndTable:
$LN23@EndTable:

; 1339 :     }
; 1340 : 
; 1341 :     // Apply resizing/dragging at the end of the frame
; 1342 :     if (table->ResizedColumn != -1 && table->InstanceCurrent == table->InstanceInteracted)

  008df	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  008e3	0f bf 80 fe 01
	00 00		 movsx	 eax, WORD PTR [rax+510]
  008ea	83 f8 ff	 cmp	 eax, -1
  008ed	0f 84 ba 00 00
	00		 je	 $LN28@EndTable
  008f3	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  008f7	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  008fb	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  008ff	0f bf 49 7a	 movsx	 ecx, WORD PTR [rcx+122]
  00903	3b c1		 cmp	 eax, ecx
  00905	0f 85 a2 00 00
	00		 jne	 $LN28@EndTable

; 1343 :     {
; 1344 :         ImGuiTableColumn* column = &table->Columns[table->ResizedColumn];

  0090b	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0090f	0f bf 80 fe 01
	00 00		 movsx	 eax, WORD PTR [rax+510]
  00916	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  0091a	48 83 c1 18	 add	 rcx, 24
  0091e	8b d0		 mov	 edx, eax
  00920	e8 00 00 00 00	 call	 ??A?$ImSpan@UImGuiTableColumn@@@@QEAAAEAUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
  00925	48 89 85 88 02
	00 00		 mov	 QWORD PTR column$11[rbp], rax

; 1345 :         const float new_x2 = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + TABLE_RESIZE_SEPARATOR_HALF_THICKNESS);

  0092c	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00930	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00934	f3 0f 10 80 fc
	0d 00 00	 movss	 xmm0, DWORD PTR [rax+3580]
  0093c	f3 0f 5c 81 14
	3f 00 00	 subss	 xmm0, DWORD PTR [rcx+16148]
  00944	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40800000
  0094c	f3 0f 11 85 a4
	02 00 00	 movss	 DWORD PTR new_x2$12[rbp], xmm0

; 1346 :         const float new_width = ImFloor(new_x2 - column->MinX - table->CellSpacingX1 - table->CellPaddingX * 2.0f);

  00954	48 8b 85 88 02
	00 00		 mov	 rax, QWORD PTR column$11[rbp]
  0095b	f3 0f 10 85 a4
	02 00 00	 movss	 xmm0, DWORD PTR new_x2$12[rbp]
  00963	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [rax+8]
  00968	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0096c	f3 0f 5c 80 c4
	00 00 00	 subss	 xmm0, DWORD PTR [rax+196]
  00974	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00978	f3 0f 10 88 bc
	00 00 00	 movss	 xmm1, DWORD PTR [rax+188]
  00980	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  00988	f3 0f 5c c1	 subss	 xmm0, xmm1
  0098c	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  00991	f3 0f 11 85 c4
	02 00 00	 movss	 DWORD PTR new_width$13[rbp], xmm0

; 1347 :         table->ResizedColumnNextWidth = new_width;

  00999	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  0099d	f3 0f 10 85 c4
	02 00 00	 movss	 xmm0, DWORD PTR new_width$13[rbp]
  009a5	f3 0f 11 80 dc
	00 00 00	 movss	 DWORD PTR [rax+220], xmm0
$LN28@EndTable:

; 1348 :     }
; 1349 : 
; 1350 :     // Pop from id stack
; 1351 :     IM_ASSERT_USER_ERROR(inner_window->IDStack.back() == table->ID + table->InstanceCurrent, "Mismatching PushID/PopID!");

  009ad	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  009b1	48 05 e8 00 00
	00		 add	 rax, 232		; 000000e8H
  009b7	48 8b c8	 mov	 rcx, rax
  009ba	e8 00 00 00 00	 call	 ?back@?$ImVector@I@@QEAAAEAIXZ ; ImVector<unsigned int>::back
  009bf	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  009c3	0f bf 49 78	 movsx	 ecx, WORD PTR [rcx+120]
  009c7	48 8b 55 28	 mov	 rdx, QWORD PTR table$[rbp]
  009cb	03 0a		 add	 ecx, DWORD PTR [rdx]
  009cd	39 08		 cmp	 DWORD PTR [rax], ecx
  009cf	75 0c		 jne	 SHORT $LN49@EndTable
  009d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@MHDEDKFO@Mismatching?5PushID?1PopID?$CB?$AA@
  009d8	48 85 c0	 test	 rax, rax
  009db	75 24		 jne	 SHORT $LN50@EndTable
$LN49@EndTable:
  009dd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA
  009e3	05 83 00 00 00	 add	 eax, 131		; 00000083H
  009e8	44 8b c0	 mov	 r8d, eax
  009eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  009f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1MI@BOIHHKDM@?$AA?$CI?$AAi?$AAn?$AAn?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAI?$AAD?$AAS?$AAt?$AAa?$AAc?$AAk?$AA?4?$AAb?$AAa?$AAc?$AAk?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN@
  009f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009ff	33 c0		 xor	 eax, eax
$LN50@EndTable:

; 1352 :     IM_ASSERT_USER_ERROR(outer_window->DC.ItemWidthStack.Size >= temp_data->HostBackupItemWidthStackSize, "Too many PopItemWidth!");

  00a01	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00a08	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  00a0f	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  00a12	39 88 c0 01 00
	00		 cmp	 DWORD PTR [rax+448], ecx
  00a18	7c 0c		 jl	 SHORT $LN51@EndTable
  00a1a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@GAFFHFPC@Too?5many?5PopItemWidth?$CB?$AA@
  00a21	48 85 c0	 test	 rax, rax
  00a24	75 24		 jne	 SHORT $LN52@EndTable
$LN51@EndTable:
  00a26	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA
  00a2c	05 84 00 00 00	 add	 eax, 132		; 00000084H
  00a31	44 8b c0	 mov	 r8d, eax
  00a34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00a3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1NM@BLFPKGHB@?$AA?$CI?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAI?$AAt?$AAe?$AAm?$AAW?$AAi?$AAd?$AAt?$AAh?$AAS?$AAt?$AAa?$AAc?$AAk@
  00a42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a48	33 c0		 xor	 eax, eax
$LN52@EndTable:

; 1353 :     PopID();

  00a4a	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 1354 : 
; 1355 :     // Restore window data that we modified
; 1356 :     const ImVec2 backup_outer_max_pos = outer_window->DC.CursorMaxPos;

  00a4f	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00a56	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  00a5d	48 89 85 e8 02
	00 00		 mov	 QWORD PTR backup_outer_max_pos$[rbp], rax

; 1357 :     inner_window->WorkRect = temp_data->HostBackupWorkRect;

  00a64	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00a68	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  00a6f	48 8d b8 10 02
	00 00		 lea	 rdi, QWORD PTR [rax+528]
  00a76	48 8d 71 28	 lea	 rsi, QWORD PTR [rcx+40]
  00a7a	b9 10 00 00 00	 mov	 ecx, 16
  00a7f	f3 a4		 rep movsb

; 1358 :     inner_window->ParentWorkRect = temp_data->HostBackupParentWorkRect;

  00a81	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00a85	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  00a8c	48 8d b8 20 02
	00 00		 lea	 rdi, QWORD PTR [rax+544]
  00a93	48 8d 71 38	 lea	 rsi, QWORD PTR [rcx+56]
  00a97	b9 10 00 00 00	 mov	 ecx, 16
  00a9c	f3 a4		 rep movsb

; 1359 :     inner_window->SkipItems = table->HostSkipItems;

  00a9e	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00aa2	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00aa6	0f b6 89 32 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+562]
  00aad	88 88 b3 00 00
	00		 mov	 BYTE PTR [rax+179], cl

; 1360 :     outer_window->DC.CursorPos = table->OuterRect.Min;

  00ab3	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00ab7	48 8b 80 e8 00
	00 00		 mov	 rax, QWORD PTR [rax+232]
  00abe	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR outer_window$[rbp]
  00ac5	48 89 81 f8 00
	00 00		 mov	 QWORD PTR [rcx+248], rax

; 1361 :     outer_window->DC.ItemWidth = temp_data->HostBackupItemWidth;

  00acc	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00ad3	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  00ada	f3 0f 10 41 64	 movss	 xmm0, DWORD PTR [rcx+100]
  00adf	f3 0f 11 80 b4
	01 00 00	 movss	 DWORD PTR [rax+436], xmm0

; 1362 :     outer_window->DC.ItemWidthStack.Size = temp_data->HostBackupItemWidthStackSize;

  00ae7	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00aee	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  00af5	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  00af8	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 1363 :     outer_window->DC.ColumnsOffset = temp_data->HostBackupColumnsOffset;

  00afe	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00b05	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  00b08	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR outer_window$[rbp]
  00b0f	89 81 40 01 00
	00		 mov	 DWORD PTR [rcx+320], eax

; 1364 : 
; 1365 :     // Layout in outer window
; 1366 :     // (FIXME: To allow auto-fit and allow desirable effect of SameLine() we dissociate 'used' vs 'ideal' size by overriding
; 1367 :     // CursorPosPrevLine and CursorMaxPos manually. That should be a more general layout feature, see same problem e.g. #3414)
; 1368 :     if (inner_window != outer_window)

  00b15	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00b1c	48 39 45 68	 cmp	 QWORD PTR inner_window$[rbp], rax
  00b20	74 07		 je	 SHORT $LN29@EndTable

; 1369 :     {
; 1370 :         EndChild();

  00b22	e8 00 00 00 00	 call	 ?EndChild@ImGui@@YAXXZ	; ImGui::EndChild

; 1371 :     }
; 1372 :     else

  00b27	eb 43		 jmp	 SHORT $LN30@EndTable
$LN29@EndTable:

; 1373 :     {
; 1374 :         ItemSize(table->OuterRect.GetSize());

  00b29	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00b2d	48 05 e8 00 00
	00		 add	 rax, 232		; 000000e8H
  00b33	48 8d 95 f4 04
	00 00		 lea	 rdx, QWORD PTR $T17[rbp]
  00b3a	48 8b c8	 mov	 rcx, rax
  00b3d	e8 00 00 00 00	 call	 ?GetSize@ImRect@@QEBA?AUImVec2@@XZ ; ImRect::GetSize
  00b42	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  00b4a	48 8b c8	 mov	 rcx, rax
  00b4d	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z ; ImGui::ItemSize

; 1375 :         ItemAdd(table->OuterRect, 0);

  00b52	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00b56	48 05 e8 00 00
	00		 add	 rax, 232		; 000000e8H
  00b5c	45 33 c9	 xor	 r9d, r9d
  00b5f	45 33 c0	 xor	 r8d, r8d
  00b62	33 d2		 xor	 edx, edx
  00b64	48 8b c8	 mov	 rcx, rax
  00b67	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
$LN30@EndTable:

; 1376 :     }
; 1377 : 
; 1378 :     // Override declared contents width/height to enable auto-resize while not needlessly adding a scrollbar
; 1379 :     if (table->Flags & ImGuiTableFlags_NoHostExtendX)

  00b6c	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00b70	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00b73	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00b78	85 c0		 test	 eax, eax
  00b7a	74 70		 je	 SHORT $LN31@EndTable

; 1380 :     {
; 1381 :         // FIXME-TABLE: Could we remove this section?
; 1382 :         // ColumnsAutoFitWidth may be one frame ahead here since for Fixed+NoResize is calculated from latest contents
; 1383 :         IM_ASSERT((table->Flags & ImGuiTableFlags_ScrollX) == 0);

  00b7c	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00b80	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00b83	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00b88	85 c0		 test	 eax, eax
  00b8a	74 24		 je	 SHORT $LN53@EndTable
  00b8c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA
  00b92	05 a3 00 00 00	 add	 eax, 163		; 000000a3H
  00b97	44 8b c0	 mov	 r8d, eax
  00b9a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00ba1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@ICPCKIED@?$AA?$CI?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi?$AAT?$AAa?$AAb?$AAl?$AAe?$AAF?$AAl?$AAa?$AAg?$AAs?$AA_@
  00ba8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00bae	33 c0		 xor	 eax, eax
$LN53@EndTable:

; 1384 :         outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth);

  00bb0	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00bb4	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00bb8	f3 0f 10 80 e8
	00 00 00	 movss	 xmm0, DWORD PTR [rax+232]
  00bc0	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [rcx+212]
  00bc8	0f 28 c8	 movaps	 xmm1, xmm0
  00bcb	f3 0f 10 85 e8
	02 00 00	 movss	 xmm0, DWORD PTR backup_outer_max_pos$[rbp]
  00bd3	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00bd8	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00bdf	f3 0f 11 80 10
	01 00 00	 movss	 DWORD PTR [rax+272], xmm0
  00be7	e9 1c 01 00 00	 jmp	 $LN32@EndTable
$LN31@EndTable:

; 1385 :     }
; 1386 :     else if (temp_data->UserOuterSize.x <= 0.0f)

  00bec	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00bf3	0f 57 c0	 xorps	 xmm0, xmm0
  00bf6	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [rax+8]
  00bfa	0f 82 e0 00 00
	00		 jb	 $LN33@EndTable

; 1387 :     {
; 1388 :         const float decoration_size = (table->Flags & ImGuiTableFlags_ScrollX) ? inner_window->ScrollbarSizes.x : 0.0f;

  00c00	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00c04	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00c07	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00c0c	85 c0		 test	 eax, eax
  00c0e	74 16		 je	 SHORT $LN54@EndTable
  00c10	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00c14	f3 0f 10 80 a4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+164]
  00c1c	f3 0f 11 85 04
	05 00 00	 movss	 DWORD PTR tv524[rbp], xmm0
  00c24	eb 0b		 jmp	 SHORT $LN55@EndTable
$LN54@EndTable:
  00c26	0f 57 c0	 xorps	 xmm0, xmm0
  00c29	f3 0f 11 85 04
	05 00 00	 movss	 DWORD PTR tv524[rbp], xmm0
$LN55@EndTable:
  00c31	f3 0f 10 85 04
	05 00 00	 movss	 xmm0, DWORD PTR tv524[rbp]
  00c39	f3 0f 11 85 04
	03 00 00	 movss	 DWORD PTR decoration_size$14[rbp], xmm0

; 1389 :         outer_window->DC.IdealMaxPos.x = ImMax(outer_window->DC.IdealMaxPos.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth + decoration_size - temp_data->UserOuterSize.x);

  00c41	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00c45	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00c49	f3 0f 10 80 e8
	00 00 00	 movss	 xmm0, DWORD PTR [rax+232]
  00c51	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [rcx+212]
  00c59	f3 0f 58 85 04
	03 00 00	 addss	 xmm0, DWORD PTR decoration_size$14[rbp]
  00c61	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00c68	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [rax+8]
  00c6d	0f 28 c8	 movaps	 xmm1, xmm0
  00c70	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00c77	f3 0f 10 80 18
	01 00 00	 movss	 xmm0, DWORD PTR [rax+280]
  00c7f	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00c84	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00c8b	f3 0f 11 80 18
	01 00 00	 movss	 DWORD PTR [rax+280], xmm0

; 1390 :         outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, ImMin(table->OuterRect.Max.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth));

  00c93	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00c97	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00c9b	f3 0f 10 80 e8
	00 00 00	 movss	 xmm0, DWORD PTR [rax+232]
  00ca3	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [rcx+212]
  00cab	0f 28 c8	 movaps	 xmm1, xmm0
  00cae	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00cb2	f3 0f 10 80 f0
	00 00 00	 movss	 xmm0, DWORD PTR [rax+240]
  00cba	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00cbf	0f 28 c8	 movaps	 xmm1, xmm0
  00cc2	f3 0f 10 85 e8
	02 00 00	 movss	 xmm0, DWORD PTR backup_outer_max_pos$[rbp]
  00cca	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00ccf	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00cd6	f3 0f 11 80 10
	01 00 00	 movss	 DWORD PTR [rax+272], xmm0

; 1391 :     }
; 1392 :     else

  00cde	eb 28		 jmp	 SHORT $LN34@EndTable
$LN33@EndTable:

; 1393 :     {
; 1394 :         outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Max.x);

  00ce0	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00ce4	f3 0f 10 88 f0
	00 00 00	 movss	 xmm1, DWORD PTR [rax+240]
  00cec	f3 0f 10 85 e8
	02 00 00	 movss	 xmm0, DWORD PTR backup_outer_max_pos$[rbp]
  00cf4	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00cf9	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00d00	f3 0f 11 80 10
	01 00 00	 movss	 DWORD PTR [rax+272], xmm0
$LN34@EndTable:
$LN32@EndTable:

; 1395 :     }
; 1396 :     if (temp_data->UserOuterSize.y <= 0.0f)

  00d08	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00d0f	0f 57 c0	 xorps	 xmm0, xmm0
  00d12	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [rax+12]
  00d16	0f 82 bd 00 00
	00		 jb	 $LN35@EndTable

; 1397 :     {
; 1398 :         const float decoration_size = (table->Flags & ImGuiTableFlags_ScrollY) ? inner_window->ScrollbarSizes.y : 0.0f;

  00d1c	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00d20	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00d23	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00d28	85 c0		 test	 eax, eax
  00d2a	74 16		 je	 SHORT $LN56@EndTable
  00d2c	48 8b 45 68	 mov	 rax, QWORD PTR inner_window$[rbp]
  00d30	f3 0f 10 80 a8
	00 00 00	 movss	 xmm0, DWORD PTR [rax+168]
  00d38	f3 0f 11 85 04
	05 00 00	 movss	 DWORD PTR tv577[rbp], xmm0
  00d40	eb 0b		 jmp	 SHORT $LN57@EndTable
$LN56@EndTable:
  00d42	0f 57 c0	 xorps	 xmm0, xmm0
  00d45	f3 0f 11 85 04
	05 00 00	 movss	 DWORD PTR tv577[rbp], xmm0
$LN57@EndTable:
  00d4d	f3 0f 10 85 04
	05 00 00	 movss	 xmm0, DWORD PTR tv577[rbp]
  00d55	f3 0f 11 85 24
	03 00 00	 movss	 DWORD PTR decoration_size$15[rbp], xmm0

; 1399 :         outer_window->DC.IdealMaxPos.y = ImMax(outer_window->DC.IdealMaxPos.y, inner_content_max_y + decoration_size - temp_data->UserOuterSize.y);

  00d5d	f3 0f 10 85 e4
	00 00 00	 movss	 xmm0, DWORD PTR inner_content_max_y$[rbp]
  00d65	f3 0f 58 85 24
	03 00 00	 addss	 xmm0, DWORD PTR decoration_size$15[rbp]
  00d6d	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00d74	f3 0f 5c 40 0c	 subss	 xmm0, DWORD PTR [rax+12]
  00d79	0f 28 c8	 movaps	 xmm1, xmm0
  00d7c	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00d83	f3 0f 10 80 1c
	01 00 00	 movss	 xmm0, DWORD PTR [rax+284]
  00d8b	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00d90	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00d97	f3 0f 11 80 1c
	01 00 00	 movss	 DWORD PTR [rax+284], xmm0

; 1400 :         outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, ImMin(table->OuterRect.Max.y, inner_content_max_y));

  00d9f	f3 0f 10 8d e4
	00 00 00	 movss	 xmm1, DWORD PTR inner_content_max_y$[rbp]
  00da7	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00dab	f3 0f 10 80 f4
	00 00 00	 movss	 xmm0, DWORD PTR [rax+244]
  00db3	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00db8	0f 28 c8	 movaps	 xmm1, xmm0
  00dbb	f3 0f 10 85 ec
	02 00 00	 movss	 xmm0, DWORD PTR backup_outer_max_pos$[rbp+4]
  00dc3	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00dc8	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00dcf	f3 0f 11 80 14
	01 00 00	 movss	 DWORD PTR [rax+276], xmm0

; 1401 :     }
; 1402 :     else

  00dd7	eb 28		 jmp	 SHORT $LN36@EndTable
$LN35@EndTable:

; 1403 :     {
; 1404 :         // OuterRect.Max.y may already have been pushed downward from the initial value (unless ImGuiTableFlags_NoHostExtendY is set)
; 1405 :         outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, table->OuterRect.Max.y);

  00dd9	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00ddd	f3 0f 10 88 f4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+244]
  00de5	f3 0f 10 85 ec
	02 00 00	 movss	 xmm0, DWORD PTR backup_outer_max_pos$[rbp+4]
  00ded	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00df2	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00df9	f3 0f 11 80 14
	01 00 00	 movss	 DWORD PTR [rax+276], xmm0
$LN36@EndTable:

; 1406 :     }
; 1407 : 
; 1408 :     // Save settings
; 1409 :     if (table->IsSettingsDirty)

  00e01	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00e05	0f b6 80 29 02
	00 00		 movzx	 eax, BYTE PTR [rax+553]
  00e0c	85 c0		 test	 eax, eax
  00e0e	74 09		 je	 SHORT $LN37@EndTable

; 1410 :         TableSaveSettings(table);

  00e10	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00e14	e8 00 00 00 00	 call	 ?TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableSaveSettings
$LN37@EndTable:

; 1411 :     table->IsInitializing = false;

  00e19	48 8b 45 28	 mov	 rax, QWORD PTR table$[rbp]
  00e1d	c6 80 24 02 00
	00 00		 mov	 BYTE PTR [rax+548], 0

; 1412 : 
; 1413 :     // Clear or restore current table, if any
; 1414 :     IM_ASSERT(g.CurrentWindow == outer_window && g.CurrentTable == table);

  00e24	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00e28	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR outer_window$[rbp]
  00e2f	48 39 88 a0 3e
	00 00		 cmp	 QWORD PTR [rax+16032], rcx
  00e36	75 11		 jne	 SHORT $LN58@EndTable
  00e38	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00e3c	48 8b 4d 28	 mov	 rcx, QWORD PTR table$[rbp]
  00e40	48 39 88 e8 4a
	00 00		 cmp	 QWORD PTR [rax+19176], rcx
  00e47	74 24		 je	 SHORT $LN59@EndTable
$LN58@EndTable:
  00e49	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA
  00e4f	05 c2 00 00 00	 add	 eax, 194		; 000000c2H
  00e54	44 8b c0	 mov	 r8d, eax
  00e57	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00e5e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HG@JFMKDCJB@?$AAg?$AA?4?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AAe?$AAr?$AA_?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?5@
  00e65	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e6b	33 c0		 xor	 eax, eax
$LN59@EndTable:

; 1415 :     IM_ASSERT(g.TablesTempDataStacked > 0);

  00e6d	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00e71	83 b8 f0 4a 00
	00 00		 cmp	 DWORD PTR [rax+19184], 0
  00e78	7f 24		 jg	 SHORT $LN60@EndTable
  00e7a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndTable@ImGui@@YAXXZ@4JA
  00e80	05 c3 00 00 00	 add	 eax, 195		; 000000c3H
  00e85	44 8b c0	 mov	 r8d, eax
  00e88	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GA@OPMIMIN@?$AAc?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAf?$AAr?$AAa?$AAm?$AAe?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAt?$AAo?$AAo?$AAl?$AA?2?$AAi?$AAm?$AAg?$AAu?$AAi?$AA?2?$AAi@
  00e8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@IPEFINGP@?$AAg?$AA?4?$AAT?$AAa?$AAb?$AAl?$AAe?$AAs?$AAT?$AAe?$AAm?$AAp?$AAD?$AAa?$AAt?$AAa?$AAS?$AAt?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00e96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00e9c	33 c0		 xor	 eax, eax
$LN60@EndTable:

; 1416 :     temp_data = (--g.TablesTempDataStacked > 0) ? &g.TablesTempData[g.TablesTempDataStacked - 1] : NULL;

  00e9e	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00ea2	8b 80 f0 4a 00
	00		 mov	 eax, DWORD PTR [rax+19184]
  00ea8	ff c8		 dec	 eax
  00eaa	89 85 04 05 00
	00		 mov	 DWORD PTR tv667[rbp], eax
  00eb0	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00eb4	8b 8d 04 05 00
	00		 mov	 ecx, DWORD PTR tv667[rbp]
  00eba	89 88 f0 4a 00
	00		 mov	 DWORD PTR [rax+19184], ecx
  00ec0	83 bd 04 05 00
	00 00		 cmp	 DWORD PTR tv667[rbp], 0
  00ec7	7e 27		 jle	 SHORT $LN61@EndTable
  00ec9	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00ecd	8b 80 f0 4a 00
	00		 mov	 eax, DWORD PTR [rax+19184]
  00ed3	ff c8		 dec	 eax
  00ed5	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00ed9	48 81 c1 f8 4a
	00 00		 add	 rcx, 19192		; 00004af8H
  00ee0	8b d0		 mov	 edx, eax
  00ee2	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTableTempData@@@@QEAAAEAUImGuiTableTempData@@H@Z ; ImVector<ImGuiTableTempData>::operator[]
  00ee7	48 89 85 08 05
	00 00		 mov	 QWORD PTR tv675[rbp], rax
  00eee	eb 0b		 jmp	 SHORT $LN62@EndTable
$LN61@EndTable:
  00ef0	48 c7 85 08 05
	00 00 00 00 00
	00		 mov	 QWORD PTR tv675[rbp], 0
$LN62@EndTable:
  00efb	48 8b 85 08 05
	00 00		 mov	 rax, QWORD PTR tv675[rbp]
  00f02	48 89 85 a8 00
	00 00		 mov	 QWORD PTR temp_data$[rbp], rax

; 1417 :     g.CurrentTable = temp_data ? g.Tables.GetByIndex(temp_data->TableIndex) : NULL;

  00f09	48 83 bd a8 00
	00 00 00	 cmp	 QWORD PTR temp_data$[rbp], 0
  00f11	74 24		 je	 SHORT $LN63@EndTable
  00f13	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00f17	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  00f1d	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  00f24	8b 11		 mov	 edx, DWORD PTR [rcx]
  00f26	48 8b c8	 mov	 rcx, rax
  00f29	e8 00 00 00 00	 call	 ?GetByIndex@?$ImPool@UImGuiTable@@@@QEAAPEAUImGuiTable@@H@Z ; ImPool<ImGuiTable>::GetByIndex
  00f2e	48 89 85 08 05
	00 00		 mov	 QWORD PTR tv683[rbp], rax
  00f35	eb 0b		 jmp	 SHORT $LN64@EndTable
$LN63@EndTable:
  00f37	48 c7 85 08 05
	00 00 00 00 00
	00		 mov	 QWORD PTR tv683[rbp], 0
$LN64@EndTable:
  00f42	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00f46	48 8b 8d 08 05
	00 00		 mov	 rcx, QWORD PTR tv683[rbp]
  00f4d	48 89 88 e8 4a
	00 00		 mov	 QWORD PTR [rax+19176], rcx

; 1418 :     if (g.CurrentTable)

  00f54	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00f58	48 83 b8 e8 4a
	00 00 00	 cmp	 QWORD PTR [rax+19176], 0
  00f60	74 33		 je	 SHORT $LN38@EndTable

; 1419 :     {
; 1420 :         g.CurrentTable->TempData = temp_data;

  00f62	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00f66	48 8b 80 e8 4a
	00 00		 mov	 rax, QWORD PTR [rax+19176]
  00f6d	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR temp_data$[rbp]
  00f74	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1421 :         g.CurrentTable->DrawSplitter = &temp_data->DrawSplitter;

  00f78	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR temp_data$[rbp]
  00f7f	48 83 c0 10	 add	 rax, 16
  00f83	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00f87	48 8b 89 e8 4a
	00 00		 mov	 rcx, QWORD PTR [rcx+19176]
  00f8e	48 89 81 98 01
	00 00		 mov	 QWORD PTR [rcx+408], rax
$LN38@EndTable:

; 1422 :     }
; 1423 :     outer_window->DC.CurrentTableIdx = g.CurrentTable ? g.Tables.GetIndex(g.CurrentTable) : -1;

  00f95	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00f99	48 83 b8 e8 4a
	00 00 00	 cmp	 QWORD PTR [rax+19176], 0
  00fa1	74 25		 je	 SHORT $LN65@EndTable
  00fa3	48 8b 45 08	 mov	 rax, QWORD PTR g$[rbp]
  00fa7	48 05 08 4b 00
	00		 add	 rax, 19208		; 00004b08H
  00fad	48 8b 4d 08	 mov	 rcx, QWORD PTR g$[rbp]
  00fb1	48 8b 91 e8 4a
	00 00		 mov	 rdx, QWORD PTR [rcx+19176]
  00fb8	48 8b c8	 mov	 rcx, rax
  00fbb	e8 00 00 00 00	 call	 ?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z ; ImPool<ImGuiTable>::GetIndex
  00fc0	89 85 04 05 00
	00		 mov	 DWORD PTR tv700[rbp], eax
  00fc6	eb 0a		 jmp	 SHORT $LN66@EndTable
$LN65@EndTable:
  00fc8	c7 85 04 05 00
	00 ff ff ff ff	 mov	 DWORD PTR tv700[rbp], -1
$LN66@EndTable:
  00fd2	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR outer_window$[rbp]
  00fd9	8b 8d 04 05 00
	00		 mov	 ecx, DWORD PTR tv700[rbp]
  00fdf	89 88 a8 01 00
	00		 mov	 DWORD PTR [rax+424], ecx

; 1424 : }

  00fe5	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00fe9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EndTable@ImGui@@YAXXZ$rtcFrameData
  00ff0	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00ff5	48 8b 8d 10 05
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00ffc	48 33 cd	 xor	 rcx, rbp
  00fff	e8 00 00 00 00	 call	 __security_check_cookie
  01004	48 8d a5 20 05
	00 00		 lea	 rsp, QWORD PTR [rbp+1312]
  0100b	5f		 pop	 rdi
  0100c	5e		 pop	 rsi
  0100d	5d		 pop	 rbp
  0100e	c3		 ret	 0
?EndTable@ImGui@@YAXXZ ENDP				; ImGui::EndTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\github\framework\tool\imgui\imgui_tables.cpp
;	COMDAT ?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z
_TEXT	SEGMENT
id$ = 4
str_id$ = 256
columns_count$ = 264
flags$ = 272
outer_size$ = 280
inner_width$ = 288
?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z PROC	; ImGui::BeginTable, COMDAT

; 305  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001c	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00021	48 8b fc	 mov	 rdi, rsp
  00024	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR [rsp+312]

; 306  :     ImGuiID id = GetID(str_id);

  00038	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR str_id$[rbp]
  0003f	e8 00 00 00 00	 call	 ?GetID@ImGui@@YAIPEBD@Z	; ImGui::GetID
  00044	89 45 04	 mov	 DWORD PTR id$[rbp], eax

; 307  :     return BeginTableEx(str_id, id, columns_count, flags, outer_size, inner_width);

  00047	f3 0f 10 85 20
	01 00 00	 movss	 xmm0, DWORD PTR inner_width$[rbp]
  0004f	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00055	48 8b 85 18 01
	00 00		 mov	 rax, QWORD PTR outer_size$[rbp]
  0005c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00061	44 8b 8d 10 01
	00 00		 mov	 r9d, DWORD PTR flags$[rbp]
  00068	44 8b 85 08 01
	00 00		 mov	 r8d, DWORD PTR columns_count$[rbp]
  0006f	8b 55 04	 mov	 edx, DWORD PTR id$[rbp]
  00072	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR str_id$[rbp]
  00079	e8 00 00 00 00	 call	 ?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z ; ImGui::BeginTableEx

; 308  : }

  0007e	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00085	5f		 pop	 rdi
  00086	5d		 pop	 rbp
  00087	c3		 ret	 0
?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z ENDP	; ImGui::BeginTable
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0ImVec4@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 80
_x$ = 88
_y$ = 96
_z$ = 104
_w$ = 112
??0ImVec4@@QEAA@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT

; 270  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

$LN3:
  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	55		 push	 rbp
  00018	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0001c	48 8b ec	 mov	 rbp, rsp
  0001f	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00023	f3 0f 10 45 58	 movss	 xmm0, DWORD PTR _x$[rbp]
  00028	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  0002c	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00030	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _y$[rbp]
  00035	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
  0003a	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0003e	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _z$[rbp]
  00043	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0
  00048	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0004c	f3 0f 10 45 70	 movss	 xmm0, DWORD PTR _w$[rbp]
  00051	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0
  00056	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0005a	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0005e	5d		 pop	 rbp
  0005f	c3		 ret	 0
??0ImVec4@@QEAA@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 80
_x$ = 88
_y$ = 96
??0ImVec2@@QEAA@MM@Z PROC				; ImVec2::ImVec2, COMDAT

; 257  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

$LN3:
  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  0000c	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00011	55		 push	 rbp
  00012	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00016	48 8b ec	 mov	 rbp, rsp
  00019	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001d	f3 0f 10 45 58	 movss	 xmm0, DWORD PTR _x$[rbp]
  00022	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00026	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0002a	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _y$[rbp]
  0002f	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
  00034	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00038	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
??0ImVec2@@QEAA@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\github\framework\tool\imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@XZ
_TEXT	SEGMENT
this$ = 80
??0ImVec2@@QEAA@XZ PROC					; ImVec2::ImVec2, COMDAT

; 256  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00011	0f 57 c0	 xorps	 xmm0, xmm0
  00014	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00018	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  0001c	0f 57 c0	 xorps	 xmm0, xmm0
  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
  00024	48 8b 45 50	 mov	 rax, QWORD PTR this$[rbp]
  00028	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
??0ImVec2@@QEAA@XZ ENDP					; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 192
tv67 = 200
__t$ = 240
__s$ = 248
__n$ = 256
__f$ = 264
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8b fc	 mov	 rdi, rsp
  00025	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR [rsp+280]
$LN2@vector:
  00039	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR __n$[rbp]
  00040	48 89 85 c0 00
	00 00		 mov	 QWORD PTR tv66[rbp], rax
  00047	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR __n$[rbp]
  0004e	48 ff c8	 dec	 rax
  00051	48 89 85 00 01
	00 00		 mov	 QWORD PTR __n$[rbp], rax
  00058	48 83 bd c0 00
	00 00 00	 cmp	 QWORD PTR tv66[rbp], 0
  00060	76 0c		 jbe	 SHORT $LN5@vector
  00062	c7 85 c8 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv67[rbp], 1
  0006c	eb 0a		 jmp	 SHORT $LN6@vector
$LN5@vector:
  0006e	c7 85 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv67[rbp], 0
$LN6@vector:
  00078	83 bd c8 00 00
	00 00		 cmp	 DWORD PTR tv67[rbp], 0
  0007f	74 2a		 je	 SHORT $LN3@vector
  00081	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR __t$[rbp]
  00088	ff 95 08 01 00
	00		 call	 QWORD PTR __f$[rbp]
  0008e	48 8b 85 f8 00
	00 00		 mov	 rax, QWORD PTR __s$[rbp]
  00095	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR __t$[rbp]
  0009c	48 03 c8	 add	 rcx, rax
  0009f	48 8b c1	 mov	 rax, rcx
  000a2	48 89 85 f0 00
	00 00		 mov	 QWORD PTR __t$[rbp], rax
  000a9	eb 8e		 jmp	 SHORT $LN2@vector
$LN3@vector:
  000ab	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000b2	5f		 pop	 rdi
  000b3	5d		 pop	 rbp
  000b4	c3		 ret	 0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
